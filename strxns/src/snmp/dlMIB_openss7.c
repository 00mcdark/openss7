/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "dlMIB_openss7.h"
const char sa_program[] = "dlmib";

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
int sa_nomead = 1;			/* default daemon mode */
int sa_output = 1;			/* default normal output */
int sa_agentx = 1;			/* default agentx mode */
int sa_alarms = 1;			/* default application alarms */
int sa_fclose = 1;			/* default close files between requests */
int sa_logaddr = 0;			/* log addresses */
int sa_logfillog = 0;			/* log to sa_logfile */
int sa_logstderr = 0;			/* log to standard error */
int sa_logstdout = 0;			/* log to standard output */
int sa_logsyslog = 0;			/* log to system logs */
int sa_logcallog = 0;			/* log to callback logs */
int sa_appendlog = 0;			/* append to log file without truncating */
char sa_logfile[256] = "/var/log/dlmib.log";
char sa_pidfile[256] = "/var/run/dlmib.pid";
char sa_sysctlf[256] = "/etc/dlmib.conf";
int allow_severity = LOG_ERR;
int deny_severity = LOG_ERR;

/* file stream for log file */
FILE *stdlog = NULL;

/* file descriptor for MIB use */
int sa_fd = 0;

/* indication to reread MIB configuration */
int sa_changed = 1;

/* indications that statistics, the mib or its tables need to be refreshed */
int sa_stats_refresh = 1;
#else				/* !defined MODULE */
#endif				/* !defined MODULE */
/* request number for per-request actions */
int sa_request = 1;
volatile int dlMIB_refresh = 1;
volatile int communicationsEntityTable_refresh = 1;
volatile int sap1Table_refresh = 1;
volatile int sap2Table_refresh = 1;
volatile int clProtocolMachineTable_refresh = 1;
volatile int coProtocolMachineTable_refresh = 1;
volatile int singlePeerConnectionTable_refresh = 1;
volatile int physicalEntityTable_refresh = 1;
volatile int physicalSAPTable_refresh = 1;
volatile int dataCircuitTable_refresh = 1;
volatile int physicalConnectionTable_refresh = 1;
volatile int datalinkEntityTable_refresh = 1;
volatile int dLSAPTable_refresh = 1;
volatile int lAPBDLETable_refresh = 1;
volatile int sLPPMTable_refresh = 1;
volatile int sLPConnectionTable_refresh = 1;
volatile int sLPConnectionIVMOTable_refresh = 1;
volatile int mACDLETable_refresh = 1;
volatile int mACTable_refresh = 1;
volatile int lLCDLETable_refresh = 1;
volatile int lLCCLPMTable_refresh = 1;
volatile int lLCCOPMTable_refresh = 1;
volatile int resourceTypeIdTable_refresh = 1;
volatile int lLCStationTable_refresh = 1;
volatile int lLCSAPTable_refresh = 1;
volatile int rDESetupTable_refresh = 1;
volatile int rDEPairTable_refresh = 1;
volatile int lLCConnectionLessTable_refresh = 1;
volatile int lLCConnection2Table_refresh = 1;
volatile int lLCConnection2IVMOTable_refresh = 1;
volatile int lLCConnectionlessAckTable_refresh = 1;
volatile int lLCConnectionlessAckIVMOTable_refresh = 1;
volatile int networkEntityTable_refresh = 1;
volatile int nSAPTable_refresh = 1;
volatile int cLNSTable_refresh = 1;
volatile int cLNSISISTable_refresh = 1;
volatile int cLNSISISLevel2Table_refresh = 1;
volatile int linkageTable_refresh = 1;
volatile int cONSTable_refresh = 1;
volatile int networkConnectionTable_refresh = 1;
volatile int x25PLETable_refresh = 1;
volatile int x25PLE - DTETable_refresh = 1;
volatile int x25PLE - DCETable_refresh = 1;
volatile int x25PLEIVMOTable_refresh = 1;
volatile int x25PLEIVMO - DTETable_refresh = 1;
volatile int x25PLEIVMO - DCETable_refresh = 1;
volatile int virtualCallTable_refresh = 1;
volatile int virtualCircuitTable_refresh = 1;
volatile int virtualCircuit - DTETable_refresh = 1;
volatile int virtualCircuit - DCETable_refresh = 1;
volatile int permanentVirtualCircuitTable_refresh = 1;
volatile int permanentVirtualCircuit - DTETable_refresh = 1;
volatile int permanentVirtualCircuit - DCETable_refresh = 1;
volatile int virtualCallIVMOTable_refresh = 1;
volatile int switchedVirtualCallTable_refresh = 1;
volatile int virtualCall - DTETable_refresh = 1;
volatile int virtualCall - DCETable_refresh = 1;
volatile int dSeriesCountsTable_refresh = 1;
volatile int adjacencyTable_refresh = 1;
volatile int virtualAdjacencyTable_refresh = 1;
volatile int destinationTable_refresh = 1;
volatile int destinationSystemTable_refresh = 1;
volatile int destinationAreaTable_refresh = 1;
volatile int reachableAddressTable_refresh = 1;

/*
 * dlMIB_variables_oid: object identifier for dlMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid dlMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212 };
oid physicalSAPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 8, 1, 1 };
oid dataCircuitTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 9, 1, 1 };
oid physicalConnectionTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 10, 1, 1 };
oid datalinkEntityTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 11, 1, 1 };
oid dLSAPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 12, 1, 1 };
oid lAPBDLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 13, 1, 1 };
oid sLPPMTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 14, 1, 1 };
oid sLPConnectionTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 15, 1, 1 };
oid sLPConnectionIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 16, 1, 1 };
oid mACDLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 17, 1, 1 };
oid mACTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 18, 1, 1 };
oid lLCDLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 19, 1, 1 };
oid lLCCLPMTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 20, 1, 1 };
oid lLCCOPMTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 21, 1, 1 };
oid lLCConnectionlessAckIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 31, 1, 1 };
oid networkEntityTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 32, 1, 1 };
oid nSAPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 33, 1, 1 };
oid cLNSTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 34, 1, 1 };
oid cLNSISISTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 35, 1, 1 };
oid cLNSISISLevel2Table_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 36, 1, 1 };
oid linkageTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 37, 1, 1 };
oid cONSTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 38, 1, 1 };
oid networkConnectionTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 39, 1, 1 };
oid x25PLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 40, 1, 1 };
oid x25PLEIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 43, 1, 1 };
oid x25PLEIVMO - DTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 44, 1, 1 };
oid x25PLEIVMO - DCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 45, 1, 1 };
oid permanentVirtualCircuitTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 50, 1, 1 };
oid permanentVirtualCircuit - DTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 51, 1, 1 };
oid permanentVirtualCircuit - DCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 52, 1, 1 };
oid virtualCallIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 53, 1, 1 };
oid switchedVirtualCallTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 54, 1, 1 };
oid virtualCall - DTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 55, 1, 1 };
oid virtualCall - DCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 56, 1, 1 };
oid dSeriesCountsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 57, 1, 1 };
oid adjacencyTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 58, 1, 1 };
oid reachableAddressTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 63, 1, 1 };

/*
 * variable7 dlMIB_variables: tree for dlMIB
 * This variable defines function callbacks and type return information for the dlMIB mib section
 */
struct variable7 dlMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   COMMUNICATIONSENTITYLOCALSAPNAMES  (4 % 256)
	{COMMUNICATIONSENTITYLOCALSAPNAMES, ASN_OBJECT_ID, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 2}},
#define   COMMUNICATIONSENTITYOPERATIONALSTATE  (5 % 256)
	{COMMUNICATIONSENTITYOPERATIONALSTATE, ASN_INTEGER, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 3}},
#define   SAP1ADDRESS           (10 % 256)
	{SAP1ADDRESS, ASN_UNSIGNED, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 2}},
#define   SAP1USERENTITYNAMES   (11 % 256)
	{SAP1USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 3}},
#define   SAP2ADDRESS           (15 % 256)
	{SAP2ADDRESS, ASN_OCTET_STR, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 1}},
#define   SAP2USERENTITYNAMES   (16 % 256)
	{SAP2USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 2}},
#define   SAP2PROVIDERENTITYNAMES  (17 % 256)
	{SAP2PROVIDERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 3}},
#define   CLPROTOCOLMACHINEOPERATIONALSTATE  (22 % 256)
	{CLPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 2}},
#define   CLPROTOCOLMACHINETOTALREMOTESAPS  (23 % 256)
	{CLPROTOCOLMACHINETOTALREMOTESAPS, ASN_COUNTER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 3}},
#define   COPROTOCOLMACHINEOPERATIONALSTATE  (28 % 256)
	{COPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_coProtocolMachineTable, 6, {1, 1, 5, 1, 1, 2}},
#define   UNDERLYINGCONNECTIONNAMES  (34 % 256)
	{UNDERLYINGCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 2}},
#define   SUPPPORTEDCONNECTIONNAMES  (35 % 256)
	{SUPPPORTEDCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 3}},
#define   PHYSICALENTITYPHYSICALENTITYTITLES  (39 % 256)
	{PHYSICALENTITYPHYSICALENTITYTITLES, ASN_OBJECT_ID, RWRITE, var_physicalEntityTable, 6, {1, 1, 7, 1, 1, 1}},
#define   DATACIRCUITBITERRORSRECEIVED  (49 % 256)
	{DATACIRCUITBITERRORSRECEIVED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 1}},
#define   DATACIRCUITBITERRORSTRANSMITTED  (50 % 256)
	{DATACIRCUITBITERRORSTRANSMITTED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 2}},
#define   DATACIRCUITBITERRORSTHRESHOLD  (51 % 256)
	{DATACIRCUITBITERRORSTHRESHOLD, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 3}},
#define   DATACIRCUITTYPE       (52 % 256)
	{DATACIRCUITTYPE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 4}},
#define   DATACIRCUITPHYSICALMEDIANAMES  (53 % 256)
	{DATACIRCUITPHYSICALMEDIANAMES, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 5}},
#define   DATACIRCUITPHYSICALINTERFACETYPE  (54 % 256)
	{DATACIRCUITPHYSICALINTERFACETYPE, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 6}},
#define   DATACIRCUITPHYSICALINTERFACESTANDARD  (55 % 256)
	{DATACIRCUITPHYSICALINTERFACESTANDARD, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 7}},
#define   DATACIRCUITSYNCHRONIZATIONMODE  (56 % 256)
	{DATACIRCUITSYNCHRONIZATIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 8}},
#define   DATACIRCUITTRANSMISSIONCODING  (57 % 256)
	{DATACIRCUITTRANSMISSIONCODING, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 9}},
#define   DATACIRCUITTRANSMISSIONMODE  (58 % 256)
	{DATACIRCUITTRANSMISSIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 10}},
#define   DATACIRCUITTRANSMISSIONRATE  (59 % 256)
	{DATACIRCUITTRANSMISSIONRATE, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 11}},
#define   DATACIRCUITROWSTATUS  (60 % 256)
	{DATACIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 12}},
#define   PHYSICALCONNECTIONENDPOINTIDENTIFIER  (66 % 256)
	{PHYSICALCONNECTIONENDPOINTIDENTIFIER, ASN_OCTET_STR, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 1}},
#define   PHYSICALCONNECTIONPORTNUMBER  (67 % 256)
	{PHYSICALCONNECTIONPORTNUMBER, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 2}},
#define   PHYSICALCONNECTIONROWSTATUS  (68 % 256)
	{PHYSICALCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 3}},
#define   DATALINKENTITYPROVIDERENTITYNAMES  (72 % 256)
	{DATALINKENTITYPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 1}},
#define   DATALINKENTITYROWSTATUS  (73 % 256)
	{DATALINKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 2}},
#define   DLSAPROWSTATUS        (78 % 256)
	{DLSAPROWSTATUS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 12, 1, 1, 1}},
#define   LAPBDLEMT1TIMER       (82 % 256)
	{LAPBDLEMT1TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 1}},
#define   LAPBDLEMT3TIMER       (83 % 256)
	{LAPBDLEMT3TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 2}},
#define   LAPBDLEMW             (84 % 256)
	{LAPBDLEMW, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 3}},
#define   LAPBDLEMXSEND         (85 % 256)
	{LAPBDLEMXSEND, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 4}},
#define   LAPBDLEMXRECEIVE      (86 % 256)
	{LAPBDLEMXRECEIVE, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 5}},
#define   LAPBDLEMT2TIMER       (87 % 256)
	{LAPBDLEMT2TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 6}},
#define   LAPBDLERECEIVEDMLPRESETS  (88 % 256)
	{LAPBDLERECEIVEDMLPRESETS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 7}},
#define   LAPBDLETIMESMT1EXPIRED  (89 % 256)
	{LAPBDLETIMESMT1EXPIRED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 8}},
#define   LAPBDLEIFRAMESREASSIGNMENTS  (90 % 256)
	{LAPBDLEIFRAMESREASSIGNMENTS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 9}},
#define   LAPBDLEMLPFRAMESRECEIVED  (91 % 256)
	{LAPBDLEMLPFRAMESRECEIVED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 10}},
#define   LAPBDLEMLPFRAMESSENT  (92 % 256)
	{LAPBDLEMLPFRAMESSENT, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 11}},
#define   LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD  (93 % 256)
	{LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 12}},
#define   LAPBDLERECEIVEDMLPFRAMESINGUARDREGION  (94 % 256)
	{LAPBDLERECEIVEDMLPFRAMESINGUARDREGION, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 13}},
#define   LAPBDLEROWSTATUS      (95 % 256)
	{LAPBDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 14}},
#define   SLPPMADMINISTRATIVESTATE  (100 % 256)
	{SLPPMADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 3}},
#define   SLPPMROWSTATUS        (101 % 256)
	{SLPPMROWSTATUS, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 4}},
#define   SLPCONNECTIONINTERFACETYPE  (107 % 256)
	{SLPCONNECTIONINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 1}},
#define   SLPCONNECTIONK        (108 % 256)
	{SLPCONNECTIONK, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 2}},
#define   SLPCONNECTIONN1       (109 % 256)
	{SLPCONNECTIONN1, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 3}},
#define   SLPCONNECTIONN2       (110 % 256)
	{SLPCONNECTIONN2, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 4}},
#define   SLPCONNECTIONSEQUENCEMODULUS  (111 % 256)
	{SLPCONNECTIONSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 5}},
#define   SLPCONNECTIONT1TIMER  (112 % 256)
	{SLPCONNECTIONT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 6}},
#define   SLPCONNECTIONT2TIMER  (113 % 256)
	{SLPCONNECTIONT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 7}},
#define   SLPCONNECTIONFCSERRORSRECEIVED  (114 % 256)
	{SLPCONNECTIONFCSERRORSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 8}},
#define   SLPCONNECTIONFRMRSRECEIVED  (115 % 256)
	{SLPCONNECTIONFRMRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 9}},
#define   SLPCONNECTIONFRMRSSENT  (116 % 256)
	{SLPCONNECTIONFRMRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 10}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED  (117 % 256)
	{SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 11}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSSENT  (118 % 256)
	{SLPCONNECTIONIFRAMEDATAOCTETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 12}},
#define   SLPCONNECTIONIFRAMESRECEIVED  (119 % 256)
	{SLPCONNECTIONIFRAMESRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 13}},
#define   SLPCONNECTIONIFRAMESSENT  (120 % 256)
	{SLPCONNECTIONIFRAMESSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 14}},
#define   SLPCONNECTIONPOLLSRECEIVED  (121 % 256)
	{SLPCONNECTIONPOLLSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 15}},
#define   SLPCONNECTIONREJSRECEIVED  (122 % 256)
	{SLPCONNECTIONREJSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 16}},
#define   SLPCONNECTIONREJSSENT  (123 % 256)
	{SLPCONNECTIONREJSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 17}},
#define   SLPCONNECTIONRNRSRECEIVED  (124 % 256)
	{SLPCONNECTIONRNRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 18}},
#define   SLPCONNECTIONRNRSSENT  (125 % 256)
	{SLPCONNECTIONRNRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 19}},
#define   SLPCONNECTIONSABMSRECEIVED  (126 % 256)
	{SLPCONNECTIONSABMSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 20}},
#define   SLPCONNECTIONSABMSSENT  (127 % 256)
	{SLPCONNECTIONSABMSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 21}},
#define   SLPCONNECTIONPROTOCOLSTATE  (128 % 256)
	{SLPCONNECTIONPROTOCOLSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 22}},
#define   SLPCONNECTIONTIMEST1EXPIRED  (129 % 256)
	{SLPCONNECTIONTIMEST1EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 23}},
#define   SLPCONNECTIONT3TIMER  (130 % 256)
	{SLPCONNECTIONT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 24}},
#define   SLPCONNECTIONTIMEST3EXPIRED  (131 % 256)
	{SLPCONNECTIONTIMEST3EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 25}},
#define   SLPCONNECTIONT4TIMER  (132 % 256)
	{SLPCONNECTIONT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 26}},
#define   SLPCONNECTIONTIMEST4EXPIRED  (133 % 256)
	{SLPCONNECTIONTIMEST4EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 27}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED  (134 % 256)
	{SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 28}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSSENT  (135 % 256)
	{SLPCONNECTIONABNORMALLINKDISCONNECTSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 29}},
#define   SLPCONNECTIONLINKRESETSRECEIVED  (136 % 256)
	{SLPCONNECTIONLINKRESETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 30}},
#define   SLPCONNECTIONLINKRESETSSENT  (137 % 256)
	{SLPCONNECTIONLINKRESETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 31}},
#define   SLPCONNECTIONTIMESN2REACHED  (138 % 256)
	{SLPCONNECTIONTIMESN2REACHED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 32}},
#define   SLPCONNECTIONADMINISTRATIVESTATE  (139 % 256)
	{SLPCONNECTIONADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 33}},
#define   SLPCONNECTIONOPERATIONALSTATE  (140 % 256)
	{SLPCONNECTIONOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 34}},
#define   SLPCONNECTIONUSAGESTATE  (141 % 256)
	{SLPCONNECTIONUSAGESTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 35}},
#define   SLPCONNECTIONPROCEDURALSTATUS  (142 % 256)
	{SLPCONNECTIONPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 36}},
#define   SLPCONNECTIONALARMSTATUS  (143 % 256)
	{SLPCONNECTIONALARMSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 37}},
#define   SLPCONNECTIONROWSTATUS  (144 % 256)
	{SLPCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 38}},
#define   SLPCONNECTIONIVMOID   (150 % 256)
	{SLPCONNECTIONIVMOID, ASN_OCTET_STR, RONLY, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 1}},
#define   SLPCONNECTIONIVMOINTERFACETYPE  (151 % 256)
	{SLPCONNECTIONIVMOINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   SLPCONNECTIONIVMOK    (152 % 256)
	{SLPCONNECTIONIVMOK, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 3}},
#define   SLPCONNECTIONIVMON1   (153 % 256)
	{SLPCONNECTIONIVMON1, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 4}},
#define   SLPCONNECTIONIVMON2   (154 % 256)
	{SLPCONNECTIONIVMON2, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 5}},
#define   SLPCONNECTIONIVMOSEQUENCEMODULUS  (155 % 256)
	{SLPCONNECTIONIVMOSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 6}},
#define   SLPCONNECTIONIVMOT1TIMER  (156 % 256)
	{SLPCONNECTIONIVMOT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 7}},
#define   SLPCONNECTIONIVMOT2TIMER  (157 % 256)
	{SLPCONNECTIONIVMOT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 8}},
#define   SLPCONNECTIONIVMOT3TIMER  (158 % 256)
	{SLPCONNECTIONIVMOT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 9}},
#define   SLPCONNECTIONIVMOT4TIMER  (159 % 256)
	{SLPCONNECTIONIVMOT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 10}},
#define   SLPCONNECTIONIVMOROWSTATUS  (160 % 256)
	{SLPCONNECTIONIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 11}},
#define   MACDLEROWSTATUS       (164 % 256)
	{MACDLEROWSTATUS, ASN_INTEGER, RWRITE, var_mACDLETable, 6, {1, 1, 17, 1, 1, 1}},
#define   MACOPERATIONALSTATE   (168 % 256)
	{MACOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mACTable, 6, {1, 1, 18, 1, 1, 1}},
#define   MACROWSTATUS          (170 % 256)
	{MACROWSTATUS, ASN_INTEGER, RWRITE, var_mACTable, 6, {1, 1, 18, 1, 1, 3}},
#define   LLCDLEROWSTATUS       (174 % 256)
	{LLCDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lLCDLETable, 6, {1, 1, 19, 1, 1, 1}},
#define   LLCCLPMROWSTATUS      (179 % 256)
	{LLCCLPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCLPMTable, 6, {1, 1, 20, 1, 1, 1}},
#define   LLCCOPMROWSTATUS      (184 % 256)
	{LLCCOPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCOPMTable, 6, {1, 1, 21, 1, 1, 1}},
#define   RESOURCETYPEIDNAME    (188 % 256)
	{RESOURCETYPEIDNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 1}},
#define   RESOURCEINFOMANUFACTUREROUI  (189 % 256)
	{RESOURCEINFOMANUFACTUREROUI, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 2}},
#define   RESOURCEINFOMANUFACTURERNAME  (190 % 256)
	{RESOURCEINFOMANUFACTURERNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 3}},
#define   RESOURCEINFOMANUFACTURERPRODUCTNAME  (191 % 256)
	{RESOURCEINFOMANUFACTURERPRODUCTNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 4}},
#define   RESOURCEINFOMANUFACTURERPRODUCTVERSION  (192 % 256)
	{RESOURCEINFOMANUFACTURERPRODUCTVERSION, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 5}},
#define   LLCSTATIONLLCNAME     (197 % 256)
	{LLCSTATIONLLCNAME, ASN_OCTET_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 1}},
#define   LLCSTATIONMAXIMUMLSAPSCONFIGURED  (198 % 256)
	{LLCSTATIONMAXIMUMLSAPSCONFIGURED, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 2}},
#define   LLCSTATIONNUMBEROFACTIVELSAPS  (199 % 256)
	{LLCSTATIONNUMBEROFACTIVELSAPS, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 3}},
#define   LLCSTATIONSUPPORTEDSERVICESTYPES  (200 % 256)
	{LLCSTATIONSUPPORTEDSERVICESTYPES, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 4}},
#define   LLCSTATIONSTATUS      (201 % 256)
	{LLCSTATIONSTATUS, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 5}},
#define   LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE  (202 % 256)
	{LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 6}},
#define   LLCSTATIONTYPE1MAXIMUMRETRYCOUNT  (203 % 256)
	{LLCSTATIONTYPE1MAXIMUMRETRYCOUNT, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 7}},
#define   LLCSTATIONMAXIMUMPDUN3  (204 % 256)
	{LLCSTATIONMAXIMUMPDUN3, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 8}},
#define   LLCSTATIONMAXIMUMRETRANSMISSIONS4  (205 % 256)
	{LLCSTATIONMAXIMUMRETRANSMISSIONS4, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 9}},
#define   LLCSTATIONRECEIVEVARIABLELIFETIME  (206 % 256)
	{LLCSTATIONRECEIVEVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 10}},
#define   LLCSTATIONTRANSMITVARIABLELIFETIME  (207 % 256)
	{LLCSTATIONTRANSMITVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 11}},
#define   LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE  (208 % 256)
	{LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 12}},
#define   LLCSTATIONTYPE3RETRANSMISSIONS  (209 % 256)
	{LLCSTATIONTYPE3RETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 13}},
#define   LLCSTATIONAVGBUFFERUSESIZE  (210 % 256)
	{LLCSTATIONAVGBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 14}},
#define   LLCSTATIONBUFFERPROBLEMS  (211 % 256)
	{LLCSTATIONBUFFERPROBLEMS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 15}},
#define   LLCSTATIONBUFFERSIZE  (212 % 256)
	{LLCSTATIONBUFFERSIZE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 16}},
#define   LLCSTATIONMAXBUFFERUSESIZE  (213 % 256)
	{LLCSTATIONMAXBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 17}},
#define   LLCSTATIONINACTIVELSAP  (214 % 256)
	{LLCSTATIONINACTIVELSAP, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 18}},
#define   LLCSTATIONPDUSDISCARD  (215 % 256)
	{LLCSTATIONPDUSDISCARD, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 19}},
#define   LLCSTATIONSTRINDICATOR  (216 % 256)
	{LLCSTATIONSTRINDICATOR, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 20}},
#define   LLCSTATIONVERSIONNUMBER  (217 % 256)
	{LLCSTATIONVERSIONNUMBER, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 21}},
#define   LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS  (218 % 256)
	{LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 22}},
#define   LLCSAPADDRESS         (224 % 256)
	{LLCSAPADDRESS, ASN_OCTET_STR, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 2}},
#define   LLCSAPRDE             (225 % 256)
	{LLCSAPRDE, ASN_INTEGER, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 3}},
#define   RDESETUPAGINGENABLED  (230 % 256)
	{RDESETUPAGINGENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 1}},
#define   RDESETUPAGINGVALUE    (231 % 256)
	{RDESETUPAGINGVALUE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 2}},
#define   RDESETUPENABLETYPE2RESET  (232 % 256)
	{RDESETUPENABLETYPE2RESET, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 3}},
#define   RDESETUPMAXIMUMROUTEDESCRIPTORS  (233 % 256)
	{RDESETUPMAXIMUMROUTEDESCRIPTORS, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 4}},
#define   RDESETUPMAXIMUMRESPONSETIME  (234 % 256)
	{RDESETUPMAXIMUMRESPONSETIME, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 5}},
#define   RDESETUPMINIMUMPDUSIZE  (235 % 256)
	{RDESETUPMINIMUMPDUSIZE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 6}},
#define   RDESETUPRDEHOLD       (236 % 256)
	{RDESETUPRDEHOLD, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 7}},
#define   RDESETUPRDEREPLACE    (237 % 256)
	{RDESETUPRDEREPLACE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 8}},
#define   RDESETUPNAME          (238 % 256)
	{RDESETUPNAME, ASN_INTEGER, RONLY, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 9}},
#define   RDESETUPRESETONTESTENABLED  (239 % 256)
	{RDESETUPRESETONTESTENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 10}},
#define   RDEPAIRDISCARDCOUNTER  (245 % 256)
	{RDEPAIRDISCARDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 2}},
#define   RDEPAIRNSRPDUCOUNTER  (246 % 256)
	{RDEPAIRNSRPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 3}},
#define   RDEPAIRNSRSELECTEDCOUNTER  (247 % 256)
	{RDEPAIRNSRSELECTEDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 4}},
#define   RDEPAIRRIF            (248 % 256)
	{RDEPAIRRIF, ASN_OCTET_STR, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 5}},
#define   RDEPAIRSRFPDUCOUNTER  (249 % 256)
	{RDEPAIRSRFPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 6}},
#define   RDEPAIRQUERYCOUNTER   (250 % 256)
	{RDEPAIRQUERYCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 7}},
#define   LLCCONNECTIONLESSNAME  (256 % 256)
	{LLCCONNECTIONLESSNAME, ASN_OCTET_STR, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 1}},
#define   LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE  (257 % 256)
	{LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 2}},
#define   LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE  (258 % 256)
	{LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 3}},
#define   LLCCONNECTIONLESSTESTRECEIVEDCOMMAND  (259 % 256)
	{LLCCONNECTIONLESSTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 4}},
#define   LLCCONNECTIONLESSTESTRECEIVEDRESPONSE  (260 % 256)
	{LLCCONNECTIONLESSTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 5}},
#define   LLCCONNECTIONLESSTESTSENTABBRESPONSE  (261 % 256)
	{LLCCONNECTIONLESSTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 6}},
#define   LLCCONNECTIONLESSTESTSENTCOMMAND  (262 % 256)
	{LLCCONNECTIONLESSTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 7}},
#define   LLCCONNECTIONLESSTESTSENTRESPONSE  (263 % 256)
	{LLCCONNECTIONLESSTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 8}},
#define   LLCCONNECTIONLESSUIRECEIVED  (264 % 256)
	{LLCCONNECTIONLESSUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 9}},
#define   LLCCONNECTIONLESSUISENT  (265 % 256)
	{LLCCONNECTIONLESSUISENT, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 10}},
#define   LLCCONNECTIONLESSXIDRECEIVEDCOMMAND  (266 % 256)
	{LLCCONNECTIONLESSXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 11}},
#define   LLCCONNECTIONLESSXIDRECEIVEDRESPONSE  (267 % 256)
	{LLCCONNECTIONLESSXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 12}},
#define   LLCCONNECTIONLESSXIDSENTCOMMAND  (268 % 256)
	{LLCCONNECTIONLESSXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 13}},
#define   LLCCONNECTIONLESSXIDSENTRESPONSE  (269 % 256)
	{LLCCONNECTIONLESSXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 14}},
#define   LLCCONNECTION2NAME    (275 % 256)
	{LLCCONNECTION2NAME, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 1}},
#define   LLCCONNECTION2MAXIMUMRETRANSMISSIONS  (276 % 256)
	{LLCCONNECTION2MAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 2}},
#define   LLCCONNECTION2RECEIVEDWINDOWSIZE  (277 % 256)
	{LLCCONNECTION2RECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 3}},
#define   LLCCONNECTION2SENDWINDOWSIZE  (278 % 256)
	{LLCCONNECTION2SENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 4}},
#define   LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE  (279 % 256)
	{LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 5}},
#define   LLCCONNECTION2BUSYSTATETIMEOUTVALUE  (280 % 256)
	{LLCCONNECTION2BUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 6}},
#define   LLCCONNECTION2PBITTIMEOUTVALUE  (281 % 256)
	{LLCCONNECTION2PBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 7}},
#define   LLCCONNECTION2REJECTTIMEOUTVALUE  (282 % 256)
	{LLCCONNECTION2REJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 8}},
#define   LLCCONNECTION2LOCALBUSY  (283 % 256)
	{LLCCONNECTION2LOCALBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 9}},
#define   LLCCONNECTION2REMOTEBUSY  (284 % 256)
	{LLCCONNECTION2REMOTEBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 10}},
#define   LLCCONNECTION2REMOTERESET  (285 % 256)
	{LLCCONNECTION2REMOTERESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 11}},
#define   LLCCONNECTION2LOCALRESET  (286 % 256)
	{LLCCONNECTION2LOCALRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 12}},
#define   LLCCONNECTION2PROVIDERRESET  (287 % 256)
	{LLCCONNECTION2PROVIDERRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 13}},
#define   LLCCONNECTION2ROUTE   (288 % 256)
	{LLCCONNECTION2ROUTE, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 14}},
#define   LLCCONNECTION2KSTEP   (289 % 256)
	{LLCCONNECTION2KSTEP, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 15}},
#define   LLCCONNECTION2MAXSENDWINDOWSIZE  (290 % 256)
	{LLCCONNECTION2MAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 16}},
#define   LLCCONNECTION2RECEIVEDI  (291 % 256)
	{LLCCONNECTION2RECEIVEDI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 17}},
#define   LLCCONNECTION2SENTI   (292 % 256)
	{LLCCONNECTION2SENTI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 18}},
#define   LLCCONNECTION2SENTACKS  (293 % 256)
	{LLCCONNECTION2SENTACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 19}},
#define   LLCCONNECTION2RECEIVEDACKS  (294 % 256)
	{LLCCONNECTION2RECEIVEDACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 20}},
#define   LLCCONNECTION2RECEIVEDFRMR  (295 % 256)
	{LLCCONNECTION2RECEIVEDFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 21}},
#define   LLCCONNECTION2SENTFRMR  (296 % 256)
	{LLCCONNECTION2SENTFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 22}},
#define   LLCCONNECTION2RECEIVEDRR  (297 % 256)
	{LLCCONNECTION2RECEIVEDRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 23}},
#define   LLCCONNECTION2SENTRR  (298 % 256)
	{LLCCONNECTION2SENTRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 24}},
#define   LLCCONNECTION2RECEIVEDRNR  (299 % 256)
	{LLCCONNECTION2RECEIVEDRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 25}},
#define   LLCCONNECTION2SENTRNR  (300 % 256)
	{LLCCONNECTION2SENTRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 26}},
#define   LLCCONNECTION2RECEIVEDREJ  (301 % 256)
	{LLCCONNECTION2RECEIVEDREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 27}},
#define   LLCCONNECTION2SENTREJ  (302 % 256)
	{LLCCONNECTION2SENTREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 28}},
#define   LLCCONNECTION2RECEIVEDSABME  (303 % 256)
	{LLCCONNECTION2RECEIVEDSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 29}},
#define   LLCCONNECTION2SENTSABME  (304 % 256)
	{LLCCONNECTION2SENTSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 30}},
#define   LLCCONNECTION2RECEIVEDUA  (305 % 256)
	{LLCCONNECTION2RECEIVEDUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 31}},
#define   LLCCONNECTION2SENTUA  (306 % 256)
	{LLCCONNECTION2SENTUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 32}},
#define   LLCCONNECTION2RECEIVEDDISC  (307 % 256)
	{LLCCONNECTION2RECEIVEDDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 33}},
#define   LLCCONNECTION2SENTDISC  (308 % 256)
	{LLCCONNECTION2SENTDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 34}},
#define   LLCCONNECTION2RECEIVEDDM  (309 % 256)
	{LLCCONNECTION2RECEIVEDDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 35}},
#define   LLCCONNECTION2SENTDM  (310 % 256)
	{LLCCONNECTION2SENTDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 36}},
#define   LLCCONNECTION2PDUSDISCARDED1  (311 % 256)
	{LLCCONNECTION2PDUSDISCARDED1, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 37}},
#define   LLCCONNECTION2PDUSDISCARDED2  (312 % 256)
	{LLCCONNECTION2PDUSDISCARDED2, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 38}},
#define   LLCCONNECTION2PDURETRANSMISSIONS  (313 % 256)
	{LLCCONNECTION2PDURETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 39}},
#define   LLCCONNECTION2OPTIONALTOLERATIONIPDUS  (314 % 256)
	{LLCCONNECTION2OPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 40}},
#define   LLCCONNECTION2DUPLICATEIPDUSRECEIVED  (315 % 256)
	{LLCCONNECTION2DUPLICATEIPDUSRECEIVED, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 41}},
#define   LLCCONNECTION2VIOLATION  (316 % 256)
	{LLCCONNECTION2VIOLATION, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 42}},
#define   LLCCONNECTION2PROTOCOLSTATE  (317 % 256)
	{LLCCONNECTION2PROTOCOLSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 43}},
#define   LLCCONNECTION2ADMINISTRATIVESTATE  (318 % 256)
	{LLCCONNECTION2ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 44}},
#define   LLCCONNECTION2OPERATIONALSTATE  (319 % 256)
	{LLCCONNECTION2OPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 45}},
#define   LLCCONNECTION2USAGESTATE  (320 % 256)
	{LLCCONNECTION2USAGESTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 46}},
#define   LLCCONNECTION2PROCEDURALSTATUS  (321 % 256)
	{LLCCONNECTION2PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 47}},
#define   LLCCONNECTION2ALARMSTATUS  (322 % 256)
	{LLCCONNECTION2ALARMSTATUS, ASN_BIT_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 48}},
#define   LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS  (329 % 256)
	{LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 2}},
#define   LLCCONNECTION2IVMORECEIVEDWINDOWSIZE  (330 % 256)
	{LLCCONNECTION2IVMORECEIVEDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 3}},
#define   LLCCONNECTION2IVMOSENDWINDOWSIZE  (331 % 256)
	{LLCCONNECTION2IVMOSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 4}},
#define   LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE  (332 % 256)
	{LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 5}},
#define   LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE  (333 % 256)
	{LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 6}},
#define   LLCCONNECTION2IVMOBITTIMEOUTVALUE  (334 % 256)
	{LLCCONNECTION2IVMOBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 7}},
#define   LLCCONNECTION2IVMOREJECTTIMEOUTVALUE  (335 % 256)
	{LLCCONNECTION2IVMOREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 8}},
#define   LLCCONNECTION2IVMOROUTE  (336 % 256)
	{LLCCONNECTION2IVMOROUTE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 9}},
#define   LLCCONNECTION2IVMOKSTEP  (337 % 256)
	{LLCCONNECTION2IVMOKSTEP, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 10}},
#define   LLCCONNECTION2IVMOMAXSENDWINDOWSIZE  (338 % 256)
	{LLCCONNECTION2IVMOMAXSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 11}},
#define   LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS  (339 % 256)
	{LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE  (346 % 256)
	{LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS  (347 % 256)
	{LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE  (348 % 256)
	{LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 4}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND  (349 % 256)
	{LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 5}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE  (350 % 256)
	{LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 6}},
#define   LLCCONNECTIONLESSACKTESTSENTABBRESPONSE  (351 % 256)
	{LLCCONNECTIONLESSACKTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 7}},
#define   LLCCONNECTIONLESSACKTESTSENTCOMMAND  (352 % 256)
	{LLCCONNECTIONLESSACKTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 8}},
#define   LLCCONNECTIONLESSACKTESTSENTRESPONSE  (353 % 256)
	{LLCCONNECTIONLESSACKTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 9}},
#define   LLCCONNECTIONLESSACKRECEIVERESOURCES  (354 % 256)
	{LLCCONNECTIONLESSACKRECEIVERESOURCES, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 10}},
#define   LLCCONNECTIONLESSACKUIRECEIVED  (355 % 256)
	{LLCCONNECTIONLESSACKUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 11}},
#define   LLCCONNECTIONLESSACKUISENT  (356 % 256)
	{LLCCONNECTIONLESSACKUISENT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND  (357 % 256)
	{LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 13}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE  (358 % 256)
	{LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 14}},
#define   LLCCONNECTIONLESSACKXIDSENTCOMMAND  (359 % 256)
	{LLCCONNECTIONLESSACKXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 15}},
#define   LLCCONNECTIONLESSACKXIDSENTRESPONSE  (360 % 256)
	{LLCCONNECTIONLESSACKXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 16}},
#define   LLCCONNECTIONLESSACKRETRANSMISSIONS  (361 % 256)
	{LLCCONNECTIONLESSACKRETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 17}},
#define   LLCCONNECTIONLESSACKNORESPONSE  (362 % 256)
	{LLCCONNECTIONLESSACKNORESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 18}},
#define   LLCCONNECTIONLESSACKCOMMANDIP  (363 % 256)
	{LLCCONNECTIONLESSACKCOMMANDIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 19}},
#define   LLCCONNECTIONLESSACKCOMMANDIT  (364 % 256)
	{LLCCONNECTIONLESSACKCOMMANDIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 20}},
#define   LLCCONNECTIONLESSACKCOMMANDOK  (365 % 256)
	{LLCCONNECTIONLESSACKCOMMANDOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 21}},
#define   LLCCONNECTIONLESSACKCOMMANDPE  (366 % 256)
	{LLCCONNECTIONLESSACKCOMMANDPE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 22}},
#define   LLCCONNECTIONLESSACKCOMMANDRS  (367 % 256)
	{LLCCONNECTIONLESSACKCOMMANDRS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 23}},
#define   LLCCONNECTIONLESSACKCOMMANDUE  (368 % 256)
	{LLCCONNECTIONLESSACKCOMMANDUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 24}},
#define   LLCCONNECTIONLESSACKCOMMANDUN  (369 % 256)
	{LLCCONNECTIONLESSACKCOMMANDUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 25}},
#define   LLCCONNECTIONLESSACKRECEIVEDACCOMMAND  (370 % 256)
	{LLCCONNECTIONLESSACKRECEIVEDACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 26}},
#define   LLCCONNECTIONLESSACKSENTACCOMMAND  (371 % 256)
	{LLCCONNECTIONLESSACKSENTACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 27}},
#define   LLCCONNECTIONLESSACKRESPONSEIP  (372 % 256)
	{LLCCONNECTIONLESSACKRESPONSEIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 28}},
#define   LLCCONNECTIONLESSACKRESPONSEIT  (373 % 256)
	{LLCCONNECTIONLESSACKRESPONSEIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 29}},
#define   LLCCONNECTIONLESSACKRESPONSENE  (374 % 256)
	{LLCCONNECTIONLESSACKRESPONSENE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 30}},
#define   LLCCONNECTIONLESSACKRESPONSENR  (375 % 256)
	{LLCCONNECTIONLESSACKRESPONSENR, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 31}},
#define   LLCCONNECTIONLESSACKRESPONSEOK  (376 % 256)
	{LLCCONNECTIONLESSACKRESPONSEOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 32}},
#define   LLCCONNECTIONLESSACKRESPONSERS  (377 % 256)
	{LLCCONNECTIONLESSACKRESPONSERS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 33}},
#define   LLCCONNECTIONLESSACKRESPONSEUE  (378 % 256)
	{LLCCONNECTIONLESSACKRESPONSEUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 34}},
#define   LLCCONNECTIONLESSACKRESPONSEUN  (379 % 256)
	{LLCCONNECTIONLESSACKRESPONSEUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 35}},
#define   LLCCONNECTIONLESSACKVIOLATION  (380 % 256)
	{LLCCONNECTIONLESSACKVIOLATION, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 36}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE  (386 % 256)
	{LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS  (387 % 256)
	{LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKIVMOROWSTATUS  (388 % 256)
	{LLCCONNECTIONLESSACKIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 4}},
#define   NETWORKENTITYTITLES   (392 % 256)
	{NETWORKENTITYTITLES, ASN_OCTET_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 1}},
#define   NETWORKENTITYSYSTEMTYPES  (393 % 256)
	{NETWORKENTITYSYSTEMTYPES, ASN_BIT_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 2}},
#define   NETWORKENTITYROWSTATUS  (394 % 256)
	{NETWORKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 3}},
#define   NSAPROWSTATUS         (398 % 256)
	{NSAPROWSTATUS, ASN_INTEGER, RWRITE, var_nSAPTable, 6, {1, 1, 33, 1, 1, 1}},
#define   CLNSADMINISTRATIVESTATE  (403 % 256)
	{CLNSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 1}},
#define   CLNSSUPPORTEDPROTOCOLS  (404 % 256)
	{CLNSSUPPORTEDPROTOCOLS, ASN_OCTET_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 2}},
#define   CLNSOPERATIONALSYSTEMTYPE  (405 % 256)
	{CLNSOPERATIONALSYSTEMTYPE, ASN_BIT_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 3}},
#define   CLNSOCTETSSENTCOUNTER  (406 % 256)
	{CLNSOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 4}},
#define   CLNSOCTETSRECEIVEDCOUNTER  (407 % 256)
	{CLNSOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 5}},
#define   CLNSSEGMENTSRECEIVED  (408 % 256)
	{CLNSSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 6}},
#define   CLNSSEGMENTSDISCARDED  (409 % 256)
	{CLNSSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 7}},
#define   CLNSASSEMBLINGSEGMENTSDISCARDED  (410 % 256)
	{CLNSASSEMBLINGSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 8}},
#define   CLNSERRORREPORTSRECEIVED  (411 % 256)
	{CLNSERRORREPORTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 9}},
#define   CLNSPDUDISCARDS       (412 % 256)
	{CLNSPDUDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 10}},
#define   CLNSCONGESTIONDISCARDS  (413 % 256)
	{CLNSCONGESTIONDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 11}},
#define   CLNSMAXIMUMLIFETIME   (414 % 256)
	{CLNSMAXIMUMLIFETIME, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 12}},
#define   CLNSENABLECHECKSUM    (415 % 256)
	{CLNSENABLECHECKSUM, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 13}},
#define   CLNSROWSTATUS         (416 % 256)
	{CLNSROWSTATUS, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 14}},
#define   CLNSISISVERSION       (421 % 256)
	{CLNSISISVERSION, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 1}},
#define   CLNSISISISTYPE        (422 % 256)
	{CLNSISISISTYPE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 2}},
#define   CLNSISISSYSTEMID      (423 % 256)
	{CLNSISISSYSTEMID, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 3}},
#define   CLNSISISMAXIMUMPATHSPLITS  (424 % 256)
	{CLNSISISMAXIMUMPATHSPLITS, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 4}},
#define   CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL  (425 % 256)
	{CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 5}},
#define   CLNSISISMAXIMUMLSPGENERATIONINTERVAL  (426 % 256)
	{CLNSISISMAXIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 6}},
#define   CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL  (427 % 256)
	{CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 7}},
#define   CLNSISISCOMPLETESNPINTERVAL  (428 % 256)
	{CLNSISISCOMPLETESNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 8}},
#define   CLNSISISORIGINATINGL1LSPBUFFERSIZE  (429 % 256)
	{CLNSISISORIGINATINGL1LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 9}},
#define   CLNSISISMANUALAREAADDRESSES  (430 % 256)
	{CLNSISISMANUALAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 10}},
#define   CLNSISISMAXIMUMAREAADDRESSES  (431 % 256)
	{CLNSISISMAXIMUMAREAADDRESSES, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 11}},
#define   CLNSISISMINIMUMLSPGENERATIONINTERVAL  (432 % 256)
	{CLNSISISMINIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 12}},
#define   CLNSISISPOLLESHELLORATE  (433 % 256)
	{CLNSISISPOLLESHELLORATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 13}},
#define   CLNSISISPARTIALSNPINTERVAL  (434 % 256)
	{CLNSISISPARTIALSNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 14}},
#define   CLNSISISWAITINGTIME   (435 % 256)
	{CLNSISISWAITINGTIME, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 15}},
#define   CLNSISISDRISISHELLOTIMER  (436 % 256)
	{CLNSISISDRISISHELLOTIMER, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 16}},
#define   CLNSISISL1STATE       (437 % 256)
	{CLNSISISL1STATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 17}},
#define   CLNSISISAREAADDRESSES  (438 % 256)
	{CLNSISISAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 18}},
#define   CLNSISISCORRUPTEDLSPSDETECTED  (439 % 256)
	{CLNSISISCORRUPTEDLSPSDETECTED, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 19}},
#define   CLNSISISLSPL1DATABASEOVERLOADS  (440 % 256)
	{CLNSISISLSPL1DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 20}},
#define   CLNSISISMANUALADDRESSESDROPPEDFROMAREAS  (441 % 256)
	{CLNSISISMANUALADDRESSESDROPPEDFROMAREAS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 21}},
#define   CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER  (442 % 256)
	{CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 22}},
#define   CLNSISISSEQUENCENUMBERSKIPS  (443 % 256)
	{CLNSISISSEQUENCENUMBERSKIPS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 23}},
#define   CLNSISISOWNLSPPURGES  (444 % 256)
	{CLNSISISOWNLSPPURGES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 24}},
#define   CLNSISISIDFIELDLENGTHMISMATCHES  (445 % 256)
	{CLNSISISIDFIELDLENGTHMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 25}},
#define   CLNSISISMAXIMUMAREAADDRESSESMISMATCHES  (446 % 256)
	{CLNSISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 26}},
#define   CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES  (447 % 256)
	{CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 27}},
#define   CLNSISISLSPTOOLARGETOPROPAGATE  (448 % 256)
	{CLNSISISLSPTOOLARGETOPROPAGATE, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 28}},
#define   CLNSISISAREATRANSMITPASSWORD  (449 % 256)
	{CLNSISISAREATRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 29}},
#define   CLNSISISAREARECEIVEPASSWORDS  (450 % 256)
	{CLNSISISAREARECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 30}},
#define   CLNSISISAUTHENTICATIONFAILURES  (451 % 256)
	{CLNSISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 31}},
#define   CLNSISISROWSTATUS     (452 % 256)
	{CLNSISISROWSTATUS, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 32}},
#define   CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES  (456 % 256)
	{CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 1}},
#define   CLNSISISLEVEL2PARTITIONAREAADDRESSES  (457 % 256)
	{CLNSISISLEVEL2PARTITIONAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 2}},
#define   CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM  (458 % 256)
	{CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 3}},
#define   CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES  (459 % 256)
	{CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 4}},
#define   CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE  (460 % 256)
	{CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 5}},
#define   CLNSISISLEVEL2L2STATE  (461 % 256)
	{CLNSISISLEVEL2L2STATE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 6}},
#define   CLNSISISLEVEL2LSPL2DATABASEOVERLOADS  (462 % 256)
	{CLNSISISLEVEL2LSPL2DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 7}},
#define   CLNSISISLEVEL2DOMAINTRANSMITPASSWORD  (463 % 256)
	{CLNSISISLEVEL2DOMAINTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 8}},
#define   CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS  (464 % 256)
	{CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 9}},
#define   CLNSISISLEVEL2ROWSTATUS  (465 % 256)
	{CLNSISISLEVEL2ROWSTATUS, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 10}},
#define   LINKAGEOPERATIONALSTATE  (471 % 256)
	{LINKAGEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 3}},
#define   LINKAGEADMINISTRATIVESTATE  (472 % 256)
	{LINKAGEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 4}},
#define   LINKAGESNSERVICEPROVIDER  (473 % 256)
	{LINKAGESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 5}},
#define   LINKAGESNSAP          (474 % 256)
	{LINKAGESNSAP, ASN_OBJECT_ID, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 6}},
#define   LINKAGEOPERATIONALPROTOCOLS  (475 % 256)
	{LINKAGEOPERATIONALPROTOCOLS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 7}},
#define   LINKAGEISISO9542OPERATIONALSUBSETS  (476 % 256)
	{LINKAGEISISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 8}},
#define   LINKAGEISHOLDINGTIMERMULTIPLIER  (477 % 256)
	{LINKAGEISHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 9}},
#define   LINKAGEISISCONFIGURATIONTIMER  (478 % 256)
	{LINKAGEISISCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 10}},
#define   LINKAGEISSUGGESTEDESCONFIGURATIONTIMER  (479 % 256)
	{LINKAGEISSUGGESTEDESCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 11}},
#define   LINKAGEISREDIRECTHOLDINGTIME  (480 % 256)
	{LINKAGEISREDIRECTHOLDINGTIME, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 12}},
#define   LINKAGEISESREACHABILITYCHANGES  (481 % 256)
	{LINKAGEISESREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 13}},
#define   LINKAGEISINVALID9542PDUS  (482 % 256)
	{LINKAGEISINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 14}},
#define   LINKAGEESISO9542OPERATIONALSUBSETS  (483 % 256)
	{LINKAGEESISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 15}},
#define   LINKAGEESHOLDINGTIMERMULTIPLIER  (484 % 256)
	{LINKAGEESHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 16}},
#define   LINKAGEESMANUALISSNPAADDRESS  (485 % 256)
	{LINKAGEESMANUALISSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 17}},
#define   LINKAGEESDEFAULTESCONFIGTIMER  (486 % 256)
	{LINKAGEESDEFAULTESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 18}},
#define   LINKAGEESACTIVEESCONFIGTIMER  (487 % 256)
	{LINKAGEESACTIVEESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 19}},
#define   LINKAGEESISREACHABILITYCHANGES  (488 % 256)
	{LINKAGEESISREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 20}},
#define   LINKAGEESINVALID9542PDUS  (489 % 256)
	{LINKAGEESINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 21}},
#define   LINKAGEENABLECHECKSUM  (490 % 256)
	{LINKAGEENABLECHECKSUM, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 22}},
#define   LINKAGEINITIALMINIMUMTIMER  (491 % 256)
	{LINKAGEINITIALMINIMUMTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 23}},
#define   LINKAGERESERVETIMER   (492 % 256)
	{LINKAGERESERVETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 24}},
#define   LINKAGEIDLETIMER      (493 % 256)
	{LINKAGEIDLETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 25}},
#define   LINKAGESNDCFCALLSPLACED  (494 % 256)
	{LINKAGESNDCFCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 26}},
#define   LINKAGESNDCFCALLSFAILED  (495 % 256)
	{LINKAGESNDCFCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 27}},
#define   LINKAGECODLCALLSPLACED  (496 % 256)
	{LINKAGECODLCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 28}},
#define   LINKAGECODLCALLSFAILED  (497 % 256)
	{LINKAGECODLCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 29}},
#define   LINKAGEISISTYPE       (498 % 256)
	{LINKAGEISISTYPE, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 30}},
#define   LINKAGEISISISISHELLOTIMER  (499 % 256)
	{LINKAGEISISISISHELLOTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 31}},
#define   LINKAGEISISL1DEFAULTMETRIC  (500 % 256)
	{LINKAGEISISL1DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 32}},
#define   LINKAGEISISL1DELAYMETRIC  (501 % 256)
	{LINKAGEISISL1DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 33}},
#define   LINKAGEISISL1EXPENSEMETRIC  (502 % 256)
	{LINKAGEISISL1EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 34}},
#define   LINKAGEISISL1ERRORMETRIC  (503 % 256)
	{LINKAGEISISL1ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 35}},
#define   LINKAGEISISEXTERNALDOMAIN  (504 % 256)
	{LINKAGEISISEXTERNALDOMAIN, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 36}},
#define   LINKAGEISISCHANGEDINADJACENCYSTATE  (505 % 256)
	{LINKAGEISISCHANGEDINADJACENCYSTATE, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 37}},
#define   LINKAGEISISINITIALISATIONFAILURES  (506 % 256)
	{LINKAGEISISINITIALISATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 38}},
#define   LINKAGEISISREJECTEDADJACENCIES  (507 % 256)
	{LINKAGEISISREJECTEDADJACENCIES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 39}},
#define   LINKAGEISISISISCONTROLPDUSSENT  (508 % 256)
	{LINKAGEISISISISCONTROLPDUSSENT, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 40}},
#define   LINKAGEISISISISCONTROLPDUSRECEIVED  (509 % 256)
	{LINKAGEISISISISCONTROLPDUSRECEIVED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 41}},
#define   LINKAGEISISIDFIELDLENTHMISMATCHES  (510 % 256)
	{LINKAGEISISIDFIELDLENTHMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 42}},
#define   LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES  (511 % 256)
	{LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 43}},
#define   LINKAGEISISCIRCUITTRANSMITPASSWORD  (512 % 256)
	{LINKAGEISISCIRCUITTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 44}},
#define   LINKAGEISISCIRCUITRECEIVEDPASSWORDS  (513 % 256)
	{LINKAGEISISCIRCUITRECEIVEDPASSWORDS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 45}},
#define   LINKAGEISISAUTHENTICATIONFAILURES  (514 % 256)
	{LINKAGEISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 46}},
#define   LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY  (515 % 256)
	{LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 47}},
#define   LINKAGEISISL1CIRCUITID  (516 % 256)
	{LINKAGEISISL1CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 48}},
#define   LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM  (517 % 256)
	{LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 49}},
#define   LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES  (518 % 256)
	{LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 50}},
#define   LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT  (519 % 256)
	{LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 51}},
#define   LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT  (520 % 256)
	{LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 52}},
#define   LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT  (521 % 256)
	{LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 53}},
#define   LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT  (522 % 256)
	{LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 54}},
#define   LINKAGEISISPTPTCIRCUITID  (523 % 256)
	{LINKAGEISISPTPTCIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 55}},
#define   LINKAGEISISOUTGOINGCALLIVMO  (524 % 256)
	{LINKAGEISISOUTGOINGCALLIVMO, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 56}},
#define   LINKAGEISISNEIGHBORSNPAADDRESS  (525 % 256)
	{LINKAGEISISNEIGHBORSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 57}},
#define   LINKAGEISISL2DEFAULTMETRIC  (526 % 256)
	{LINKAGEISISL2DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 58}},
#define   LINKAGEISISL2DELAYMETRIC  (527 % 256)
	{LINKAGEISISL2DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 59}},
#define   LINKAGEISISL2EXPENSEMETRIC  (528 % 256)
	{LINKAGEISISL2EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 60}},
#define   LINKAGEISISL2ERRORMETRIC  (529 % 256)
	{LINKAGEISISL2ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 61}},
#define   LINKAGEISISMANUALL2ONLYMODE  (530 % 256)
	{LINKAGEISISMANUALL2ONLYMODE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 62}},
#define   LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY  (531 % 256)
	{LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 63}},
#define   LINKAGEISISL2CIRCUITID  (532 % 256)
	{LINKAGEISISL2CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 64}},
#define   LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM  (533 % 256)
	{LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 65}},
#define   LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES  (534 % 256)
	{LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 66}},
#define   LINKAGEROWSTATUS      (535 % 256)
	{LINKAGEROWSTATUS, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 67}},
#define   CONSADMINISTRATIVESTATE  (540 % 256)
	{CONSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 1}},
#define   CONSOPERATIONALSYSTEMTYPE  (541 % 256)
	{CONSOPERATIONALSYSTEMTYPE, ASN_BIT_STR, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 2}},
#define   CONSROWSTATUS         (542 % 256)
	{CONSROWSTATUS, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 3}},
#define   NETWORKCONNECTIONLOCALNSAPMO  (548 % 256)
	{NETWORKCONNECTIONLOCALNSAPMO, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 1}},
#define   NETWORKCONNECTIONREMOTENSAPADDRESS  (549 % 256)
	{NETWORKCONNECTIONREMOTENSAPADDRESS, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 2}},
#define   NETWORKCONNECTIONROWSTATUS  (550 % 256)
	{NETWORKCONNECTIONROWSTATUS, ASN_INTEGER, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 3}},
#define   X25PLEOPERATIONALSTATE  (554 % 256)
	{X25PLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 2}},
#define   X25PLEADMINISTRATIVESTATE  (555 % 256)
	{X25PLEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 3}},
#define   X25PLEPROTOCOLVERSIONSUPPORTED  (556 % 256)
	{X25PLEPROTOCOLVERSIONSUPPORTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 4}},
#define   X25PLELOCALDTEADDRESS  (557 % 256)
	{X25PLELOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 5}},
#define   X25PLEMODE            (558 % 256)
	{X25PLEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 6}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSES  (559 % 256)
	{X25PLEDEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 7}},
#define   X25PLEFLOWCONTROLPARAMETERNEGOTIATION  (560 % 256)
	{X25PLEFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 8}},
#define   X25PLEDEFAULTPACKAGESIZES  (561 % 256)
	{X25PLEDEFAULTPACKAGESIZES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 9}},
#define   X25PLETHROUGHPUTCLASSNEGOTIATION  (562 % 256)
	{X25PLETHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 10}},
#define   X25PLESNSERVICEPROVIDER  (563 % 256)
	{X25PLESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 11}},
#define   X25PLESNSAP           (564 % 256)
	{X25PLESNSAP, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 12}},
#define   X25PELOGICALCHANNELASSIGNMENTS  (565 % 256)
	{X25PELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 13}},
#define   X25PLEINTERFACEMODE   (566 % 256)
	{X25PLEINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 14}},
#define   X25PLEDEFAULTTHROUGHPUTCLASS  (567 % 256)
	{X25PLEDEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 15}},
#define   X25PLEFLOWCONTROLNEGOTIATIONPERMITTED  (568 % 256)
	{X25PLEFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 16}},
#define   X25PLECALLDEFLECTIONSUBSCRIPTION  (569 % 256)
	{X25PLECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 17}},
#define   X25PLEMAXACTIVECIRCUITS  (570 % 256)
	{X25PLEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 18}},
#define   X25PLERESTARTTIME     (571 % 256)
	{X25PLERESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 19}},
#define   X25PLEDEFAULTPACKETSIZE  (572 % 256)
	{X25PLEDEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 20}},
#define   X25PLEDEFAULTWINDOWSIZE  (573 % 256)
	{X25PLEDEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 21}},
#define   X25PLEMINIMUMRECALLTIMER  (574 % 256)
	{X25PLEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 22}},
#define   X25PLERESTARTCOUNT    (575 % 256)
	{X25PLERESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 23}},
#define   X25PLESN-SERVICEPROVIDER  (576 % 256)
	{X25PLESN - SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 24}},
#define   X25PLESN-SA-P         (577 % 256)
	{X25PLESN - SA - P, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 25}},
#define   X25PLELOGICALCHANNELASSIGNMENTS  (578 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 26}},
#define   X25PLEPACKETSEQUENCING  (579 % 256)
	{X25PLEPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 27}},
#define   X25PLEOCTETSSENTCOUNTER  (580 % 256)
	{X25PLEOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 28}},
#define   X25PLEOCTETSRECEIVEDCOUNTER  (581 % 256)
	{X25PLEOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 29}},
#define   X25PLEDATAPACKETSSENT  (582 % 256)
	{X25PLEDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 30}},
#define   X25PLEDATAPACKETSRECEIVED  (583 % 256)
	{X25PLEDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 31}},
#define   X25PLECALLATTEMPTS    (584 % 256)
	{X25PLECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 32}},
#define   X25PLECALLSCONNECTED  (585 % 256)
	{X25PLECALLSCONNECTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 33}},
#define   X25PLEPROVIDERINITIATEDDISCONNECTS  (586 % 256)
	{X25PLEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 34}},
#define   X25PLECALLTIMEOUTS    (587 % 256)
	{X25PLECALLTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 35}},
#define   X25PLECLEARTIMEOUTS   (588 % 256)
	{X25PLECLEARTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 36}},
#define   X25PLEREMOTELYINITIATEDRESETS  (589 % 256)
	{X25PLEREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 37}},
#define   X25PLEDATARETRANSMISSIONTIMEREXPIRIES  (590 % 256)
	{X25PLEDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 38}},
#define   X25PLEPROVIDERINITIATEDRESETS  (591 % 256)
	{X25PLEPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 39}},
#define   X25PLERESETTIMEOUTS   (592 % 256)
	{X25PLERESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 40}},
#define   X25PLEREMOTELYINITIATEDRESTARTS  (593 % 256)
	{X25PLEREMOTELYINITIATEDRESTARTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 41}},
#define   X25PLERESTARTCOUNTSEXCEEDED  (594 % 256)
	{X25PLERESTARTCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 42}},
#define   X25PLEPROTOCOLERRORSDETECTEDLOCALLY  (595 % 256)
	{X25PLEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 43}},
#define   X25PLEPROTOCOLERRORSACCUSEDOF  (596 % 256)
	{X25PLEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 44}},
#define   X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  (597 % 256)
	{X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 45}},
#define   X25PLECLEARCOUNTSEXCEEDED  (598 % 256)
	{X25PLECLEARCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 46}},
#define   X25PLEPLECLIENTMONAME  (599 % 256)
	{X25PLEPLECLIENTMONAME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 47}},
#define   X25PLEREGISTRATIONREQUESTTIME  (600 % 256)
	{X25PLEREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 48}},
#define   X25PLEREGISTRATIONREQUESTCOUNT  (601 % 256)
	{X25PLEREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 49}},
#define   X25PLEREGISTRATIONPERMITTED  (602 % 256)
	{X25PLEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 50}},
#define   X25PLEROWSTATUS       (603 % 256)
	{X25PLEROWSTATUS, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 51}},
#define   X25PLE-DTECALLDEFLECTIONSUBSCRIPTION  (607 % 256)
	{X25PLE - DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 1}},
#define   X25PLE-DTECALLREQUESTRESPONSETIMER  (608 % 256)
	{X25PLE - DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 2}},
#define   X25PLE-DTEEXTENDEDPACKETSEQUENCENUMBERING  (609 % 256)
	{X25PLE - DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 3}},
#define   X25PLE-DTEMAXACTIVECIRCUITS  (610 % 256)
	{X25PLE - DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 4}},
#define   X25PLE-DTEMINIMUMRECALLTIMER  (611 % 256)
	{X25PLE - DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 5}},
#define   X25PLE-DTERESETREQUESTRESPONSETIMER  (612 % 256)
	{X25PLE - DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 6}},
#define   X25PLE-DTERESTARTREQUESTRETRANSMISSIONCOUNT  (613 % 256)
	{X25PLE - DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 7}},
#define   X25PLE-DTERESTARTREQUESTRESPONSETIMER  (614 % 256)
	{X25PLE - DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 8}},
#define   X25PLE-DTECLEARREQUESTRESPONSETIMER  (615 % 256)
	{X25PLE - DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 9}},
#define   X25PLE-DTEINTERRUPTRESPONSETIMER  (616 % 256)
	{X25PLE - DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 10}},
#define   X25PLE-DTERESETREQUESTRETRANSMISSIONCOUNT  (617 % 256)
	{X25PLE - DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 11}},
#define   X25PLE-DTECLEARREQUESTRETRANSMISSIONCOUNT  (618 % 256)
	{X25PLE - DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 12}},
#define   X25PLE-DTECALLATTEMPTS  (619 % 256)
	{X25PLE - DTECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 13}},
#define   X25PLE-DTEPROTOCOLERRORSDETECTEDLOCALLY  (620 % 256)
	{X25PLE - DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 14}},
#define   X25PLE-DTEPROTOCOLERRORSACCUSEDOF  (621 % 256)
	{X25PLE - DTEPROTOCOLERRORSACCUSEDOF, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 15}},
#define   X25PLE-DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  (622 % 256)
	{X25PLE - DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 16}},
#define   X25PLE-DTEOCTETSRECEIVEDCOUNTER  (623 % 256)
	{X25PLE - DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 17}},
#define   X25PLE-DTEOCTETSSENTCOUNTER  (624 % 256)
	{X25PLE - DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 18}},
#define   X25PLE-DTECALLTIMEOUTS  (625 % 256)
	{X25PLE - DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 19}},
#define   X25PLE-DTECALLSCONNECTED  (626 % 256)
	{X25PLE - DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 20}},
#define   X25PLE-DTECLEARCOUNTSEXCEEDED  (627 % 256)
	{X25PLE - DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 21}},
#define   X25PLE-DTECLEARTIMEOUTS  (628 % 256)
	{X25PLE - DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 22}},
#define   X25PLE-DTEDATAPACKETSRECEIVED  (629 % 256)
	{X25PLE - DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 23}},
#define   X25PLE-DTEDATAPACKETSSENT  (630 % 256)
	{X25PLE - DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 24}},
#define   X25PLE-DTEDATARETRANSMISSIONTIMEREXPIRIES  (631 % 256)
	{X25PLE - DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 25}},
#define   X25PLE-DTEPROVIDERINITIATEDRESETS  (632 % 256)
	{X25PLE - DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 26}},
#define   X25PLE-DTEPROVIDERINITIATEDDISCONNECTS  (633 % 256)
	{X25PLE - DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 27}},
#define   X25PLE-DTEREMOTELYINITIATEDRESETS  (634 % 256)
	{X25PLE - DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 28}},
#define   X25PLE-DTEREMOTELYINITIATEDRESTARTS  (635 % 256)
	{X25PLE - DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 29}},
#define   X25PLE-DTERESETTIMEOUTS  (636 % 256)
	{X25PLE - DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 30}},
#define   X25PLE-DTERESTARTCOUNTSEXCEEDED  (637 % 256)
	{X25PLE - DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 31}},
#define   X25PLE-DTEWINDOWSTATUSTRANSMISSIONTIMER  (638 % 256)
	{X25PLE - DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 32}},
#define   X25PLE-DTEWINDOWROTATIONTIMER  (639 % 256)
	{X25PLE - DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 33}},
#define   X25PLE-DTEDATAPACKETRETRANSMISSIONCOUNT  (640 % 256)
	{X25PLE - DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 34}},
#define   X25PLE-DTEREJECTRESPONSETIMER  (641 % 256)
	{X25PLE - DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 35}},
#define   X25PLE-DTEREJECTRETRANSMISSIONCOUNT  (642 % 256)
	{X25PLE - DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 36}},
#define   X25PLE-DTEREGISTRATIONREQUESTRESPONSETIMER  (643 % 256)
	{X25PLE - DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 37}},
#define   X25PLE-DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  (644 % 256)
	{X25PLE - DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 38}},
#define   X25PLE-DTEREGISTRATIONPERMITTED  (645 % 256)
	{X25PLE - DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLE - DTETable, 6, {1, 1, 41, 1, 1, 39}},
#define   X25PLE-DCECALLATTEMPTS  (649 % 256)
	{X25PLE - DCECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 1}},
#define   X25PLE-DCECALLSCONNECTED  (650 % 256)
	{X25PLE - DCECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 2}},
#define   X25PLE-DCECUG         (651 % 256)
	{X25PLE - DCECUG, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 3}},
#define   X25PLE-DCEFASTSELECTACCEPTANCE  (652 % 256)
	{X25PLE - DCEFASTSELECTACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 4}},
#define   X25PLE-DCEINCOMINGCALLSBARRED  (653 % 256)
	{X25PLE - DCEINCOMINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 5}},
#define   X25PLE-DCEONEWAYLOGICALCHANNELOUTGOING  (654 % 256)
	{X25PLE - DCEONEWAYLOGICALCHANNELOUTGOING, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 6}},
#define   X25PLE-DCEOUTGOINGCALLSBARRED  (655 % 256)
	{X25PLE - DCEOUTGOINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 7}},
#define   X25PLE-DCEDATAPACKETSRECEIVED  (656 % 256)
	{X25PLE - DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 8}},
#define   X25PLE-DCEDATAPACKETSSENT  (657 % 256)
	{X25PLE - DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 9}},
#define   X25PLE-DCEINTERRUPTPACKETSRECEIVED  (658 % 256)
	{X25PLE - DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 10}},
#define   X25PLE-DCEINTERRUPTPACKETSSENT  (659 % 256)
	{X25PLE - DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 11}},
#define   X25PLE-DCEINTERRUPTTIMEREXPIRIES  (660 % 256)
	{X25PLE - DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 12}},
#define   X25PLE-DCEOCTETSRECEIVEDCOUNTER  (661 % 256)
	{X25PLE - DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 13}},
#define   X25PLE-DCEOCTETSSENTCOUNTER  (662 % 256)
	{X25PLE - DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 14}},
#define   X25PLE-DCEPROVIDERINITIATEDDISCONNECTS  (663 % 256)
	{X25PLE - DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 15}},
#define   X25PLE-DCEPROVIDERINITIATEDRESETS  (664 % 256)
	{X25PLE - DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 16}},
#define   X25PLE-DCEREMOTELYINITIATEDRESTARTS  (665 % 256)
	{X25PLE - DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 17}},
#define   X25PLE-DCEREMOTELYINITIATEDRESETS  (666 % 256)
	{X25PLE - DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 18}},
#define   X25PLE-DCERESETTIMEOUTS  (667 % 256)
	{X25PLE - DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 19}},
#define   X25PLE-DCEX25SEGMENTSRECEIVED  (668 % 256)
	{X25PLE - DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 20}},
#define   X25PLE-DCEX25SEGMENTSSENT  (669 % 256)
	{X25PLE - DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 21}},
#define   X25PLE-DCEBILATERALCUG  (670 % 256)
	{X25PLE - DCEBILATERALCUG, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 22}},
#define   X25PLE-DCEBILATERALCUGWITHOUTGOINGACCESS  (671 % 256)
	{X25PLE - DCEBILATERALCUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 23}},
#define   X25PLE-DCECALLDEFLECTIONSUBSCRIPTION  (672 % 256)
	{X25PLE - DCECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 24}},
#define   X25PLE-DCECALLREDIRECTION  (673 % 256)
	{X25PLE - DCECALLREDIRECTION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 25}},
#define   X25PLE-DCECHARGINGINFORMATION  (674 % 256)
	{X25PLE - DCECHARGINGINFORMATION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 26}},
#define   X25PLE-DCECUGWITHINCOMINGACCESS  (675 % 256)
	{X25PLE - DCECUGWITHINCOMINGACCESS, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 27}},
#define   X25PLE-DCECUGWITHOUTGOINGACCESS  (676 % 256)
	{X25PLE - DCECUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 28}},
#define   X25PLE-DCEDBITMODIFICATION  (677 % 256)
	{X25PLE - DCEDBITMODIFICATION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 29}},
#define   X25PLE-DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT  (678 % 256)
	{X25PLE - DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT, ASN_OCTET_STR, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 30}},
#define   X25PLE-DCEEXTENDEDPACKETSEQUENCENUMBERING  (679 % 256)
	{X25PLE - DCEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 31}},
#define   X25PLE-DCEHUNTGROUP   (680 % 256)
	{X25PLE - DCEHUNTGROUP, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 32}},
#define   X25PLE-DCEINCOMINGCALLBARREDWITHINCUG  (681 % 256)
	{X25PLE - DCEINCOMINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 33}},
#define   X25PLE-DCELOCALCHARGINGPREVENTION  (682 % 256)
	{X25PLE - DCELOCALCHARGINGPREVENTION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 34}},
#define   X25PLE-DCENONSTANDARDDEFAULTPACKETSIZES  (683 % 256)
	{X25PLE - DCENONSTANDARDDEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 35}},
#define   X25PLE-DCENONSTANDARDDEFAULTWINDOWSIZES  (684 % 256)
	{X25PLE - DCENONSTANDARDDEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 36}},
#define   X25PLE-DCENUIOVERRIDE  (685 % 256)
	{X25PLE - DCENUIOVERRIDE, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 37}},
#define   X25PLE-DCENUISUBSCRIPTION  (686 % 256)
	{X25PLE - DCENUISUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 38}},
#define   X25PLE-DCEONEWAYLOGICALCHANNELINCOMING  (687 % 256)
	{X25PLE - DCEONEWAYLOGICALCHANNELINCOMING, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 39}},
#define   X25PLE-DCEONLINEFACILITYREGISTRATION  (688 % 256)
	{X25PLE - DCEONLINEFACILITYREGISTRATION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 40}},
#define   X25PLE-DCEOUTGOINGCALLBARREDWITHINCUG  (689 % 256)
	{X25PLE - DCEOUTGOINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 41}},
#define   X25PLE-DCEPACKETRETRANSMISSION  (690 % 256)
	{X25PLE - DCEPACKETRETRANSMISSION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 42}},
#define   X25PLE-DCEREVERSECHARGINGACCEPTANCE  (691 % 256)
	{X25PLE - DCEREVERSECHARGINGACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 43}},
#define   X25PLE-DCEROASUBSCRIPTION  (692 % 256)
	{X25PLE - DCEROASUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 44}},
#define   X25PLE-DCECLEARINDICATION  (693 % 256)
	{X25PLE - DCECLEARINDICATION, ASN_INTEGER, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 45}},
#define   X25PLE-DCEINCOMINGCALL  (694 % 256)
	{X25PLE - DCEINCOMINGCALL, ASN_OCTET_STR, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 46}},
#define   X25PLE-DCERESETINDICATION  (695 % 256)
	{X25PLE - DCERESETINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 47}},
#define   X25PLE-DCERESTARTINDICATION  (696 % 256)
	{X25PLE - DCERESTARTINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE - DCETable, 6, {1, 1, 42, 1, 1, 48}},
#define   X25PLEIVMOLOCALDTEADDRESS  (700 % 256)
	{X25PLEIVMOLOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 2}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTS  (701 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 3}},
#define   X25PLEIVMOSN-SERVICEPROVIDER  (702 % 256)
	{X25PLEIVMOSN - SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 4}},
#define   X25PLEIVMODEFAULTPACKETSIZES  (703 % 256)
	{X25PLEIVMODEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 5}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSES  (704 % 256)
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 6}},
#define   X25PLEIVMODEFAULTWINDOWSIZES  (705 % 256)
	{X25PLEIVMODEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 7}},
#define   X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION  (706 % 256)
	{X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 8}},
#define   X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION  (707 % 256)
	{X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 9}},
#define   X25PLEIVMOX25PLEMODE  (708 % 256)
	{X25PLEIVMOX25PLEMODE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 10}},
#define   X25PLEIVMOINTERFACEMODE  (709 % 256)
	{X25PLEIVMOINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 11}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASS  (710 % 256)
	{X25PLEIVMODEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 12}},
#define   X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED  (711 % 256)
	{X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 13}},
#define   X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION  (712 % 256)
	{X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 14}},
#define   X25PLEIVMOMAXACTIVECIRCUITS  (713 % 256)
	{X25PLEIVMOMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 15}},
#define   X25PLEIVMORESTARTTIME  (714 % 256)
	{X25PLEIVMORESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 16}},
#define   X25PLEIVMODEFAULTPACKETSIZE  (715 % 256)
	{X25PLEIVMODEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 17}},
#define   X25PLEIVMODEFAULTWINDOWSIZE  (716 % 256)
	{X25PLEIVMODEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 18}},
#define   X25PLEIVMOMINIMUMRECALLTIMER  (717 % 256)
	{X25PLEIVMOMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 19}},
#define   X25PLEIVMORESTARTCOUNT  (718 % 256)
	{X25PLEIVMORESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 20}},
#define   X25PLEIVMOPACKETSEQUENCING  (719 % 256)
	{X25PLEIVMOPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 21}},
#define   X25PLEIVMOREGISTRATIONREQUESTTIME  (720 % 256)
	{X25PLEIVMOREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 22}},
#define   X25PLEIVMOREGISTRATIONREQUESTCOUNT  (721 % 256)
	{X25PLEIVMOREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 23}},
#define   X25PLEIVMOREGISTRATIONPERMITTED  (722 % 256)
	{X25PLEIVMOREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 24}},
#define   X25PLEIVMOROWSTATUS   (723 % 256)
	{X25PLEIVMOROWSTATUS, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 25}},
#define   X25PLEIVMO-DTECALLDEFLECTIONSUBSCRIPTION  (727 % 256)
	{X25PLEIVMO - DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 1}},
#define   X25PLEIVMO-DTECALLREQUESTRESPONSETIMER  (728 % 256)
	{X25PLEIVMO - DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 2}},
#define   X25PLEIVMO-DTEEXTENDEDPACKETSEQUENCENUMBERING  (729 % 256)
	{X25PLEIVMO - DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 3}},
#define   X25PLEIVMO-DTEMAXACTIVECIRCUITS  (730 % 256)
	{X25PLEIVMO - DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 4}},
#define   X25PLEIVMO-DTEMINIMUMRECALLTIMER  (731 % 256)
	{X25PLEIVMO - DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 5}},
#define   X25PLEIVMO-DTERESETREQUESTRESPONSETIMER  (732 % 256)
	{X25PLEIVMO - DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 6}},
#define   X25PLEIVMO-DTERESTARTREQUESTRETRANSMISSIONCOUNT  (733 % 256)
	{X25PLEIVMO - DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 7}},
#define   X25PLEIVMO-DTERESTARTREQUESTRESPONSETIMER  (734 % 256)
	{X25PLEIVMO - DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 8}},
#define   X25PLEIVMO-DTECLEARREQUESTRESPONSETIMER  (735 % 256)
	{X25PLEIVMO - DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 9}},
#define   X25PLEIVMO-DTEINTERRUPTRESPONSETIMER  (736 % 256)
	{X25PLEIVMO - DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 10}},
#define   X25PLEIVMO-DTERESETREQUESTRETRANSMISSIONCOUNT  (737 % 256)
	{X25PLEIVMO - DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 11}},
#define   X25PLEIVMO-DTECLEARREQUESTRETRANSMISSIONCOUNT  (738 % 256)
	{X25PLEIVMO - DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 12}},
#define   X25PLEIVMO-DTECALLATTEMPTS  (739 % 256)
	{X25PLEIVMO - DTECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 13}},
#define   X25PLEIVMO-DTEPROTOCOLERRORSDETECTEDLOCALLY  (740 % 256)
	{X25PLEIVMO - DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 14}},
#define   X25PLEIVMO-DTEPROTOCOLERRORSACCUSEDOF  (741 % 256)
	{X25PLEIVMO - DTEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 15}},
#define   X25PLEIVMO-DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  (742 % 256)
	{X25PLEIVMO - DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 16}},
#define   X25PLEIVMO-DTEOCTETSRECEIVEDCOUNTER  (743 % 256)
	{X25PLEIVMO - DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 17}},
#define   X25PLEIVMO-DTEOCTETSSENTCOUNTER  (744 % 256)
	{X25PLEIVMO - DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 18}},
#define   X25PLEIVMO-DTECALLTIMEOUTS  (745 % 256)
	{X25PLEIVMO - DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 19}},
#define   X25PLEIVMO-DTECALLSCONNECTED  (746 % 256)
	{X25PLEIVMO - DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 20}},
#define   X25PLEIVMO-DTECLEARCOUNTSEXCEEDED  (747 % 256)
	{X25PLEIVMO - DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 21}},
#define   X25PLEIVMO-DTECLEARTIMEOUTS  (748 % 256)
	{X25PLEIVMO - DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 22}},
#define   X25PLEIVMO-DTEDATAPACKETSRECEIVED  (749 % 256)
	{X25PLEIVMO - DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 23}},
#define   X25PLEIVMO-DTEDATAPACKETSSENT  (750 % 256)
	{X25PLEIVMO - DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 24}},
#define   X25PLEIVMO-DTEDATARETRANSMISSIONTIMEREXPIRIES  (751 % 256)
	{X25PLEIVMO - DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 25}},
#define   X25PLEIVMO-DTEPROVIDERINITIATEDRESETS  (752 % 256)
	{X25PLEIVMO - DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 26}},
#define   X25PLEIVMO-DTEPROVIDERINITIATEDDISCONNECTS  (753 % 256)
	{X25PLEIVMO - DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 27}},
#define   X25PLEIVMO-DTEREMOTELYINITIATEDRESETS  (754 % 256)
	{X25PLEIVMO - DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 28}},
#define   X25PLEIVMO-DTEREMOTELYINITIATEDRESTARTS  (755 % 256)
	{X25PLEIVMO - DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 29}},
#define   X25PLEIVMO-DTERESETTIMEOUTS  (756 % 256)
	{X25PLEIVMO - DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 30}},
#define   X25PLEIVMO-DTERESTARTCOUNTSEXCEEDED  (757 % 256)
	{X25PLEIVMO - DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 31}},
#define   X25PLEIVMO-DTEWINDOWSTATUSTRANSMISSIONTIMER  (758 % 256)
	{X25PLEIVMO - DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 32}},
#define   X25PLEIVMO-DTEWINDOWROTATIONTIMER  (759 % 256)
	{X25PLEIVMO - DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 33}},
#define   X25PLEIVMO-DTEDATAPACKETRETRANSMISSIONCOUNT  (760 % 256)
	{X25PLEIVMO - DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 34}},
#define   X25PLEIVMO-DTEREJECTRESPONSETIMER  (761 % 256)
	{X25PLEIVMO - DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 35}},
#define   X25PLEIVMO-DTEREJECTRETRANSMISSIONCOUNT  (762 % 256)
	{X25PLEIVMO - DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 36}},
#define   X25PLEIVMO-DTEREGISTRATIONREQUESTRESPONSETIMER  (763 % 256)
	{X25PLEIVMO - DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 37}},
#define   X25PLEIVMO-DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  (764 % 256)
	{X25PLEIVMO - DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 38}},
#define   X25PLEIVMO-DTEREGISTRATIONPERMITTED  (765 % 256)
	{X25PLEIVMO - DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 39}},
#define   X25PLEIVMO-DTEROWSTATUS  (766 % 256)
	{X25PLEIVMO - DTEROWSTATUS, ASN_INTEGER, RONLY, var_x25PLEIVMO - DTETable, 6, {1, 1, 44, 1, 1, 40}},
#define   X25PLEIVMO-DCEROWSTATUS  (770 % 256)
	{X25PLEIVMO - DCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMO - DCETable, 6, {1, 1, 45, 1, 1, 1}},
#define   VIRTUALCALLCHANNEL    (774 % 256)
	{VIRTUALCALLCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 2}},
#define   VIRTUALCALLPACKETSIZE  (775 % 256)
	{VIRTUALCALLPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 3}},
#define   VIRTUALCALLWINDOWSIZE  (776 % 256)
	{VIRTUALCALLWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 4}},
#define   VIRTUALCALLOCTETSSENTCOUNTER  (777 % 256)
	{VIRTUALCALLOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 5}},
#define   VIRTUALCALLOCTETSRECEIVEDCOUNTER  (778 % 256)
	{VIRTUALCALLOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 6}},
#define   VIRTUALCALLDATAPACKETSSENT  (779 % 256)
	{VIRTUALCALLDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 7}},
#define   VIRTUALCALLDATAPACKETSRECEIVED  (780 % 256)
	{VIRTUALCALLDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 8}},
#define   VIRTUALCALLREMOTELYINITIATEDRESETS  (781 % 256)
	{VIRTUALCALLREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 9}},
#define   VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES  (782 % 256)
	{VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 10}},
#define   VIRTUALCALLPROVIDERINITIATEDRESETS  (783 % 256)
	{VIRTUALCALLPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 11}},
#define   VIRTUALCALLRESETTIMEOUTS  (784 % 256)
	{VIRTUALCALLRESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 12}},
#define   VIRTUALCALLINTERRUPTPACKETSSENT  (785 % 256)
	{VIRTUALCALLINTERRUPTPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 13}},
#define   VIRTUALCALLINTERRUPTPACKETSRECEIVED  (786 % 256)
	{VIRTUALCALLINTERRUPTPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 14}},
#define   VIRTUALCALLINTERRUPTTIMEREXPIRIES  (787 % 256)
	{VIRTUALCALLINTERRUPTTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 15}},
#define   VIRTUALCIRCUITLOGICALCHANNEL  (791 % 256)
	{VIRTUALCIRCUITLOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 2}},
#define   VIRTUALCIRCUITPACKETSIZES  (792 % 256)
	{VIRTUALCIRCUITPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 3}},
#define   VIRTUALCIRCUITTHROUGHPUTCLASSES  (793 % 256)
	{VIRTUALCIRCUITTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 4}},
#define   VIRTUALCIRCUITWINDOWSIZES  (794 % 256)
	{VIRTUALCIRCUITWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 5}},
#define   VIRTUALCIRCUIT-DTEOCTETSSENTCOUNTER  (798 % 256)
	{VIRTUALCIRCUIT - DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 1}},
#define   VIRTUALCIRCUIT-DTEOCTETSRECEIVEDCOUNTER  (799 % 256)
	{VIRTUALCIRCUIT - DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 2}},
#define   VIRTUALCIRCUIT-DTEDATAPACKETSRECEIVED  (800 % 256)
	{VIRTUALCIRCUIT - DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 3}},
#define   VIRTUALCIRCUIT-DTEDATAPACKETSSENT  (801 % 256)
	{VIRTUALCIRCUIT - DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 4}},
#define   VIRTUALCIRCUIT-DTEDATARETRANSMISSIONTIMEREXPIRIES  (802 % 256)
	{VIRTUALCIRCUIT - DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 5}},
#define   VIRTUALCIRCUIT-DTEINTERRUPTPACKETSRECEIVED  (803 % 256)
	{VIRTUALCIRCUIT - DTEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 6}},
#define   VIRTUALCIRCUIT-DTEINTERRUPTPACKETSSENT  (804 % 256)
	{VIRTUALCIRCUIT - DTEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 7}},
#define   VIRTUALCIRCUIT-DTEINTERRUPTTIMEREXPIRIES  (805 % 256)
	{VIRTUALCIRCUIT - DTEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 8}},
#define   VIRTUALCIRCUIT-DTEPROVIDERINITIATEDRESETS  (806 % 256)
	{VIRTUALCIRCUIT - DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 9}},
#define   VIRTUALCIRCUIT-DTEREMOTELYINITIATEDRESETS  (807 % 256)
	{VIRTUALCIRCUIT - DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 10}},
#define   VIRTUALCIRCUIT-DTERESETTIMEOUTS  (808 % 256)
	{VIRTUALCIRCUIT - DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit - DTETable, 6, {1, 1, 48, 1, 1, 11}},
#define   VIRTUALCIRCUIT-DCEDATAPACKETSRECEIVED  (812 % 256)
	{VIRTUALCIRCUIT - DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 1}},
#define   VIRTUALCIRCUIT-DCEDATAPACKETSSENT  (813 % 256)
	{VIRTUALCIRCUIT - DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 2}},
#define   VIRTUALCIRCUIT-DCEINTERRUPTPACKETSRECEIVED  (814 % 256)
	{VIRTUALCIRCUIT - DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 3}},
#define   VIRTUALCIRCUIT-DCEINTERRUPTPACKETSSENT  (815 % 256)
	{VIRTUALCIRCUIT - DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 4}},
#define   VIRTUALCIRCUIT-DCEINTERRUPTTIMEREXPIRIES  (816 % 256)
	{VIRTUALCIRCUIT - DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 5}},
#define   VIRTUALCIRCUIT-DCEOCTETSRECEIVEDCOUNTER  (817 % 256)
	{VIRTUALCIRCUIT - DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 6}},
#define   VIRTUALCIRCUIT-DCEOCTETSSENTCOUNTER  (818 % 256)
	{VIRTUALCIRCUIT - DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 7}},
#define   VIRTUALCIRCUIT-DCEPROVIDERINITIATEDDISCONNECTS  (819 % 256)
	{VIRTUALCIRCUIT - DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 8}},
#define   VIRTUALCIRCUIT-DCEPROVIDERINITIATEDRESETS  (820 % 256)
	{VIRTUALCIRCUIT - DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 9}},
#define   VIRTUALCIRCUIT-DCEREMOTELYINITIATEDRESTARTS  (821 % 256)
	{VIRTUALCIRCUIT - DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 10}},
#define   VIRTUALCIRCUIT-DCEREMOTELYINITIATEDRESETS  (822 % 256)
	{VIRTUALCIRCUIT - DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 11}},
#define   VIRTUALCIRCUIT-DCERESETTIMEOUTS  (823 % 256)
	{VIRTUALCIRCUIT - DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 12}},
#define   VIRTUALCIRCUIT-DCEX25SEGMENTSRECEIVED  (824 % 256)
	{VIRTUALCIRCUIT - DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 13}},
#define   VIRTUALCIRCUIT-DCEX25SEGMENTSSENT  (825 % 256)
	{VIRTUALCIRCUIT - DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_virtualCircuit - DCETable, 6, {1, 1, 49, 1, 1, 14}},
#define   PERMANENTVIRTUALCIRCUITCHANNEL  (830 % 256)
	{PERMANENTVIRTUALCIRCUITCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUITROWSTATUS  (831 % 256)
	{PERMANENTVIRTUALCIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT-DTELOGICALCHANNEL  (836 % 256)
	{PERMANENTVIRTUALCIRCUIT - DTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DTETable, 6, {1, 1, 51, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT-DTEPACKETSIZES  (837 % 256)
	{PERMANENTVIRTUALCIRCUIT - DTEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DTETable, 6, {1, 1, 51, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT-DTETHROUGHPUTCLASSES  (838 % 256)
	{PERMANENTVIRTUALCIRCUIT - DTETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DTETable, 6, {1, 1, 51, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT-DTEWINDOWSIZES  (839 % 256)
	{PERMANENTVIRTUALCIRCUIT - DTEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DTETable, 6, {1, 1, 51, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT-DTEROWSTATUS  (840 % 256)
	{PERMANENTVIRTUALCIRCUIT - DTEROWSTATUS, ASN_INTEGER, RONLY, var_permanentVirtualCircuit - DTETable, 6, {1, 1, 51, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT-DCECHARGINGDIRECTION  (845 % 256)
	{PERMANENTVIRTUALCIRCUIT - DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DCETable, 6, {1, 1, 52, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT-DCELOGICALCHANNEL  (846 % 256)
	{PERMANENTVIRTUALCIRCUIT - DCELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DCETable, 6, {1, 1, 52, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT-DCEPACKETSIZES  (847 % 256)
	{PERMANENTVIRTUALCIRCUIT - DCEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DCETable, 6, {1, 1, 52, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT-DCETHROUGHPUTCLASSES  (848 % 256)
	{PERMANENTVIRTUALCIRCUIT - DCETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DCETable, 6, {1, 1, 52, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT-DCEWINDOWSIZES  (849 % 256)
	{PERMANENTVIRTUALCIRCUIT - DCEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DCETable, 6, {1, 1, 52, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT-DCEOPERATIONALSTATE  (850 % 256)
	{PERMANENTVIRTUALCIRCUIT - DCEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_permanentVirtualCircuit - DCETable, 6, {1, 1, 52, 1, 1, 6}},
#define   PERMANENTVIRTUALCIRCUIT-DCEREMOTEDTEADDRESS  (851 % 256)
	{PERMANENTVIRTUALCIRCUIT - DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DCETable, 6, {1, 1, 52, 1, 1, 7}},
#define   PERMANENTVIRTUALCIRCUIT-DCEREMOTELOGICALCHANNEL  (852 % 256)
	{PERMANENTVIRTUALCIRCUIT - DCEREMOTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit - DCETable, 6, {1, 1, 52, 1, 1, 8}},
#define   PERMANENTVIRTUALCIRCUIT-DCEROWSTATUS  (853 % 256)
	{PERMANENTVIRTUALCIRCUIT - DCEROWSTATUS, ASN_INTEGER, RONLY, var_permanentVirtualCircuit - DCETable, 6, {1, 1, 52, 1, 1, 9}},
#define   VIRTUALCALLIVMOFASTSELECT  (858 % 256)
	{VIRTUALCALLIVMOFASTSELECT, ASN_INTEGER, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 2}},
#define   VIRTUALCALLIVMOPACKETSIZES  (859 % 256)
	{VIRTUALCALLIVMOPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 3}},
#define   VIRTUALCALLIVMOREVERSECHARGING  (860 % 256)
	{VIRTUALCALLIVMOREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 4}},
#define   VIRTUALCALLIVMOTHROUGHPUTCLASSES  (861 % 256)
	{VIRTUALCALLIVMOTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 5}},
#define   VIRTUALCALLIVMOWINDOWSIZES  (862 % 256)
	{VIRTUALCALLIVMOWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 6}},
#define   VIRTUALCALLIVMOPROPOSEDPACKETSIZE  (863 % 256)
	{VIRTUALCALLIVMOPROPOSEDPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 7}},
#define   VIRTUALCALLIVMOPROPOSEDWINDOWSIZE  (864 % 256)
	{VIRTUALCALLIVMOPROPOSEDWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 8}},
#define   VIRTUALCALLIVMOACCEPTREVERSECHARGING  (865 % 256)
	{VIRTUALCALLIVMOACCEPTREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 9}},
#define   VIRTUALCALLIVMOPROPOSEREVERSECHARGING  (866 % 256)
	{VIRTUALCALLIVMOPROPOSEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 10}},
#define   VIRTUALCALLIVMOCALLTIME  (867 % 256)
	{VIRTUALCALLIVMOCALLTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 11}},
#define   VIRTUALCALLIVMORESETTIME  (868 % 256)
	{VIRTUALCALLIVMORESETTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 12}},
#define   VIRTUALCALLIVMOCLEARTIME  (869 % 256)
	{VIRTUALCALLIVMOCLEARTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 13}},
#define   VIRTUALCALLIVMOINTERRUPTTIME  (870 % 256)
	{VIRTUALCALLIVMOINTERRUPTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 14}},
#define   VIRTUALCALLIVMORESETCOUNT  (871 % 256)
	{VIRTUALCALLIVMORESETCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 15}},
#define   VIRTUALCALLIVMOCLEARCOUNT  (872 % 256)
	{VIRTUALCALLIVMOCLEARCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 16}},
#define   VIRTUALCALLIVMOWINDOWTIME  (873 % 256)
	{VIRTUALCALLIVMOWINDOWTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 17}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONTIME  (874 % 256)
	{VIRTUALCALLIVMODATARETRANSMISSIONTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 18}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONCOUNT  (875 % 256)
	{VIRTUALCALLIVMODATARETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 19}},
#define   VIRTUALCALLIVMOREJECTTIME  (876 % 256)
	{VIRTUALCALLIVMOREJECTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 20}},
#define   VIRTUALCALLIVMOREJECTCOUNT  (877 % 256)
	{VIRTUALCALLIVMOREJECTCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 21}},
#define   VIRTUALCALLIVMOROWSTATUS  (878 % 256)
	{VIRTUALCALLIVMOROWSTATUS, ASN_INTEGER, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 22}},
#define   SWITCHEDVIRTUALCALLDIRECTION  (883 % 256)
	{SWITCHEDVIRTUALCALLDIRECTION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 1}},
#define   SWITCHEDVIRTUALCALLREMOTEDTEADDRESS  (884 % 256)
	{SWITCHEDVIRTUALCALLREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 2}},
#define   SWITCHEDVIRTUALCALLTHROUGHPUTCLASS  (885 % 256)
	{SWITCHEDVIRTUALCALLTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 3}},
#define   SWITCHEDVIRTUALCALLREDIRECTREASON  (886 % 256)
	{SWITCHEDVIRTUALCALLREDIRECTREASON, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 4}},
#define   SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS  (887 % 256)
	{SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 5}},
#define   SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION  (888 % 256)
	{SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 6}},
#define   SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION  (889 % 256)
	{SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 7}},
#define   SWITCHEDVIRTUALCALLROWSTATUS  (890 % 256)
	{SWITCHEDVIRTUALCALLROWSTATUS, ASN_INTEGER, RWRITE, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 8}},
#define   VIRTUALCALL-DTECALLINGADDRESSEXTENSION  (895 % 256)
	{VIRTUALCALL - DTECALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall - DTETable, 6, {1, 1, 55, 1, 1, 1}},
#define   VIRTUALCALL-DTECALLEDADDRESSEXTENSION  (896 % 256)
	{VIRTUALCALL - DTECALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall - DTETable, 6, {1, 1, 55, 1, 1, 2}},
#define   VIRTUALCALL-DTEDIRECTION  (897 % 256)
	{VIRTUALCALL - DTEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall - DTETable, 6, {1, 1, 55, 1, 1, 3}},
#define   VIRTUALCALL-DTEFASTSELECT  (898 % 256)
	{VIRTUALCALL - DTEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall - DTETable, 6, {1, 1, 55, 1, 1, 4}},
#define   VIRTUALCALL-DTEORIGINALLYCALLEDADDRESS  (899 % 256)
	{VIRTUALCALL - DTEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall - DTETable, 6, {1, 1, 55, 1, 1, 5}},
#define   VIRTUALCALL-DTEREDIRECTREASON  (900 % 256)
	{VIRTUALCALL - DTEREDIRECTREASON, ASN_OCTET_STR, RONLY, var_virtualCall - DTETable, 6, {1, 1, 55, 1, 1, 6}},
#define   VIRTUALCALL-DTEREMOTEDTEADDRESS  (901 % 256)
	{VIRTUALCALL - DTEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall - DTETable, 6, {1, 1, 55, 1, 1, 7}},
#define   VIRTUALCALL-DTEREVERSECHARGING  (902 % 256)
	{VIRTUALCALL - DTEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall - DTETable, 6, {1, 1, 55, 1, 1, 8}},
#define   VIRTUALCALL-DTEROWSTATUS  (903 % 256)
	{VIRTUALCALL - DTEROWSTATUS, ASN_INTEGER, RWRITE, var_virtualCall - DTETable, 6, {1, 1, 55, 1, 1, 9}},
#define   VIRTUALCALL-DCECHARGINGDIRECTION  (908 % 256)
	{VIRTUALCALL - DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 1}},
#define   VIRTUALCALL-DCECUGSELECTION  (909 % 256)
	{VIRTUALCALL - DCECUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 2}},
#define   VIRTUALCALL-DCEDIRECTION  (910 % 256)
	{VIRTUALCALL - DCEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 3}},
#define   VIRTUALCALL-DCEFASTSELECT  (911 % 256)
	{VIRTUALCALL - DCEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 4}},
#define   VIRTUALCALL-DCEREMOTEDTEADDRESS  (912 % 256)
	{VIRTUALCALL - DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 5}},
#define   VIRTUALCALL-DCETRANSITDELAYSELECTIONANDINDICATION  (913 % 256)
	{VIRTUALCALL - DCETRANSITDELAYSELECTIONANDINDICATION, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 6}},
#define   VIRTUALCALL-DCEBILATERALCUGSELECTION  (914 % 256)
	{VIRTUALCALL - DCEBILATERALCUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 7}},
#define   VIRTUALCALL-DCECALLREDIRECTIONDEFLECTIONNOTIFICATION  (915 % 256)
	{VIRTUALCALL - DCECALLREDIRECTIONDEFLECTIONNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 8}},
#define   VIRTUALCALL-DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION  (916 % 256)
	{VIRTUALCALL - DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 9}},
#define   VIRTUALCALL-DCECUGWITHOUTGOINGACCESSSELECTION  (917 % 256)
	{VIRTUALCALL - DCECUGWITHOUTGOINGACCESSSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 10}},
#define   VIRTUALCALL-DCENUISELECTION  (918 % 256)
	{VIRTUALCALL - DCENUISELECTION, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 11}},
#define   VIRTUALCALL-DCEREVERSECHARGING  (919 % 256)
	{VIRTUALCALL - DCEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 12}},
#define   VIRTUALCALL-DCEROASELECTION  (920 % 256)
	{VIRTUALCALL - DCEROASELECTION, ASN_OCTET_STR, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 13}},
#define   VIRTUALCALL-DCEROWSTATUS  (921 % 256)
	{VIRTUALCALL - DCEROWSTATUS, ASN_INTEGER, RONLY, var_virtualCall - DCETable, 6, {1, 1, 56, 1, 1, 14}},
#define   DSERIESRESETREQUESTINDICATIONPACKETS  (927 % 256)
	{DSERIESRESETREQUESTINDICATIONPACKETS, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 2}},
#define   DSERIESSEGMENTSSENT   (928 % 256)
	{DSERIESSEGMENTSSENT, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 3}},
#define   DSERIESSEGMENTSRECEIVED  (929 % 256)
	{DSERIESSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 4}},
#define   DSERIESROWSTATUS      (930 % 256)
	{DSERIESROWSTATUS, ASN_INTEGER, RWRITE, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 5}},
#define   ADJACENCYSTATE        (937 % 256)
	{ADJACENCYSTATE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 2}},
#define   NEIGHBOURSNPAADDRESS  (938 % 256)
	{NEIGHBOURSNPAADDRESS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 3}},
#define   NEIGHBOURSYSTEMTYPE   (939 % 256)
	{NEIGHBOURSYSTEMTYPE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 4}},
#define   NEIGHBOURSYSTEMIDS    (940 % 256)
	{NEIGHBOURSYSTEMIDS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 5}},
#define   ADJACENCYUSAGE        (941 % 256)
	{ADJACENCYUSAGE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 6}},
#define   AREAADDRESSESOFNEIGHBOUR  (942 % 256)
	{AREAADDRESSESOFNEIGHBOUR, ASN_OCTET_STR, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 7}},
#define   HOLDINGTIMER          (943 % 256)
	{HOLDINGTIMER, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 8}},
#define   PRIORITYOFNEIGHBOUR   (944 % 256)
	{PRIORITYOFNEIGHBOUR, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 9}},
#define   ADJACENCYROWSTATUS    (945 % 256)
	{ADJACENCYROWSTATUS, ASN_INTEGER, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 10}},
#define   VIRTUALADJACENCYMETRIC  (951 % 256)
	{VIRTUALADJACENCYMETRIC, ASN_INTEGER, RONLY, var_virtualAdjacencyTable, 6, {1, 1, 59, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICPATHCOST  (957 % 256)
	{DESTINATIONDEFAULTMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES  (958 % 256)
	{DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 3}},
#define   DESTINATIONDELAYMETRICPATHCOST  (959 % 256)
	{DESTINATIONDELAYMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 4}},
#define   DESTINATIONDELAYMETRICOUTPUTADJACENCIES  (960 % 256)
	{DESTINATIONDELAYMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 5}},
#define   DESTINATIONEXPENSEMETRICPATHCOST  (961 % 256)
	{DESTINATIONEXPENSEMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 6}},
#define   DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES  (962 % 256)
	{DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 7}},
#define   DESTINATIONERRORMETRICPATHCOST  (963 % 256)
	{DESTINATIONERRORMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 8}},
#define   DESTINATIONERRORMETRICOUTPUTADJACENCIES  (964 % 256)
	{DESTINATIONERRORMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 9}},
#define   DESINTATIONSYSTEMMETRIC  (971 % 256)
	{DESINTATIONSYSTEMMETRIC, ASN_INTEGER, RONLY, var_destinationSystemTable, 6, {1, 1, 61, 1, 1, 3}},
#define   DESTINATIONAREAID     (975 % 256)
	{DESTINATIONAREAID, ASN_OCTET_STR, RONLY, var_destinationAreaTable, 6, {1, 1, 62, 1, 1, 1}},
#define   REACHABLEADDRESSPREFIX  (979 % 256)
	{REACHABLEADDRESSPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 2}},
#define   REACHABLEADDRESSMAPPINGTYPE  (980 % 256)
	{REACHABLEADDRESSMAPPINGTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 3}},
#define   REACHABLEADDRESSDEFAULTMETRIC  (981 % 256)
	{REACHABLEADDRESSDEFAULTMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 4}},
#define   REACHABLEADDRESSDELAYMETRIC  (982 % 256)
	{REACHABLEADDRESSDELAYMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 5}},
#define   REACHABLEADDRESSEXPENSEMETRIC  (983 % 256)
	{REACHABLEADDRESSEXPENSEMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 6}},
#define   REACHABLEADDRESSERRORMETRIC  (984 % 256)
	{REACHABLEADDRESSERRORMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 7}},
#define   REACHABLEADDRESSDEFAULTMETRICTYPE  (985 % 256)
	{REACHABLEADDRESSDEFAULTMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 8}},
#define   REACHABLEADDRESSDELAYMETRICTYPE  (986 % 256)
	{REACHABLEADDRESSDELAYMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 9}},
#define   REACHABLEADDRESSEXPENSEMETRICTYPE  (987 % 256)
	{REACHABLEADDRESSEXPENSEMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 10}},
#define   REACHABLEADDRESSERRORMETRICTYPE  (988 % 256)
	{REACHABLEADDRESSERRORMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 11}},
#define   REACHABLEADDRESSOPERATIONALSTATE  (989 % 256)
	{REACHABLEADDRESSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 12}},
#define   REACHABLEADDRESSADMINISTRATIVESTATE  (990 % 256)
	{REACHABLEADDRESSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 13}},
#define   REACHABLEADDRESSSNPAADDRESSES  (991 % 256)
	{REACHABLEADDRESSSNPAADDRESSES, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 14}},
#define   REACHABLEADDRESSSNPAMASK  (992 % 256)
	{REACHABLEADDRESSSNPAMASK, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 15}},
#define   REACHABLEADDRESSSNPAPREFIX  (993 % 256)
	{REACHABLEADDRESSSNPAPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 16}},
#define   REACHABLEADDRESSROWSTATUS  (994 % 256)
	{REACHABLEADDRESSROWSTATUS, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 17}},
#define   LLCDISCONTINUITYTIME  (995 % 256)
	{LLCDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_dlMIB, 4, {1, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTINTERFACETYPE  (996 % 256)
	{SLPCONNECTIONDEFAULTINTERFACETYPE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTK  (997 % 256)
	{SLPCONNECTIONDEFAULTK, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 2}},
#define   SLPCONNECTIONDEFAULTN1  (998 % 256)
	{SLPCONNECTIONDEFAULTN1, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 3}},
#define   SLPCONNECTIONDEFAULTN2  (999 % 256)
	{SLPCONNECTIONDEFAULTN2, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 4}},
#define   SLPCONNECTIONDEFAULTSEQUENCEMODULUS  (1000 % 256)
	{SLPCONNECTIONDEFAULTSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 5}},
#define   SLPCONNECTIONDEFAULTT1TIMER  (1001 % 256)
	{SLPCONNECTIONDEFAULTT1TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 6}},
#define   SLPCONNECTIONDEFAULTT2TIMER  (1002 % 256)
	{SLPCONNECTIONDEFAULTT2TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 7}},
#define   SLPCONNECTIONDEFAULTT3TIMER  (1003 % 256)
	{SLPCONNECTIONDEFAULTT3TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 8}},
#define   SLPCONNECTIONDEFAULTT4TIMER  (1004 % 256)
	{SLPCONNECTIONDEFAULTT4TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 9}},
#define   LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS  (1005 % 256)
	{LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 1}},
#define   LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE  (1006 % 256)
	{LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 2}},
#define   LLCCONNECTION2DEFAULTSENDWINDOWSIZE  (1007 % 256)
	{LLCCONNECTION2DEFAULTSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 3}},
#define   LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE  (1008 % 256)
	{LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 4}},
#define   LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE  (1009 % 256)
	{LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 5}},
#define   LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE  (1010 % 256)
	{LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 6}},
#define   LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE  (1011 % 256)
	{LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 7}},
#define   LLCCONNECTION2DEFAULTROUTE  (1012 % 256)
	{LLCCONNECTION2DEFAULTROUTE, ASN_OCTET_STR, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 8}},
#define   LLCCONNECTION2DEFAULTKSTEP  (1013 % 256)
	{LLCCONNECTION2DEFAULTKSTEP, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 9}},
#define   LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE  (1014 % 256)
	{LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 10}},
#define   LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS  (1015 % 256)
	{LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 11}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE  (1016 % 256)
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 1}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS  (1017 % 256)
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 2}},
};

/* (L = length of the oidsuffix) */
struct dlMIB_data *dlMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *communicationsEntityTableStorage = NULL;
struct header_complex_index *sap1TableStorage = NULL;
struct header_complex_index *sap2TableStorage = NULL;
struct header_complex_index *clProtocolMachineTableStorage = NULL;
struct header_complex_index *coProtocolMachineTableStorage = NULL;
struct header_complex_index *singlePeerConnectionTableStorage = NULL;
struct header_complex_index *physicalEntityTableStorage = NULL;
struct header_complex_index *physicalSAPTableStorage = NULL;
struct header_complex_index *dataCircuitTableStorage = NULL;
struct header_complex_index *physicalConnectionTableStorage = NULL;
struct header_complex_index *datalinkEntityTableStorage = NULL;
struct header_complex_index *dLSAPTableStorage = NULL;
struct header_complex_index *lAPBDLETableStorage = NULL;
struct header_complex_index *sLPPMTableStorage = NULL;
struct header_complex_index *sLPConnectionTableStorage = NULL;
struct header_complex_index *sLPConnectionIVMOTableStorage = NULL;
struct header_complex_index *mACDLETableStorage = NULL;
struct header_complex_index *mACTableStorage = NULL;
struct header_complex_index *lLCDLETableStorage = NULL;
struct header_complex_index *lLCCLPMTableStorage = NULL;
struct header_complex_index *lLCCOPMTableStorage = NULL;
struct header_complex_index *resourceTypeIdTableStorage = NULL;
struct header_complex_index *lLCStationTableStorage = NULL;
struct header_complex_index *lLCSAPTableStorage = NULL;
struct header_complex_index *rDESetupTableStorage = NULL;
struct header_complex_index *rDEPairTableStorage = NULL;
struct header_complex_index *lLCConnectionLessTableStorage = NULL;
struct header_complex_index *lLCConnection2TableStorage = NULL;
struct header_complex_index *lLCConnection2IVMOTableStorage = NULL;
struct header_complex_index *lLCConnectionlessAckTableStorage = NULL;
struct header_complex_index *lLCConnectionlessAckIVMOTableStorage = NULL;
struct header_complex_index *networkEntityTableStorage = NULL;
struct header_complex_index *nSAPTableStorage = NULL;
struct header_complex_index *cLNSTableStorage = NULL;
struct header_complex_index *cLNSISISTableStorage = NULL;
struct header_complex_index *cLNSISISLevel2TableStorage = NULL;
struct header_complex_index *linkageTableStorage = NULL;
struct header_complex_index *cONSTableStorage = NULL;
struct header_complex_index *networkConnectionTableStorage = NULL;
struct header_complex_index *x25PLETableStorage = NULL;
struct header_complex_index *x25PLE - DTETableStorage = NULL;
struct header_complex_index *x25PLE - DCETableStorage = NULL;
struct header_complex_index *x25PLEIVMOTableStorage = NULL;
struct header_complex_index *x25PLEIVMO - DTETableStorage = NULL;
struct header_complex_index *x25PLEIVMO - DCETableStorage = NULL;
struct header_complex_index *virtualCallTableStorage = NULL;
struct header_complex_index *virtualCircuitTableStorage = NULL;
struct header_complex_index *virtualCircuit - DTETableStorage = NULL;
struct header_complex_index *virtualCircuit - DCETableStorage = NULL;
struct header_complex_index *permanentVirtualCircuitTableStorage = NULL;
struct header_complex_index *permanentVirtualCircuit - DTETableStorage = NULL;
struct header_complex_index *permanentVirtualCircuit - DCETableStorage = NULL;
struct header_complex_index *virtualCallIVMOTableStorage = NULL;
struct header_complex_index *switchedVirtualCallTableStorage = NULL;
struct header_complex_index *virtualCall - DTETableStorage = NULL;
struct header_complex_index *virtualCall - DCETableStorage = NULL;
struct header_complex_index *dSeriesCountsTableStorage = NULL;
struct header_complex_index *adjacencyTableStorage = NULL;
struct header_complex_index *virtualAdjacencyTableStorage = NULL;
struct header_complex_index *destinationTableStorage = NULL;
struct header_complex_index *destinationSystemTableStorage = NULL;
struct header_complex_index *destinationAreaTableStorage = NULL;
struct header_complex_index *reachableAddressTableStorage = NULL;

/*
 * init_dlMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_dlMIB(void)
{
	DEBUGMSGTL(("dlMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("dlMIB", dlMIB_variables, variable7, dlMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_dlMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("dlMIB", parse_dlMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("communicationsEntityTable", parse_communicationsEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sap1Table", parse_sap1Table, NULL, "HELP STRING");
	snmpd_register_config_handler("sap2Table", parse_sap2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("clProtocolMachineTable", parse_clProtocolMachineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("coProtocolMachineTable", parse_coProtocolMachineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("singlePeerConnectionTable", parse_singlePeerConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("physicalEntityTable", parse_physicalEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("physicalSAPTable", parse_physicalSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dataCircuitTable", parse_dataCircuitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("physicalConnectionTable", parse_physicalConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("datalinkEntityTable", parse_datalinkEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dLSAPTable", parse_dLSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lAPBDLETable", parse_lAPBDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPPMTable", parse_sLPPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPConnectionTable", parse_sLPConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPConnectionIVMOTable", parse_sLPConnectionIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mACDLETable", parse_mACDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("mACTable", parse_mACTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCDLETable", parse_lLCDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCCLPMTable", parse_lLCCLPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCCOPMTable", parse_lLCCOPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("resourceTypeIdTable", parse_resourceTypeIdTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCStationTable", parse_lLCStationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCSAPTable", parse_lLCSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("rDESetupTable", parse_rDESetupTable, NULL, "HELP STRING");
	snmpd_register_config_handler("rDEPairTable", parse_rDEPairTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionLessTable", parse_lLCConnectionLessTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnection2Table", parse_lLCConnection2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnection2IVMOTable", parse_lLCConnection2IVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionlessAckTable", parse_lLCConnectionlessAckTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionlessAckIVMOTable", parse_lLCConnectionlessAckIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("networkEntityTable", parse_networkEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("nSAPTable", parse_nSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cLNSTable", parse_cLNSTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cLNSISISTable", parse_cLNSISISTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cLNSISISLevel2Table", parse_cLNSISISLevel2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("linkageTable", parse_linkageTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cONSTable", parse_cONSTable, NULL, "HELP STRING");
	snmpd_register_config_handler("networkConnectionTable", parse_networkConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLETable", parse_x25PLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLE-DTETable", parse_x25PLE - DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLE-DCETable", parse_x25PLE - DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMOTable", parse_x25PLEIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMO-DTETable", parse_x25PLEIVMO - DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMO-DCETable", parse_x25PLEIVMO - DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCallTable", parse_virtualCallTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCircuitTable", parse_virtualCircuitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCircuit-DTETable", parse_virtualCircuit - DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCircuit-DCETable", parse_virtualCircuit - DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("permanentVirtualCircuitTable", parse_permanentVirtualCircuitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("permanentVirtualCircuit-DTETable", parse_permanentVirtualCircuit - DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("permanentVirtualCircuit-DCETable", parse_permanentVirtualCircuit - DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCallIVMOTable", parse_virtualCallIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("switchedVirtualCallTable", parse_switchedVirtualCallTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCall-DTETable", parse_virtualCall - DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCall-DCETable", parse_virtualCall - DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("dSeriesCountsTable", parse_dSeriesCountsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("adjacencyTable", parse_adjacencyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualAdjacencyTable", parse_virtualAdjacencyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("destinationTable", parse_destinationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("destinationSystemTable", parse_destinationSystemTable, NULL, "HELP STRING");
	snmpd_register_config_handler("destinationAreaTable", parse_destinationAreaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("reachableAddressTable", parse_reachableAddressTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dlMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_communicationsEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sap1Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sap2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_clProtocolMachineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_coProtocolMachineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_singlePeerConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_physicalEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_physicalSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dataCircuitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_physicalConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_datalinkEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dLSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lAPBDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPConnectionIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mACDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mACTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCCLPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCCOPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_resourceTypeIdTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCStationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_rDESetupTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_rDEPairTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionLessTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnection2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnection2IVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionlessAckTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionlessAckIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_networkEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_nSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cLNSTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cLNSISISTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cLNSISISLevel2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_linkageTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cONSTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_networkConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLE - DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLE - DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLEIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLEIVMO - DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLEIVMO - DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCallTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCircuitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCircuit - DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCircuit - DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_permanentVirtualCircuitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_permanentVirtualCircuit - DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_permanentVirtualCircuit - DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCallIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_switchedVirtualCallTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCall - DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCall - DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dSeriesCountsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_adjacencyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualAdjacencyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_destinationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_destinationSystemTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_destinationAreaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_reachableAddressTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * deinit_dlMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_dlMIB(void)
{
	DEBUGMSGTL(("dlMIB", "deinitializating...  "));
	unregister_mib(dlMIB_variables_oid, sizeof(dlMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("dlMIB");
	snmpd_unregister_config_handler("communicationsEntityTable");
	snmpd_unregister_config_handler("sap1Table");
	snmpd_unregister_config_handler("sap2Table");
	snmpd_unregister_config_handler("clProtocolMachineTable");
	snmpd_unregister_config_handler("coProtocolMachineTable");
	snmpd_unregister_config_handler("singlePeerConnectionTable");
	snmpd_unregister_config_handler("physicalEntityTable");
	snmpd_unregister_config_handler("physicalSAPTable");
	snmpd_unregister_config_handler("dataCircuitTable");
	snmpd_unregister_config_handler("physicalConnectionTable");
	snmpd_unregister_config_handler("datalinkEntityTable");
	snmpd_unregister_config_handler("dLSAPTable");
	snmpd_unregister_config_handler("lAPBDLETable");
	snmpd_unregister_config_handler("sLPPMTable");
	snmpd_unregister_config_handler("sLPConnectionTable");
	snmpd_unregister_config_handler("sLPConnectionIVMOTable");
	snmpd_unregister_config_handler("mACDLETable");
	snmpd_unregister_config_handler("mACTable");
	snmpd_unregister_config_handler("lLCDLETable");
	snmpd_unregister_config_handler("lLCCLPMTable");
	snmpd_unregister_config_handler("lLCCOPMTable");
	snmpd_unregister_config_handler("resourceTypeIdTable");
	snmpd_unregister_config_handler("lLCStationTable");
	snmpd_unregister_config_handler("lLCSAPTable");
	snmpd_unregister_config_handler("rDESetupTable");
	snmpd_unregister_config_handler("rDEPairTable");
	snmpd_unregister_config_handler("lLCConnectionLessTable");
	snmpd_unregister_config_handler("lLCConnection2Table");
	snmpd_unregister_config_handler("lLCConnection2IVMOTable");
	snmpd_unregister_config_handler("lLCConnectionlessAckTable");
	snmpd_unregister_config_handler("lLCConnectionlessAckIVMOTable");
	snmpd_unregister_config_handler("networkEntityTable");
	snmpd_unregister_config_handler("nSAPTable");
	snmpd_unregister_config_handler("cLNSTable");
	snmpd_unregister_config_handler("cLNSISISTable");
	snmpd_unregister_config_handler("cLNSISISLevel2Table");
	snmpd_unregister_config_handler("linkageTable");
	snmpd_unregister_config_handler("cONSTable");
	snmpd_unregister_config_handler("networkConnectionTable");
	snmpd_unregister_config_handler("x25PLETable");
	snmpd_unregister_config_handler("x25PLE-DTETable");
	snmpd_unregister_config_handler("x25PLE-DCETable");
	snmpd_unregister_config_handler("x25PLEIVMOTable");
	snmpd_unregister_config_handler("x25PLEIVMO-DTETable");
	snmpd_unregister_config_handler("x25PLEIVMO-DCETable");
	snmpd_unregister_config_handler("virtualCallTable");
	snmpd_unregister_config_handler("virtualCircuitTable");
	snmpd_unregister_config_handler("virtualCircuit-DTETable");
	snmpd_unregister_config_handler("virtualCircuit-DCETable");
	snmpd_unregister_config_handler("permanentVirtualCircuitTable");
	snmpd_unregister_config_handler("permanentVirtualCircuit-DTETable");
	snmpd_unregister_config_handler("permanentVirtualCircuit-DCETable");
	snmpd_unregister_config_handler("virtualCallIVMOTable");
	snmpd_unregister_config_handler("switchedVirtualCallTable");
	snmpd_unregister_config_handler("virtualCall-DTETable");
	snmpd_unregister_config_handler("virtualCall-DCETable");
	snmpd_unregister_config_handler("dSeriesCountsTable");
	snmpd_unregister_config_handler("adjacencyTable");
	snmpd_unregister_config_handler("virtualAdjacencyTable");
	snmpd_unregister_config_handler("destinationTable");
	snmpd_unregister_config_handler("destinationSystemTable");
	snmpd_unregister_config_handler("destinationAreaTable");
	snmpd_unregister_config_handler("reachableAddressTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

int
term_dlMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_dlMIB();
	return 0;
}

/*
 * dlMIB_add(): adds a structure node for scalars
 */
int
dlMIB_add(struct dlMIB_data *thedata)
{
	DEBUGMSGTL(("dlMIB", "adding data...  "));
	dlMIBStorage = thedata;
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_dlMIB(): parses .conf file entries needed to configure the mib.
 */
void
parse_dlMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct dlMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(dlMIB_data);

	DEBUGMSGTL(("dlMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->llcDiscontinuityTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultInterfaceType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultK, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultN2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultSequenceModulus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT2Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT4Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultPBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultRejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2DefaultRoute, &tmpsize);
	StorageTmp->lLCConnection2DefaultRouteLen = tmpsize;
	if (StorageTmp->lLCConnection2DefaultRoute == NULL) {
		config_perror("invalid specification for lLCConnection2DefaultRoute");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultKStep, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultMaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions, &tmpsize);
	dlMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_dlMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_dlMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dlMIB_data *StorageTmp;

	DEBUGMSGTL(("dlMIB", "storing data...  "));
	refresh_dlMIB();
	if ((StorageTmp = dlMIBStorage) == NULL) {
		DEBUGMSGTL(("dlMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->dlMIBStorageType == ST_NONVOLATILE) */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "dlMIB ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->llcDiscontinuityTime, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultInterfaceType, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultK, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultN1, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultN2, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultSequenceModulus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT1Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT2Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT3Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT4Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultMaximumRetransmissions, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultReceivedWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultSendWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultPBitTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultRejectTimeoutValue, &tmpsize);
		tmpsize = StorageTmp->lLCConnection2DefaultRouteLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2DefaultRoute, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultKStep, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultMaxSendWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_dlMIB: refresh dlMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS susbystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_dlMIB(void)
{
	if (dlMIBStorage == NULL) {
		struct dlMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(dlMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		StorageNew->sLPConnectionDefaultInterfaceType = dTE;
		dlMIBStorage = StorageNew;
		dlMIB_refresh = 1;
	}
	if (dlMIB_refresh == 0)
		return;
	dlMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_dlMIB(): locate variables in dlMIB
 *
 * This function is called every time the agent gets a request for a scalar variable that might be
 * found within your mib section registered above.  It is up to you to do the right thing and return
 * the correct value.  You should also correct the value of "var_len" if necessary.
 *
 * Please see the documentation for more information about writing module extensions, and check out
 * the examples in the examples and mibII directories.
 */
u_char *
var_dlMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dlMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_dlMIB();
	if ((StorageTmp = dlMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCDISCONTINUITYTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->llcDiscontinuityTime);
		return (u_char *) &StorageTmp->llcDiscontinuityTime;
	case SLPCONNECTIONDEFAULTINTERFACETYPE:
		*write_method = write_sLPConnectionDefaultInterfaceType;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultInterfaceType);
		return (u_char *) &StorageTmp->sLPConnectionDefaultInterfaceType;
	case SLPCONNECTIONDEFAULTK:
		*write_method = write_sLPConnectionDefaultK;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultK);
		return (u_char *) &StorageTmp->sLPConnectionDefaultK;
	case SLPCONNECTIONDEFAULTN1:
		*write_method = write_sLPConnectionDefaultN1;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultN1);
		return (u_char *) &StorageTmp->sLPConnectionDefaultN1;
	case SLPCONNECTIONDEFAULTN2:
		*write_method = write_sLPConnectionDefaultN2;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultN2);
		return (u_char *) &StorageTmp->sLPConnectionDefaultN2;
	case SLPCONNECTIONDEFAULTSEQUENCEMODULUS:
		*write_method = write_sLPConnectionDefaultSequenceModulus;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultSequenceModulus);
		return (u_char *) &StorageTmp->sLPConnectionDefaultSequenceModulus;
	case SLPCONNECTIONDEFAULTT1TIMER:
		*write_method = write_sLPConnectionDefaultT1Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT1Timer);
		return (u_char *) &StorageTmp->sLPConnectionDefaultT1Timer;
	case SLPCONNECTIONDEFAULTT2TIMER:
		*write_method = write_sLPConnectionDefaultT2Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT2Timer);
		return (u_char *) &StorageTmp->sLPConnectionDefaultT2Timer;
	case SLPCONNECTIONDEFAULTT3TIMER:
		*write_method = write_sLPConnectionDefaultT3Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT3Timer);
		return (u_char *) &StorageTmp->sLPConnectionDefaultT3Timer;
	case SLPCONNECTIONDEFAULTT4TIMER:
		*write_method = write_sLPConnectionDefaultT4Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT4Timer);
		return (u_char *) &StorageTmp->sLPConnectionDefaultT4Timer;
	case LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2DefaultMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2DefaultMaximumRetransmissions;
	case LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2DefaultReceivedWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultReceivedWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2DefaultReceivedWindowSize;
	case LLCCONNECTION2DEFAULTSENDWINDOWSIZE:
		*write_method = write_lLCConnection2DefaultSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2DefaultSendWindowSize;
	case LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultAcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue;
	case LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultBusyStateTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue;
	case LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultPBitTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultPBitTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultPBitTimeoutValue;
	case LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultRejectTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultRejectTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultRejectTimeoutValue;
	case LLCCONNECTION2DEFAULTROUTE:
		*write_method = write_lLCConnection2DefaultRoute;
		*var_len = StorageTmp->lLCConnection2DefaultRouteLen;
		return (u_char *) StorageTmp->lLCConnection2DefaultRoute;
	case LLCCONNECTION2DEFAULTKSTEP:
		*write_method = write_lLCConnection2DefaultKStep;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultKStep);
		return (u_char *) &StorageTmp->lLCConnection2DefaultKStep;
	case LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2DefaultMaxSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultMaxSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2DefaultMaxSendWindowSize;
	case LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2DefaultOptionalTolerationIPDUs;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs);
		return (u_char *) &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs;
	case LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckDefaultMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * communicationsEntityTable_add(): adds a structure node to our data set
 */
int
communicationsEntityTable_add(struct communicationsEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("communicationsEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&communicationsEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("communicationsEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * communicationsEntityTable_del(): delete a structure
 */
int
communicationsEntityTable_del(struct communicationsEntityTable_data **thedata)
{
	struct communicationsEntityTable_data *StorageDel;

	DEBUGMSGTL(("communicationsEntityTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->communicationsEntityLocalSapNames);
		StorageDel->communicationsEntityLocalSapNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_communicationsEntityTable(): parse configuration file for communicationsEntityTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_communicationsEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct communicationsEntityTable_data *StorageTmp = SNMP_MALLOC_STRUCT(communicationsEntityTable_data);

	DEBUGMSGTL(("communicationsEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->communicationsEntityLocalSapNames, &tmpsize);
	StorageTmp->communicationsEntityLocalSapNamesLen = tmpsize;
	if (StorageTmp->communicationsEntityLocalSapNames == NULL) {
		config_perror("invalid specification for communicationsEntityLocalSapNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->communicationsEntityOperationalState, &tmpsize);
	communicationsEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
}

/*
 * store_communicationsEntityTable(): store configuraiton file for communicationsEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_communicationsEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct communicationsEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("communicationsEntityTable", "storing data...  "));
	refresh_communicationsEntityTable();
	(void) tmpsize;
	for (hcindex = communicationsEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct communicationsEntityTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->communicationsEntityTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "communicationsEntityTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->communicationsEntityLocalSapNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->communicationsEntityLocalSapNames, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->communicationsEntityOperationalState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("communicationsEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sap1Table_add(): adds a structure node to our data set
 */
int
sap1Table_add(struct sap1Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sap1Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&sap1TableStorage, vars, thedata);
	DEBUGMSGTL(("sap1Table", "registered an entry\n"));
	DEBUGMSGTL(("sap1Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sap1Table_del(): delete a structure
 */
int
sap1Table_del(struct sap1Table_data **thedata)
{
	struct sap1Table_data *StorageDel;

	DEBUGMSGTL(("sap1Table", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->sap1UserEntityNames);
		StorageDel->sap1UserEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sap1Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sap1Table(): parse configuration file for sap1Table
 * parses .conf file entries needed to configure the mib.
 */
void
parse_sap1Table(const char *token, char *line)
{
	size_t tmpsize;
	struct sap1Table_data *StorageTmp = SNMP_MALLOC_STRUCT(sap1Table_data);

	DEBUGMSGTL(("sap1Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &tmpsize);
	StorageTmp->sapIdLen = tmpsize;
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sap1Address, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sap1UserEntityNames, &tmpsize);
	StorageTmp->sap1UserEntityNamesLen = tmpsize;
	if (StorageTmp->sap1UserEntityNames == NULL) {
		config_perror("invalid specification for sap1UserEntityNames");
		return;
	}

	sap1Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sap1Table", "done.\n"));
}

/*
 * store_sap1Table(): store configuraiton file for sap1Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_sap1Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sap1Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sap1Table", "storing data...  "));
	refresh_sap1Table();
	(void) tmpsize;
	for (hcindex = sap1TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sap1Table_data *) hcindex->data;
		/* XXX: if (StorageTmp->sap1TableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sap1Table ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->sapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sap1Address, &tmpsize);
			tmpsize = StorageTmp->sap1UserEntityNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sap1UserEntityNames, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sap1Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sap2Table_add(): adds a structure node to our data set
 */
int
sap2Table_add(struct sap2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sap2Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&sap2TableStorage, vars, thedata);
	DEBUGMSGTL(("sap2Table", "registered an entry\n"));
	DEBUGMSGTL(("sap2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sap2Table_del(): delete a structure
 */
int
sap2Table_del(struct sap2Table_data **thedata)
{
	struct sap2Table_data *StorageDel;

	DEBUGMSGTL(("sap2Table", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->sap2Address);
		StorageDel->sap2AddressLen = 0;
		SNMP_FREE(StorageDel->sap2UserEntityNames);
		StorageDel->sap2UserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->sap2ProviderEntityNames);
		StorageDel->sap2ProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sap2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sap2Table(): parse configuration file for sap2Table
 * parses .conf file entries needed to configure the mib.
 */
void
parse_sap2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct sap2Table_data *StorageTmp = SNMP_MALLOC_STRUCT(sap2Table_data);

	DEBUGMSGTL(("sap2Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &tmpsize);
	StorageTmp->sapIdLen = tmpsize;
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sap2Address, &tmpsize);
	StorageTmp->sap2AddressLen = tmpsize;
	if (StorageTmp->sap2Address == NULL) {
		config_perror("invalid specification for sap2Address");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sap2UserEntityNames, &tmpsize);
	StorageTmp->sap2UserEntityNamesLen = tmpsize;
	if (StorageTmp->sap2UserEntityNames == NULL) {
		config_perror("invalid specification for sap2UserEntityNames");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sap2ProviderEntityNames, &tmpsize);
	StorageTmp->sap2ProviderEntityNamesLen = tmpsize;
	if (StorageTmp->sap2ProviderEntityNames == NULL) {
		config_perror("invalid specification for sap2ProviderEntityNames");
		return;
	}

	sap2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sap2Table", "done.\n"));
}

/*
 * store_sap2Table(): store configuraiton file for sap2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_sap2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sap2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sap2Table", "storing data...  "));
	refresh_sap2Table();
	(void) tmpsize;
	for (hcindex = sap2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sap2Table_data *) hcindex->data;
		/* XXX: if (StorageTmp->sap2TableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sap2Table ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->sapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &tmpsize);
			tmpsize = StorageTmp->sap2AddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sap2Address, &tmpsize);
			tmpsize = StorageTmp->sap2UserEntityNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sap2UserEntityNames, &tmpsize);
			tmpsize = StorageTmp->sap2ProviderEntityNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sap2ProviderEntityNames, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sap2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * clProtocolMachineTable_add(): adds a structure node to our data set
 */
int
clProtocolMachineTable_add(struct clProtocolMachineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("clProtocolMachineTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&clProtocolMachineTableStorage, vars, thedata);
	DEBUGMSGTL(("clProtocolMachineTable", "registered an entry\n"));
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * clProtocolMachineTable_del(): delete a structure
 */
int
clProtocolMachineTable_del(struct clProtocolMachineTable_data **thedata)
{
	struct clProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("clProtocolMachineTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_clProtocolMachineTable(): parse configuration file for clProtocolMachineTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_clProtocolMachineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct clProtocolMachineTable_data *StorageTmp = SNMP_MALLOC_STRUCT(clProtocolMachineTable_data);

	DEBUGMSGTL(("clProtocolMachineTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->clProtocolMachineOperationalState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->clProtocolMachineTotalRemoteSAPs, &tmpsize);
	clProtocolMachineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
}

/*
 * store_clProtocolMachineTable(): store configuraiton file for clProtocolMachineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_clProtocolMachineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct clProtocolMachineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("clProtocolMachineTable", "storing data...  "));
	refresh_clProtocolMachineTable();
	(void) tmpsize;
	for (hcindex = clProtocolMachineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct clProtocolMachineTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->clProtocolMachineTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "clProtocolMachineTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->clProtocolMachineOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->clProtocolMachineTotalRemoteSAPs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("clProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * coProtocolMachineTable_add(): adds a structure node to our data set
 */
int
coProtocolMachineTable_add(struct coProtocolMachineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("coProtocolMachineTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&coProtocolMachineTableStorage, vars, thedata);
	DEBUGMSGTL(("coProtocolMachineTable", "registered an entry\n"));
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * coProtocolMachineTable_del(): delete a structure
 */
int
coProtocolMachineTable_del(struct coProtocolMachineTable_data **thedata)
{
	struct coProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("coProtocolMachineTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_coProtocolMachineTable(): parse configuration file for coProtocolMachineTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_coProtocolMachineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct coProtocolMachineTable_data *StorageTmp = SNMP_MALLOC_STRUCT(coProtocolMachineTable_data);

	DEBUGMSGTL(("coProtocolMachineTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->coProtocolMachineOperationalState, &tmpsize);
	coProtocolMachineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
}

/*
 * store_coProtocolMachineTable(): store configuraiton file for coProtocolMachineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_coProtocolMachineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct coProtocolMachineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("coProtocolMachineTable", "storing data...  "));
	refresh_coProtocolMachineTable();
	(void) tmpsize;
	for (hcindex = coProtocolMachineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct coProtocolMachineTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->coProtocolMachineTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "coProtocolMachineTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->coProtocolMachineOperationalState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("coProtocolMachineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * singlePeerConnectionTable_add(): adds a structure node to our data set
 */
int
singlePeerConnectionTable_add(struct singlePeerConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("singlePeerConnectionTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&singlePeerConnectionTableStorage, vars, thedata);
	DEBUGMSGTL(("singlePeerConnectionTable", "registered an entry\n"));
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * singlePeerConnectionTable_del(): delete a structure
 */
int
singlePeerConnectionTable_del(struct singlePeerConnectionTable_data **thedata)
{
	struct singlePeerConnectionTable_data *StorageDel;

	DEBUGMSGTL(("singlePeerConnectionTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->underlyingConnectionNames);
		StorageDel->underlyingConnectionNamesLen = 0;
		SNMP_FREE(StorageDel->suppportedConnectionNames);
		StorageDel->suppportedConnectionNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_singlePeerConnectionTable(): parse configuration file for singlePeerConnectionTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_singlePeerConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct singlePeerConnectionTable_data *StorageTmp = SNMP_MALLOC_STRUCT(singlePeerConnectionTable_data);

	DEBUGMSGTL(("singlePeerConnectionTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &tmpsize);
	StorageTmp->connectionIdLen = tmpsize;
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->underlyingConnectionNames, &tmpsize);
	StorageTmp->underlyingConnectionNamesLen = tmpsize;
	if (StorageTmp->underlyingConnectionNames == NULL) {
		config_perror("invalid specification for underlyingConnectionNames");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->suppportedConnectionNames, &tmpsize);
	StorageTmp->suppportedConnectionNamesLen = tmpsize;
	if (StorageTmp->suppportedConnectionNames == NULL) {
		config_perror("invalid specification for suppportedConnectionNames");
		return;
	}

	singlePeerConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
}

/*
 * store_singlePeerConnectionTable(): store configuraiton file for singlePeerConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_singlePeerConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct singlePeerConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("singlePeerConnectionTable", "storing data...  "));
	refresh_singlePeerConnectionTable();
	(void) tmpsize;
	for (hcindex = singlePeerConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct singlePeerConnectionTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->singlePeerConnectionTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "singlePeerConnectionTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->connectionIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &tmpsize);
			tmpsize = StorageTmp->underlyingConnectionNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->underlyingConnectionNames, &tmpsize);
			tmpsize = StorageTmp->suppportedConnectionNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->suppportedConnectionNames, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("singlePeerConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * physicalEntityTable_add(): adds a structure node to our data set
 */
int
physicalEntityTable_add(struct physicalEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("physicalEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&physicalEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("physicalEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * physicalEntityTable_del(): delete a structure
 */
int
physicalEntityTable_del(struct physicalEntityTable_data **thedata)
{
	struct physicalEntityTable_data *StorageDel;

	DEBUGMSGTL(("physicalEntityTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->physicalEntityPhysicalEntityTitles);
		StorageDel->physicalEntityPhysicalEntityTitlesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_physicalEntityTable(): parse configuration file for physicalEntityTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_physicalEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct physicalEntityTable_data *StorageTmp = SNMP_MALLOC_STRUCT(physicalEntityTable_data);

	DEBUGMSGTL(("physicalEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->physicalEntityPhysicalEntityTitles, &tmpsize);
	StorageTmp->physicalEntityPhysicalEntityTitlesLen = tmpsize;
	if (StorageTmp->physicalEntityPhysicalEntityTitles == NULL) {
		config_perror("invalid specification for physicalEntityPhysicalEntityTitles");
		return;
	}

	physicalEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
}

/*
 * store_physicalEntityTable(): store configuraiton file for physicalEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_physicalEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct physicalEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("physicalEntityTable", "storing data...  "));
	refresh_physicalEntityTable();
	(void) tmpsize;
	for (hcindex = physicalEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct physicalEntityTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->physicalEntityTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "physicalEntityTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->physicalEntityPhysicalEntityTitlesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->physicalEntityPhysicalEntityTitles, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("physicalEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * physicalSAPTable_add(): adds a structure node to our data set
 */
int
physicalSAPTable_add(struct physicalSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("physicalSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&physicalSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("physicalSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * physicalSAPTable_del(): delete a structure
 */
int
physicalSAPTable_del(struct physicalSAPTable_data **thedata)
{
	struct physicalSAPTable_data *StorageDel;

	DEBUGMSGTL(("physicalSAPTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_physicalSAPTable(): parse configuration file for physicalSAPTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_physicalSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct physicalSAPTable_data *StorageTmp = SNMP_MALLOC_STRUCT(physicalSAPTable_data);

	DEBUGMSGTL(("physicalSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &tmpsize);
	StorageTmp->sapIdLen = tmpsize;
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->physicalSAPRowStatus, &tmpsize);
	physicalSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
}

/*
 * store_physicalSAPTable(): store configuraiton file for physicalSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_physicalSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct physicalSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("physicalSAPTable", "storing data...  "));
	refresh_physicalSAPTable();
	(void) tmpsize;
	for (hcindex = physicalSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct physicalSAPTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->physicalSAPTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "physicalSAPTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->sapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->physicalSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("physicalSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * dataCircuitTable_add(): adds a structure node to our data set
 */
int
dataCircuitTable_add(struct dataCircuitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dataCircuitTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&dataCircuitTableStorage, vars, thedata);
	DEBUGMSGTL(("dataCircuitTable", "registered an entry\n"));
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * dataCircuitTable_del(): delete a structure
 */
int
dataCircuitTable_del(struct dataCircuitTable_data **thedata)
{
	struct dataCircuitTable_data *StorageDel;

	DEBUGMSGTL(("dataCircuitTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->dataCircuitPhysicalMediaNames);
		StorageDel->dataCircuitPhysicalMediaNamesLen = 0;
		SNMP_FREE(StorageDel->dataCircuitPhysicalInterfaceType);
		StorageDel->dataCircuitPhysicalInterfaceTypeLen = 0;
		SNMP_FREE(StorageDel->dataCircuitPhysicalInterfaceStandard);
		StorageDel->dataCircuitPhysicalInterfaceStandardLen = 0;
		SNMP_FREE(StorageDel->dataCircuitTransmissionCoding);
		StorageDel->dataCircuitTransmissionCodingLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_dataCircuitTable(): parse configuration file for dataCircuitTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_dataCircuitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dataCircuitTable_data *StorageTmp = SNMP_MALLOC_STRUCT(dataCircuitTable_data);

	DEBUGMSGTL(("dataCircuitTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dataCircuitBitErrorsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dataCircuitBitErrorsTransmitted, &tmpsize);
	line = read_config_read_data(ASN_OPAQUE, line, &StorageTmp->dataCircuitBitErrorsThreshold, &tmpsize);
	StorageTmp->dataCircuitBitErrorsThresholdLen = tmpsize;
	if (StorageTmp->dataCircuitBitErrorsThreshold == NULL) {
		config_perror("invalid specification for dataCircuitBitErrorsThreshold");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitPhysicalMediaNames, &tmpsize);
	StorageTmp->dataCircuitPhysicalMediaNamesLen = tmpsize;
	if (StorageTmp->dataCircuitPhysicalMediaNames == NULL) {
		config_perror("invalid specification for dataCircuitPhysicalMediaNames");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitPhysicalInterfaceType, &tmpsize);
	StorageTmp->dataCircuitPhysicalInterfaceTypeLen = tmpsize;
	if (StorageTmp->dataCircuitPhysicalInterfaceType == NULL) {
		config_perror("invalid specification for dataCircuitPhysicalInterfaceType");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitPhysicalInterfaceStandard, &tmpsize);
	StorageTmp->dataCircuitPhysicalInterfaceStandardLen = tmpsize;
	if (StorageTmp->dataCircuitPhysicalInterfaceStandard == NULL) {
		config_perror("invalid specification for dataCircuitPhysicalInterfaceStandard");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitSynchronizationMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitTransmissionCoding, &tmpsize);
	StorageTmp->dataCircuitTransmissionCodingLen = tmpsize;
	if (StorageTmp->dataCircuitTransmissionCoding == NULL) {
		config_perror("invalid specification for dataCircuitTransmissionCoding");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitTransmissionMode, &tmpsize);
	line = read_config_read_data(ASN_OPAQUE, line, &StorageTmp->dataCircuitTransmissionRate, &tmpsize);
	StorageTmp->dataCircuitTransmissionRateLen = tmpsize;
	if (StorageTmp->dataCircuitTransmissionRate == NULL) {
		config_perror("invalid specification for dataCircuitTransmissionRate");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitRowStatus, &tmpsize);
	dataCircuitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
}

/*
 * store_dataCircuitTable(): store configuraiton file for dataCircuitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dataCircuitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dataCircuitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dataCircuitTable", "storing data...  "));
	refresh_dataCircuitTable();
	(void) tmpsize;
	for (hcindex = dataCircuitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dataCircuitTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->dataCircuitTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dataCircuitTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dataCircuitBitErrorsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dataCircuitBitErrorsTransmitted, &tmpsize);
			tmpsize = StorageTmp->dataCircuitBitErrorsThresholdLen;
			cptr = read_config_store_data(ASN_OPAQUE, cptr, &StorageTmp->dataCircuitBitErrorsThreshold, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitType, &tmpsize);
			tmpsize = StorageTmp->dataCircuitPhysicalMediaNamesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitPhysicalMediaNames, &tmpsize);
			tmpsize = StorageTmp->dataCircuitPhysicalInterfaceTypeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitPhysicalInterfaceType, &tmpsize);
			tmpsize = StorageTmp->dataCircuitPhysicalInterfaceStandardLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitPhysicalInterfaceStandard, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitSynchronizationMode, &tmpsize);
			tmpsize = StorageTmp->dataCircuitTransmissionCodingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitTransmissionCoding, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitTransmissionMode, &tmpsize);
			tmpsize = StorageTmp->dataCircuitTransmissionRateLen;
			cptr = read_config_store_data(ASN_OPAQUE, cptr, &StorageTmp->dataCircuitTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dataCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * physicalConnectionTable_add(): adds a structure node to our data set
 */
int
physicalConnectionTable_add(struct physicalConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("physicalConnectionTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&physicalConnectionTableStorage, vars, thedata);
	DEBUGMSGTL(("physicalConnectionTable", "registered an entry\n"));
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * physicalConnectionTable_del(): delete a structure
 */
int
physicalConnectionTable_del(struct physicalConnectionTable_data **thedata)
{
	struct physicalConnectionTable_data *StorageDel;

	DEBUGMSGTL(("physicalConnectionTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->physicalConnectionEndpointIdentifier);
		StorageDel->physicalConnectionEndpointIdentifierLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_physicalConnectionTable(): parse configuration file for physicalConnectionTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_physicalConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct physicalConnectionTable_data *StorageTmp = SNMP_MALLOC_STRUCT(physicalConnectionTable_data);

	DEBUGMSGTL(("physicalConnectionTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &tmpsize);
	StorageTmp->connectionIdLen = tmpsize;
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->physicalConnectionEndpointIdentifier, &tmpsize);
	StorageTmp->physicalConnectionEndpointIdentifierLen = tmpsize;
	if (StorageTmp->physicalConnectionEndpointIdentifier == NULL) {
		config_perror("invalid specification for physicalConnectionEndpointIdentifier");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->physicalConnectionPortNumber, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->physicalConnectionRowStatus, &tmpsize);
	physicalConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
}

/*
 * store_physicalConnectionTable(): store configuraiton file for physicalConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_physicalConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct physicalConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("physicalConnectionTable", "storing data...  "));
	refresh_physicalConnectionTable();
	(void) tmpsize;
	for (hcindex = physicalConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct physicalConnectionTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->physicalConnectionTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "physicalConnectionTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->connectionIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &tmpsize);
			tmpsize = StorageTmp->physicalConnectionEndpointIdentifierLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->physicalConnectionEndpointIdentifier, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->physicalConnectionPortNumber, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->physicalConnectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("physicalConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * datalinkEntityTable_add(): adds a structure node to our data set
 */
int
datalinkEntityTable_add(struct datalinkEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("datalinkEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&datalinkEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("datalinkEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * datalinkEntityTable_del(): delete a structure
 */
int
datalinkEntityTable_del(struct datalinkEntityTable_data **thedata)
{
	struct datalinkEntityTable_data *StorageDel;

	DEBUGMSGTL(("datalinkEntityTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->datalinkEntityProviderEntityNames);
		StorageDel->datalinkEntityProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_datalinkEntityTable(): parse configuration file for datalinkEntityTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_datalinkEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct datalinkEntityTable_data *StorageTmp = SNMP_MALLOC_STRUCT(datalinkEntityTable_data);

	DEBUGMSGTL(("datalinkEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->datalinkEntityProviderEntityNames, &tmpsize);
	StorageTmp->datalinkEntityProviderEntityNamesLen = tmpsize;
	if (StorageTmp->datalinkEntityProviderEntityNames == NULL) {
		config_perror("invalid specification for datalinkEntityProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->datalinkEntityRowStatus, &tmpsize);
	datalinkEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
}

/*
 * store_datalinkEntityTable(): store configuraiton file for datalinkEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_datalinkEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct datalinkEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("datalinkEntityTable", "storing data...  "));
	refresh_datalinkEntityTable();
	(void) tmpsize;
	for (hcindex = datalinkEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct datalinkEntityTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->datalinkEntityTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "datalinkEntityTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->datalinkEntityProviderEntityNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->datalinkEntityProviderEntityNames, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->datalinkEntityRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("datalinkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * dLSAPTable_add(): adds a structure node to our data set
 */
int
dLSAPTable_add(struct dLSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dLSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&dLSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("dLSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * dLSAPTable_del(): delete a structure
 */
int
dLSAPTable_del(struct dLSAPTable_data **thedata)
{
	struct dLSAPTable_data *StorageDel;

	DEBUGMSGTL(("dLSAPTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_dLSAPTable(): parse configuration file for dLSAPTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_dLSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp = SNMP_MALLOC_STRUCT(dLSAPTable_data);

	DEBUGMSGTL(("dLSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &tmpsize);
	StorageTmp->sapIdLen = tmpsize;
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dLSAPRowStatus, &tmpsize);
	dLSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
}

/*
 * store_dLSAPTable(): store configuraiton file for dLSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dLSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dLSAPTable", "storing data...  "));
	refresh_dLSAPTable();
	(void) tmpsize;
	for (hcindex = dLSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dLSAPTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->dLSAPTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dLSAPTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->sapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dLSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lAPBDLETable_add(): adds a structure node to our data set
 */
int
lAPBDLETable_add(struct lAPBDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lAPBDLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&lAPBDLETableStorage, vars, thedata);
	DEBUGMSGTL(("lAPBDLETable", "registered an entry\n"));
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lAPBDLETable_del(): delete a structure
 */
int
lAPBDLETable_del(struct lAPBDLETable_data **thedata)
{
	struct lAPBDLETable_data *StorageDel;

	DEBUGMSGTL(("lAPBDLETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lAPBDLETable(): parse configuration file for lAPBDLETable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lAPBDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct lAPBDLETable_data *StorageTmp = SNMP_MALLOC_STRUCT(lAPBDLETable_data);

	DEBUGMSGTL(("lAPBDLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmW, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmXSend, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmXReceive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT2Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEreceivedMlpResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEtimesMT1Expired, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEIframesReassignments, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLERowStatus, &tmpsize);
	lAPBDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
}

/*
 * store_lAPBDLETable(): store configuraiton file for lAPBDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lAPBDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lAPBDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lAPBDLETable", "storing data...  "));
	refresh_lAPBDLETable();
	(void) tmpsize;
	for (hcindex = lAPBDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lAPBDLETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lAPBDLETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lAPBDLETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT1Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT3Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmW, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmXSend, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmXReceive, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT2Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEreceivedMlpResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEtimesMT1Expired, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEIframesReassignments, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sLPPMTable_add(): adds a structure node to our data set
 */
int
sLPPMTable_add(struct sLPPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sLPPMTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&sLPPMTableStorage, vars, thedata);
	DEBUGMSGTL(("sLPPMTable", "registered an entry\n"));
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sLPPMTable_del(): delete a structure
 */
int
sLPPMTable_del(struct sLPPMTable_data **thedata)
{
	struct sLPPMTable_data *StorageDel;

	DEBUGMSGTL(("sLPPMTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sLPPMTable(): parse configuration file for sLPPMTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_sLPPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPPMTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sLPPMTable_data);

	DEBUGMSGTL(("sLPPMTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPPMadministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPPMRowStatus, &tmpsize);
	sLPPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
}

/*
 * store_sLPPMTable(): store configuraiton file for sLPPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sLPPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sLPPMTable", "storing data...  "));
	refresh_sLPPMTable();
	(void) tmpsize;
	for (hcindex = sLPPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPPMTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->sLPPMTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sLPPMTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPPMadministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sLPConnectionTable_add(): adds a structure node to our data set
 */
int
sLPConnectionTable_add(struct sLPConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sLPConnectionTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&sLPConnectionTableStorage, vars, thedata);
	DEBUGMSGTL(("sLPConnectionTable", "registered an entry\n"));
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sLPConnectionTable_del(): delete a structure
 */
int
sLPConnectionTable_del(struct sLPConnectionTable_data **thedata)
{
	struct sLPConnectionTable_data *StorageDel;

	DEBUGMSGTL(("sLPConnectionTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->sLPConnectionProceduralStatus);
		StorageDel->sLPConnectionProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->sLPConnectionAlarmStatus);
		StorageDel->sLPConnectionAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sLPConnectionTable(): parse configuration file for sLPConnectionTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_sLPConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPConnectionTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sLPConnectionTable_data);

	DEBUGMSGTL(("sLPConnectionTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &tmpsize);
	StorageTmp->connectionIdLen = tmpsize;
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionInterfaceType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionK, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionN2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionSequenceModulus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT2Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFCSErrorsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFRMRsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFRMRsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFrameDataOctetsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFrameDataOctetsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFramesReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFramesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionPollsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionREJsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionREJsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionRNRsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionRNRsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionSABMsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionSABMsSent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionProtocolState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT1Expired, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT3Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT3Expired, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT4Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT4Expired, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionLinkResetsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionLinkResetsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesN2Reached, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionUsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sLPConnectionProceduralStatus, &tmpsize);
	StorageTmp->sLPConnectionProceduralStatusLen = tmpsize;
	if (StorageTmp->sLPConnectionProceduralStatus == NULL) {
		config_perror("invalid specification for sLPConnectionProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sLPConnectionAlarmStatus, &tmpsize);
	StorageTmp->sLPConnectionAlarmStatusLen = tmpsize;
	if (StorageTmp->sLPConnectionAlarmStatus == NULL) {
		config_perror("invalid specification for sLPConnectionAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionRowStatus, &tmpsize);
	sLPConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
}

/*
 * store_sLPConnectionTable(): store configuraiton file for sLPConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sLPConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sLPConnectionTable", "storing data...  "));
	refresh_sLPConnectionTable();
	(void) tmpsize;
	for (hcindex = sLPConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPConnectionTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->sLPConnectionTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sLPConnectionTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->connectionIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionInterfaceType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionK, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionN2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionSequenceModulus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT1Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT2Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFCSErrorsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFRMRsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFRMRsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFrameDataOctetsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFrameDataOctetsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFramesReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFramesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionPollsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionREJsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionREJsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionRNRsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionRNRsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionSABMsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionSABMsSent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionProtocolState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesT1Expired, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT3Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesT3Expired, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT4Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesT4Expired, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionLinkResetsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionLinkResetsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesN2Reached, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionUsageState, &tmpsize);
			tmpsize = StorageTmp->sLPConnectionProceduralStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sLPConnectionProceduralStatus, &tmpsize);
			tmpsize = StorageTmp->sLPConnectionAlarmStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sLPConnectionAlarmStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sLPConnectionIVMOTable_add(): adds a structure node to our data set
 */
int
sLPConnectionIVMOTable_add(struct sLPConnectionIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sLPConnectionIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&sLPConnectionIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("sLPConnectionIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sLPConnectionIVMOTable_del(): delete a structure
 */
int
sLPConnectionIVMOTable_del(struct sLPConnectionIVMOTable_data **thedata)
{
	struct sLPConnectionIVMOTable_data *StorageDel;

	DEBUGMSGTL(("sLPConnectionIVMOTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->sLPConnectionIVMOid);
		StorageDel->sLPConnectionIVMOidLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sLPConnectionIVMOTable(): parse configuration file for sLPConnectionIVMOTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_sLPConnectionIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPConnectionIVMOTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sLPConnectionIVMOTable_data);

	DEBUGMSGTL(("sLPConnectionIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &tmpsize);
	StorageTmp->connectionIdLen = tmpsize;
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sLPConnectionIVMOid, &tmpsize);
	StorageTmp->sLPConnectionIVMOidLen = tmpsize;
	if (StorageTmp->sLPConnectionIVMOid == NULL) {
		config_perror("invalid specification for sLPConnectionIVMOid");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOinterfaceType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOk, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOn1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOn2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOsequenceModulus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt2Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt4Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMORowStatus, &tmpsize);
	sLPConnectionIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
}

/*
 * store_sLPConnectionIVMOTable(): store configuraiton file for sLPConnectionIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sLPConnectionIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPConnectionIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sLPConnectionIVMOTable", "storing data...  "));
	refresh_sLPConnectionIVMOTable();
	(void) tmpsize;
	for (hcindex = sLPConnectionIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPConnectionIVMOTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->sLPConnectionIVMOTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sLPConnectionIVMOTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->connectionIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &tmpsize);
			tmpsize = StorageTmp->sLPConnectionIVMOidLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sLPConnectionIVMOid, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOinterfaceType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOk, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOn1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOn2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOsequenceModulus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt1Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt2Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt3Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt4Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mACDLETable_add(): adds a structure node to our data set
 */
int
mACDLETable_add(struct mACDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mACDLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&mACDLETableStorage, vars, thedata);
	DEBUGMSGTL(("mACDLETable", "registered an entry\n"));
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mACDLETable_del(): delete a structure
 */
int
mACDLETable_del(struct mACDLETable_data **thedata)
{
	struct mACDLETable_data *StorageDel;

	DEBUGMSGTL(("mACDLETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mACDLETable(): parse configuration file for mACDLETable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mACDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct mACDLETable_data *StorageTmp = SNMP_MALLOC_STRUCT(mACDLETable_data);

	DEBUGMSGTL(("mACDLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACDLERowStatus, &tmpsize);
	mACDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mACDLETable", "done.\n"));
}

/*
 * store_mACDLETable(): store configuraiton file for mACDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mACDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mACDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mACDLETable", "storing data...  "));
	refresh_mACDLETable();
	(void) tmpsize;
	for (hcindex = mACDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mACDLETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mACDLETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mACDLETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mACTable_add(): adds a structure node to our data set
 */
int
mACTable_add(struct mACTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mACTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* mACId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mACId, thedata->mACIdLen);
	header_complex_add_data(&mACTableStorage, vars, thedata);
	DEBUGMSGTL(("mACTable", "registered an entry\n"));
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mACTable_del(): delete a structure
 */
int
mACTable_del(struct mACTable_data **thedata)
{
	struct mACTable_data *StorageDel;

	DEBUGMSGTL(("mACTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->mACId);
		StorageDel->mACIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mACTable(): parse configuration file for mACTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mACTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mACTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mACTable_data);

	DEBUGMSGTL(("mACTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACOperationalState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mACId, &tmpsize);
	StorageTmp->mACIdLen = tmpsize;
	if (StorageTmp->mACId == NULL) {
		config_perror("invalid specification for mACId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACRowStatus, &tmpsize);
	mACTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mACTable", "done.\n"));
}

/*
 * store_mACTable(): store configuraiton file for mACTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mACTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mACTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mACTable", "storing data...  "));
	refresh_mACTable();
	(void) tmpsize;
	for (hcindex = mACTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mACTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mACTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mACTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACOperationalState, &tmpsize);
			tmpsize = StorageTmp->mACIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mACId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCDLETable_add(): adds a structure node to our data set
 */
int
lLCDLETable_add(struct lLCDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCDLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&lLCDLETableStorage, vars, thedata);
	DEBUGMSGTL(("lLCDLETable", "registered an entry\n"));
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCDLETable_del(): delete a structure
 */
int
lLCDLETable_del(struct lLCDLETable_data **thedata)
{
	struct lLCDLETable_data *StorageDel;

	DEBUGMSGTL(("lLCDLETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCDLETable(): parse configuration file for lLCDLETable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCDLETable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCDLETable_data);

	DEBUGMSGTL(("lLCDLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCDLERowStatus, &tmpsize);
	lLCDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
}

/*
 * store_lLCDLETable(): store configuraiton file for lLCDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCDLETable", "storing data...  "));
	refresh_lLCDLETable();
	(void) tmpsize;
	for (hcindex = lLCDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCDLETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCDLETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCDLETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCCLPMTable_add(): adds a structure node to our data set
 */
int
lLCCLPMTable_add(struct lLCCLPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCCLPMTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&lLCCLPMTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCCLPMTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCCLPMTable_del(): delete a structure
 */
int
lLCCLPMTable_del(struct lLCCLPMTable_data **thedata)
{
	struct lLCCLPMTable_data *StorageDel;

	DEBUGMSGTL(("lLCCLPMTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCCLPMTable(): parse configuration file for lLCCLPMTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCCLPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCCLPMTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCCLPMTable_data);

	DEBUGMSGTL(("lLCCLPMTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCLPMRowStatus, &tmpsize);
	lLCCLPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
}

/*
 * store_lLCCLPMTable(): store configuraiton file for lLCCLPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCCLPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCCLPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCCLPMTable", "storing data...  "));
	refresh_lLCCLPMTable();
	(void) tmpsize;
	for (hcindex = lLCCLPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCCLPMTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCCLPMTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCCLPMTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCLPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCCOPMTable_add(): adds a structure node to our data set
 */
int
lLCCOPMTable_add(struct lLCCOPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCCOPMTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&lLCCOPMTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCCOPMTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCCOPMTable_del(): delete a structure
 */
int
lLCCOPMTable_del(struct lLCCOPMTable_data **thedata)
{
	struct lLCCOPMTable_data *StorageDel;

	DEBUGMSGTL(("lLCCOPMTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCCOPMTable(): parse configuration file for lLCCOPMTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCCOPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCCOPMTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCCOPMTable_data);

	DEBUGMSGTL(("lLCCOPMTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCOPMRowStatus, &tmpsize);
	lLCCOPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
}

/*
 * store_lLCCOPMTable(): store configuraiton file for lLCCOPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCCOPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCCOPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCCOPMTable", "storing data...  "));
	refresh_lLCCOPMTable();
	(void) tmpsize;
	for (hcindex = lLCCOPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCCOPMTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCCOPMTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCCOPMTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCOPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * resourceTypeIdTable_add(): adds a structure node to our data set
 */
int
resourceTypeIdTable_add(struct resourceTypeIdTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("resourceTypeIdTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&resourceTypeIdTableStorage, vars, thedata);
	DEBUGMSGTL(("resourceTypeIdTable", "registered an entry\n"));
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * resourceTypeIdTable_del(): delete a structure
 */
int
resourceTypeIdTable_del(struct resourceTypeIdTable_data **thedata)
{
	struct resourceTypeIdTable_data *StorageDel;

	DEBUGMSGTL(("resourceTypeIdTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->resourceTypeIdName);
		StorageDel->resourceTypeIdNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerOUI);
		StorageDel->resourceInfoManufacturerOUILen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerName);
		StorageDel->resourceInfoManufacturerNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerProductName);
		StorageDel->resourceInfoManufacturerProductNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerProductVersion);
		StorageDel->resourceInfoManufacturerProductVersionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_resourceTypeIdTable(): parse configuration file for resourceTypeIdTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_resourceTypeIdTable(const char *token, char *line)
{
	size_t tmpsize;
	struct resourceTypeIdTable_data *StorageTmp = SNMP_MALLOC_STRUCT(resourceTypeIdTable_data);

	DEBUGMSGTL(("resourceTypeIdTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceTypeIdName, &tmpsize);
	StorageTmp->resourceTypeIdNameLen = tmpsize;
	if (StorageTmp->resourceTypeIdName == NULL) {
		config_perror("invalid specification for resourceTypeIdName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerOUI, &tmpsize);
	StorageTmp->resourceInfoManufacturerOUILen = tmpsize;
	if (StorageTmp->resourceInfoManufacturerOUI == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerOUI");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerName, &tmpsize);
	StorageTmp->resourceInfoManufacturerNameLen = tmpsize;
	if (StorageTmp->resourceInfoManufacturerName == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerProductName, &tmpsize);
	StorageTmp->resourceInfoManufacturerProductNameLen = tmpsize;
	if (StorageTmp->resourceInfoManufacturerProductName == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerProductName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerProductVersion, &tmpsize);
	StorageTmp->resourceInfoManufacturerProductVersionLen = tmpsize;
	if (StorageTmp->resourceInfoManufacturerProductVersion == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerProductVersion");
		return;
	}

	resourceTypeIdTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
}

/*
 * store_resourceTypeIdTable(): store configuraiton file for resourceTypeIdTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_resourceTypeIdTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct resourceTypeIdTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("resourceTypeIdTable", "storing data...  "));
	refresh_resourceTypeIdTable();
	(void) tmpsize;
	for (hcindex = resourceTypeIdTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct resourceTypeIdTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->resourceTypeIdTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "resourceTypeIdTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->resourceTypeIdNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceTypeIdName, &tmpsize);
			tmpsize = StorageTmp->resourceInfoManufacturerOUILen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerOUI, &tmpsize);
			tmpsize = StorageTmp->resourceInfoManufacturerNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerName, &tmpsize);
			tmpsize = StorageTmp->resourceInfoManufacturerProductNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerProductName, &tmpsize);
			tmpsize = StorageTmp->resourceInfoManufacturerProductVersionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerProductVersion, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCStationTable_add(): adds a structure node to our data set
 */
int
lLCStationTable_add(struct lLCStationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCStationTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&lLCStationTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCStationTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCStationTable_del(): delete a structure
 */
int
lLCStationTable_del(struct lLCStationTable_data **thedata)
{
	struct lLCStationTable_data *StorageDel;

	DEBUGMSGTL(("lLCStationTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->lLCStationLLCName);
		StorageDel->lLCStationLLCNameLen = 0;
		SNMP_FREE(StorageDel->lLCStationSupportedServicesTypes);
		StorageDel->lLCStationSupportedServicesTypesLen = 0;
		SNMP_FREE(StorageDel->lLCStationSTRIndicator);
		StorageDel->lLCStationSTRIndicatorLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCStationTable(): parse configuration file for lLCStationTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCStationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCStationTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCStationTable_data);

	DEBUGMSGTL(("lLCStationTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &tmpsize);
	StorageTmp->sapIdLen = tmpsize;
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCStationLLCName, &tmpsize);
	StorageTmp->lLCStationLLCNameLen = tmpsize;
	if (StorageTmp->lLCStationLLCName == NULL) {
		config_perror("invalid specification for lLCStationLLCName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumLSAPsConfigured, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationNumberOfActiveLSAPs, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCStationSupportedServicesTypes, &tmpsize);
	StorageTmp->lLCStationSupportedServicesTypesLen = tmpsize;
	if (StorageTmp->lLCStationSupportedServicesTypes == NULL) {
		config_perror("invalid specification for lLCStationSupportedServicesTypes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType1AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType1MaximumRetryCount, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumPDUN3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumRetransmissions4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationReceiveVariableLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationTransmitVariableLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType3AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationType3Retransmissions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationAvgBufferUseSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationBufferProblems, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationBufferSize, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationMaxBufferUseSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationInactiveLSAP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationPDUsDiscard, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCStationSTRIndicator, &tmpsize);
	StorageTmp->lLCStationSTRIndicatorLen = tmpsize;
	if (StorageTmp->lLCStationSTRIndicator == NULL) {
		config_perror("invalid specification for lLCStationSTRIndicator");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationVersionNumber, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts, &tmpsize);
	lLCStationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
}

/*
 * store_lLCStationTable(): store configuraiton file for lLCStationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCStationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCStationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCStationTable", "storing data...  "));
	refresh_lLCStationTable();
	(void) tmpsize;
	for (hcindex = lLCStationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCStationTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCStationTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCStationTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->sapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &tmpsize);
			tmpsize = StorageTmp->lLCStationLLCNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCStationLLCName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumLSAPsConfigured, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationNumberOfActiveLSAPs, &tmpsize);
			tmpsize = StorageTmp->lLCStationSupportedServicesTypesLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCStationSupportedServicesTypes, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType1AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType1MaximumRetryCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumPDUN3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumRetransmissions4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationReceiveVariableLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationTransmitVariableLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType3AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationType3Retransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationAvgBufferUseSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationBufferProblems, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationBufferSize, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationMaxBufferUseSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationInactiveLSAP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationPDUsDiscard, &tmpsize);
			tmpsize = StorageTmp->lLCStationSTRIndicatorLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCStationSTRIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationVersionNumber, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCSAPTable_add(): adds a structure node to our data set
 */
int
lLCSAPTable_add(struct lLCSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&lLCSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCSAPTable_del(): delete a structure
 */
int
lLCSAPTable_del(struct lLCSAPTable_data **thedata)
{
	struct lLCSAPTable_data *StorageDel;

	DEBUGMSGTL(("lLCSAPTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->lLCSAPName);
		StorageDel->lLCSAPNameLen = 0;
		SNMP_FREE(StorageDel->lLCSAPAddress);
		StorageDel->lLCSAPAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCSAPTable(): parse configuration file for lLCSAPTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCSAPTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCSAPTable_data);

	DEBUGMSGTL(("lLCSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &tmpsize);
	StorageTmp->sapIdLen = tmpsize;
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCSAPName, &tmpsize);
	StorageTmp->lLCSAPNameLen = tmpsize;
	if (StorageTmp->lLCSAPName == NULL) {
		config_perror("invalid specification for lLCSAPName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCSAPAddress, &tmpsize);
	StorageTmp->lLCSAPAddressLen = tmpsize;
	if (StorageTmp->lLCSAPAddress == NULL) {
		config_perror("invalid specification for lLCSAPAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCSAPRDE, &tmpsize);
	lLCSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
}

/*
 * store_lLCSAPTable(): store configuraiton file for lLCSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCSAPTable", "storing data...  "));
	refresh_lLCSAPTable();
	(void) tmpsize;
	for (hcindex = lLCSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCSAPTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCSAPTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCSAPTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->sapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &tmpsize);
			tmpsize = StorageTmp->lLCSAPNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCSAPName, &tmpsize);
			tmpsize = StorageTmp->lLCSAPAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCSAPAddress, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCSAPRDE, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * rDESetupTable_add(): adds a structure node to our data set
 */
int
rDESetupTable_add(struct rDESetupTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("rDESetupTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&rDESetupTableStorage, vars, thedata);
	DEBUGMSGTL(("rDESetupTable", "registered an entry\n"));
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * rDESetupTable_del(): delete a structure
 */
int
rDESetupTable_del(struct rDESetupTable_data **thedata)
{
	struct rDESetupTable_data *StorageDel;

	DEBUGMSGTL(("rDESetupTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_rDESetupTable(): parse configuration file for rDESetupTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_rDESetupTable(const char *token, char *line)
{
	size_t tmpsize;
	struct rDESetupTable_data *StorageTmp = SNMP_MALLOC_STRUCT(rDESetupTable_data);

	DEBUGMSGTL(("rDESetupTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &tmpsize);
	StorageTmp->sapIdLen = tmpsize;
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupAgingEnabled, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupAgingValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupEnableType2Reset, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMaximumRouteDescriptors, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMaximumResponseTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMinimumPDUSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupRDEHold, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupRDEReplace, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupName, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupResetOnTestEnabled, &tmpsize);
	rDESetupTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
}

/*
 * store_rDESetupTable(): store configuraiton file for rDESetupTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_rDESetupTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct rDESetupTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("rDESetupTable", "storing data...  "));
	refresh_rDESetupTable();
	(void) tmpsize;
	for (hcindex = rDESetupTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct rDESetupTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->rDESetupTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "rDESetupTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->sapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupAgingEnabled, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupAgingValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupEnableType2Reset, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMaximumRouteDescriptors, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMaximumResponseTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMinimumPDUSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupRDEHold, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupRDEReplace, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupResetOnTestEnabled, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * rDEPairTable_add(): adds a structure node to our data set
 */
int
rDEPairTable_add(struct rDEPairTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("rDEPairTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	/* rDEPairName */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->rDEPairName, thedata->rDEPairNameLen);
	header_complex_add_data(&rDEPairTableStorage, vars, thedata);
	DEBUGMSGTL(("rDEPairTable", "registered an entry\n"));
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * rDEPairTable_del(): delete a structure
 */
int
rDEPairTable_del(struct rDEPairTable_data **thedata)
{
	struct rDEPairTable_data *StorageDel;

	DEBUGMSGTL(("rDEPairTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->rDEPairName);
		StorageDel->rDEPairNameLen = 0;
		SNMP_FREE(StorageDel->rDEPairRIF);
		StorageDel->rDEPairRIFLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_rDEPairTable(): parse configuration file for rDEPairTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_rDEPairTable(const char *token, char *line)
{
	size_t tmpsize;
	struct rDEPairTable_data *StorageTmp = SNMP_MALLOC_STRUCT(rDEPairTable_data);

	DEBUGMSGTL(("rDEPairTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &tmpsize);
	StorageTmp->sapIdLen = tmpsize;
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->rDEPairName, &tmpsize);
	StorageTmp->rDEPairNameLen = tmpsize;
	if (StorageTmp->rDEPairName == NULL) {
		config_perror("invalid specification for rDEPairName");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairDiscardCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairNSRPDUCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairNSRSelectedCounter, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->rDEPairRIF, &tmpsize);
	StorageTmp->rDEPairRIFLen = tmpsize;
	if (StorageTmp->rDEPairRIF == NULL) {
		config_perror("invalid specification for rDEPairRIF");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairSRFPDUCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairQueryCounter, &tmpsize);
	rDEPairTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
}

/*
 * store_rDEPairTable(): store configuraiton file for rDEPairTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_rDEPairTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct rDEPairTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("rDEPairTable", "storing data...  "));
	refresh_rDEPairTable();
	(void) tmpsize;
	for (hcindex = rDEPairTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct rDEPairTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->rDEPairTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "rDEPairTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->sapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &tmpsize);
			tmpsize = StorageTmp->rDEPairNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->rDEPairName, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairDiscardCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairNSRPDUCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairNSRSelectedCounter, &tmpsize);
			tmpsize = StorageTmp->rDEPairRIFLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->rDEPairRIF, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairSRFPDUCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairQueryCounter, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionLessTable_add(): adds a structure node to our data set
 */
int
lLCConnectionLessTable_add(struct lLCConnectionLessTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnectionLessTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&lLCConnectionLessTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnectionLessTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionLessTable_del(): delete a structure
 */
int
lLCConnectionLessTable_del(struct lLCConnectionLessTable_data **thedata)
{
	struct lLCConnectionLessTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionLessTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnectionlessName);
		StorageDel->lLCConnectionlessNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnectionLessTable(): parse configuration file for lLCConnectionLessTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnectionLessTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionLessTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnectionLessTable_data);

	DEBUGMSGTL(("lLCConnectionLessTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessName, &tmpsize);
	StorageTmp->lLCConnectionlessNameLen = tmpsize;
	if (StorageTmp->lLCConnectionlessName == NULL) {
		config_perror("invalid specification for lLCConnectionlessName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessUIReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessUISent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDSentResponse, &tmpsize);
	lLCConnectionLessTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
}

/*
 * store_lLCConnectionLessTable(): store configuraiton file for lLCConnectionLessTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionLessTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionLessTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnectionLessTable", "storing data...  "));
	refresh_lLCConnectionLessTable();
	(void) tmpsize;
	for (hcindex = lLCConnectionLessTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionLessTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnectionLessTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionLessTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->lLCConnectionlessNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessUIReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessUISent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDSentResponse, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnection2Table_add(): adds a structure node to our data set
 */
int
lLCConnection2Table_add(struct lLCConnection2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnection2Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&lLCConnection2TableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnection2Table", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnection2Table_del(): delete a structure
 */
int
lLCConnection2Table_del(struct lLCConnection2Table_data **thedata)
{
	struct lLCConnection2Table_data *StorageDel;

	DEBUGMSGTL(("lLCConnection2Table", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2Name);
		StorageDel->lLCConnection2NameLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2Route);
		StorageDel->lLCConnection2RouteLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2ProceduralStatus);
		StorageDel->lLCConnection2ProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2AlarmStatus);
		StorageDel->lLCConnection2AlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnection2Table(): parse configuration file for lLCConnection2Table
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnection2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnection2Table_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnection2Table_data);

	DEBUGMSGTL(("lLCConnection2Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2Name, &tmpsize);
	StorageTmp->lLCConnection2NameLen = tmpsize;
	if (StorageTmp->lLCConnection2Name == NULL) {
		config_perror("invalid specification for lLCConnection2Name");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2MaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2ReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2SendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2BusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2PBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2RejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2LocalBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2RemoteBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2RemoteReset, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2LocalReset, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ProviderReset, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2Route, &tmpsize);
	StorageTmp->lLCConnection2RouteLen = tmpsize;
	if (StorageTmp->lLCConnection2Route == NULL) {
		config_perror("invalid specification for lLCConnection2Route");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2KStep, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2MaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedI, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentI, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentAcks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedAcks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedFRMR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentFRMR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedRR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentRR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedRNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentRNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedREJ, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentREJ, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedSABME, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentSABME, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedUA, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentUA, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedDISC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentDISC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedDM, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentDM, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDUsDiscarded1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDUsDiscarded2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDURetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2OptionalTolerationIPDUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2DuplicateIPDUsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2Violation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2ProtocolState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2AdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2OperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2UsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCConnection2ProceduralStatus, &tmpsize);
	StorageTmp->lLCConnection2ProceduralStatusLen = tmpsize;
	if (StorageTmp->lLCConnection2ProceduralStatus == NULL) {
		config_perror("invalid specification for lLCConnection2ProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCConnection2AlarmStatus, &tmpsize);
	StorageTmp->lLCConnection2AlarmStatusLen = tmpsize;
	if (StorageTmp->lLCConnection2AlarmStatus == NULL) {
		config_perror("invalid specification for lLCConnection2AlarmStatus");
		return;
	}

	lLCConnection2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
}

/*
 * store_lLCConnection2Table(): store configuraiton file for lLCConnection2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnection2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnection2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnection2Table", "storing data...  "));
	refresh_lLCConnection2Table();
	(void) tmpsize;
	for (hcindex = lLCConnection2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnection2Table_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnection2TableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnection2Table ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->lLCConnection2NameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2Name, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2MaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2ReceivedWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2SendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2BusyStateTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2PBitTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2RejectTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2LocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2RemoteBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2RemoteReset, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2LocalReset, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ProviderReset, &tmpsize);
			tmpsize = StorageTmp->lLCConnection2RouteLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2Route, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2KStep, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2MaxSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedI, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentI, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentAcks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedAcks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedFRMR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentFRMR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedRR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentRR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedRNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentRNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedREJ, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentREJ, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedSABME, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentSABME, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedUA, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentUA, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedDISC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentDISC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedDM, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentDM, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDUsDiscarded1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDUsDiscarded2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDURetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2OptionalTolerationIPDUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2DuplicateIPDUsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2Violation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2ProtocolState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2AdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2OperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2UsageState, &tmpsize);
			tmpsize = StorageTmp->lLCConnection2ProceduralStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCConnection2ProceduralStatus, &tmpsize);
			tmpsize = StorageTmp->lLCConnection2AlarmStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCConnection2AlarmStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnection2IVMOTable_add(): adds a structure node to our data set
 */
int
lLCConnection2IVMOTable_add(struct lLCConnection2IVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&lLCConnection2IVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnection2IVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnection2IVMOTable_del(): delete a structure
 */
int
lLCConnection2IVMOTable_del(struct lLCConnection2IVMOTable_data **thedata)
{
	struct lLCConnection2IVMOTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2IVMOName);
		StorageDel->lLCConnection2IVMONameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnection2IVMOTable(): parse configuration file for lLCConnection2IVMOTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnection2IVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnection2IVMOTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnection2IVMOTable_data);

	DEBUGMSGTL(("lLCConnection2IVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &tmpsize);
	StorageTmp->connectionIdLen = tmpsize;
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2IVMOName, &tmpsize);
	StorageTmp->lLCConnection2IVMONameLen = tmpsize;
	if (StorageTmp->lLCConnection2IVMOName == NULL) {
		config_perror("invalid specification for lLCConnection2IVMOName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMORejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMORoute, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOKStep, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOMaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs, &tmpsize);
	lLCConnection2IVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
}

/*
 * store_lLCConnection2IVMOTable(): store configuraiton file for lLCConnection2IVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnection2IVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnection2IVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "storing data...  "));
	refresh_lLCConnection2IVMOTable();
	(void) tmpsize;
	for (hcindex = lLCConnection2IVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnection2IVMOTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnection2IVMOTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnection2IVMOTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->connectionIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &tmpsize);
			tmpsize = StorageTmp->lLCConnection2IVMONameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2IVMOName, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOReceivedWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOBitTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMORejectTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMORoute, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOKStep, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOMaxSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionlessAckTable_add(): adds a structure node to our data set
 */
int
lLCConnectionlessAckTable_add(struct lLCConnectionlessAckTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* lLCConnectionlessAckName */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCConnectionlessAckName, thedata->lLCConnectionlessAckNameLen);
	header_complex_add_data(&lLCConnectionlessAckTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnectionlessAckTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionlessAckTable_del(): delete a structure
 */
int
lLCConnectionlessAckTable_del(struct lLCConnectionlessAckTable_data **thedata)
{
	struct lLCConnectionlessAckTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnectionlessAckName);
		StorageDel->lLCConnectionlessAckNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnectionlessAckTable(): parse configuration file for lLCConnectionlessAckTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnectionlessAckTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionlessAckTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnectionlessAckTable_data);

	DEBUGMSGTL(("lLCConnectionlessAckTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessAckName, &tmpsize);
	StorageTmp->lLCConnectionlessAckNameLen = tmpsize;
	if (StorageTmp->lLCConnectionlessAckName == NULL) {
		config_perror("invalid specification for lLCConnectionlessAckName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentResponse, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckReceiveResources, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckUIReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckUISent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDSentResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckNoResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandIP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandIT, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandOK, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandPE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandRS, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandUE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandUN, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckReceivedACCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckSentACCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseIP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseIT, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseNE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseOK, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseRS, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseUE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseUN, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckViolation, &tmpsize);
	lLCConnectionlessAckTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
}

/*
 * store_lLCConnectionlessAckTable(): store configuraiton file for lLCConnectionlessAckTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionlessAckTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionlessAckTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "storing data...  "));
	refresh_lLCConnectionlessAckTable();
	(void) tmpsize;
	for (hcindex = lLCConnectionlessAckTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionlessAckTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnectionlessAckTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionlessAckTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->lLCConnectionlessAckNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessAckName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckReceiveResources, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckUIReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckUISent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckNoResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandIP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandIT, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandOK, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandPE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandRS, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandUE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandUN, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckReceivedACCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckSentACCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseIP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseIT, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseNE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseOK, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseRS, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseUE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseUN, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckViolation, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionlessAckIVMOTable_add(): adds a structure node to our data set
 */
int
lLCConnectionlessAckIVMOTable_add(struct lLCConnectionlessAckIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* lLCConnectionlessAckIVMOName */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCConnectionlessAckIVMOName, thedata->lLCConnectionlessAckIVMONameLen);
	header_complex_add_data(&lLCConnectionlessAckIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionlessAckIVMOTable_del(): delete a structure
 */
int
lLCConnectionlessAckIVMOTable_del(struct lLCConnectionlessAckIVMOTable_data **thedata)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnectionlessAckIVMOName);
		StorageDel->lLCConnectionlessAckIVMONameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnectionlessAckIVMOTable(): parse configuration file for lLCConnectionlessAckIVMOTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnectionlessAckIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnectionlessAckIVMOTable_data);

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessAckIVMOName, &tmpsize);
	StorageTmp->lLCConnectionlessAckIVMONameLen = tmpsize;
	if (StorageTmp->lLCConnectionlessAckIVMOName == NULL) {
		config_perror("invalid specification for lLCConnectionlessAckIVMOName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMORowStatus, &tmpsize);
	lLCConnectionlessAckIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
}

/*
 * store_lLCConnectionlessAckIVMOTable(): store configuraiton file for lLCConnectionlessAckIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionlessAckIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "storing data...  "));
	refresh_lLCConnectionlessAckIVMOTable();
	(void) tmpsize;
	for (hcindex = lLCConnectionlessAckIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionlessAckIVMOTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnectionlessAckIVMOTableStorageType == ST_NONVOLATILE) 
		 */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionlessAckIVMOTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->lLCConnectionlessAckIVMONameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessAckIVMOName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * networkEntityTable_add(): adds a structure node to our data set
 */
int
networkEntityTable_add(struct networkEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("networkEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	header_complex_add_data(&networkEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("networkEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * networkEntityTable_del(): delete a structure
 */
int
networkEntityTable_del(struct networkEntityTable_data **thedata)
{
	struct networkEntityTable_data *StorageDel;

	DEBUGMSGTL(("networkEntityTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->networkEntityTitles);
		StorageDel->networkEntityTitlesLen = 0;
		SNMP_FREE(StorageDel->networkEntitySystemTypes);
		StorageDel->networkEntitySystemTypesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_networkEntityTable(): parse configuration file for networkEntityTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_networkEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct networkEntityTable_data *StorageTmp = SNMP_MALLOC_STRUCT(networkEntityTable_data);

	DEBUGMSGTL(("networkEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkEntityTitles, &tmpsize);
	StorageTmp->networkEntityTitlesLen = tmpsize;
	if (StorageTmp->networkEntityTitles == NULL) {
		config_perror("invalid specification for networkEntityTitles");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->networkEntitySystemTypes, &tmpsize);
	StorageTmp->networkEntitySystemTypesLen = tmpsize;
	if (StorageTmp->networkEntitySystemTypes == NULL) {
		config_perror("invalid specification for networkEntitySystemTypes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->networkEntityRowStatus, &tmpsize);
	networkEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
}

/*
 * store_networkEntityTable(): store configuraiton file for networkEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_networkEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct networkEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("networkEntityTable", "storing data...  "));
	refresh_networkEntityTable();
	(void) tmpsize;
	for (hcindex = networkEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct networkEntityTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->networkEntityTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "networkEntityTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->networkEntityTitlesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkEntityTitles, &tmpsize);
			tmpsize = StorageTmp->networkEntitySystemTypesLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->networkEntitySystemTypes, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->networkEntityRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("networkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * nSAPTable_add(): adds a structure node to our data set
 */
int
nSAPTable_add(struct nSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("nSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
	header_complex_add_data(&nSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("nSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("nSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * nSAPTable_del(): delete a structure
 */
int
nSAPTable_del(struct nSAPTable_data **thedata)
{
	struct nSAPTable_data *StorageDel;

	DEBUGMSGTL(("nSAPTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("nSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_nSAPTable(): parse configuration file for nSAPTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_nSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct nSAPTable_data *StorageTmp = SNMP_MALLOC_STRUCT(nSAPTable_data);

	DEBUGMSGTL(("nSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &tmpsize);
	StorageTmp->sapIdLen = tmpsize;
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->nSAPRowStatus, &tmpsize);
	nSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("nSAPTable", "done.\n"));
}

/*
 * store_nSAPTable(): store configuraiton file for nSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_nSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct nSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("nSAPTable", "storing data...  "));
	refresh_nSAPTable();
	(void) tmpsize;
	for (hcindex = nSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct nSAPTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->nSAPTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "nSAPTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->sapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->nSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("nSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * cLNSTable_add(): adds a structure node to our data set
 */
int
cLNSTable_add(struct cLNSTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("cLNSTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&cLNSTableStorage, vars, thedata);
	DEBUGMSGTL(("cLNSTable", "registered an entry\n"));
	DEBUGMSGTL(("cLNSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * cLNSTable_del(): delete a structure
 */
int
cLNSTable_del(struct cLNSTable_data **thedata)
{
	struct cLNSTable_data *StorageDel;

	DEBUGMSGTL(("cLNSTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cLNSSupportedProtocols);
		StorageDel->cLNSSupportedProtocolsLen = 0;
		SNMP_FREE(StorageDel->cLNSOperationalSystemType);
		StorageDel->cLNSOperationalSystemTypeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("cLNSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_cLNSTable(): parse configuration file for cLNSTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_cLNSTable(const char *token, char *line)
{
	size_t tmpsize;
	struct cLNSTable_data *StorageTmp = SNMP_MALLOC_STRUCT(cLNSTable_data);

	DEBUGMSGTL(("cLNSTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSSupportedProtocols, &tmpsize);
	StorageTmp->cLNSSupportedProtocolsLen = tmpsize;
	if (StorageTmp->cLNSSupportedProtocols == NULL) {
		config_perror("invalid specification for cLNSSupportedProtocols");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->cLNSOperationalSystemType, &tmpsize);
	StorageTmp->cLNSOperationalSystemTypeLen = tmpsize;
	if (StorageTmp->cLNSOperationalSystemType == NULL) {
		config_perror("invalid specification for cLNSOperationalSystemType");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSOctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSOctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSSegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSSegmentsDiscarded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSAssemblingSegmentsDiscarded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSErrorReportsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSpDUDiscards, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSCongestionDiscards, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSMaximumLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSEnableChecksum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSRowStatus, &tmpsize);
	cLNSTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("cLNSTable", "done.\n"));
}

/*
 * store_cLNSTable(): store configuraiton file for cLNSTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_cLNSTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cLNSTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("cLNSTable", "storing data...  "));
	refresh_cLNSTable();
	(void) tmpsize;
	for (hcindex = cLNSTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cLNSTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->cLNSTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cLNSTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSAdministrativeState, &tmpsize);
			tmpsize = StorageTmp->cLNSSupportedProtocolsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSSupportedProtocols, &tmpsize);
			tmpsize = StorageTmp->cLNSOperationalSystemTypeLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->cLNSOperationalSystemType, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSOctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSOctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSSegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSSegmentsDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSAssemblingSegmentsDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSErrorReportsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSpDUDiscards, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSCongestionDiscards, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSMaximumLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSEnableChecksum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("cLNSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * cLNSISISTable_add(): adds a structure node to our data set
 */
int
cLNSISISTable_add(struct cLNSISISTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("cLNSISISTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	header_complex_add_data(&cLNSISISTableStorage, vars, thedata);
	DEBUGMSGTL(("cLNSISISTable", "registered an entry\n"));
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * cLNSISISTable_del(): delete a structure
 */
int
cLNSISISTable_del(struct cLNSISISTable_data **thedata)
{
	struct cLNSISISTable_data *StorageDel;

	DEBUGMSGTL(("cLNSISISTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cLNSISISversion);
		StorageDel->cLNSISISversionLen = 0;
		SNMP_FREE(StorageDel->cLNSISISsystemId);
		StorageDel->cLNSISISsystemIdLen = 0;
		SNMP_FREE(StorageDel->cLNSISISmanualAreaAddresses);
		StorageDel->cLNSISISmanualAreaAddressesLen = 0;
		SNMP_FREE(StorageDel->cLNSISISareaAddresses);
		StorageDel->cLNSISISareaAddressesLen = 0;
		SNMP_FREE(StorageDel->cLNSISISareaTransmitPassword);
		StorageDel->cLNSISISareaTransmitPasswordLen = 0;
		SNMP_FREE(StorageDel->cLNSISISareaReceivePasswords);
		StorageDel->cLNSISISareaReceivePasswordsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_cLNSISISTable(): parse configuration file for cLNSISISTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_cLNSISISTable(const char *token, char *line)
{
	size_t tmpsize;
	struct cLNSISISTable_data *StorageTmp = SNMP_MALLOC_STRUCT(cLNSISISTable_data);

	DEBUGMSGTL(("cLNSISISTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISversion, &tmpsize);
	StorageTmp->cLNSISISversionLen = tmpsize;
	if (StorageTmp->cLNSISISversion == NULL) {
		config_perror("invalid specification for cLNSISISversion");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISiSType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISsystemId, &tmpsize);
	StorageTmp->cLNSISISsystemIdLen = tmpsize;
	if (StorageTmp->cLNSISISsystemId == NULL) {
		config_perror("invalid specification for cLNSISISsystemId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISmaximumPathSplits, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISminimumLSPTransmissionInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISmaximumLSPGenerationInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISIScompleteSNPInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISoriginatingL1LSPBufferSize, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISmanualAreaAddresses, &tmpsize);
	StorageTmp->cLNSISISmanualAreaAddressesLen = tmpsize;
	if (StorageTmp->cLNSISISmanualAreaAddresses == NULL) {
		config_perror("invalid specification for cLNSISISmanualAreaAddresses");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISmaximumAreaAddresses, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISminimumLSPGenerationInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISpollESHelloRate, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISpartialSNPInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISwaitingTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISdRISISHelloTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISl1State, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISareaAddresses, &tmpsize);
	StorageTmp->cLNSISISareaAddressesLen = tmpsize;
	if (StorageTmp->cLNSISISareaAddresses == NULL) {
		config_perror("invalid specification for cLNSISISareaAddresses");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISIScorruptedLSPsDetected, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISlSPL1DatabaseOverloads, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISmanualAddressesDroppedFromAreas, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISsequenceNumberSkips, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISownLSPPurges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISiDFieldLengthMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISmaximumAreaAddressesMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISlSPTooLargeToPropagate, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISareaTransmitPassword, &tmpsize);
	StorageTmp->cLNSISISareaTransmitPasswordLen = tmpsize;
	if (StorageTmp->cLNSISISareaTransmitPassword == NULL) {
		config_perror("invalid specification for cLNSISISareaTransmitPassword");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISareaReceivePasswords, &tmpsize);
	StorageTmp->cLNSISISareaReceivePasswordsLen = tmpsize;
	if (StorageTmp->cLNSISISareaReceivePasswords == NULL) {
		config_perror("invalid specification for cLNSISISareaReceivePasswords");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISauthenticationFailures, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISRowStatus, &tmpsize);
	cLNSISISTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
}

/*
 * store_cLNSISISTable(): store configuraiton file for cLNSISISTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_cLNSISISTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cLNSISISTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("cLNSISISTable", "storing data...  "));
	refresh_cLNSISISTable();
	(void) tmpsize;
	for (hcindex = cLNSISISTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cLNSISISTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->cLNSISISTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cLNSISISTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->cLNSISISversionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISversion, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISiSType, &tmpsize);
			tmpsize = StorageTmp->cLNSISISsystemIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISsystemId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISmaximumPathSplits, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISminimumLSPTransmissionInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISmaximumLSPGenerationInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISIScompleteSNPInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISoriginatingL1LSPBufferSize, &tmpsize);
			tmpsize = StorageTmp->cLNSISISmanualAreaAddressesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISmanualAreaAddresses, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISmaximumAreaAddresses, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISminimumLSPGenerationInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISpollESHelloRate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISpartialSNPInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISwaitingTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISdRISISHelloTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISl1State, &tmpsize);
			tmpsize = StorageTmp->cLNSISISareaAddressesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISareaAddresses, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISIScorruptedLSPsDetected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISlSPL1DatabaseOverloads, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISmanualAddressesDroppedFromAreas, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISsequenceNumberSkips, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISownLSPPurges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISiDFieldLengthMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISmaximumAreaAddressesMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISlSPTooLargeToPropagate, &tmpsize);
			tmpsize = StorageTmp->cLNSISISareaTransmitPasswordLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISareaTransmitPassword, &tmpsize);
			tmpsize = StorageTmp->cLNSISISareaReceivePasswordsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISareaReceivePasswords, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISauthenticationFailures, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("cLNSISISTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * cLNSISISLevel2Table_add(): adds a structure node to our data set
 */
int
cLNSISISLevel2Table_add(struct cLNSISISLevel2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("cLNSISISLevel2Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&cLNSISISLevel2TableStorage, vars, thedata);
	DEBUGMSGTL(("cLNSISISLevel2Table", "registered an entry\n"));
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * cLNSISISLevel2Table_del(): delete a structure
 */
int
cLNSISISLevel2Table_del(struct cLNSISISLevel2Table_data **thedata)
{
	struct cLNSISISLevel2Table_data *StorageDel;

	DEBUGMSGTL(("cLNSISISLevel2Table", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2partitionAreaAddresses);
		StorageDel->cLNSISISLevel2partitionAreaAddressesLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2partitionDesignatedL2IntermediateSystem);
		StorageDel->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2domainTransmitPassword);
		StorageDel->cLNSISISLevel2domainTransmitPasswordLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2domainReceivePasswords);
		StorageDel->cLNSISISLevel2domainReceivePasswordsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_cLNSISISLevel2Table(): parse configuration file for cLNSISISLevel2Table
 * parses .conf file entries needed to configure the mib.
 */
void
parse_cLNSISISLevel2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct cLNSISISLevel2Table_data *StorageTmp = SNMP_MALLOC_STRUCT(cLNSISISLevel2Table_data);

	DEBUGMSGTL(("cLNSISISLevel2Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2partitionAreaAddresses, &tmpsize);
	StorageTmp->cLNSISISLevel2partitionAreaAddressesLen = tmpsize;
	if (StorageTmp->cLNSISISLevel2partitionAreaAddresses == NULL) {
		config_perror("invalid specification for cLNSISISLevel2partitionAreaAddresses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem, &tmpsize);
	StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen = tmpsize;
	if (StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem == NULL) {
		config_perror("invalid specification for cLNSISISLevel2partitionDesignatedL2IntermediateSystem");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2l2State, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2domainTransmitPassword, &tmpsize);
	StorageTmp->cLNSISISLevel2domainTransmitPasswordLen = tmpsize;
	if (StorageTmp->cLNSISISLevel2domainTransmitPassword == NULL) {
		config_perror("invalid specification for cLNSISISLevel2domainTransmitPassword");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2domainReceivePasswords, &tmpsize);
	StorageTmp->cLNSISISLevel2domainReceivePasswordsLen = tmpsize;
	if (StorageTmp->cLNSISISLevel2domainReceivePasswords == NULL) {
		config_perror("invalid specification for cLNSISISLevel2domainReceivePasswords");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2RowStatus, &tmpsize);
	cLNSISISLevel2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
}

/*
 * store_cLNSISISLevel2Table(): store configuraiton file for cLNSISISLevel2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_cLNSISISLevel2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cLNSISISLevel2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("cLNSISISLevel2Table", "storing data...  "));
	refresh_cLNSISISLevel2Table();
	(void) tmpsize;
	for (hcindex = cLNSISISLevel2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cLNSISISLevel2Table_data *) hcindex->data;
		/* XXX: if (StorageTmp->cLNSISISLevel2TableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cLNSISISLevel2Table ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies, &tmpsize);
			tmpsize = StorageTmp->cLNSISISLevel2partitionAreaAddressesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2partitionAreaAddresses, &tmpsize);
			tmpsize = StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2l2State, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads, &tmpsize);
			tmpsize = StorageTmp->cLNSISISLevel2domainTransmitPasswordLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2domainTransmitPassword, &tmpsize);
			tmpsize = StorageTmp->cLNSISISLevel2domainReceivePasswordsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2domainReceivePasswords, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2RowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("cLNSISISLevel2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * linkageTable_add(): adds a structure node to our data set
 */
int
linkageTable_add(struct linkageTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("linkageTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* protocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->protocolMachineId, thedata->protocolMachineIdLen);
	/* linkageId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->linkageId, thedata->linkageIdLen);
	header_complex_add_data(&linkageTableStorage, vars, thedata);
	DEBUGMSGTL(("linkageTable", "registered an entry\n"));
	DEBUGMSGTL(("linkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * linkageTable_del(): delete a structure
 */
int
linkageTable_del(struct linkageTable_data **thedata)
{
	struct linkageTable_data *StorageDel;

	DEBUGMSGTL(("linkageTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->protocolMachineId);
		StorageDel->protocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->linkageId);
		StorageDel->linkageIdLen = 0;
		SNMP_FREE(StorageDel->linkageSnServiceProvider);
		StorageDel->linkageSnServiceProviderLen = 0;
		SNMP_FREE(StorageDel->linkageSnSAP);
		StorageDel->linkageSnSAPLen = 0;
		SNMP_FREE(StorageDel->linkageOperationalProtocols);
		StorageDel->linkageOperationalProtocolsLen = 0;
		SNMP_FREE(StorageDel->linkageISiSO9542OperationalSubsets);
		StorageDel->linkageISiSO9542OperationalSubsetsLen = 0;
		SNMP_FREE(StorageDel->linkageISHoldingTimerMultiplier);
		StorageDel->linkageISHoldingTimerMultiplierLen = 0;
		SNMP_FREE(StorageDel->linkageISISConfigurationTimer);
		StorageDel->linkageISISConfigurationTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISSuggestedEsConfigurationTimer);
		StorageDel->linkageISSuggestedEsConfigurationTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISRedirectHoldingTime);
		StorageDel->linkageISRedirectHoldingTimeLen = 0;
		SNMP_FREE(StorageDel->linkageESiSO9542OperationalSubsets);
		StorageDel->linkageESiSO9542OperationalSubsetsLen = 0;
		SNMP_FREE(StorageDel->linkageESHoldingTimerMultiplier);
		StorageDel->linkageESHoldingTimerMultiplierLen = 0;
		SNMP_FREE(StorageDel->linkageESManualISSNPAAddress);
		StorageDel->linkageESManualISSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->linkageESDefaultESConfigTimer);
		StorageDel->linkageESDefaultESConfigTimerLen = 0;
		SNMP_FREE(StorageDel->linkageESActiveESConfigTimer);
		StorageDel->linkageESActiveESConfigTimerLen = 0;
		SNMP_FREE(StorageDel->linkageInitialMinimumTimer);
		StorageDel->linkageInitialMinimumTimerLen = 0;
		SNMP_FREE(StorageDel->linkageReserveTimer);
		StorageDel->linkageReserveTimerLen = 0;
		SNMP_FREE(StorageDel->linkageIdleTimer);
		StorageDel->linkageIdleTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISISType);
		StorageDel->linkageISISTypeLen = 0;
		SNMP_FREE(StorageDel->linkageISISiSISHelloTimer);
		StorageDel->linkageISISiSISHelloTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1DefaultMetric);
		StorageDel->linkageISISl1DefaultMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1DelayMetric);
		StorageDel->linkageISISl1DelayMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1ExpenseMetric);
		StorageDel->linkageISISl1ExpenseMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1ErrorMetric);
		StorageDel->linkageISISl1ErrorMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISexternalDomain);
		StorageDel->linkageISISexternalDomainLen = 0;
		SNMP_FREE(StorageDel->linkageISIScircuitTransmitPassword);
		StorageDel->linkageISIScircuitTransmitPasswordLen = 0;
		SNMP_FREE(StorageDel->linkageISIScircuitReceivedPasswords);
		StorageDel->linkageISIScircuitReceivedPasswordsLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1IntermediateSystemPriority);
		StorageDel->linkageISISl1IntermediateSystemPriorityLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1CircuitID);
		StorageDel->linkageISISl1CircuitIDLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1DesignatedIntermediateSystem);
		StorageDel->linkageISISl1DesignatedIntermediateSystemLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentDefaultMetricIncrement);
		StorageDel->linkageISIScallEstablishmentDefaultMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentDelayMetricIncrement);
		StorageDel->linkageISIScallEstablishmentDelayMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentExpenseMetricIncrement);
		StorageDel->linkageISIScallEstablishmentExpenseMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentErrorMetricIncrement);
		StorageDel->linkageISIScallEstablishmentErrorMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISISptPtCircuitID);
		StorageDel->linkageISISptPtCircuitIDLen = 0;
		SNMP_FREE(StorageDel->linkageISISoutgoingCallIVMO);
		StorageDel->linkageISISoutgoingCallIVMOLen = 0;
		SNMP_FREE(StorageDel->linkageISISneighborSNPAAddress);
		StorageDel->linkageISISneighborSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2DefaultMetric);
		StorageDel->linkageISISl2DefaultMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2DelayMetric);
		StorageDel->linkageISISl2DelayMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2ExpenseMetric);
		StorageDel->linkageISISl2ExpenseMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2ErrorMetric);
		StorageDel->linkageISISl2ErrorMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2IntermediateSystemPriority);
		StorageDel->linkageISISl2IntermediateSystemPriorityLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2CircuitID);
		StorageDel->linkageISISl2CircuitIDLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2DesignatedIntermediateSystem);
		StorageDel->linkageISISl2DesignatedIntermediateSystemLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("linkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_linkageTable(): parse configuration file for linkageTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_linkageTable(const char *token, char *line)
{
	size_t tmpsize;
	struct linkageTable_data *StorageTmp = SNMP_MALLOC_STRUCT(linkageTable_data);

	DEBUGMSGTL(("linkageTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->protocolMachineId, &tmpsize);
	StorageTmp->protocolMachineIdLen = tmpsize;
	if (StorageTmp->protocolMachineId == NULL) {
		config_perror("invalid specification for protocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageId, &tmpsize);
	StorageTmp->linkageIdLen = tmpsize;
	if (StorageTmp->linkageId == NULL) {
		config_perror("invalid specification for linkageId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageSnServiceProvider, &tmpsize);
	StorageTmp->linkageSnServiceProviderLen = tmpsize;
	if (StorageTmp->linkageSnServiceProvider == NULL) {
		config_perror("invalid specification for linkageSnServiceProvider");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->linkageSnSAP, &tmpsize);
	StorageTmp->linkageSnSAPLen = tmpsize;
	if (StorageTmp->linkageSnSAP == NULL) {
		config_perror("invalid specification for linkageSnSAP");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageOperationalProtocols, &tmpsize);
	StorageTmp->linkageOperationalProtocolsLen = tmpsize;
	if (StorageTmp->linkageOperationalProtocols == NULL) {
		config_perror("invalid specification for linkageOperationalProtocols");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISiSO9542OperationalSubsets, &tmpsize);
	StorageTmp->linkageISiSO9542OperationalSubsetsLen = tmpsize;
	if (StorageTmp->linkageISiSO9542OperationalSubsets == NULL) {
		config_perror("invalid specification for linkageISiSO9542OperationalSubsets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISHoldingTimerMultiplier, &tmpsize);
	StorageTmp->linkageISHoldingTimerMultiplierLen = tmpsize;
	if (StorageTmp->linkageISHoldingTimerMultiplier == NULL) {
		config_perror("invalid specification for linkageISHoldingTimerMultiplier");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISConfigurationTimer, &tmpsize);
	StorageTmp->linkageISISConfigurationTimerLen = tmpsize;
	if (StorageTmp->linkageISISConfigurationTimer == NULL) {
		config_perror("invalid specification for linkageISISConfigurationTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISSuggestedEsConfigurationTimer, &tmpsize);
	StorageTmp->linkageISSuggestedEsConfigurationTimerLen = tmpsize;
	if (StorageTmp->linkageISSuggestedEsConfigurationTimer == NULL) {
		config_perror("invalid specification for linkageISSuggestedEsConfigurationTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISRedirectHoldingTime, &tmpsize);
	StorageTmp->linkageISRedirectHoldingTimeLen = tmpsize;
	if (StorageTmp->linkageISRedirectHoldingTime == NULL) {
		config_perror("invalid specification for linkageISRedirectHoldingTime");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISESReachabilityChanges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISInvalid9542PDUs, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESiSO9542OperationalSubsets, &tmpsize);
	StorageTmp->linkageESiSO9542OperationalSubsetsLen = tmpsize;
	if (StorageTmp->linkageESiSO9542OperationalSubsets == NULL) {
		config_perror("invalid specification for linkageESiSO9542OperationalSubsets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESHoldingTimerMultiplier, &tmpsize);
	StorageTmp->linkageESHoldingTimerMultiplierLen = tmpsize;
	if (StorageTmp->linkageESHoldingTimerMultiplier == NULL) {
		config_perror("invalid specification for linkageESHoldingTimerMultiplier");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESManualISSNPAAddress, &tmpsize);
	StorageTmp->linkageESManualISSNPAAddressLen = tmpsize;
	if (StorageTmp->linkageESManualISSNPAAddress == NULL) {
		config_perror("invalid specification for linkageESManualISSNPAAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESDefaultESConfigTimer, &tmpsize);
	StorageTmp->linkageESDefaultESConfigTimerLen = tmpsize;
	if (StorageTmp->linkageESDefaultESConfigTimer == NULL) {
		config_perror("invalid specification for linkageESDefaultESConfigTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESActiveESConfigTimer, &tmpsize);
	StorageTmp->linkageESActiveESConfigTimerLen = tmpsize;
	if (StorageTmp->linkageESActiveESConfigTimer == NULL) {
		config_perror("invalid specification for linkageESActiveESConfigTimer");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageESISReachabilityChanges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageESInvalid9542PDUs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageEnableChecksum, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageInitialMinimumTimer, &tmpsize);
	StorageTmp->linkageInitialMinimumTimerLen = tmpsize;
	if (StorageTmp->linkageInitialMinimumTimer == NULL) {
		config_perror("invalid specification for linkageInitialMinimumTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageReserveTimer, &tmpsize);
	StorageTmp->linkageReserveTimerLen = tmpsize;
	if (StorageTmp->linkageReserveTimer == NULL) {
		config_perror("invalid specification for linkageReserveTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageIdleTimer, &tmpsize);
	StorageTmp->linkageIdleTimerLen = tmpsize;
	if (StorageTmp->linkageIdleTimer == NULL) {
		config_perror("invalid specification for linkageIdleTimer");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageSNDCFCallsPlaced, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageSNDCFCallsFailed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageCODLCallsPlaced, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageCODLCallsFailed, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISType, &tmpsize);
	StorageTmp->linkageISISTypeLen = tmpsize;
	if (StorageTmp->linkageISISType == NULL) {
		config_perror("invalid specification for linkageISISType");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISiSISHelloTimer, &tmpsize);
	StorageTmp->linkageISISiSISHelloTimerLen = tmpsize;
	if (StorageTmp->linkageISISiSISHelloTimer == NULL) {
		config_perror("invalid specification for linkageISISiSISHelloTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1DefaultMetric, &tmpsize);
	StorageTmp->linkageISISl1DefaultMetricLen = tmpsize;
	if (StorageTmp->linkageISISl1DefaultMetric == NULL) {
		config_perror("invalid specification for linkageISISl1DefaultMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1DelayMetric, &tmpsize);
	StorageTmp->linkageISISl1DelayMetricLen = tmpsize;
	if (StorageTmp->linkageISISl1DelayMetric == NULL) {
		config_perror("invalid specification for linkageISISl1DelayMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1ExpenseMetric, &tmpsize);
	StorageTmp->linkageISISl1ExpenseMetricLen = tmpsize;
	if (StorageTmp->linkageISISl1ExpenseMetric == NULL) {
		config_perror("invalid specification for linkageISISl1ExpenseMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1ErrorMetric, &tmpsize);
	StorageTmp->linkageISISl1ErrorMetricLen = tmpsize;
	if (StorageTmp->linkageISISl1ErrorMetric == NULL) {
		config_perror("invalid specification for linkageISISl1ErrorMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISexternalDomain, &tmpsize);
	StorageTmp->linkageISISexternalDomainLen = tmpsize;
	if (StorageTmp->linkageISISexternalDomain == NULL) {
		config_perror("invalid specification for linkageISISexternalDomain");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISchangedInAdjacencyState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISinitialisationFailures, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISrejectedAdjacencies, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISiSISControlPDUsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISiSISControlPDUsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISiDFieldLenthMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISmaximumAreaAddressesMismatches, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScircuitTransmitPassword, &tmpsize);
	StorageTmp->linkageISIScircuitTransmitPasswordLen = tmpsize;
	if (StorageTmp->linkageISIScircuitTransmitPassword == NULL) {
		config_perror("invalid specification for linkageISIScircuitTransmitPassword");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScircuitReceivedPasswords, &tmpsize);
	StorageTmp->linkageISIScircuitReceivedPasswordsLen = tmpsize;
	if (StorageTmp->linkageISIScircuitReceivedPasswords == NULL) {
		config_perror("invalid specification for linkageISIScircuitReceivedPasswords");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISauthenticationFailures, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1IntermediateSystemPriority, &tmpsize);
	StorageTmp->linkageISISl1IntermediateSystemPriorityLen = tmpsize;
	if (StorageTmp->linkageISISl1IntermediateSystemPriority == NULL) {
		config_perror("invalid specification for linkageISISl1IntermediateSystemPriority");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1CircuitID, &tmpsize);
	StorageTmp->linkageISISl1CircuitIDLen = tmpsize;
	if (StorageTmp->linkageISISl1CircuitID == NULL) {
		config_perror("invalid specification for linkageISISl1CircuitID");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1DesignatedIntermediateSystem, &tmpsize);
	StorageTmp->linkageISISl1DesignatedIntermediateSystemLen = tmpsize;
	if (StorageTmp->linkageISISl1DesignatedIntermediateSystem == NULL) {
		config_perror("invalid specification for linkageISISl1DesignatedIntermediateSystem");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement, &tmpsize);
	StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrementLen = tmpsize;
	if (StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentDefaultMetricIncrement");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement, &tmpsize);
	StorageTmp->linkageISIScallEstablishmentDelayMetricIncrementLen = tmpsize;
	if (StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentDelayMetricIncrement");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement, &tmpsize);
	StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrementLen = tmpsize;
	if (StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentExpenseMetricIncrement");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement, &tmpsize);
	StorageTmp->linkageISIScallEstablishmentErrorMetricIncrementLen = tmpsize;
	if (StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentErrorMetricIncrement");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISptPtCircuitID, &tmpsize);
	StorageTmp->linkageISISptPtCircuitIDLen = tmpsize;
	if (StorageTmp->linkageISISptPtCircuitID == NULL) {
		config_perror("invalid specification for linkageISISptPtCircuitID");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISoutgoingCallIVMO, &tmpsize);
	StorageTmp->linkageISISoutgoingCallIVMOLen = tmpsize;
	if (StorageTmp->linkageISISoutgoingCallIVMO == NULL) {
		config_perror("invalid specification for linkageISISoutgoingCallIVMO");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISneighborSNPAAddress, &tmpsize);
	StorageTmp->linkageISISneighborSNPAAddressLen = tmpsize;
	if (StorageTmp->linkageISISneighborSNPAAddress == NULL) {
		config_perror("invalid specification for linkageISISneighborSNPAAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2DefaultMetric, &tmpsize);
	StorageTmp->linkageISISl2DefaultMetricLen = tmpsize;
	if (StorageTmp->linkageISISl2DefaultMetric == NULL) {
		config_perror("invalid specification for linkageISISl2DefaultMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2DelayMetric, &tmpsize);
	StorageTmp->linkageISISl2DelayMetricLen = tmpsize;
	if (StorageTmp->linkageISISl2DelayMetric == NULL) {
		config_perror("invalid specification for linkageISISl2DelayMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2ExpenseMetric, &tmpsize);
	StorageTmp->linkageISISl2ExpenseMetricLen = tmpsize;
	if (StorageTmp->linkageISISl2ExpenseMetric == NULL) {
		config_perror("invalid specification for linkageISISl2ExpenseMetric");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2ErrorMetric, &tmpsize);
	StorageTmp->linkageISISl2ErrorMetricLen = tmpsize;
	if (StorageTmp->linkageISISl2ErrorMetric == NULL) {
		config_perror("invalid specification for linkageISISl2ErrorMetric");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageISISmanualL2OnlyMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2IntermediateSystemPriority, &tmpsize);
	StorageTmp->linkageISISl2IntermediateSystemPriorityLen = tmpsize;
	if (StorageTmp->linkageISISl2IntermediateSystemPriority == NULL) {
		config_perror("invalid specification for linkageISISl2IntermediateSystemPriority");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2CircuitID, &tmpsize);
	StorageTmp->linkageISISl2CircuitIDLen = tmpsize;
	if (StorageTmp->linkageISISl2CircuitID == NULL) {
		config_perror("invalid specification for linkageISISl2CircuitID");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2DesignatedIntermediateSystem, &tmpsize);
	StorageTmp->linkageISISl2DesignatedIntermediateSystemLen = tmpsize;
	if (StorageTmp->linkageISISl2DesignatedIntermediateSystem == NULL) {
		config_perror("invalid specification for linkageISISl2DesignatedIntermediateSystem");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageRowStatus, &tmpsize);
	linkageTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("linkageTable", "done.\n"));
}

/*
 * store_linkageTable(): store configuraiton file for linkageTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_linkageTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct linkageTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("linkageTable", "storing data...  "));
	refresh_linkageTable();
	(void) tmpsize;
	for (hcindex = linkageTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct linkageTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->linkageTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "linkageTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->protocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->protocolMachineId, &tmpsize);
			tmpsize = StorageTmp->linkageIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageAdministrativeState, &tmpsize);
			tmpsize = StorageTmp->linkageSnServiceProviderLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageSnServiceProvider, &tmpsize);
			tmpsize = StorageTmp->linkageSnSAPLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->linkageSnSAP, &tmpsize);
			tmpsize = StorageTmp->linkageOperationalProtocolsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageOperationalProtocols, &tmpsize);
			tmpsize = StorageTmp->linkageISiSO9542OperationalSubsetsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISiSO9542OperationalSubsets, &tmpsize);
			tmpsize = StorageTmp->linkageISHoldingTimerMultiplierLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISHoldingTimerMultiplier, &tmpsize);
			tmpsize = StorageTmp->linkageISISConfigurationTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISConfigurationTimer, &tmpsize);
			tmpsize = StorageTmp->linkageISSuggestedEsConfigurationTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISSuggestedEsConfigurationTimer, &tmpsize);
			tmpsize = StorageTmp->linkageISRedirectHoldingTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISRedirectHoldingTime, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISESReachabilityChanges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISInvalid9542PDUs, &tmpsize);
			tmpsize = StorageTmp->linkageESiSO9542OperationalSubsetsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESiSO9542OperationalSubsets, &tmpsize);
			tmpsize = StorageTmp->linkageESHoldingTimerMultiplierLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESHoldingTimerMultiplier, &tmpsize);
			tmpsize = StorageTmp->linkageESManualISSNPAAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESManualISSNPAAddress, &tmpsize);
			tmpsize = StorageTmp->linkageESDefaultESConfigTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESDefaultESConfigTimer, &tmpsize);
			tmpsize = StorageTmp->linkageESActiveESConfigTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESActiveESConfigTimer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageESISReachabilityChanges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageESInvalid9542PDUs, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageEnableChecksum, &tmpsize);
			tmpsize = StorageTmp->linkageInitialMinimumTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageInitialMinimumTimer, &tmpsize);
			tmpsize = StorageTmp->linkageReserveTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageReserveTimer, &tmpsize);
			tmpsize = StorageTmp->linkageIdleTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageIdleTimer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageSNDCFCallsPlaced, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageSNDCFCallsFailed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageCODLCallsPlaced, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageCODLCallsFailed, &tmpsize);
			tmpsize = StorageTmp->linkageISISTypeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISType, &tmpsize);
			tmpsize = StorageTmp->linkageISISiSISHelloTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISiSISHelloTimer, &tmpsize);
			tmpsize = StorageTmp->linkageISISl1DefaultMetricLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1DefaultMetric, &tmpsize);
			tmpsize = StorageTmp->linkageISISl1DelayMetricLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1DelayMetric, &tmpsize);
			tmpsize = StorageTmp->linkageISISl1ExpenseMetricLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1ExpenseMetric, &tmpsize);
			tmpsize = StorageTmp->linkageISISl1ErrorMetricLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1ErrorMetric, &tmpsize);
			tmpsize = StorageTmp->linkageISISexternalDomainLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISexternalDomain, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISchangedInAdjacencyState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISinitialisationFailures, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISrejectedAdjacencies, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISiSISControlPDUsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISiSISControlPDUsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISiDFieldLenthMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISmaximumAreaAddressesMismatches, &tmpsize);
			tmpsize = StorageTmp->linkageISIScircuitTransmitPasswordLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScircuitTransmitPassword, &tmpsize);
			tmpsize = StorageTmp->linkageISIScircuitReceivedPasswordsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScircuitReceivedPasswords, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISauthenticationFailures, &tmpsize);
			tmpsize = StorageTmp->linkageISISl1IntermediateSystemPriorityLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1IntermediateSystemPriority, &tmpsize);
			tmpsize = StorageTmp->linkageISISl1CircuitIDLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1CircuitID, &tmpsize);
			tmpsize = StorageTmp->linkageISISl1DesignatedIntermediateSystemLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1DesignatedIntermediateSystem, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges, &tmpsize);
			tmpsize = StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrementLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement, &tmpsize);
			tmpsize = StorageTmp->linkageISIScallEstablishmentDelayMetricIncrementLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement, &tmpsize);
			tmpsize = StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrementLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement, &tmpsize);
			tmpsize = StorageTmp->linkageISIScallEstablishmentErrorMetricIncrementLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement, &tmpsize);
			tmpsize = StorageTmp->linkageISISptPtCircuitIDLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISptPtCircuitID, &tmpsize);
			tmpsize = StorageTmp->linkageISISoutgoingCallIVMOLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISoutgoingCallIVMO, &tmpsize);
			tmpsize = StorageTmp->linkageISISneighborSNPAAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISneighborSNPAAddress, &tmpsize);
			tmpsize = StorageTmp->linkageISISl2DefaultMetricLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2DefaultMetric, &tmpsize);
			tmpsize = StorageTmp->linkageISISl2DelayMetricLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2DelayMetric, &tmpsize);
			tmpsize = StorageTmp->linkageISISl2ExpenseMetricLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2ExpenseMetric, &tmpsize);
			tmpsize = StorageTmp->linkageISISl2ErrorMetricLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2ErrorMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageISISmanualL2OnlyMode, &tmpsize);
			tmpsize = StorageTmp->linkageISISl2IntermediateSystemPriorityLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2IntermediateSystemPriority, &tmpsize);
			tmpsize = StorageTmp->linkageISISl2CircuitIDLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2CircuitID, &tmpsize);
			tmpsize = StorageTmp->linkageISISl2DesignatedIntermediateSystemLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2DesignatedIntermediateSystem, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("linkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * cONSTable_add(): adds a structure node to our data set
 */
int
cONSTable_add(struct cONSTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("cONSTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	header_complex_add_data(&cONSTableStorage, vars, thedata);
	DEBUGMSGTL(("cONSTable", "registered an entry\n"));
	DEBUGMSGTL(("cONSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * cONSTable_del(): delete a structure
 */
int
cONSTable_del(struct cONSTable_data **thedata)
{
	struct cONSTable_data *StorageDel;

	DEBUGMSGTL(("cONSTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cONSOperationalSystemType);
		StorageDel->cONSOperationalSystemTypeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("cONSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_cONSTable(): parse configuration file for cONSTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_cONSTable(const char *token, char *line)
{
	size_t tmpsize;
	struct cONSTable_data *StorageTmp = SNMP_MALLOC_STRUCT(cONSTable_data);

	DEBUGMSGTL(("cONSTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cONSAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->cONSOperationalSystemType, &tmpsize);
	StorageTmp->cONSOperationalSystemTypeLen = tmpsize;
	if (StorageTmp->cONSOperationalSystemType == NULL) {
		config_perror("invalid specification for cONSOperationalSystemType");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cONSRowStatus, &tmpsize);
	cONSTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("cONSTable", "done.\n"));
}

/*
 * store_cONSTable(): store configuraiton file for cONSTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_cONSTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cONSTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("cONSTable", "storing data...  "));
	refresh_cONSTable();
	(void) tmpsize;
	for (hcindex = cONSTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cONSTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->cONSTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cONSTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cONSAdministrativeState, &tmpsize);
			tmpsize = StorageTmp->cONSOperationalSystemTypeLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->cONSOperationalSystemType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cONSRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("cONSTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * networkConnectionTable_add(): adds a structure node to our data set
 */
int
networkConnectionTable_add(struct networkConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("networkConnectionTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* coProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
	/* connectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
	header_complex_add_data(&networkConnectionTableStorage, vars, thedata);
	DEBUGMSGTL(("networkConnectionTable", "registered an entry\n"));
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * networkConnectionTable_del(): delete a structure
 */
int
networkConnectionTable_del(struct networkConnectionTable_data **thedata)
{
	struct networkConnectionTable_data *StorageDel;

	DEBUGMSGTL(("networkConnectionTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->networkConnectionLocalNSAPMO);
		StorageDel->networkConnectionLocalNSAPMOLen = 0;
		SNMP_FREE(StorageDel->networkConnectionRemoteNSAPAddress);
		StorageDel->networkConnectionRemoteNSAPAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_networkConnectionTable(): parse configuration file for networkConnectionTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_networkConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct networkConnectionTable_data *StorageTmp = SNMP_MALLOC_STRUCT(networkConnectionTable_data);

	DEBUGMSGTL(("networkConnectionTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &tmpsize);
	StorageTmp->coProtocolMachineIdLen = tmpsize;
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &tmpsize);
	StorageTmp->connectionIdLen = tmpsize;
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkConnectionLocalNSAPMO, &tmpsize);
	StorageTmp->networkConnectionLocalNSAPMOLen = tmpsize;
	if (StorageTmp->networkConnectionLocalNSAPMO == NULL) {
		config_perror("invalid specification for networkConnectionLocalNSAPMO");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkConnectionRemoteNSAPAddress, &tmpsize);
	StorageTmp->networkConnectionRemoteNSAPAddressLen = tmpsize;
	if (StorageTmp->networkConnectionRemoteNSAPAddress == NULL) {
		config_perror("invalid specification for networkConnectionRemoteNSAPAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->networkConnectionRowStatus, &tmpsize);
	networkConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
}

/*
 * store_networkConnectionTable(): store configuraiton file for networkConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_networkConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct networkConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("networkConnectionTable", "storing data...  "));
	refresh_networkConnectionTable();
	(void) tmpsize;
	for (hcindex = networkConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct networkConnectionTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->networkConnectionTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "networkConnectionTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->coProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->connectionIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &tmpsize);
			tmpsize = StorageTmp->networkConnectionLocalNSAPMOLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkConnectionLocalNSAPMO, &tmpsize);
			tmpsize = StorageTmp->networkConnectionRemoteNSAPAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkConnectionRemoteNSAPAddress, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->networkConnectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("networkConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLETable_add(): adds a structure node to our data set
 */
int
x25PLETable_add(struct x25PLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLETable_del(): delete a structure
 */
int
x25PLETable_del(struct x25PLETable_data **thedata)
{
	struct x25PLETable_data *StorageDel;

	DEBUGMSGTL(("x25PLETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEprotocolVersionSupported);
		StorageDel->x25PLEprotocolVersionSupportedLen = 0;
		SNMP_FREE(StorageDel->x25PLElocalDTEAddress);
		StorageDel->x25PLElocalDTEAddressLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultThroughputClasses);
		StorageDel->x25PLEdefaultThroughputClassesLen = 0;
		SNMP_FREE(StorageDel->x25PLEflowControlParameterNegotiation);
		StorageDel->x25PLEflowControlParameterNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultPackageSizes);
		StorageDel->x25PLEdefaultPackageSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLEthroughputClassNegotiation);
		StorageDel->x25PLEthroughputClassNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEsNserviceProvider);
		StorageDel->x25PLEsNserviceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLEsNsAP);
		StorageDel->x25PLEsNsAPLen = 0;
		SNMP_FREE(StorageDel->x25PElogicalChannelAssignments);
		StorageDel->x25PElogicalChannelAssignmentsLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultThroughputClass);
		StorageDel->x25PLEdefaultThroughputClassLen = 0;
		SNMP_FREE(StorageDel->x25PLEflowControlNegotiationPermitted);
		StorageDel->x25PLEflowControlNegotiationPermittedLen = 0;
		SNMP_FREE(StorageDel->x25PLEmaxActiveCircuits);
		StorageDel->x25PLEmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLErestartTime);
		StorageDel->x25PLErestartTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultPacketSize);
		StorageDel->x25PLEdefaultPacketSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultWindowSize);
		StorageDel->x25PLEdefaultWindowSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEminimumRecallTimer);
		StorageDel->x25PLEminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLErestartCount);
		StorageDel->x25PLErestartCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEsN - ServiceProvider);
		StorageDel->x25PLEsN - ServiceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLEsN - SA - P);
		StorageDel->x25PLEsN - SA - PLen = 0;
		SNMP_FREE(StorageDel->x25PLElogicalChannelAssignments);
		StorageDel->x25PLElogicalChannelAssignmentsLen = 0;
		SNMP_FREE(StorageDel->x25PLEpacketSequencing);
		StorageDel->x25PLEpacketSequencingLen = 0;
		SNMP_FREE(StorageDel->x25PLEoctetsSentCounter);
		StorageDel->x25PLEoctetsSentCounterLen = 0;
		SNMP_FREE(StorageDel->x25PLEoctetsReceivedCounter);
		StorageDel->x25PLEoctetsReceivedCounterLen = 0;
		SNMP_FREE(StorageDel->x25PLEdataPacketsSent);
		StorageDel->x25PLEdataPacketsSentLen = 0;
		SNMP_FREE(StorageDel->x25PLEdataPacketsReceived);
		StorageDel->x25PLEdataPacketsReceivedLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallAttempts);
		StorageDel->x25PLEcallAttemptsLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallsConnected);
		StorageDel->x25PLEcallsConnectedLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallTimeouts);
		StorageDel->x25PLEcallTimeoutsLen = 0;
		SNMP_FREE(StorageDel->x25PLEclearTimeouts);
		StorageDel->x25PLEclearTimeoutsLen = 0;
		SNMP_FREE(StorageDel->x25PLEremotelyInitiatedResets);
		StorageDel->x25PLEremotelyInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->x25PLEdataRetransmissionTimerExpiries);
		StorageDel->x25PLEdataRetransmissionTimerExpiriesLen = 0;
		SNMP_FREE(StorageDel->x25PLEproviderInitiatedResets);
		StorageDel->x25PLEproviderInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->x25PLEresetTimeouts);
		StorageDel->x25PLEresetTimeoutsLen = 0;
		SNMP_FREE(StorageDel->x25PLEremotelyInitiatedRestarts);
		StorageDel->x25PLEremotelyInitiatedRestartsLen = 0;
		SNMP_FREE(StorageDel->x25PLErestartCountsExceeded);
		StorageDel->x25PLErestartCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEprotocolErrorsDetectedLocally);
		StorageDel->x25PLEprotocolErrorsDetectedLocallyLen = 0;
		SNMP_FREE(StorageDel->x25PLEprotocolErrorsAccusedOf);
		StorageDel->x25PLEprotocolErrorsAccusedOfLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallEstablishmentRetryCountsExceeded);
		StorageDel->x25PLEcallEstablishmentRetryCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEclearCountsExceeded);
		StorageDel->x25PLEclearCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEpLEClientMOName);
		StorageDel->x25PLEpLEClientMONameLen = 0;
		SNMP_FREE(StorageDel->x25PLEregistrationRequestTime);
		StorageDel->x25PLEregistrationRequestTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEregistrationRequestCount);
		StorageDel->x25PLEregistrationRequestCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLETable(): parse configuration file for x25PLETable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLETable_data);

	DEBUGMSGTL(("x25PLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEoperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEadministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEprotocolVersionSupported, &tmpsize);
	StorageTmp->x25PLEprotocolVersionSupportedLen = tmpsize;
	if (StorageTmp->x25PLEprotocolVersionSupported == NULL) {
		config_perror("invalid specification for x25PLEprotocolVersionSupported");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLElocalDTEAddress, &tmpsize);
	StorageTmp->x25PLElocalDTEAddressLen = tmpsize;
	if (StorageTmp->x25PLElocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLElocalDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultThroughputClasses, &tmpsize);
	StorageTmp->x25PLEdefaultThroughputClassesLen = tmpsize;
	if (StorageTmp->x25PLEdefaultThroughputClasses == NULL) {
		config_perror("invalid specification for x25PLEdefaultThroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEflowControlParameterNegotiation, &tmpsize);
	StorageTmp->x25PLEflowControlParameterNegotiationLen = tmpsize;
	if (StorageTmp->x25PLEflowControlParameterNegotiation == NULL) {
		config_perror("invalid specification for x25PLEflowControlParameterNegotiation");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultPackageSizes, &tmpsize);
	StorageTmp->x25PLEdefaultPackageSizesLen = tmpsize;
	if (StorageTmp->x25PLEdefaultPackageSizes == NULL) {
		config_perror("invalid specification for x25PLEdefaultPackageSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEthroughputClassNegotiation, &tmpsize);
	StorageTmp->x25PLEthroughputClassNegotiationLen = tmpsize;
	if (StorageTmp->x25PLEthroughputClassNegotiation == NULL) {
		config_perror("invalid specification for x25PLEthroughputClassNegotiation");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsNserviceProvider, &tmpsize);
	StorageTmp->x25PLEsNserviceProviderLen = tmpsize;
	if (StorageTmp->x25PLEsNserviceProvider == NULL) {
		config_perror("invalid specification for x25PLEsNserviceProvider");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsNsAP, &tmpsize);
	StorageTmp->x25PLEsNsAPLen = tmpsize;
	if (StorageTmp->x25PLEsNsAP == NULL) {
		config_perror("invalid specification for x25PLEsNsAP");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PElogicalChannelAssignments, &tmpsize);
	StorageTmp->x25PElogicalChannelAssignmentsLen = tmpsize;
	if (StorageTmp->x25PElogicalChannelAssignments == NULL) {
		config_perror("invalid specification for x25PElogicalChannelAssignments");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEinterfaceMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultThroughputClass, &tmpsize);
	StorageTmp->x25PLEdefaultThroughputClassLen = tmpsize;
	if (StorageTmp->x25PLEdefaultThroughputClass == NULL) {
		config_perror("invalid specification for x25PLEdefaultThroughputClass");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEflowControlNegotiationPermitted, &tmpsize);
	StorageTmp->x25PLEflowControlNegotiationPermittedLen = tmpsize;
	if (StorageTmp->x25PLEflowControlNegotiationPermitted == NULL) {
		config_perror("invalid specification for x25PLEflowControlNegotiationPermitted");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEmaxActiveCircuits, &tmpsize);
	StorageTmp->x25PLEmaxActiveCircuitsLen = tmpsize;
	if (StorageTmp->x25PLEmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLEmaxActiveCircuits");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLErestartTime, &tmpsize);
	StorageTmp->x25PLErestartTimeLen = tmpsize;
	if (StorageTmp->x25PLErestartTime == NULL) {
		config_perror("invalid specification for x25PLErestartTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultPacketSize, &tmpsize);
	StorageTmp->x25PLEdefaultPacketSizeLen = tmpsize;
	if (StorageTmp->x25PLEdefaultPacketSize == NULL) {
		config_perror("invalid specification for x25PLEdefaultPacketSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultWindowSize, &tmpsize);
	StorageTmp->x25PLEdefaultWindowSizeLen = tmpsize;
	if (StorageTmp->x25PLEdefaultWindowSize == NULL) {
		config_perror("invalid specification for x25PLEdefaultWindowSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEminimumRecallTimer, &tmpsize);
	StorageTmp->x25PLEminimumRecallTimerLen = tmpsize;
	if (StorageTmp->x25PLEminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLEminimumRecallTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLErestartCount, &tmpsize);
	StorageTmp->x25PLErestartCountLen = tmpsize;
	if (StorageTmp->x25PLErestartCount == NULL) {
		config_perror("invalid specification for x25PLErestartCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsN - ServiceProvider, &tmpsize);
	StorageTmp->x25PLEsN - ServiceProviderLen = tmpsize;
	if (StorageTmp->x25PLEsN - ServiceProvider == NULL) {
		config_perror("invalid specification for x25PLEsN-ServiceProvider");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsN - SA - P, &tmpsize);
	StorageTmp->x25PLEsN - SA - PLen = tmpsize;
	if (StorageTmp->x25PLEsN - SA - P == NULL) {
		config_perror("invalid specification for x25PLEsN-SA-P");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLElogicalChannelAssignments, &tmpsize);
	StorageTmp->x25PLElogicalChannelAssignmentsLen = tmpsize;
	if (StorageTmp->x25PLElogicalChannelAssignments == NULL) {
		config_perror("invalid specification for x25PLElogicalChannelAssignments");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEpacketSequencing, &tmpsize);
	StorageTmp->x25PLEpacketSequencingLen = tmpsize;
	if (StorageTmp->x25PLEpacketSequencing == NULL) {
		config_perror("invalid specification for x25PLEpacketSequencing");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEoctetsSentCounter, &tmpsize);
	StorageTmp->x25PLEoctetsSentCounterLen = tmpsize;
	if (StorageTmp->x25PLEoctetsSentCounter == NULL) {
		config_perror("invalid specification for x25PLEoctetsSentCounter");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEoctetsReceivedCounter, &tmpsize);
	StorageTmp->x25PLEoctetsReceivedCounterLen = tmpsize;
	if (StorageTmp->x25PLEoctetsReceivedCounter == NULL) {
		config_perror("invalid specification for x25PLEoctetsReceivedCounter");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdataPacketsSent, &tmpsize);
	StorageTmp->x25PLEdataPacketsSentLen = tmpsize;
	if (StorageTmp->x25PLEdataPacketsSent == NULL) {
		config_perror("invalid specification for x25PLEdataPacketsSent");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdataPacketsReceived, &tmpsize);
	StorageTmp->x25PLEdataPacketsReceivedLen = tmpsize;
	if (StorageTmp->x25PLEdataPacketsReceived == NULL) {
		config_perror("invalid specification for x25PLEdataPacketsReceived");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallAttempts, &tmpsize);
	StorageTmp->x25PLEcallAttemptsLen = tmpsize;
	if (StorageTmp->x25PLEcallAttempts == NULL) {
		config_perror("invalid specification for x25PLEcallAttempts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallsConnected, &tmpsize);
	StorageTmp->x25PLEcallsConnectedLen = tmpsize;
	if (StorageTmp->x25PLEcallsConnected == NULL) {
		config_perror("invalid specification for x25PLEcallsConnected");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallTimeouts, &tmpsize);
	StorageTmp->x25PLEcallTimeoutsLen = tmpsize;
	if (StorageTmp->x25PLEcallTimeouts == NULL) {
		config_perror("invalid specification for x25PLEcallTimeouts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEclearTimeouts, &tmpsize);
	StorageTmp->x25PLEclearTimeoutsLen = tmpsize;
	if (StorageTmp->x25PLEclearTimeouts == NULL) {
		config_perror("invalid specification for x25PLEclearTimeouts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEremotelyInitiatedResets, &tmpsize);
	StorageTmp->x25PLEremotelyInitiatedResetsLen = tmpsize;
	if (StorageTmp->x25PLEremotelyInitiatedResets == NULL) {
		config_perror("invalid specification for x25PLEremotelyInitiatedResets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdataRetransmissionTimerExpiries, &tmpsize);
	StorageTmp->x25PLEdataRetransmissionTimerExpiriesLen = tmpsize;
	if (StorageTmp->x25PLEdataRetransmissionTimerExpiries == NULL) {
		config_perror("invalid specification for x25PLEdataRetransmissionTimerExpiries");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEproviderInitiatedResets, &tmpsize);
	StorageTmp->x25PLEproviderInitiatedResetsLen = tmpsize;
	if (StorageTmp->x25PLEproviderInitiatedResets == NULL) {
		config_perror("invalid specification for x25PLEproviderInitiatedResets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEresetTimeouts, &tmpsize);
	StorageTmp->x25PLEresetTimeoutsLen = tmpsize;
	if (StorageTmp->x25PLEresetTimeouts == NULL) {
		config_perror("invalid specification for x25PLEresetTimeouts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEremotelyInitiatedRestarts, &tmpsize);
	StorageTmp->x25PLEremotelyInitiatedRestartsLen = tmpsize;
	if (StorageTmp->x25PLEremotelyInitiatedRestarts == NULL) {
		config_perror("invalid specification for x25PLEremotelyInitiatedRestarts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLErestartCountsExceeded, &tmpsize);
	StorageTmp->x25PLErestartCountsExceededLen = tmpsize;
	if (StorageTmp->x25PLErestartCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLErestartCountsExceeded");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEprotocolErrorsDetectedLocally, &tmpsize);
	StorageTmp->x25PLEprotocolErrorsDetectedLocallyLen = tmpsize;
	if (StorageTmp->x25PLEprotocolErrorsDetectedLocally == NULL) {
		config_perror("invalid specification for x25PLEprotocolErrorsDetectedLocally");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEprotocolErrorsAccusedOf, &tmpsize);
	StorageTmp->x25PLEprotocolErrorsAccusedOfLen = tmpsize;
	if (StorageTmp->x25PLEprotocolErrorsAccusedOf == NULL) {
		config_perror("invalid specification for x25PLEprotocolErrorsAccusedOf");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded, &tmpsize);
	StorageTmp->x25PLEcallEstablishmentRetryCountsExceededLen = tmpsize;
	if (StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLEcallEstablishmentRetryCountsExceeded");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEclearCountsExceeded, &tmpsize);
	StorageTmp->x25PLEclearCountsExceededLen = tmpsize;
	if (StorageTmp->x25PLEclearCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLEclearCountsExceeded");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEpLEClientMOName, &tmpsize);
	StorageTmp->x25PLEpLEClientMONameLen = tmpsize;
	if (StorageTmp->x25PLEpLEClientMOName == NULL) {
		config_perror("invalid specification for x25PLEpLEClientMOName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEregistrationRequestTime, &tmpsize);
	StorageTmp->x25PLEregistrationRequestTimeLen = tmpsize;
	if (StorageTmp->x25PLEregistrationRequestTime == NULL) {
		config_perror("invalid specification for x25PLEregistrationRequestTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEregistrationRequestCount, &tmpsize);
	StorageTmp->x25PLEregistrationRequestCountLen = tmpsize;
	if (StorageTmp->x25PLEregistrationRequestCount == NULL) {
		config_perror("invalid specification for x25PLEregistrationRequestCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEregistrationPermitted, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLERowStatus, &tmpsize);
	x25PLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLETable", "done.\n"));
}

/*
 * store_x25PLETable(): store configuraiton file for x25PLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLETable", "storing data...  "));
	refresh_x25PLETable();
	(void) tmpsize;
	for (hcindex = x25PLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->x25PLETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEoperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEadministrativeState, &tmpsize);
			tmpsize = StorageTmp->x25PLEprotocolVersionSupportedLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEprotocolVersionSupported, &tmpsize);
			tmpsize = StorageTmp->x25PLElocalDTEAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLElocalDTEAddress, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEMode, &tmpsize);
			tmpsize = StorageTmp->x25PLEdefaultThroughputClassesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultThroughputClasses, &tmpsize);
			tmpsize = StorageTmp->x25PLEflowControlParameterNegotiationLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEflowControlParameterNegotiation, &tmpsize);
			tmpsize = StorageTmp->x25PLEdefaultPackageSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultPackageSizes, &tmpsize);
			tmpsize = StorageTmp->x25PLEthroughputClassNegotiationLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEthroughputClassNegotiation, &tmpsize);
			tmpsize = StorageTmp->x25PLEsNserviceProviderLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsNserviceProvider, &tmpsize);
			tmpsize = StorageTmp->x25PLEsNsAPLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsNsAP, &tmpsize);
			tmpsize = StorageTmp->x25PElogicalChannelAssignmentsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PElogicalChannelAssignments, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEinterfaceMode, &tmpsize);
			tmpsize = StorageTmp->x25PLEdefaultThroughputClassLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultThroughputClass, &tmpsize);
			tmpsize = StorageTmp->x25PLEflowControlNegotiationPermittedLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEflowControlNegotiationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEcallDeflectionSubscription, &tmpsize);
			tmpsize = StorageTmp->x25PLEmaxActiveCircuitsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEmaxActiveCircuits, &tmpsize);
			tmpsize = StorageTmp->x25PLErestartTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLErestartTime, &tmpsize);
			tmpsize = StorageTmp->x25PLEdefaultPacketSizeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultPacketSize, &tmpsize);
			tmpsize = StorageTmp->x25PLEdefaultWindowSizeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultWindowSize, &tmpsize);
			tmpsize = StorageTmp->x25PLEminimumRecallTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEminimumRecallTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLErestartCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLErestartCount, &tmpsize);
			tmpsize = StorageTmp->x25PLEsN - ServiceProviderLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsN - ServiceProvider, &tmpsize);
			tmpsize = StorageTmp->x25PLEsN - SA - PLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsN - SA - P, &tmpsize);
			tmpsize = StorageTmp->x25PLElogicalChannelAssignmentsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLElogicalChannelAssignments, &tmpsize);
			tmpsize = StorageTmp->x25PLEpacketSequencingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEpacketSequencing, &tmpsize);
			tmpsize = StorageTmp->x25PLEoctetsSentCounterLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEoctetsSentCounter, &tmpsize);
			tmpsize = StorageTmp->x25PLEoctetsReceivedCounterLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEoctetsReceivedCounter, &tmpsize);
			tmpsize = StorageTmp->x25PLEdataPacketsSentLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdataPacketsSent, &tmpsize);
			tmpsize = StorageTmp->x25PLEdataPacketsReceivedLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdataPacketsReceived, &tmpsize);
			tmpsize = StorageTmp->x25PLEcallAttemptsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallAttempts, &tmpsize);
			tmpsize = StorageTmp->x25PLEcallsConnectedLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEproviderInitiatedDisconnects, &tmpsize);
			tmpsize = StorageTmp->x25PLEcallTimeoutsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallTimeouts, &tmpsize);
			tmpsize = StorageTmp->x25PLEclearTimeoutsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEclearTimeouts, &tmpsize);
			tmpsize = StorageTmp->x25PLEremotelyInitiatedResetsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEremotelyInitiatedResets, &tmpsize);
			tmpsize = StorageTmp->x25PLEdataRetransmissionTimerExpiriesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdataRetransmissionTimerExpiries, &tmpsize);
			tmpsize = StorageTmp->x25PLEproviderInitiatedResetsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEproviderInitiatedResets, &tmpsize);
			tmpsize = StorageTmp->x25PLEresetTimeoutsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEresetTimeouts, &tmpsize);
			tmpsize = StorageTmp->x25PLEremotelyInitiatedRestartsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEremotelyInitiatedRestarts, &tmpsize);
			tmpsize = StorageTmp->x25PLErestartCountsExceededLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLErestartCountsExceeded, &tmpsize);
			tmpsize = StorageTmp->x25PLEprotocolErrorsDetectedLocallyLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEprotocolErrorsDetectedLocally, &tmpsize);
			tmpsize = StorageTmp->x25PLEprotocolErrorsAccusedOfLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEprotocolErrorsAccusedOf, &tmpsize);
			tmpsize = StorageTmp->x25PLEcallEstablishmentRetryCountsExceededLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded, &tmpsize);
			tmpsize = StorageTmp->x25PLEclearCountsExceededLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEclearCountsExceeded, &tmpsize);
			tmpsize = StorageTmp->x25PLEpLEClientMONameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEpLEClientMOName, &tmpsize);
			tmpsize = StorageTmp->x25PLEregistrationRequestTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEregistrationRequestTime, &tmpsize);
			tmpsize = StorageTmp->x25PLEregistrationRequestCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEregistrationRequestCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEregistrationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLE-DTETable_add(): adds a structure node to our data set
 */
int
 x25PLE -
DTETable_add(struct x25PLE -DTETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLE-DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLE - DTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLE-DTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLE-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLE-DTETable_del(): delete a structure
 */
int
 x25PLE -
DTETable_del(struct x25PLE -DTETable_data ** thedata)
{
	struct x25PLE -DTETable_data * StorageDel;

	DEBUGMSGTL(("x25PLE-DTETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEcallRequestResponseTimer);
		StorageDel->x25PLE - DTEcallRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEextendedPacketSequenceNumbering);
		StorageDel->x25PLE - DTEextendedPacketSequenceNumberingLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEmaxActiveCircuits);
		StorageDel->x25PLE - DTEmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEminimumRecallTimer);
		StorageDel->x25PLE - DTEminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEresetRequestResponseTimer);
		StorageDel->x25PLE - DTEresetRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTErestartRequestRetransmissionCount);
		StorageDel->x25PLE - DTErestartRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTErestartRequestResponseTimer);
		StorageDel->x25PLE - DTErestartRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEclearRequestResponseTimer);
		StorageDel->x25PLE - DTEclearRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEinterruptResponseTimer);
		StorageDel->x25PLE - DTEinterruptResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEresetRequestRetransmissionCount);
		StorageDel->x25PLE - DTEresetRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEclearRequestRetransmissionCount);
		StorageDel->x25PLE - DTEclearRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEwindowStatusTransmissionTimer);
		StorageDel->x25PLE - DTEwindowStatusTransmissionTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEwindowRotationTimer);
		StorageDel->x25PLE - DTEwindowRotationTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEdataPacketRetransmissionCount);
		StorageDel->x25PLE - DTEdataPacketRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTErejectResponseTimer);
		StorageDel->x25PLE - DTErejectResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTErejectRetransmissionCount);
		StorageDel->x25PLE - DTErejectRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEregistrationRequestResponseTimer);
		StorageDel->x25PLE - DTEregistrationRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DTEregistrationRequestRetransmissionCount);
		StorageDel->x25PLE - DTEregistrationRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLE-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLE-DTETable(): parse configuration file for x25PLE-DTETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_x25PLE -
DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLE -DTETable_data * StorageTmp = SNMP_MALLOC_STRUCT(x25PLE - DTETable_data);

	DEBUGMSGTL(("x25PLE-DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DTEcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEcallRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLE - DTEcallRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTEcallRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTEcallRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEextendedPacketSequenceNumbering, &tmpsize);
	StorageTmp->x25PLE - DTEextendedPacketSequenceNumberingLen = tmpsize;
	if (StorageTmp->x25PLE - DTEextendedPacketSequenceNumbering == NULL) {
		config_perror("invalid specification for x25PLE-DTEextendedPacketSequenceNumbering");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEmaxActiveCircuits, &tmpsize);
	StorageTmp->x25PLE - DTEmaxActiveCircuitsLen = tmpsize;
	if (StorageTmp->x25PLE - DTEmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLE-DTEmaxActiveCircuits");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEminimumRecallTimer, &tmpsize);
	StorageTmp->x25PLE - DTEminimumRecallTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTEminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTEminimumRecallTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEresetRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLE - DTEresetRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTEresetRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTEresetRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTErestartRequestRetransmissionCount, &tmpsize);
	StorageTmp->x25PLE - DTErestartRequestRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLE - DTErestartRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE-DTErestartRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTErestartRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLE - DTErestartRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTErestartRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTErestartRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEclearRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLE - DTEclearRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTEclearRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTEclearRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEinterruptResponseTimer, &tmpsize);
	StorageTmp->x25PLE - DTEinterruptResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTEinterruptResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTEinterruptResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEresetRequestRetransmissionCount, &tmpsize);
	StorageTmp->x25PLE - DTEresetRequestRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLE - DTEresetRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE-DTEresetRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEclearRequestRetransmissionCount, &tmpsize);
	StorageTmp->x25PLE - DTEclearRequestRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLE - DTEclearRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE-DTEclearRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEcallAttempts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEprotocolErrorsDetectedLocally, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEprotocolErrorsAccusedOf, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEcallEstablishmentRetryCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEcallTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEcallsConnected, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEclearCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEclearTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEdataRetransmissionTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DTErestartCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEwindowStatusTransmissionTimer, &tmpsize);
	StorageTmp->x25PLE - DTEwindowStatusTransmissionTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTEwindowStatusTransmissionTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTEwindowStatusTransmissionTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEwindowRotationTimer, &tmpsize);
	StorageTmp->x25PLE - DTEwindowRotationTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTEwindowRotationTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTEwindowRotationTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEdataPacketRetransmissionCount, &tmpsize);
	StorageTmp->x25PLE - DTEdataPacketRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLE - DTEdataPacketRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE-DTEdataPacketRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTErejectResponseTimer, &tmpsize);
	StorageTmp->x25PLE - DTErejectResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTErejectResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTErejectResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTErejectRetransmissionCount, &tmpsize);
	StorageTmp->x25PLE - DTErejectRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLE - DTErejectRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE-DTErejectRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEregistrationRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLE - DTEregistrationRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLE - DTEregistrationRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE-DTEregistrationRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DTEregistrationRequestRetransmissionCount, &tmpsize);
	StorageTmp->x25PLE - DTEregistrationRequestRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLE - DTEregistrationRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE-DTEregistrationRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DTEregistrationPermitted, &tmpsize);
	x25PLE - DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLE-DTETable", "done.\n"));
}

/*
 * store_x25PLE-DTETable(): store configuraiton file for x25PLE-DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_x25PLE -
DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLE -DTETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLE-DTETable", "storing data...  "));
	refresh_x25PLE - DTETable();
	(void) tmpsize;
	for (hcindex = x25PLE - DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLE - DTETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->x25PLE-DTETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLE-DTETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DTEcallDeflectionSubscription, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEcallRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEcallRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEextendedPacketSequenceNumberingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEextendedPacketSequenceNumbering, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEmaxActiveCircuitsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEmaxActiveCircuits, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEminimumRecallTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEminimumRecallTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEresetRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEresetRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTErestartRequestRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTErestartRequestRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTErestartRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTErestartRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEclearRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEclearRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEinterruptResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEinterruptResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEresetRequestRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEresetRequestRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEclearRequestRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEclearRequestRetransmissionCount, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEcallAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEprotocolErrorsDetectedLocally, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEprotocolErrorsAccusedOf, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEcallEstablishmentRetryCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEcallTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEclearCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEclearTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEdataRetransmissionTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DTErestartCountsExceeded, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEwindowStatusTransmissionTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEwindowStatusTransmissionTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEwindowRotationTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEwindowRotationTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEdataPacketRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEdataPacketRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTErejectResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTErejectResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTErejectRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTErejectRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEregistrationRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEregistrationRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DTEregistrationRequestRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DTEregistrationRequestRetransmissionCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DTEregistrationPermitted, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLE-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLE-DCETable_add(): adds a structure node to our data set
 */
int
 x25PLE -
DCETable_add(struct x25PLE -DCETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLE-DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLE - DCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLE-DCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLE-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLE-DCETable_del(): delete a structure
 */
int
 x25PLE -
DCETable_del(struct x25PLE -DCETable_data ** thedata)
{
	struct x25PLE -DCETable_data * StorageDel;

	DEBUGMSGTL(("x25PLE-DCETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DCEdefaultThroughputClassesAssignment);
		StorageDel->x25PLE - DCEdefaultThroughputClassesAssignmentLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DCEextendedPacketSequenceNumbering);
		StorageDel->x25PLE - DCEextendedPacketSequenceNumberingLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DCEnonStandardDefaultPacketSizes);
		StorageDel->x25PLE - DCEnonStandardDefaultPacketSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DCEnonStandardDefaultWindowSizes);
		StorageDel->x25PLE - DCEnonStandardDefaultWindowSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DCEincomingCall);
		StorageDel->x25PLE - DCEincomingCallLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DCEresetIndication);
		StorageDel->x25PLE - DCEresetIndicationLen = 0;
		SNMP_FREE(StorageDel->x25PLE - DCErestartIndication);
		StorageDel->x25PLE - DCErestartIndicationLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLE-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLE-DCETable(): parse configuration file for x25PLE-DCETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_x25PLE -
DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLE -DCETable_data * StorageTmp = SNMP_MALLOC_STRUCT(x25PLE - DCETable_data);

	DEBUGMSGTL(("x25PLE-DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEcallAttempts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEcallsConnected, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEcUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEfastSelectAcceptance, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEincomingCallsBarred, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEoneWayLogicalChannelOutgoing, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEoutgoingCallsBarred, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEinterruptPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEinterruptPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEinterruptTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEx25SegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE - DCEx25SegmentsSent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEbilateralCUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEbilateralCUGWithOutgoingAccess, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEcallRedirection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEchargingInformation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEcUGWithIncomingAccess, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEcUGWithOutgoingAccess, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEdBitModification, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DCEdefaultThroughputClassesAssignment, &tmpsize);
	StorageTmp->x25PLE - DCEdefaultThroughputClassesAssignmentLen = tmpsize;
	if (StorageTmp->x25PLE - DCEdefaultThroughputClassesAssignment == NULL) {
		config_perror("invalid specification for x25PLE-DCEdefaultThroughputClassesAssignment");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DCEextendedPacketSequenceNumbering, &tmpsize);
	StorageTmp->x25PLE - DCEextendedPacketSequenceNumberingLen = tmpsize;
	if (StorageTmp->x25PLE - DCEextendedPacketSequenceNumbering == NULL) {
		config_perror("invalid specification for x25PLE-DCEextendedPacketSequenceNumbering");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEhuntGroup, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEincomingCallBarredWithinCUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCElocalChargingPrevention, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DCEnonStandardDefaultPacketSizes, &tmpsize);
	StorageTmp->x25PLE - DCEnonStandardDefaultPacketSizesLen = tmpsize;
	if (StorageTmp->x25PLE - DCEnonStandardDefaultPacketSizes == NULL) {
		config_perror("invalid specification for x25PLE-DCEnonStandardDefaultPacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DCEnonStandardDefaultWindowSizes, &tmpsize);
	StorageTmp->x25PLE - DCEnonStandardDefaultWindowSizesLen = tmpsize;
	if (StorageTmp->x25PLE - DCEnonStandardDefaultWindowSizes == NULL) {
		config_perror("invalid specification for x25PLE-DCEnonStandardDefaultWindowSizes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEnUIOverride, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEnUISubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEoneWayLogicalChannelIncoming, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEonlineFacilityRegistration, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEoutgoingCallBarredWithinCUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEpacketRetransmission, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEreverseChargingAcceptance, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCErOASubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE - DCEclearIndication, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DCEincomingCall, &tmpsize);
	StorageTmp->x25PLE - DCEincomingCallLen = tmpsize;
	if (StorageTmp->x25PLE - DCEincomingCall == NULL) {
		config_perror("invalid specification for x25PLE-DCEincomingCall");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DCEresetIndication, &tmpsize);
	StorageTmp->x25PLE - DCEresetIndicationLen = tmpsize;
	if (StorageTmp->x25PLE - DCEresetIndication == NULL) {
		config_perror("invalid specification for x25PLE-DCEresetIndication");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE - DCErestartIndication, &tmpsize);
	StorageTmp->x25PLE - DCErestartIndicationLen = tmpsize;
	if (StorageTmp->x25PLE - DCErestartIndication == NULL) {
		config_perror("invalid specification for x25PLE-DCErestartIndication");
		return;
	}

	x25PLE - DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLE-DCETable", "done.\n"));
}

/*
 * store_x25PLE-DCETable(): store configuraiton file for x25PLE-DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_x25PLE -
DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLE -DCETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLE-DCETable", "storing data...  "));
	refresh_x25PLE - DCETable();
	(void) tmpsize;
	for (hcindex = x25PLE - DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLE - DCETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->x25PLE-DCETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLE-DCETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEcallAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEcUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEfastSelectAcceptance, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEincomingCallsBarred, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEoneWayLogicalChannelOutgoing, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEoutgoingCallsBarred, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEinterruptPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEinterruptPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEinterruptTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEx25SegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE - DCEx25SegmentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEbilateralCUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEbilateralCUGWithOutgoingAccess, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEcallRedirection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEchargingInformation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEcUGWithIncomingAccess, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEcUGWithOutgoingAccess, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEdBitModification, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DCEdefaultThroughputClassesAssignmentLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DCEdefaultThroughputClassesAssignment, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DCEextendedPacketSequenceNumberingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DCEextendedPacketSequenceNumbering, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEhuntGroup, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEincomingCallBarredWithinCUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCElocalChargingPrevention, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DCEnonStandardDefaultPacketSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DCEnonStandardDefaultPacketSizes, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DCEnonStandardDefaultWindowSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DCEnonStandardDefaultWindowSizes, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEnUIOverride, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEnUISubscription, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEoneWayLogicalChannelIncoming, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEonlineFacilityRegistration, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEoutgoingCallBarredWithinCUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEpacketRetransmission, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEreverseChargingAcceptance, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCErOASubscription, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE - DCEclearIndication, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DCEincomingCallLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DCEincomingCall, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DCEresetIndicationLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DCEresetIndication, &tmpsize);
			tmpsize = StorageTmp->x25PLE - DCErestartIndicationLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE - DCErestartIndication, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLE-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMOTable_add(): adds a structure node to our data set
 */
int
x25PLEIVMOTable_add(struct x25PLEIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId, thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMOTable_del(): delete a structure
 */
int
x25PLEIVMOTable_del(struct x25PLEIVMOTable_data **thedata)
{
	struct x25PLEIVMOTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMOTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOlocalDTEAddress);
		StorageDel->x25PLEIVMOlocalDTEAddressLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOlogicalChannelAssignments);
		StorageDel->x25PLEIVMOlogicalChannelAssignmentsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOsN - ServiceProvider);
		StorageDel->x25PLEIVMOsN - ServiceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultPacketSizes);
		StorageDel->x25PLEIVMOdefaultPacketSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultThroughputClasses);
		StorageDel->x25PLEIVMOdefaultThroughputClassesLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultWindowSizes);
		StorageDel->x25PLEIVMOdefaultWindowSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOflowControlParameterNegotiation);
		StorageDel->x25PLEIVMOflowControlParameterNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOthroughputClassNegotiation);
		StorageDel->x25PLEIVMOthroughputClassNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOx25PLEMode);
		StorageDel->x25PLEIVMOx25PLEModeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultThroughputClass);
		StorageDel->x25PLEIVMOdefaultThroughputClassLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOflowControlNegotiationPermitted);
		StorageDel->x25PLEIVMOflowControlNegotiationPermittedLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOmaxActiveCircuits);
		StorageDel->x25PLEIVMOmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOrestartTime);
		StorageDel->x25PLEIVMOrestartTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultPacketSize);
		StorageDel->x25PLEIVMOdefaultPacketSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultWindowSize);
		StorageDel->x25PLEIVMOdefaultWindowSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOminimumRecallTimer);
		StorageDel->x25PLEIVMOminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOrestartCount);
		StorageDel->x25PLEIVMOrestartCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOpacketSequencing);
		StorageDel->x25PLEIVMOpacketSequencingLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOregistrationRequestTime);
		StorageDel->x25PLEIVMOregistrationRequestTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOregistrationRequestCount);
		StorageDel->x25PLEIVMOregistrationRequestCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEIVMOTable(): parse configuration file for x25PLEIVMOTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEIVMOTable_data);

	DEBUGMSGTL(("x25PLEIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &tmpsize);
	StorageTmp->x25PLEIVMOIdLen = tmpsize;
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOlocalDTEAddress, &tmpsize);
	StorageTmp->x25PLEIVMOlocalDTEAddressLen = tmpsize;
	if (StorageTmp->x25PLEIVMOlocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLEIVMOlocalDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOlogicalChannelAssignments, &tmpsize);
	StorageTmp->x25PLEIVMOlogicalChannelAssignmentsLen = tmpsize;
	if (StorageTmp->x25PLEIVMOlogicalChannelAssignments == NULL) {
		config_perror("invalid specification for x25PLEIVMOlogicalChannelAssignments");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOsN - ServiceProvider, &tmpsize);
	StorageTmp->x25PLEIVMOsN - ServiceProviderLen = tmpsize;
	if (StorageTmp->x25PLEIVMOsN - ServiceProvider == NULL) {
		config_perror("invalid specification for x25PLEIVMOsN-ServiceProvider");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultPacketSizes, &tmpsize);
	StorageTmp->x25PLEIVMOdefaultPacketSizesLen = tmpsize;
	if (StorageTmp->x25PLEIVMOdefaultPacketSizes == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultPacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultThroughputClasses, &tmpsize);
	StorageTmp->x25PLEIVMOdefaultThroughputClassesLen = tmpsize;
	if (StorageTmp->x25PLEIVMOdefaultThroughputClasses == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultThroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultWindowSizes, &tmpsize);
	StorageTmp->x25PLEIVMOdefaultWindowSizesLen = tmpsize;
	if (StorageTmp->x25PLEIVMOdefaultWindowSizes == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultWindowSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOflowControlParameterNegotiation, &tmpsize);
	StorageTmp->x25PLEIVMOflowControlParameterNegotiationLen = tmpsize;
	if (StorageTmp->x25PLEIVMOflowControlParameterNegotiation == NULL) {
		config_perror("invalid specification for x25PLEIVMOflowControlParameterNegotiation");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOthroughputClassNegotiation, &tmpsize);
	StorageTmp->x25PLEIVMOthroughputClassNegotiationLen = tmpsize;
	if (StorageTmp->x25PLEIVMOthroughputClassNegotiation == NULL) {
		config_perror("invalid specification for x25PLEIVMOthroughputClassNegotiation");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOx25PLEMode, &tmpsize);
	StorageTmp->x25PLEIVMOx25PLEModeLen = tmpsize;
	if (StorageTmp->x25PLEIVMOx25PLEMode == NULL) {
		config_perror("invalid specification for x25PLEIVMOx25PLEMode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOinterfaceMode, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultThroughputClass, &tmpsize);
	StorageTmp->x25PLEIVMOdefaultThroughputClassLen = tmpsize;
	if (StorageTmp->x25PLEIVMOdefaultThroughputClass == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultThroughputClass");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOflowControlNegotiationPermitted, &tmpsize);
	StorageTmp->x25PLEIVMOflowControlNegotiationPermittedLen = tmpsize;
	if (StorageTmp->x25PLEIVMOflowControlNegotiationPermitted == NULL) {
		config_perror("invalid specification for x25PLEIVMOflowControlNegotiationPermitted");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOmaxActiveCircuits, &tmpsize);
	StorageTmp->x25PLEIVMOmaxActiveCircuitsLen = tmpsize;
	if (StorageTmp->x25PLEIVMOmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLEIVMOmaxActiveCircuits");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOrestartTime, &tmpsize);
	StorageTmp->x25PLEIVMOrestartTimeLen = tmpsize;
	if (StorageTmp->x25PLEIVMOrestartTime == NULL) {
		config_perror("invalid specification for x25PLEIVMOrestartTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultPacketSize, &tmpsize);
	StorageTmp->x25PLEIVMOdefaultPacketSizeLen = tmpsize;
	if (StorageTmp->x25PLEIVMOdefaultPacketSize == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultPacketSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultWindowSize, &tmpsize);
	StorageTmp->x25PLEIVMOdefaultWindowSizeLen = tmpsize;
	if (StorageTmp->x25PLEIVMOdefaultWindowSize == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultWindowSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOminimumRecallTimer, &tmpsize);
	StorageTmp->x25PLEIVMOminimumRecallTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMOminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMOminimumRecallTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOrestartCount, &tmpsize);
	StorageTmp->x25PLEIVMOrestartCountLen = tmpsize;
	if (StorageTmp->x25PLEIVMOrestartCount == NULL) {
		config_perror("invalid specification for x25PLEIVMOrestartCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOpacketSequencing, &tmpsize);
	StorageTmp->x25PLEIVMOpacketSequencingLen = tmpsize;
	if (StorageTmp->x25PLEIVMOpacketSequencing == NULL) {
		config_perror("invalid specification for x25PLEIVMOpacketSequencing");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOregistrationRequestTime, &tmpsize);
	StorageTmp->x25PLEIVMOregistrationRequestTimeLen = tmpsize;
	if (StorageTmp->x25PLEIVMOregistrationRequestTime == NULL) {
		config_perror("invalid specification for x25PLEIVMOregistrationRequestTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOregistrationRequestCount, &tmpsize);
	StorageTmp->x25PLEIVMOregistrationRequestCountLen = tmpsize;
	if (StorageTmp->x25PLEIVMOregistrationRequestCount == NULL) {
		config_perror("invalid specification for x25PLEIVMOregistrationRequestCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOregistrationPermitted, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMORowStatus, &tmpsize);
	x25PLEIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
}

/*
 * store_x25PLEIVMOTable(): store configuraiton file for x25PLEIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMOTable", "storing data...  "));
	refresh_x25PLEIVMOTable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMOTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->x25PLEIVMOTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMOTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIVMOIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOlocalDTEAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOlocalDTEAddress, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOlogicalChannelAssignmentsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOlogicalChannelAssignments, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOsN - ServiceProviderLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOsN - ServiceProvider, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOdefaultPacketSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultPacketSizes, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOdefaultThroughputClassesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultThroughputClasses, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOdefaultWindowSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultWindowSizes, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOflowControlParameterNegotiationLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOflowControlParameterNegotiation, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOthroughputClassNegotiationLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOthroughputClassNegotiation, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOx25PLEModeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOx25PLEMode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOinterfaceMode, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOdefaultThroughputClassLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultThroughputClass, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOflowControlNegotiationPermittedLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOflowControlNegotiationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOcallDeflectionSubscription, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOmaxActiveCircuitsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOmaxActiveCircuits, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOrestartTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOrestartTime, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOdefaultPacketSizeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultPacketSize, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOdefaultWindowSizeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultWindowSize, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOminimumRecallTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOminimumRecallTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOrestartCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOrestartCount, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOpacketSequencingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOpacketSequencing, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOregistrationRequestTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOregistrationRequestTime, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMOregistrationRequestCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOregistrationRequestCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOregistrationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMO-DTETable_add(): adds a structure node to our data set
 */
int
 x25PLEIVMO -
DTETable_add(struct x25PLEIVMO -DTETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMO-DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId, thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMO - DTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMO-DTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMO-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMO-DTETable_del(): delete a structure
 */
int
 x25PLEIVMO -
DTETable_del(struct x25PLEIVMO -DTETable_data ** thedata)
{
	struct x25PLEIVMO -DTETable_data * StorageDel;

	DEBUGMSGTL(("x25PLEIVMO-DTETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEcallRequestResponseTimer);
		StorageDel->x25PLEIVMO - DTEcallRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEextendedPacketSequenceNumbering);
		StorageDel->x25PLEIVMO - DTEextendedPacketSequenceNumberingLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEmaxActiveCircuits);
		StorageDel->x25PLEIVMO - DTEmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEminimumRecallTimer);
		StorageDel->x25PLEIVMO - DTEminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEresetRequestResponseTimer);
		StorageDel->x25PLEIVMO - DTEresetRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTErestartRequestRetransmissionCount);
		StorageDel->x25PLEIVMO - DTErestartRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTErestartRequestResponseTimer);
		StorageDel->x25PLEIVMO - DTErestartRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEclearRequestResponseTimer);
		StorageDel->x25PLEIVMO - DTEclearRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEinterruptResponseTimer);
		StorageDel->x25PLEIVMO - DTEinterruptResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEresetRequestRetransmissionCount);
		StorageDel->x25PLEIVMO - DTEresetRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEclearRequestRetransmissionCount);
		StorageDel->x25PLEIVMO - DTEclearRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEcallAttempts);
		StorageDel->x25PLEIVMO - DTEcallAttemptsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEprotocolErrorsDetectedLocally);
		StorageDel->x25PLEIVMO - DTEprotocolErrorsDetectedLocallyLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEprotocolErrorsAccusedOf);
		StorageDel->x25PLEIVMO - DTEprotocolErrorsAccusedOfLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEcallEstablishmentRetryCountsExceeded);
		StorageDel->x25PLEIVMO - DTEcallEstablishmentRetryCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEwindowStatusTransmissionTimer);
		StorageDel->x25PLEIVMO - DTEwindowStatusTransmissionTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEwindowRotationTimer);
		StorageDel->x25PLEIVMO - DTEwindowRotationTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEdataPacketRetransmissionCount);
		StorageDel->x25PLEIVMO - DTEdataPacketRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTErejectResponseTimer);
		StorageDel->x25PLEIVMO - DTErejectResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTErejectRetransmissionCount);
		StorageDel->x25PLEIVMO - DTErejectRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEregistrationRequestResponseTimer);
		StorageDel->x25PLEIVMO - DTEregistrationRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO - DTEregistrationRequestRetransmissionCount);
		StorageDel->x25PLEIVMO - DTEregistrationRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMO-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEIVMO-DTETable(): parse configuration file for x25PLEIVMO-DTETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_x25PLEIVMO -
DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMO -DTETable_data * StorageTmp = SNMP_MALLOC_STRUCT(x25PLEIVMO - DTETable_data);

	DEBUGMSGTL(("x25PLEIVMO-DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &tmpsize);
	StorageTmp->x25PLEIVMOIdLen = tmpsize;
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO - DTEcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEcallRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEcallRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEcallRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEcallRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEextendedPacketSequenceNumbering, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEextendedPacketSequenceNumberingLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEextendedPacketSequenceNumbering == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEextendedPacketSequenceNumbering");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEmaxActiveCircuits, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEmaxActiveCircuitsLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEmaxActiveCircuits");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEminimumRecallTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEminimumRecallTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEminimumRecallTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEresetRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEresetRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEresetRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEresetRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTErestartRequestRetransmissionCount, &tmpsize);
	StorageTmp->x25PLEIVMO - DTErestartRequestRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTErestartRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTErestartRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTErestartRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTErestartRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTErestartRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTErestartRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEclearRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEclearRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEclearRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEclearRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEinterruptResponseTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEinterruptResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEinterruptResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEinterruptResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEresetRequestRetransmissionCount, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEresetRequestRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEresetRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEresetRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEclearRequestRetransmissionCount, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEclearRequestRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEclearRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEclearRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEcallAttempts, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEcallAttemptsLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEcallAttempts == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEcallAttempts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEprotocolErrorsDetectedLocally, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEprotocolErrorsDetectedLocallyLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEprotocolErrorsDetectedLocally == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEprotocolErrorsDetectedLocally");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEprotocolErrorsAccusedOf, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEprotocolErrorsAccusedOfLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEprotocolErrorsAccusedOf == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEprotocolErrorsAccusedOf");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEcallEstablishmentRetryCountsExceeded, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEcallEstablishmentRetryCountsExceededLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEcallEstablishmentRetryCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEcallEstablishmentRetryCountsExceeded");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEcallTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEcallsConnected, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEclearCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEclearTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEdataRetransmissionTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO - DTErestartCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEwindowStatusTransmissionTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEwindowStatusTransmissionTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEwindowStatusTransmissionTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEwindowStatusTransmissionTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEwindowRotationTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEwindowRotationTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEwindowRotationTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEwindowRotationTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEdataPacketRetransmissionCount, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEdataPacketRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEdataPacketRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEdataPacketRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTErejectResponseTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTErejectResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTErejectResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTErejectResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTErejectRetransmissionCount, &tmpsize);
	StorageTmp->x25PLEIVMO - DTErejectRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTErejectRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTErejectRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEregistrationRequestResponseTimer, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEregistrationRequestResponseTimerLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEregistrationRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEregistrationRequestResponseTimer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO - DTEregistrationRequestRetransmissionCount, &tmpsize);
	StorageTmp->x25PLEIVMO - DTEregistrationRequestRetransmissionCountLen = tmpsize;
	if (StorageTmp->x25PLEIVMO - DTEregistrationRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO-DTEregistrationRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO - DTEregistrationPermitted, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO - DTERowStatus, &tmpsize);
	x25PLEIVMO - DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMO-DTETable", "done.\n"));
}

/*
 * store_x25PLEIVMO-DTETable(): store configuraiton file for x25PLEIVMO-DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_x25PLEIVMO -
DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMO -DTETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMO-DTETable", "storing data...  "));
	refresh_x25PLEIVMO - DTETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMO - DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMO - DTETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->x25PLEIVMO-DTETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMO-DTETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIVMOIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO - DTEcallDeflectionSubscription, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEcallRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEcallRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEextendedPacketSequenceNumberingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEextendedPacketSequenceNumbering, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEmaxActiveCircuitsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEmaxActiveCircuits, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEminimumRecallTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEminimumRecallTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEresetRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEresetRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTErestartRequestRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTErestartRequestRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTErestartRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTErestartRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEclearRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEclearRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEinterruptResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEinterruptResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEresetRequestRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEresetRequestRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEclearRequestRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEclearRequestRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEcallAttemptsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEcallAttempts, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEprotocolErrorsDetectedLocallyLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEprotocolErrorsDetectedLocally, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEprotocolErrorsAccusedOfLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEprotocolErrorsAccusedOf, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEcallEstablishmentRetryCountsExceededLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEcallEstablishmentRetryCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEcallTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEclearCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEclearTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEdataRetransmissionTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO - DTErestartCountsExceeded, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEwindowStatusTransmissionTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEwindowStatusTransmissionTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEwindowRotationTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEwindowRotationTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEdataPacketRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEdataPacketRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTErejectResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTErejectResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTErejectRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTErejectRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEregistrationRequestResponseTimerLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEregistrationRequestResponseTimer, &tmpsize);
			tmpsize = StorageTmp->x25PLEIVMO - DTEregistrationRequestRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO - DTEregistrationRequestRetransmissionCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO - DTEregistrationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO - DTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMO-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMO-DCETable_add(): adds a structure node to our data set
 */
int
 x25PLEIVMO -
DCETable_add(struct x25PLEIVMO -DCETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMO-DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId, thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMO - DCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMO-DCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMO-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMO-DCETable_del(): delete a structure
 */
int
 x25PLEIVMO -
DCETable_del(struct x25PLEIVMO -DCETable_data ** thedata)
{
	struct x25PLEIVMO -DCETable_data * StorageDel;

	DEBUGMSGTL(("x25PLEIVMO-DCETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMO-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEIVMO-DCETable(): parse configuration file for x25PLEIVMO-DCETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_x25PLEIVMO -
DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMO -DCETable_data * StorageTmp = SNMP_MALLOC_STRUCT(x25PLEIVMO - DCETable_data);

	DEBUGMSGTL(("x25PLEIVMO-DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &tmpsize);
	StorageTmp->x25PLEIVMOIdLen = tmpsize;
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO - DCERowStatus, &tmpsize);
	x25PLEIVMO - DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMO-DCETable", "done.\n"));
}

/*
 * store_x25PLEIVMO-DCETable(): store configuraiton file for x25PLEIVMO-DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_x25PLEIVMO -
DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMO -DCETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMO-DCETable", "storing data...  "));
	refresh_x25PLEIVMO - DCETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMO - DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMO - DCETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->x25PLEIVMO-DCETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMO-DCETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIVMOIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO - DCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMO-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCallTable_add(): adds a structure node to our data set
 */
int
virtualCallTable_add(struct virtualCallTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCallTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* virtualCallId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallId, thedata->virtualCallIdLen);
	header_complex_add_data(&virtualCallTableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCallTable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCallTable_del(): delete a structure
 */
int
virtualCallTable_del(struct virtualCallTable_data **thedata)
{
	struct virtualCallTable_data *StorageDel;

	DEBUGMSGTL(("virtualCallTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCallId);
		StorageDel->virtualCallIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallChannel);
		StorageDel->virtualCallChannelLen = 0;
		SNMP_FREE(StorageDel->virtualCallPacketSize);
		StorageDel->virtualCallPacketSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallWindowSize);
		StorageDel->virtualCallWindowSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallOctetsSentCounter);
		StorageDel->virtualCallOctetsSentCounterLen = 0;
		SNMP_FREE(StorageDel->virtualCallOctetsReceivedCounter);
		StorageDel->virtualCallOctetsReceivedCounterLen = 0;
		SNMP_FREE(StorageDel->virtualCallDataPacketsSent);
		StorageDel->virtualCallDataPacketsSentLen = 0;
		SNMP_FREE(StorageDel->virtualCallDataPacketsReceived);
		StorageDel->virtualCallDataPacketsReceivedLen = 0;
		SNMP_FREE(StorageDel->virtualCallRemotelyInitiatedResets);
		StorageDel->virtualCallRemotelyInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->virtualCallDataRetransmissionTimerExpiries);
		StorageDel->virtualCallDataRetransmissionTimerExpiriesLen = 0;
		SNMP_FREE(StorageDel->virtualCallProviderInitiatedResets);
		StorageDel->virtualCallProviderInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->virtualCallResetTimeouts);
		StorageDel->virtualCallResetTimeoutsLen = 0;
		SNMP_FREE(StorageDel->virtualCallInterruptPacketsSent);
		StorageDel->virtualCallInterruptPacketsSentLen = 0;
		SNMP_FREE(StorageDel->virtualCallInterruptPacketsReceived);
		StorageDel->virtualCallInterruptPacketsReceivedLen = 0;
		SNMP_FREE(StorageDel->virtualCallInterruptTimerExpiries);
		StorageDel->virtualCallInterruptTimerExpiriesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_virtualCallTable(): parse configuration file for virtualCallTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_virtualCallTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCallTable_data *StorageTmp = SNMP_MALLOC_STRUCT(virtualCallTable_data);

	DEBUGMSGTL(("virtualCallTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallId, &tmpsize);
	StorageTmp->virtualCallIdLen = tmpsize;
	if (StorageTmp->virtualCallId == NULL) {
		config_perror("invalid specification for virtualCallId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallChannel, &tmpsize);
	StorageTmp->virtualCallChannelLen = tmpsize;
	if (StorageTmp->virtualCallChannel == NULL) {
		config_perror("invalid specification for virtualCallChannel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallPacketSize, &tmpsize);
	StorageTmp->virtualCallPacketSizeLen = tmpsize;
	if (StorageTmp->virtualCallPacketSize == NULL) {
		config_perror("invalid specification for virtualCallPacketSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallWindowSize, &tmpsize);
	StorageTmp->virtualCallWindowSizeLen = tmpsize;
	if (StorageTmp->virtualCallWindowSize == NULL) {
		config_perror("invalid specification for virtualCallWindowSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallOctetsSentCounter, &tmpsize);
	StorageTmp->virtualCallOctetsSentCounterLen = tmpsize;
	if (StorageTmp->virtualCallOctetsSentCounter == NULL) {
		config_perror("invalid specification for virtualCallOctetsSentCounter");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallOctetsReceivedCounter, &tmpsize);
	StorageTmp->virtualCallOctetsReceivedCounterLen = tmpsize;
	if (StorageTmp->virtualCallOctetsReceivedCounter == NULL) {
		config_perror("invalid specification for virtualCallOctetsReceivedCounter");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallDataPacketsSent, &tmpsize);
	StorageTmp->virtualCallDataPacketsSentLen = tmpsize;
	if (StorageTmp->virtualCallDataPacketsSent == NULL) {
		config_perror("invalid specification for virtualCallDataPacketsSent");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallDataPacketsReceived, &tmpsize);
	StorageTmp->virtualCallDataPacketsReceivedLen = tmpsize;
	if (StorageTmp->virtualCallDataPacketsReceived == NULL) {
		config_perror("invalid specification for virtualCallDataPacketsReceived");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallRemotelyInitiatedResets, &tmpsize);
	StorageTmp->virtualCallRemotelyInitiatedResetsLen = tmpsize;
	if (StorageTmp->virtualCallRemotelyInitiatedResets == NULL) {
		config_perror("invalid specification for virtualCallRemotelyInitiatedResets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallDataRetransmissionTimerExpiries, &tmpsize);
	StorageTmp->virtualCallDataRetransmissionTimerExpiriesLen = tmpsize;
	if (StorageTmp->virtualCallDataRetransmissionTimerExpiries == NULL) {
		config_perror("invalid specification for virtualCallDataRetransmissionTimerExpiries");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallProviderInitiatedResets, &tmpsize);
	StorageTmp->virtualCallProviderInitiatedResetsLen = tmpsize;
	if (StorageTmp->virtualCallProviderInitiatedResets == NULL) {
		config_perror("invalid specification for virtualCallProviderInitiatedResets");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallResetTimeouts, &tmpsize);
	StorageTmp->virtualCallResetTimeoutsLen = tmpsize;
	if (StorageTmp->virtualCallResetTimeouts == NULL) {
		config_perror("invalid specification for virtualCallResetTimeouts");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallInterruptPacketsSent, &tmpsize);
	StorageTmp->virtualCallInterruptPacketsSentLen = tmpsize;
	if (StorageTmp->virtualCallInterruptPacketsSent == NULL) {
		config_perror("invalid specification for virtualCallInterruptPacketsSent");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallInterruptPacketsReceived, &tmpsize);
	StorageTmp->virtualCallInterruptPacketsReceivedLen = tmpsize;
	if (StorageTmp->virtualCallInterruptPacketsReceived == NULL) {
		config_perror("invalid specification for virtualCallInterruptPacketsReceived");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallInterruptTimerExpiries, &tmpsize);
	StorageTmp->virtualCallInterruptTimerExpiriesLen = tmpsize;
	if (StorageTmp->virtualCallInterruptTimerExpiries == NULL) {
		config_perror("invalid specification for virtualCallInterruptTimerExpiries");
		return;
	}

	virtualCallTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
}

/*
 * store_virtualCallTable(): store configuraiton file for virtualCallTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCallTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCallTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCallTable", "storing data...  "));
	refresh_virtualCallTable();
	(void) tmpsize;
	for (hcindex = virtualCallTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCallTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->virtualCallTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCallTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->virtualCallIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallId, &tmpsize);
			tmpsize = StorageTmp->virtualCallChannelLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallChannel, &tmpsize);
			tmpsize = StorageTmp->virtualCallPacketSizeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallPacketSize, &tmpsize);
			tmpsize = StorageTmp->virtualCallWindowSizeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallWindowSize, &tmpsize);
			tmpsize = StorageTmp->virtualCallOctetsSentCounterLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallOctetsSentCounter, &tmpsize);
			tmpsize = StorageTmp->virtualCallOctetsReceivedCounterLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallOctetsReceivedCounter, &tmpsize);
			tmpsize = StorageTmp->virtualCallDataPacketsSentLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallDataPacketsSent, &tmpsize);
			tmpsize = StorageTmp->virtualCallDataPacketsReceivedLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallDataPacketsReceived, &tmpsize);
			tmpsize = StorageTmp->virtualCallRemotelyInitiatedResetsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallRemotelyInitiatedResets, &tmpsize);
			tmpsize = StorageTmp->virtualCallDataRetransmissionTimerExpiriesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallDataRetransmissionTimerExpiries, &tmpsize);
			tmpsize = StorageTmp->virtualCallProviderInitiatedResetsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallProviderInitiatedResets, &tmpsize);
			tmpsize = StorageTmp->virtualCallResetTimeoutsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallResetTimeouts, &tmpsize);
			tmpsize = StorageTmp->virtualCallInterruptPacketsSentLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallInterruptPacketsSent, &tmpsize);
			tmpsize = StorageTmp->virtualCallInterruptPacketsReceivedLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallInterruptPacketsReceived, &tmpsize);
			tmpsize = StorageTmp->virtualCallInterruptTimerExpiriesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallInterruptTimerExpiries, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCircuitTable_add(): adds a structure node to our data set
 */
int
virtualCircuitTable_add(struct virtualCircuitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCircuitTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCircuitTableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCircuitTable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCircuitTable_del(): delete a structure
 */
int
virtualCircuitTable_del(struct virtualCircuitTable_data **thedata)
{
	struct virtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("virtualCircuitTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitLogicalChannel);
		StorageDel->virtualCircuitLogicalChannelLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitPacketSizes);
		StorageDel->virtualCircuitPacketSizesLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitThroughputClasses);
		StorageDel->virtualCircuitThroughputClassesLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitWindowSizes);
		StorageDel->virtualCircuitWindowSizesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_virtualCircuitTable(): parse configuration file for virtualCircuitTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_virtualCircuitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCircuitTable_data *StorageTmp = SNMP_MALLOC_STRUCT(virtualCircuitTable_data);

	DEBUGMSGTL(("virtualCircuitTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &tmpsize);
	StorageTmp->virtualCircuitIdLen = tmpsize;
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitLogicalChannel, &tmpsize);
	StorageTmp->virtualCircuitLogicalChannelLen = tmpsize;
	if (StorageTmp->virtualCircuitLogicalChannel == NULL) {
		config_perror("invalid specification for virtualCircuitLogicalChannel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitPacketSizes, &tmpsize);
	StorageTmp->virtualCircuitPacketSizesLen = tmpsize;
	if (StorageTmp->virtualCircuitPacketSizes == NULL) {
		config_perror("invalid specification for virtualCircuitPacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitThroughputClasses, &tmpsize);
	StorageTmp->virtualCircuitThroughputClassesLen = tmpsize;
	if (StorageTmp->virtualCircuitThroughputClasses == NULL) {
		config_perror("invalid specification for virtualCircuitThroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitWindowSizes, &tmpsize);
	StorageTmp->virtualCircuitWindowSizesLen = tmpsize;
	if (StorageTmp->virtualCircuitWindowSizes == NULL) {
		config_perror("invalid specification for virtualCircuitWindowSizes");
		return;
	}

	virtualCircuitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
}

/*
 * store_virtualCircuitTable(): store configuraiton file for virtualCircuitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCircuitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCircuitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCircuitTable", "storing data...  "));
	refresh_virtualCircuitTable();
	(void) tmpsize;
	for (hcindex = virtualCircuitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCircuitTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->virtualCircuitTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCircuitTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->virtualCircuitIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &tmpsize);
			tmpsize = StorageTmp->virtualCircuitLogicalChannelLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitLogicalChannel, &tmpsize);
			tmpsize = StorageTmp->virtualCircuitPacketSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitPacketSizes, &tmpsize);
			tmpsize = StorageTmp->virtualCircuitThroughputClassesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitThroughputClasses, &tmpsize);
			tmpsize = StorageTmp->virtualCircuitWindowSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitWindowSizes, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCircuit-DTETable_add(): adds a structure node to our data set
 */
int
 virtualCircuit -
DTETable_add(struct virtualCircuit -DTETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCircuit-DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCircuit - DTETableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCircuit-DTETable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCircuit-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCircuit-DTETable_del(): delete a structure
 */
int
 virtualCircuit -
DTETable_del(struct virtualCircuit -DTETable_data ** thedata)
{
	struct virtualCircuit -DTETable_data * StorageDel;

	DEBUGMSGTL(("virtualCircuit-DTETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCircuit-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_virtualCircuit-DTETable(): parse configuration file for virtualCircuit-DTETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_virtualCircuit -
DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCircuit -DTETable_data * StorageTmp = SNMP_MALLOC_STRUCT(virtualCircuit - DTETable_data);

	DEBUGMSGTL(("virtualCircuit-DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &tmpsize);
	StorageTmp->virtualCircuitIdLen = tmpsize;
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEdataRetransmissionTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEinterruptPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEinterruptPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEinterruptTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DTEresetTimeouts, &tmpsize);
	virtualCircuit - DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCircuit-DTETable", "done.\n"));
}

/*
 * store_virtualCircuit-DTETable(): store configuraiton file for virtualCircuit-DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_virtualCircuit -
DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCircuit -DTETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCircuit-DTETable", "storing data...  "));
	refresh_virtualCircuit - DTETable();
	(void) tmpsize;
	for (hcindex = virtualCircuit - DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCircuit - DTETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->virtualCircuit-DTETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCircuit-DTETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->virtualCircuitIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEdataRetransmissionTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEinterruptPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEinterruptPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEinterruptTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DTEresetTimeouts, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCircuit-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCircuit-DCETable_add(): adds a structure node to our data set
 */
int
 virtualCircuit -
DCETable_add(struct virtualCircuit -DCETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCircuit-DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCircuit - DCETableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCircuit-DCETable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCircuit-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCircuit-DCETable_del(): delete a structure
 */
int
 virtualCircuit -
DCETable_del(struct virtualCircuit -DCETable_data ** thedata)
{
	struct virtualCircuit -DCETable_data * StorageDel;

	DEBUGMSGTL(("virtualCircuit-DCETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCircuit-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_virtualCircuit-DCETable(): parse configuration file for virtualCircuit-DCETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_virtualCircuit -
DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCircuit -DCETable_data * StorageTmp = SNMP_MALLOC_STRUCT(virtualCircuit - DCETable_data);

	DEBUGMSGTL(("virtualCircuit-DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &tmpsize);
	StorageTmp->virtualCircuitIdLen = tmpsize;
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEinterruptPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEinterruptPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEinterruptTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEx25SegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit - DCEx25SegmentsSent, &tmpsize);
	virtualCircuit - DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCircuit-DCETable", "done.\n"));
}

/*
 * store_virtualCircuit-DCETable(): store configuraiton file for virtualCircuit-DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_virtualCircuit -
DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCircuit -DCETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCircuit-DCETable", "storing data...  "));
	refresh_virtualCircuit - DCETable();
	(void) tmpsize;
	for (hcindex = virtualCircuit - DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCircuit - DCETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->virtualCircuit-DCETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCircuit-DCETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->virtualCircuitIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEinterruptPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEinterruptPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEinterruptTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEx25SegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit - DCEx25SegmentsSent, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCircuit-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * permanentVirtualCircuitTable_add(): adds a structure node to our data set
 */
int
permanentVirtualCircuitTable_add(struct permanentVirtualCircuitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("permanentVirtualCircuitTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCallId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallId, thedata->virtualCallIdLen);
	header_complex_add_data(&permanentVirtualCircuitTableStorage, vars, thedata);
	DEBUGMSGTL(("permanentVirtualCircuitTable", "registered an entry\n"));
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * permanentVirtualCircuitTable_del(): delete a structure
 */
int
permanentVirtualCircuitTable_del(struct permanentVirtualCircuitTable_data **thedata)
{
	struct permanentVirtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("permanentVirtualCircuitTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallId);
		StorageDel->virtualCallIdLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuitChannel);
		StorageDel->permanentVirtualCircuitChannelLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_permanentVirtualCircuitTable(): parse configuration file for permanentVirtualCircuitTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_permanentVirtualCircuitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct permanentVirtualCircuitTable_data *StorageTmp = SNMP_MALLOC_STRUCT(permanentVirtualCircuitTable_data);

	DEBUGMSGTL(("permanentVirtualCircuitTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallId, &tmpsize);
	StorageTmp->virtualCallIdLen = tmpsize;
	if (StorageTmp->virtualCallId == NULL) {
		config_perror("invalid specification for virtualCallId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuitChannel, &tmpsize);
	StorageTmp->permanentVirtualCircuitChannelLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuitChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuitChannel");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuitRowStatus, &tmpsize);
	permanentVirtualCircuitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
}

/*
 * store_permanentVirtualCircuitTable(): store configuraiton file for permanentVirtualCircuitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_permanentVirtualCircuitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct permanentVirtualCircuitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("permanentVirtualCircuitTable", "storing data...  "));
	refresh_permanentVirtualCircuitTable();
	(void) tmpsize;
	for (hcindex = permanentVirtualCircuitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct permanentVirtualCircuitTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->permanentVirtualCircuitTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "permanentVirtualCircuitTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			tmpsize = StorageTmp->virtualCallIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallId, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuitChannelLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuitChannel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuitRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("permanentVirtualCircuitTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * permanentVirtualCircuit-DTETable_add(): adds a structure node to our data set
 */
int
 permanentVirtualCircuit -
DTETable_add(struct permanentVirtualCircuit -DTETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("permanentVirtualCircuit-DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&permanentVirtualCircuit - DTETableStorage, vars, thedata);
	DEBUGMSGTL(("permanentVirtualCircuit-DTETable", "registered an entry\n"));
	DEBUGMSGTL(("permanentVirtualCircuit-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * permanentVirtualCircuit-DTETable_del(): delete a structure
 */
int
 permanentVirtualCircuit -
DTETable_del(struct permanentVirtualCircuit -DTETable_data ** thedata)
{
	struct permanentVirtualCircuit -DTETable_data * StorageDel;

	DEBUGMSGTL(("permanentVirtualCircuit-DTETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DTElogicalChannel);
		StorageDel->permanentVirtualCircuit - DTElogicalChannelLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DTEpacketSizes);
		StorageDel->permanentVirtualCircuit - DTEpacketSizesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DTEthroughputClasses);
		StorageDel->permanentVirtualCircuit - DTEthroughputClassesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DTEwindowSizes);
		StorageDel->permanentVirtualCircuit - DTEwindowSizesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("permanentVirtualCircuit-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_permanentVirtualCircuit-DTETable(): parse configuration file for permanentVirtualCircuit-DTETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_permanentVirtualCircuit -
DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct permanentVirtualCircuit -DTETable_data * StorageTmp = SNMP_MALLOC_STRUCT(permanentVirtualCircuit - DTETable_data);

	DEBUGMSGTL(("permanentVirtualCircuit-DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &tmpsize);
	StorageTmp->virtualCircuitIdLen = tmpsize;
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DTElogicalChannel, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DTElogicalChannelLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DTElogicalChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DTElogicalChannel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DTEpacketSizes, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DTEpacketSizesLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DTEpacketSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DTEpacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DTEthroughputClasses, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DTEthroughputClassesLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DTEthroughputClasses == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DTEthroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DTEwindowSizes, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DTEwindowSizesLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DTEwindowSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DTEwindowSizes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuit - DTERowStatus, &tmpsize);
	permanentVirtualCircuit - DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("permanentVirtualCircuit-DTETable", "done.\n"));
}

/*
 * store_permanentVirtualCircuit-DTETable(): store configuraiton file for permanentVirtualCircuit-DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_permanentVirtualCircuit -
DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct permanentVirtualCircuit -DTETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("permanentVirtualCircuit-DTETable", "storing data...  "));
	refresh_permanentVirtualCircuit - DTETable();
	(void) tmpsize;
	for (hcindex = permanentVirtualCircuit - DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct permanentVirtualCircuit - DTETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->permanentVirtualCircuit-DTETableStorageType ==
		   ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "permanentVirtualCircuit-DTETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			tmpsize = StorageTmp->virtualCircuitIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DTElogicalChannelLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DTElogicalChannel, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DTEpacketSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DTEpacketSizes, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DTEthroughputClassesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DTEthroughputClasses, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DTEwindowSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DTEwindowSizes, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuit - DTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("permanentVirtualCircuit-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * permanentVirtualCircuit-DCETable_add(): adds a structure node to our data set
 */
int
 permanentVirtualCircuit -
DCETable_add(struct permanentVirtualCircuit -DCETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("permanentVirtualCircuit-DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&permanentVirtualCircuit - DCETableStorage, vars, thedata);
	DEBUGMSGTL(("permanentVirtualCircuit-DCETable", "registered an entry\n"));
	DEBUGMSGTL(("permanentVirtualCircuit-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * permanentVirtualCircuit-DCETable_del(): delete a structure
 */
int
 permanentVirtualCircuit -
DCETable_del(struct permanentVirtualCircuit -DCETable_data ** thedata)
{
	struct permanentVirtualCircuit -DCETable_data * StorageDel;

	DEBUGMSGTL(("permanentVirtualCircuit-DCETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DCEchargingDirection);
		StorageDel->permanentVirtualCircuit - DCEchargingDirectionLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DCElogicalChannel);
		StorageDel->permanentVirtualCircuit - DCElogicalChannelLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DCEpacketSizes);
		StorageDel->permanentVirtualCircuit - DCEpacketSizesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DCEthroughputClasses);
		StorageDel->permanentVirtualCircuit - DCEthroughputClassesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DCEwindowSizes);
		StorageDel->permanentVirtualCircuit - DCEwindowSizesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DCEremoteDTEAddress);
		StorageDel->permanentVirtualCircuit - DCEremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit - DCEremoteLogicalChannel);
		StorageDel->permanentVirtualCircuit - DCEremoteLogicalChannelLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("permanentVirtualCircuit-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_permanentVirtualCircuit-DCETable(): parse configuration file for permanentVirtualCircuit-DCETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_permanentVirtualCircuit -
DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct permanentVirtualCircuit -DCETable_data * StorageTmp = SNMP_MALLOC_STRUCT(permanentVirtualCircuit - DCETable_data);

	DEBUGMSGTL(("permanentVirtualCircuit-DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &tmpsize);
	StorageTmp->virtualCircuitIdLen = tmpsize;
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DCEchargingDirection, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DCEchargingDirectionLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DCEchargingDirection == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DCEchargingDirection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DCElogicalChannel, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DCElogicalChannelLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DCElogicalChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DCElogicalChannel");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DCEpacketSizes, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DCEpacketSizesLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DCEpacketSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DCEpacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DCEthroughputClasses, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DCEthroughputClassesLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DCEthroughputClasses == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DCEthroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DCEwindowSizes, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DCEwindowSizesLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DCEwindowSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DCEwindowSizes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuit - DCEoperationalState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DCEremoteDTEAddress, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DCEremoteDTEAddressLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DCEremoteDTEAddress == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DCEremoteDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit - DCEremoteLogicalChannel, &tmpsize);
	StorageTmp->permanentVirtualCircuit - DCEremoteLogicalChannelLen = tmpsize;
	if (StorageTmp->permanentVirtualCircuit - DCEremoteLogicalChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit-DCEremoteLogicalChannel");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuit - DCERowStatus, &tmpsize);
	permanentVirtualCircuit - DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("permanentVirtualCircuit-DCETable", "done.\n"));
}

/*
 * store_permanentVirtualCircuit-DCETable(): store configuraiton file for permanentVirtualCircuit-DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_permanentVirtualCircuit -
DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct permanentVirtualCircuit -DCETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("permanentVirtualCircuit-DCETable", "storing data...  "));
	refresh_permanentVirtualCircuit - DCETable();
	(void) tmpsize;
	for (hcindex = permanentVirtualCircuit - DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct permanentVirtualCircuit - DCETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->permanentVirtualCircuit-DCETableStorageType ==
		   ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "permanentVirtualCircuit-DCETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			tmpsize = StorageTmp->virtualCircuitIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DCEchargingDirectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DCEchargingDirection, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DCElogicalChannelLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DCElogicalChannel, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DCEpacketSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DCEpacketSizes, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DCEthroughputClassesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DCEthroughputClasses, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DCEwindowSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DCEwindowSizes, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuit - DCEoperationalState, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DCEremoteDTEAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DCEremoteDTEAddress, &tmpsize);
			tmpsize = StorageTmp->permanentVirtualCircuit - DCEremoteLogicalChannelLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit - DCEremoteLogicalChannel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuit - DCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("permanentVirtualCircuit-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCallIVMOTable_add(): adds a structure node to our data set
 */
int
virtualCallIVMOTable_add(struct virtualCallIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCallIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCallIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallIVMOId, thedata->virtualCallIVMOIdLen);
	header_complex_add_data(&virtualCallIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCallIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCallIVMOTable_del(): delete a structure
 */
int
virtualCallIVMOTable_del(struct virtualCallIVMOTable_data **thedata)
{
	struct virtualCallIVMOTable_data *StorageDel;

	DEBUGMSGTL(("virtualCallIVMOTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOId);
		StorageDel->virtualCallIVMOIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOpacketSizes);
		StorageDel->virtualCallIVMOpacketSizesLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOreverseCharging);
		StorageDel->virtualCallIVMOreverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOthroughputClasses);
		StorageDel->virtualCallIVMOthroughputClassesLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOwindowSizes);
		StorageDel->virtualCallIVMOwindowSizesLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOproposedPacketSize);
		StorageDel->virtualCallIVMOproposedPacketSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOproposedWindowSize);
		StorageDel->virtualCallIVMOproposedWindowSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOacceptReverseCharging);
		StorageDel->virtualCallIVMOacceptReverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOproposeReverseCharging);
		StorageDel->virtualCallIVMOproposeReverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOcallTime);
		StorageDel->virtualCallIVMOcallTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOresetTime);
		StorageDel->virtualCallIVMOresetTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOclearTime);
		StorageDel->virtualCallIVMOclearTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOinterruptTime);
		StorageDel->virtualCallIVMOinterruptTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOresetCount);
		StorageDel->virtualCallIVMOresetCountLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOclearCount);
		StorageDel->virtualCallIVMOclearCountLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOwindowTime);
		StorageDel->virtualCallIVMOwindowTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOdataRetransmissionTime);
		StorageDel->virtualCallIVMOdataRetransmissionTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOdataRetransmissionCount);
		StorageDel->virtualCallIVMOdataRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOrejectTime);
		StorageDel->virtualCallIVMOrejectTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOrejectCount);
		StorageDel->virtualCallIVMOrejectCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_virtualCallIVMOTable(): parse configuration file for virtualCallIVMOTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_virtualCallIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCallIVMOTable_data *StorageTmp = SNMP_MALLOC_STRUCT(virtualCallIVMOTable_data);

	DEBUGMSGTL(("virtualCallIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOId, &tmpsize);
	StorageTmp->virtualCallIVMOIdLen = tmpsize;
	if (StorageTmp->virtualCallIVMOId == NULL) {
		config_perror("invalid specification for virtualCallIVMOId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCallIVMOfastSelect, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOpacketSizes, &tmpsize);
	StorageTmp->virtualCallIVMOpacketSizesLen = tmpsize;
	if (StorageTmp->virtualCallIVMOpacketSizes == NULL) {
		config_perror("invalid specification for virtualCallIVMOpacketSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOreverseCharging, &tmpsize);
	StorageTmp->virtualCallIVMOreverseChargingLen = tmpsize;
	if (StorageTmp->virtualCallIVMOreverseCharging == NULL) {
		config_perror("invalid specification for virtualCallIVMOreverseCharging");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOthroughputClasses, &tmpsize);
	StorageTmp->virtualCallIVMOthroughputClassesLen = tmpsize;
	if (StorageTmp->virtualCallIVMOthroughputClasses == NULL) {
		config_perror("invalid specification for virtualCallIVMOthroughputClasses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOwindowSizes, &tmpsize);
	StorageTmp->virtualCallIVMOwindowSizesLen = tmpsize;
	if (StorageTmp->virtualCallIVMOwindowSizes == NULL) {
		config_perror("invalid specification for virtualCallIVMOwindowSizes");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOproposedPacketSize, &tmpsize);
	StorageTmp->virtualCallIVMOproposedPacketSizeLen = tmpsize;
	if (StorageTmp->virtualCallIVMOproposedPacketSize == NULL) {
		config_perror("invalid specification for virtualCallIVMOproposedPacketSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOproposedWindowSize, &tmpsize);
	StorageTmp->virtualCallIVMOproposedWindowSizeLen = tmpsize;
	if (StorageTmp->virtualCallIVMOproposedWindowSize == NULL) {
		config_perror("invalid specification for virtualCallIVMOproposedWindowSize");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOacceptReverseCharging, &tmpsize);
	StorageTmp->virtualCallIVMOacceptReverseChargingLen = tmpsize;
	if (StorageTmp->virtualCallIVMOacceptReverseCharging == NULL) {
		config_perror("invalid specification for virtualCallIVMOacceptReverseCharging");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOproposeReverseCharging, &tmpsize);
	StorageTmp->virtualCallIVMOproposeReverseChargingLen = tmpsize;
	if (StorageTmp->virtualCallIVMOproposeReverseCharging == NULL) {
		config_perror("invalid specification for virtualCallIVMOproposeReverseCharging");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOcallTime, &tmpsize);
	StorageTmp->virtualCallIVMOcallTimeLen = tmpsize;
	if (StorageTmp->virtualCallIVMOcallTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOcallTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOresetTime, &tmpsize);
	StorageTmp->virtualCallIVMOresetTimeLen = tmpsize;
	if (StorageTmp->virtualCallIVMOresetTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOresetTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOclearTime, &tmpsize);
	StorageTmp->virtualCallIVMOclearTimeLen = tmpsize;
	if (StorageTmp->virtualCallIVMOclearTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOclearTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOinterruptTime, &tmpsize);
	StorageTmp->virtualCallIVMOinterruptTimeLen = tmpsize;
	if (StorageTmp->virtualCallIVMOinterruptTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOinterruptTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOresetCount, &tmpsize);
	StorageTmp->virtualCallIVMOresetCountLen = tmpsize;
	if (StorageTmp->virtualCallIVMOresetCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOresetCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOclearCount, &tmpsize);
	StorageTmp->virtualCallIVMOclearCountLen = tmpsize;
	if (StorageTmp->virtualCallIVMOclearCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOclearCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOwindowTime, &tmpsize);
	StorageTmp->virtualCallIVMOwindowTimeLen = tmpsize;
	if (StorageTmp->virtualCallIVMOwindowTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOwindowTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOdataRetransmissionTime, &tmpsize);
	StorageTmp->virtualCallIVMOdataRetransmissionTimeLen = tmpsize;
	if (StorageTmp->virtualCallIVMOdataRetransmissionTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOdataRetransmissionTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOdataRetransmissionCount, &tmpsize);
	StorageTmp->virtualCallIVMOdataRetransmissionCountLen = tmpsize;
	if (StorageTmp->virtualCallIVMOdataRetransmissionCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOdataRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOrejectTime, &tmpsize);
	StorageTmp->virtualCallIVMOrejectTimeLen = tmpsize;
	if (StorageTmp->virtualCallIVMOrejectTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOrejectTime");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOrejectCount, &tmpsize);
	StorageTmp->virtualCallIVMOrejectCountLen = tmpsize;
	if (StorageTmp->virtualCallIVMOrejectCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOrejectCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCallIVMORowStatus, &tmpsize);
	virtualCallIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
}

/*
 * store_virtualCallIVMOTable(): store configuraiton file for virtualCallIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCallIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCallIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCallIVMOTable", "storing data...  "));
	refresh_virtualCallIVMOTable();
	(void) tmpsize;
	for (hcindex = virtualCallIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCallIVMOTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->virtualCallIVMOTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCallIVMOTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCallIVMOfastSelect, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOpacketSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOpacketSizes, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOreverseChargingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOreverseCharging, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOthroughputClassesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOthroughputClasses, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOwindowSizesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOwindowSizes, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOproposedPacketSizeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOproposedPacketSize, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOproposedWindowSizeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOproposedWindowSize, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOacceptReverseChargingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOacceptReverseCharging, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOproposeReverseChargingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOproposeReverseCharging, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOcallTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOcallTime, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOresetTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOresetTime, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOclearTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOclearTime, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOinterruptTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOinterruptTime, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOresetCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOresetCount, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOclearCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOclearCount, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOwindowTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOwindowTime, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOdataRetransmissionTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOdataRetransmissionTime, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOdataRetransmissionCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOdataRetransmissionCount, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOrejectTimeLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOrejectTime, &tmpsize);
			tmpsize = StorageTmp->virtualCallIVMOrejectCountLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOrejectCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCallIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCallIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * switchedVirtualCallTable_add(): adds a structure node to our data set
 */
int
switchedVirtualCallTable_add(struct switchedVirtualCallTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("switchedVirtualCallTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCallId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallId, thedata->virtualCallIdLen);
	header_complex_add_data(&switchedVirtualCallTableStorage, vars, thedata);
	DEBUGMSGTL(("switchedVirtualCallTable", "registered an entry\n"));
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * switchedVirtualCallTable_del(): delete a structure
 */
int
switchedVirtualCallTable_del(struct switchedVirtualCallTable_data **thedata)
{
	struct switchedVirtualCallTable_data *StorageDel;

	DEBUGMSGTL(("switchedVirtualCallTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallId);
		StorageDel->virtualCallIdLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCalldirection);
		StorageDel->switchedVirtualCalldirectionLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallremoteDTEAddress);
		StorageDel->switchedVirtualCallremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallthroughputClass);
		StorageDel->switchedVirtualCallthroughputClassLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallredirectReason);
		StorageDel->switchedVirtualCallredirectReasonLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCalloriginallyCalledAddress);
		StorageDel->switchedVirtualCalloriginallyCalledAddressLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallcallingAddressExtension);
		StorageDel->switchedVirtualCallcallingAddressExtensionLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallcalledAddressExtension);
		StorageDel->switchedVirtualCallcalledAddressExtensionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_switchedVirtualCallTable(): parse configuration file for switchedVirtualCallTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_switchedVirtualCallTable(const char *token, char *line)
{
	size_t tmpsize;
	struct switchedVirtualCallTable_data *StorageTmp = SNMP_MALLOC_STRUCT(switchedVirtualCallTable_data);

	DEBUGMSGTL(("switchedVirtualCallTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallId, &tmpsize);
	StorageTmp->virtualCallIdLen = tmpsize;
	if (StorageTmp->virtualCallId == NULL) {
		config_perror("invalid specification for virtualCallId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCalldirection, &tmpsize);
	StorageTmp->switchedVirtualCalldirectionLen = tmpsize;
	if (StorageTmp->switchedVirtualCalldirection == NULL) {
		config_perror("invalid specification for switchedVirtualCalldirection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallremoteDTEAddress, &tmpsize);
	StorageTmp->switchedVirtualCallremoteDTEAddressLen = tmpsize;
	if (StorageTmp->switchedVirtualCallremoteDTEAddress == NULL) {
		config_perror("invalid specification for switchedVirtualCallremoteDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallthroughputClass, &tmpsize);
	StorageTmp->switchedVirtualCallthroughputClassLen = tmpsize;
	if (StorageTmp->switchedVirtualCallthroughputClass == NULL) {
		config_perror("invalid specification for switchedVirtualCallthroughputClass");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallredirectReason, &tmpsize);
	StorageTmp->switchedVirtualCallredirectReasonLen = tmpsize;
	if (StorageTmp->switchedVirtualCallredirectReason == NULL) {
		config_perror("invalid specification for switchedVirtualCallredirectReason");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCalloriginallyCalledAddress, &tmpsize);
	StorageTmp->switchedVirtualCalloriginallyCalledAddressLen = tmpsize;
	if (StorageTmp->switchedVirtualCalloriginallyCalledAddress == NULL) {
		config_perror("invalid specification for switchedVirtualCalloriginallyCalledAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallcallingAddressExtension, &tmpsize);
	StorageTmp->switchedVirtualCallcallingAddressExtensionLen = tmpsize;
	if (StorageTmp->switchedVirtualCallcallingAddressExtension == NULL) {
		config_perror("invalid specification for switchedVirtualCallcallingAddressExtension");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallcalledAddressExtension, &tmpsize);
	StorageTmp->switchedVirtualCallcalledAddressExtensionLen = tmpsize;
	if (StorageTmp->switchedVirtualCallcalledAddressExtension == NULL) {
		config_perror("invalid specification for switchedVirtualCallcalledAddressExtension");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->switchedVirtualCallRowStatus, &tmpsize);
	switchedVirtualCallTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
}

/*
 * store_switchedVirtualCallTable(): store configuraiton file for switchedVirtualCallTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_switchedVirtualCallTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct switchedVirtualCallTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("switchedVirtualCallTable", "storing data...  "));
	refresh_switchedVirtualCallTable();
	(void) tmpsize;
	for (hcindex = switchedVirtualCallTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct switchedVirtualCallTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->switchedVirtualCallTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "switchedVirtualCallTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			tmpsize = StorageTmp->virtualCallIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallId, &tmpsize);
			tmpsize = StorageTmp->switchedVirtualCalldirectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCalldirection, &tmpsize);
			tmpsize = StorageTmp->switchedVirtualCallremoteDTEAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallremoteDTEAddress, &tmpsize);
			tmpsize = StorageTmp->switchedVirtualCallthroughputClassLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallthroughputClass, &tmpsize);
			tmpsize = StorageTmp->switchedVirtualCallredirectReasonLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallredirectReason, &tmpsize);
			tmpsize = StorageTmp->switchedVirtualCalloriginallyCalledAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCalloriginallyCalledAddress, &tmpsize);
			tmpsize = StorageTmp->switchedVirtualCallcallingAddressExtensionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallcallingAddressExtension, &tmpsize);
			tmpsize = StorageTmp->switchedVirtualCallcalledAddressExtensionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallcalledAddressExtension, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->switchedVirtualCallRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("switchedVirtualCallTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCall-DTETable_add(): adds a structure node to our data set
 */
int
 virtualCall -
DTETable_add(struct virtualCall -DTETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCall-DTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCall - DTETableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCall-DTETable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCall-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCall-DTETable_del(): delete a structure
 */
int
 virtualCall -
DTETable_del(struct virtualCall -DTETable_data ** thedata)
{
	struct virtualCall -DTETable_data * StorageDel;

	DEBUGMSGTL(("virtualCall-DTETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DTEcallingAddressExtension);
		StorageDel->virtualCall - DTEcallingAddressExtensionLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DTEcalledAddressExtension);
		StorageDel->virtualCall - DTEcalledAddressExtensionLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DTEdirection);
		StorageDel->virtualCall - DTEdirectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DTEoriginallyCalledAddress);
		StorageDel->virtualCall - DTEoriginallyCalledAddressLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DTEredirectReason);
		StorageDel->virtualCall - DTEredirectReasonLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DTEremoteDTEAddress);
		StorageDel->virtualCall - DTEremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DTEreverseCharging);
		StorageDel->virtualCall - DTEreverseChargingLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCall-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_virtualCall-DTETable(): parse configuration file for virtualCall-DTETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_virtualCall -
DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCall -DTETable_data * StorageTmp = SNMP_MALLOC_STRUCT(virtualCall - DTETable_data);

	DEBUGMSGTL(("virtualCall-DTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &tmpsize);
	StorageTmp->virtualCircuitIdLen = tmpsize;
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DTEcallingAddressExtension, &tmpsize);
	StorageTmp->virtualCall - DTEcallingAddressExtensionLen = tmpsize;
	if (StorageTmp->virtualCall - DTEcallingAddressExtension == NULL) {
		config_perror("invalid specification for virtualCall-DTEcallingAddressExtension");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DTEcalledAddressExtension, &tmpsize);
	StorageTmp->virtualCall - DTEcalledAddressExtensionLen = tmpsize;
	if (StorageTmp->virtualCall - DTEcalledAddressExtension == NULL) {
		config_perror("invalid specification for virtualCall-DTEcalledAddressExtension");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DTEdirection, &tmpsize);
	StorageTmp->virtualCall - DTEdirectionLen = tmpsize;
	if (StorageTmp->virtualCall - DTEdirection == NULL) {
		config_perror("invalid specification for virtualCall-DTEdirection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall - DTEfastSelect, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DTEoriginallyCalledAddress, &tmpsize);
	StorageTmp->virtualCall - DTEoriginallyCalledAddressLen = tmpsize;
	if (StorageTmp->virtualCall - DTEoriginallyCalledAddress == NULL) {
		config_perror("invalid specification for virtualCall-DTEoriginallyCalledAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DTEredirectReason, &tmpsize);
	StorageTmp->virtualCall - DTEredirectReasonLen = tmpsize;
	if (StorageTmp->virtualCall - DTEredirectReason == NULL) {
		config_perror("invalid specification for virtualCall-DTEredirectReason");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DTEremoteDTEAddress, &tmpsize);
	StorageTmp->virtualCall - DTEremoteDTEAddressLen = tmpsize;
	if (StorageTmp->virtualCall - DTEremoteDTEAddress == NULL) {
		config_perror("invalid specification for virtualCall-DTEremoteDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DTEreverseCharging, &tmpsize);
	StorageTmp->virtualCall - DTEreverseChargingLen = tmpsize;
	if (StorageTmp->virtualCall - DTEreverseCharging == NULL) {
		config_perror("invalid specification for virtualCall-DTEreverseCharging");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall - DTERowStatus, &tmpsize);
	virtualCall - DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCall-DTETable", "done.\n"));
}

/*
 * store_virtualCall-DTETable(): store configuraiton file for virtualCall-DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_virtualCall -
DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCall -DTETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCall-DTETable", "storing data...  "));
	refresh_virtualCall - DTETable();
	(void) tmpsize;
	for (hcindex = virtualCall - DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCall - DTETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->virtualCall-DTETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCall-DTETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			tmpsize = StorageTmp->virtualCircuitIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DTEcallingAddressExtensionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DTEcallingAddressExtension, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DTEcalledAddressExtensionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DTEcalledAddressExtension, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DTEdirectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DTEdirection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall - DTEfastSelect, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DTEoriginallyCalledAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DTEoriginallyCalledAddress, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DTEredirectReasonLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DTEredirectReason, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DTEremoteDTEAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DTEremoteDTEAddress, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DTEreverseChargingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DTEreverseCharging, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall - DTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCall-DTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCall-DCETable_add(): adds a structure node to our data set
 */
int
 virtualCall -
DCETable_add(struct virtualCall -DCETable_data * thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualCall-DCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	header_complex_add_data(&virtualCall - DCETableStorage, vars, thedata);
	DEBUGMSGTL(("virtualCall-DCETable", "registered an entry\n"));
	DEBUGMSGTL(("virtualCall-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualCall-DCETable_del(): delete a structure
 */
int
 virtualCall -
DCETable_del(struct virtualCall -DCETable_data ** thedata)
{
	struct virtualCall -DCETable_data * StorageDel;

	DEBUGMSGTL(("virtualCall-DCETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCEchargingDirection);
		StorageDel->virtualCall - DCEchargingDirectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCEcUGSelection);
		StorageDel->virtualCall - DCEcUGSelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCEdirection);
		StorageDel->virtualCall - DCEdirectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCEremoteDTEAddress);
		StorageDel->virtualCall - DCEremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCEtransitDelaySelectionAndIndication);
		StorageDel->virtualCall - DCEtransitDelaySelectionAndIndicationLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCEbilateralCUGSelection);
		StorageDel->virtualCall - DCEbilateralCUGSelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCEcUGWithOutgoingAccessSelection);
		StorageDel->virtualCall - DCEcUGWithOutgoingAccessSelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCEnUISelection);
		StorageDel->virtualCall - DCEnUISelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCEreverseCharging);
		StorageDel->virtualCall - DCEreverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCall - DCErOASelection);
		StorageDel->virtualCall - DCErOASelectionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualCall-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_virtualCall-DCETable(): parse configuration file for virtualCall-DCETable
 * parses .conf file entries needed to configure the mib.
 */
void
 parse_virtualCall -
DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCall -DCETable_data * StorageTmp = SNMP_MALLOC_STRUCT(virtualCall - DCETable_data);

	DEBUGMSGTL(("virtualCall-DCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &tmpsize);
	StorageTmp->virtualCircuitIdLen = tmpsize;
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCEchargingDirection, &tmpsize);
	StorageTmp->virtualCall - DCEchargingDirectionLen = tmpsize;
	if (StorageTmp->virtualCall - DCEchargingDirection == NULL) {
		config_perror("invalid specification for virtualCall-DCEchargingDirection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCEcUGSelection, &tmpsize);
	StorageTmp->virtualCall - DCEcUGSelectionLen = tmpsize;
	if (StorageTmp->virtualCall - DCEcUGSelection == NULL) {
		config_perror("invalid specification for virtualCall-DCEcUGSelection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCEdirection, &tmpsize);
	StorageTmp->virtualCall - DCEdirectionLen = tmpsize;
	if (StorageTmp->virtualCall - DCEdirection == NULL) {
		config_perror("invalid specification for virtualCall-DCEdirection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall - DCEfastSelect, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCEremoteDTEAddress, &tmpsize);
	StorageTmp->virtualCall - DCEremoteDTEAddressLen = tmpsize;
	if (StorageTmp->virtualCall - DCEremoteDTEAddress == NULL) {
		config_perror("invalid specification for virtualCall-DCEremoteDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCEtransitDelaySelectionAndIndication, &tmpsize);
	StorageTmp->virtualCall - DCEtransitDelaySelectionAndIndicationLen = tmpsize;
	if (StorageTmp->virtualCall - DCEtransitDelaySelectionAndIndication == NULL) {
		config_perror("invalid specification for virtualCall-DCEtransitDelaySelectionAndIndication");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCEbilateralCUGSelection, &tmpsize);
	StorageTmp->virtualCall - DCEbilateralCUGSelectionLen = tmpsize;
	if (StorageTmp->virtualCall - DCEbilateralCUGSelection == NULL) {
		config_perror("invalid specification for virtualCall-DCEbilateralCUGSelection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall - DCEcallRedirectionDeflectionNotification, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall - DCEcalledLineAddressModifiedNotification, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCEcUGWithOutgoingAccessSelection, &tmpsize);
	StorageTmp->virtualCall - DCEcUGWithOutgoingAccessSelectionLen = tmpsize;
	if (StorageTmp->virtualCall - DCEcUGWithOutgoingAccessSelection == NULL) {
		config_perror("invalid specification for virtualCall-DCEcUGWithOutgoingAccessSelection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCEnUISelection, &tmpsize);
	StorageTmp->virtualCall - DCEnUISelectionLen = tmpsize;
	if (StorageTmp->virtualCall - DCEnUISelection == NULL) {
		config_perror("invalid specification for virtualCall-DCEnUISelection");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCEreverseCharging, &tmpsize);
	StorageTmp->virtualCall - DCEreverseChargingLen = tmpsize;
	if (StorageTmp->virtualCall - DCEreverseCharging == NULL) {
		config_perror("invalid specification for virtualCall-DCEreverseCharging");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall - DCErOASelection, &tmpsize);
	StorageTmp->virtualCall - DCErOASelectionLen = tmpsize;
	if (StorageTmp->virtualCall - DCErOASelection == NULL) {
		config_perror("invalid specification for virtualCall-DCErOASelection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall - DCERowStatus, &tmpsize);
	virtualCall - DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualCall-DCETable", "done.\n"));
}

/*
 * store_virtualCall-DCETable(): store configuraiton file for virtualCall-DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
 store_virtualCall -
DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCall -DCETable_data * StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualCall-DCETable", "storing data...  "));
	refresh_virtualCall - DCETable();
	(void) tmpsize;
	for (hcindex = virtualCall - DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCall - DCETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->virtualCall-DCETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCall-DCETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			tmpsize = StorageTmp->virtualCircuitIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCEchargingDirectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCEchargingDirection, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCEcUGSelectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCEcUGSelection, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCEdirectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCEdirection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall - DCEfastSelect, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCEremoteDTEAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCEremoteDTEAddress, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCEtransitDelaySelectionAndIndicationLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCEtransitDelaySelectionAndIndication, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCEbilateralCUGSelectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCEbilateralCUGSelection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall - DCEcallRedirectionDeflectionNotification, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall - DCEcalledLineAddressModifiedNotification, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCEcUGWithOutgoingAccessSelectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCEcUGWithOutgoingAccessSelection, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCEnUISelectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCEnUISelection, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCEreverseChargingLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCEreverseCharging, &tmpsize);
			tmpsize = StorageTmp->virtualCall - DCErOASelectionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall - DCErOASelection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall - DCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualCall-DCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * dSeriesCountsTable_add(): adds a structure node to our data set
 */
int
dSeriesCountsTable_add(struct dSeriesCountsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dSeriesCountsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
	/* virtualCircuitId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
	/* dSeriesId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->dSeriesId, thedata->dSeriesIdLen);
	header_complex_add_data(&dSeriesCountsTableStorage, vars, thedata);
	DEBUGMSGTL(("dSeriesCountsTable", "registered an entry\n"));
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * dSeriesCountsTable_del(): delete a structure
 */
int
dSeriesCountsTable_del(struct dSeriesCountsTable_data **thedata)
{
	struct dSeriesCountsTable_data *StorageDel;

	DEBUGMSGTL(("dSeriesCountsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->dSeriesId);
		StorageDel->dSeriesIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_dSeriesCountsTable(): parse configuration file for dSeriesCountsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_dSeriesCountsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dSeriesCountsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(dSeriesCountsTable_data);

	DEBUGMSGTL(("dSeriesCountsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &tmpsize);
	StorageTmp->virtualCircuitIdLen = tmpsize;
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dSeriesId, &tmpsize);
	StorageTmp->dSeriesIdLen = tmpsize;
	if (StorageTmp->dSeriesId == NULL) {
		config_perror("invalid specification for dSeriesId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dSeriesResetRequestIndicationPackets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dSeriesSegmentsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dSeriesSegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dSeriesRowStatus, &tmpsize);
	dSeriesCountsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
}

/*
 * store_dSeriesCountsTable(): store configuraiton file for dSeriesCountsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dSeriesCountsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dSeriesCountsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dSeriesCountsTable", "storing data...  "));
	refresh_dSeriesCountsTable();
	(void) tmpsize;
	for (hcindex = dSeriesCountsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dSeriesCountsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->dSeriesCountsTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dSeriesCountsTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->x25PLEIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
			tmpsize = StorageTmp->virtualCircuitIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &tmpsize);
			tmpsize = StorageTmp->dSeriesIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dSeriesId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dSeriesResetRequestIndicationPackets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dSeriesSegmentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dSeriesSegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dSeriesRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dSeriesCountsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * adjacencyTable_add(): adds a structure node to our data set
 */
int
adjacencyTable_add(struct adjacencyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("adjacencyTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* linkageId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->linkageId, thedata->linkageIdLen);
	/* adjacencyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->adjacencyId, thedata->adjacencyIdLen);
	header_complex_add_data(&adjacencyTableStorage, vars, thedata);
	DEBUGMSGTL(("adjacencyTable", "registered an entry\n"));
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * adjacencyTable_del(): delete a structure
 */
int
adjacencyTable_del(struct adjacencyTable_data **thedata)
{
	struct adjacencyTable_data *StorageDel;

	DEBUGMSGTL(("adjacencyTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->linkageId);
		StorageDel->linkageIdLen = 0;
		SNMP_FREE(StorageDel->adjacencyId);
		StorageDel->adjacencyIdLen = 0;
		SNMP_FREE(StorageDel->neighbourSNPAAddress);
		StorageDel->neighbourSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->neighbourSystemIds);
		StorageDel->neighbourSystemIdsLen = 0;
		SNMP_FREE(StorageDel->areaAddressesOfNeighbour);
		StorageDel->areaAddressesOfNeighbourLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_adjacencyTable(): parse configuration file for adjacencyTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_adjacencyTable(const char *token, char *line)
{
	size_t tmpsize;
	struct adjacencyTable_data *StorageTmp = SNMP_MALLOC_STRUCT(adjacencyTable_data);

	DEBUGMSGTL(("adjacencyTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageId, &tmpsize);
	StorageTmp->linkageIdLen = tmpsize;
	if (StorageTmp->linkageId == NULL) {
		config_perror("invalid specification for linkageId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->adjacencyId, &tmpsize);
	StorageTmp->adjacencyIdLen = tmpsize;
	if (StorageTmp->adjacencyId == NULL) {
		config_perror("invalid specification for adjacencyId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->adjacencyState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->neighbourSNPAAddress, &tmpsize);
	StorageTmp->neighbourSNPAAddressLen = tmpsize;
	if (StorageTmp->neighbourSNPAAddress == NULL) {
		config_perror("invalid specification for neighbourSNPAAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->neighbourSystemType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->neighbourSystemIds, &tmpsize);
	StorageTmp->neighbourSystemIdsLen = tmpsize;
	if (StorageTmp->neighbourSystemIds == NULL) {
		config_perror("invalid specification for neighbourSystemIds");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->adjacencyUsage, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->areaAddressesOfNeighbour, &tmpsize);
	StorageTmp->areaAddressesOfNeighbourLen = tmpsize;
	if (StorageTmp->areaAddressesOfNeighbour == NULL) {
		config_perror("invalid specification for areaAddressesOfNeighbour");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->holdingTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->priorityOfNeighbour, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->adjacencyRowStatus, &tmpsize);
	adjacencyTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
}

/*
 * store_adjacencyTable(): store configuraiton file for adjacencyTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_adjacencyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct adjacencyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("adjacencyTable", "storing data...  "));
	refresh_adjacencyTable();
	(void) tmpsize;
	for (hcindex = adjacencyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct adjacencyTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->adjacencyTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "adjacencyTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->linkageIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageId, &tmpsize);
			tmpsize = StorageTmp->adjacencyIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->adjacencyId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->adjacencyState, &tmpsize);
			tmpsize = StorageTmp->neighbourSNPAAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->neighbourSNPAAddress, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->neighbourSystemType, &tmpsize);
			tmpsize = StorageTmp->neighbourSystemIdsLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->neighbourSystemIds, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->adjacencyUsage, &tmpsize);
			tmpsize = StorageTmp->areaAddressesOfNeighbourLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->areaAddressesOfNeighbour, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->holdingTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->priorityOfNeighbour, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->adjacencyRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("adjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualAdjacencyTable_add(): adds a structure node to our data set
 */
int
virtualAdjacencyTable_add(struct virtualAdjacencyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("virtualAdjacencyTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* virtualAdjacencyNetworkEntityTitle */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualAdjacencyNetworkEntityTitle, thedata->virtualAdjacencyNetworkEntityTitleLen);
	header_complex_add_data(&virtualAdjacencyTableStorage, vars, thedata);
	DEBUGMSGTL(("virtualAdjacencyTable", "registered an entry\n"));
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * virtualAdjacencyTable_del(): delete a structure
 */
int
virtualAdjacencyTable_del(struct virtualAdjacencyTable_data **thedata)
{
	struct virtualAdjacencyTable_data *StorageDel;

	DEBUGMSGTL(("virtualAdjacencyTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->virtualAdjacencyNetworkEntityTitle);
		StorageDel->virtualAdjacencyNetworkEntityTitleLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_virtualAdjacencyTable(): parse configuration file for virtualAdjacencyTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_virtualAdjacencyTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualAdjacencyTable_data *StorageTmp = SNMP_MALLOC_STRUCT(virtualAdjacencyTable_data);

	DEBUGMSGTL(("virtualAdjacencyTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualAdjacencyNetworkEntityTitle, &tmpsize);
	StorageTmp->virtualAdjacencyNetworkEntityTitleLen = tmpsize;
	if (StorageTmp->virtualAdjacencyNetworkEntityTitle == NULL) {
		config_perror("invalid specification for virtualAdjacencyNetworkEntityTitle");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualAdjacencyMetric, &tmpsize);
	virtualAdjacencyTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
}

/*
 * store_virtualAdjacencyTable(): store configuraiton file for virtualAdjacencyTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualAdjacencyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualAdjacencyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("virtualAdjacencyTable", "storing data...  "));
	refresh_virtualAdjacencyTable();
	(void) tmpsize;
	for (hcindex = virtualAdjacencyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualAdjacencyTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->virtualAdjacencyTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualAdjacencyTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->virtualAdjacencyNetworkEntityTitleLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualAdjacencyNetworkEntityTitle, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualAdjacencyMetric, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("virtualAdjacencyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * destinationTable_add(): adds a structure node to our data set
 */
int
destinationTable_add(struct destinationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("destinationTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* destinationAddressPrefix */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->destinationAddressPrefix, thedata->destinationAddressPrefixLen);
	header_complex_add_data(&destinationTableStorage, vars, thedata);
	DEBUGMSGTL(("destinationTable", "registered an entry\n"));
	DEBUGMSGTL(("destinationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * destinationTable_del(): delete a structure
 */
int
destinationTable_del(struct destinationTable_data **thedata)
{
	struct destinationTable_data *StorageDel;

	DEBUGMSGTL(("destinationTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->destinationAddressPrefix);
		StorageDel->destinationAddressPrefixLen = 0;
		SNMP_FREE(StorageDel->destinationDefaultMetricOutputAdjacencies);
		StorageDel->destinationDefaultMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel->destinationDelayMetricOutputAdjacencies);
		StorageDel->destinationDelayMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel->destinationExpenseMetricOutputAdjacencies);
		StorageDel->destinationExpenseMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel->destinationErrorMetricOutputAdjacencies);
		StorageDel->destinationErrorMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("destinationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_destinationTable(): parse configuration file for destinationTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_destinationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct destinationTable_data *StorageTmp = SNMP_MALLOC_STRUCT(destinationTable_data);

	DEBUGMSGTL(("destinationTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationAddressPrefix, &tmpsize);
	StorageTmp->destinationAddressPrefixLen = tmpsize;
	if (StorageTmp->destinationAddressPrefix == NULL) {
		config_perror("invalid specification for destinationAddressPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationDefaultMetricPathCost, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationDefaultMetricOutputAdjacencies, &tmpsize);
	StorageTmp->destinationDefaultMetricOutputAdjacenciesLen = tmpsize;
	if (StorageTmp->destinationDefaultMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationDefaultMetricOutputAdjacencies");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationDelayMetricPathCost, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationDelayMetricOutputAdjacencies, &tmpsize);
	StorageTmp->destinationDelayMetricOutputAdjacenciesLen = tmpsize;
	if (StorageTmp->destinationDelayMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationDelayMetricOutputAdjacencies");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationExpenseMetricPathCost, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationExpenseMetricOutputAdjacencies, &tmpsize);
	StorageTmp->destinationExpenseMetricOutputAdjacenciesLen = tmpsize;
	if (StorageTmp->destinationExpenseMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationExpenseMetricOutputAdjacencies");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationErrorMetricPathCost, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationErrorMetricOutputAdjacencies, &tmpsize);
	StorageTmp->destinationErrorMetricOutputAdjacenciesLen = tmpsize;
	if (StorageTmp->destinationErrorMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationErrorMetricOutputAdjacencies");
		return;
	}

	destinationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("destinationTable", "done.\n"));
}

/*
 * store_destinationTable(): store configuraiton file for destinationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_destinationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct destinationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("destinationTable", "storing data...  "));
	refresh_destinationTable();
	(void) tmpsize;
	for (hcindex = destinationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct destinationTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->destinationTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "destinationTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->destinationAddressPrefixLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationAddressPrefix, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationDefaultMetricPathCost, &tmpsize);
			tmpsize = StorageTmp->destinationDefaultMetricOutputAdjacenciesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationDefaultMetricOutputAdjacencies, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationDelayMetricPathCost, &tmpsize);
			tmpsize = StorageTmp->destinationDelayMetricOutputAdjacenciesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationDelayMetricOutputAdjacencies, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationExpenseMetricPathCost, &tmpsize);
			tmpsize = StorageTmp->destinationExpenseMetricOutputAdjacenciesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationExpenseMetricOutputAdjacencies, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationErrorMetricPathCost, &tmpsize);
			tmpsize = StorageTmp->destinationErrorMetricOutputAdjacenciesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationErrorMetricOutputAdjacencies, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("destinationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * destinationSystemTable_add(): adds a structure node to our data set
 */
int
destinationSystemTable_add(struct destinationSystemTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("destinationSystemTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* communicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
	/* clProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
	/* destinationSystemNetworkEntityTitle */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->destinationSystemNetworkEntityTitle, thedata->destinationSystemNetworkEntityTitleLen);
	/* destinationSystemMetricType */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->destinationSystemMetricType, sizeof(thedata->destinationSystemMetricType));
	/* destinationSystemAdjacency */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OBJECT_ID, (u_char *) thedata->destinationSystemAdjacency, thedata->destinationSystemAdjacencyLen);
	header_complex_add_data(&destinationSystemTableStorage, vars, thedata);
	DEBUGMSGTL(("destinationSystemTable", "registered an entry\n"));
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * destinationSystemTable_del(): delete a structure
 */
int
destinationSystemTable_del(struct destinationSystemTable_data **thedata)
{
	struct destinationSystemTable_data *StorageDel;

	DEBUGMSGTL(("destinationSystemTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->destinationSystemNetworkEntityTitle);
		StorageDel->destinationSystemNetworkEntityTitleLen = 0;
		SNMP_FREE(StorageDel->destinationSystemAdjacency);
		StorageDel->destinationSystemAdjacencyLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_destinationSystemTable(): parse configuration file for destinationSystemTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_destinationSystemTable(const char *token, char *line)
{
	size_t tmpsize;
	struct destinationSystemTable_data *StorageTmp = SNMP_MALLOC_STRUCT(destinationSystemTable_data);

	DEBUGMSGTL(("destinationSystemTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &tmpsize);
	StorageTmp->communicationsEntityIdLen = tmpsize;
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &tmpsize);
	StorageTmp->clProtocolMachineIdLen = tmpsize;
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationSystemNetworkEntityTitle, &tmpsize);
	StorageTmp->destinationSystemNetworkEntityTitleLen = tmpsize;
	if (StorageTmp->destinationSystemNetworkEntityTitle == NULL) {
		config_perror("invalid specification for destinationSystemNetworkEntityTitle");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationSystemMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->desintationSystemMetric, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->destinationSystemAdjacency, &tmpsize);
	StorageTmp->destinationSystemAdjacencyLen = tmpsize;
	if (StorageTmp->destinationSystemAdjacency == NULL) {
		config_perror("invalid specification for destinationSystemAdjacency");
		return;
	}

	destinationSystemTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
}

/*
 * store_destinationSystemTable(): store configuraiton file for destinationSystemTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_destinationSystemTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct destinationSystemTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("destinationSystemTable", "storing data...  "));
	refresh_destinationSystemTable();
	(void) tmpsize;
	for (hcindex = destinationSystemTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct destinationSystemTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->destinationSystemTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "destinationSystemTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->communicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->clProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &tmpsize);
			tmpsize = StorageTmp->destinationSystemNetworkEntityTitleLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationSystemNetworkEntityTitle, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationSystemMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->desintationSystemMetric, &tmpsize);
			tmpsize = StorageTmp->destinationSystemAdjacencyLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->destinationSystemAdjacency, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("destinationSystemTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * destinationAreaTable_add(): adds a structure node to our data set
 */
int
destinationAreaTable_add(struct destinationAreaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("destinationAreaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* destinationAreaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->destinationAreaId, thedata->destinationAreaIdLen);
	header_complex_add_data(&destinationAreaTableStorage, vars, thedata);
	DEBUGMSGTL(("destinationAreaTable", "registered an entry\n"));
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * destinationAreaTable_del(): delete a structure
 */
int
destinationAreaTable_del(struct destinationAreaTable_data **thedata)
{
	struct destinationAreaTable_data *StorageDel;

	DEBUGMSGTL(("destinationAreaTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->destinationAreaId);
		StorageDel->destinationAreaIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_destinationAreaTable(): parse configuration file for destinationAreaTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_destinationAreaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct destinationAreaTable_data *StorageTmp = SNMP_MALLOC_STRUCT(destinationAreaTable_data);

	DEBUGMSGTL(("destinationAreaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationAreaId, &tmpsize);
	StorageTmp->destinationAreaIdLen = tmpsize;
	if (StorageTmp->destinationAreaId == NULL) {
		config_perror("invalid specification for destinationAreaId");
		return;
	}

	destinationAreaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
}

/*
 * store_destinationAreaTable(): store configuraiton file for destinationAreaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_destinationAreaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct destinationAreaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("destinationAreaTable", "storing data...  "));
	refresh_destinationAreaTable();
	(void) tmpsize;
	for (hcindex = destinationAreaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct destinationAreaTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->destinationAreaTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "destinationAreaTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->destinationAreaIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationAreaId, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("destinationAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * reachableAddressTable_add(): adds a structure node to our data set
 */
int
reachableAddressTable_add(struct reachableAddressTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("reachableAddressTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* reachableAddressId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->reachableAddressId, thedata->reachableAddressIdLen);
	header_complex_add_data(&reachableAddressTableStorage, vars, thedata);
	DEBUGMSGTL(("reachableAddressTable", "registered an entry\n"));
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * reachableAddressTable_del(): delete a structure
 */
int
reachableAddressTable_del(struct reachableAddressTable_data **thedata)
{
	struct reachableAddressTable_data *StorageDel;

	DEBUGMSGTL(("reachableAddressTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->reachableAddressId);
		StorageDel->reachableAddressIdLen = 0;
		SNMP_FREE(StorageDel->reachableAddressPrefix);
		StorageDel->reachableAddressPrefixLen = 0;
		SNMP_FREE(StorageDel->reachableAddressSNPAAddresses);
		StorageDel->reachableAddressSNPAAddressesLen = 0;
		SNMP_FREE(StorageDel->reachableAddressSNPAMask);
		StorageDel->reachableAddressSNPAMaskLen = 0;
		SNMP_FREE(StorageDel->reachableAddressSNPAPrefix);
		StorageDel->reachableAddressSNPAPrefixLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_reachableAddressTable(): parse configuration file for reachableAddressTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_reachableAddressTable(const char *token, char *line)
{
	size_t tmpsize;
	struct reachableAddressTable_data *StorageTmp = SNMP_MALLOC_STRUCT(reachableAddressTable_data);

	DEBUGMSGTL(("reachableAddressTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressId, &tmpsize);
	StorageTmp->reachableAddressIdLen = tmpsize;
	if (StorageTmp->reachableAddressId == NULL) {
		config_perror("invalid specification for reachableAddressId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressPrefix, &tmpsize);
	StorageTmp->reachableAddressPrefixLen = tmpsize;
	if (StorageTmp->reachableAddressPrefix == NULL) {
		config_perror("invalid specification for reachableAddressPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressMappingType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDefaultMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDelayMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressExpenseMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressErrorMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDefaultMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDelayMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressExpenseMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressErrorMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressSNPAAddresses, &tmpsize);
	StorageTmp->reachableAddressSNPAAddressesLen = tmpsize;
	if (StorageTmp->reachableAddressSNPAAddresses == NULL) {
		config_perror("invalid specification for reachableAddressSNPAAddresses");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressSNPAMask, &tmpsize);
	StorageTmp->reachableAddressSNPAMaskLen = tmpsize;
	if (StorageTmp->reachableAddressSNPAMask == NULL) {
		config_perror("invalid specification for reachableAddressSNPAMask");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressSNPAPrefix, &tmpsize);
	StorageTmp->reachableAddressSNPAPrefixLen = tmpsize;
	if (StorageTmp->reachableAddressSNPAPrefix == NULL) {
		config_perror("invalid specification for reachableAddressSNPAPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressRowStatus, &tmpsize);
	reachableAddressTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
}

/*
 * store_reachableAddressTable(): store configuraiton file for reachableAddressTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_reachableAddressTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct reachableAddressTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("reachableAddressTable", "storing data...  "));
	refresh_reachableAddressTable();
	(void) tmpsize;
	for (hcindex = reachableAddressTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct reachableAddressTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->reachableAddressTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "reachableAddressTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->reachableAddressIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressId, &tmpsize);
			tmpsize = StorageTmp->reachableAddressPrefixLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressPrefix, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressMappingType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDefaultMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDelayMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressExpenseMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressErrorMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDefaultMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDelayMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressExpenseMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressErrorMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressAdministrativeState, &tmpsize);
			tmpsize = StorageTmp->reachableAddressSNPAAddressesLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressSNPAAddresses, &tmpsize);
			tmpsize = StorageTmp->reachableAddressSNPAMaskLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressSNPAMask, &tmpsize);
			tmpsize = StorageTmp->reachableAddressSNPAPrefixLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressSNPAPrefix, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("reachableAddressTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_communicationsEntityTable(): refresh communicationsEntityTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_communicationsEntityTable(void)
{
	if (communicationsEntityTable_refresh == 0)
		return;
	communicationsEntityTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_communicationsEntityTable_row(): refresh communicationsEntityTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_communicationsEntityTable_row(struct communicationsEntityTable_data *StorageTmp)
{
	if (StorageTmp->communicationsEntityTable_request == sa_request)
		return;
	StorageTmp->communicationsEntityTable_request = sa_request;
}

/*
 * var_communicationsEntityTable(): locate variables in communicationsEntityTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_communicationsEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct communicationsEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_communicationsEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_communicationsEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(communicationsEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_communicationsEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case COMMUNICATIONSENTITYLOCALSAPNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->communicationsEntityLocalSapNamesLen;
		return (u_char *) StorageTmp->communicationsEntityLocalSapNames;
	case COMMUNICATIONSENTITYOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->communicationsEntityOperationalState);
		return (u_char *) &StorageTmp->communicationsEntityOperationalState;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sap1Table(): refresh sap1Table
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sap1Table(void)
{
	if (sap1Table_refresh == 0)
		return;
	sap1Table_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sap1Table_row(): refresh sap1Table row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sap1Table_row(struct sap1Table_data *StorageTmp)
{
	if (StorageTmp->sap1Table_request == sa_request)
		return;
	StorageTmp->sap1Table_request = sa_request;
}

/*
 * var_sap1Table(): locate variables in sap1Table
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sap1Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sap1Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sap1Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sap1Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sap1TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sap1Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SAP1ADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sap1Address);
		return (u_char *) &StorageTmp->sap1Address;
	case SAP1USERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sap1UserEntityNamesLen;
		return (u_char *) StorageTmp->sap1UserEntityNames;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sap2Table(): refresh sap2Table
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sap2Table(void)
{
	if (sap2Table_refresh == 0)
		return;
	sap2Table_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sap2Table_row(): refresh sap2Table row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sap2Table_row(struct sap2Table_data *StorageTmp)
{
	if (StorageTmp->sap2Table_request == sa_request)
		return;
	StorageTmp->sap2Table_request = sa_request;
}

/*
 * var_sap2Table(): locate variables in sap2Table
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sap2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sap2Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sap2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sap2Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sap2TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sap2Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SAP2ADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sap2AddressLen;
		return (u_char *) StorageTmp->sap2Address;
	case SAP2USERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sap2UserEntityNamesLen;
		return (u_char *) StorageTmp->sap2UserEntityNames;
	case SAP2PROVIDERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sap2ProviderEntityNamesLen;
		return (u_char *) StorageTmp->sap2ProviderEntityNames;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_clProtocolMachineTable(): refresh clProtocolMachineTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_clProtocolMachineTable(void)
{
	if (clProtocolMachineTable_refresh == 0)
		return;
	clProtocolMachineTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_clProtocolMachineTable_row(): refresh clProtocolMachineTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_clProtocolMachineTable_row(struct clProtocolMachineTable_data *StorageTmp)
{
	if (StorageTmp->clProtocolMachineTable_request == sa_request)
		return;
	StorageTmp->clProtocolMachineTable_request = sa_request;
}

/*
 * var_clProtocolMachineTable(): locate variables in clProtocolMachineTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_clProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct clProtocolMachineTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_clProtocolMachineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_clProtocolMachineTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(clProtocolMachineTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_clProtocolMachineTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CLPROTOCOLMACHINEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->clProtocolMachineOperationalState);
		return (u_char *) &StorageTmp->clProtocolMachineOperationalState;
	case CLPROTOCOLMACHINETOTALREMOTESAPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->clProtocolMachineTotalRemoteSAPs);
		return (u_char *) &StorageTmp->clProtocolMachineTotalRemoteSAPs;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_coProtocolMachineTable(): refresh coProtocolMachineTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_coProtocolMachineTable(void)
{
	if (coProtocolMachineTable_refresh == 0)
		return;
	coProtocolMachineTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_coProtocolMachineTable_row(): refresh coProtocolMachineTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_coProtocolMachineTable_row(struct coProtocolMachineTable_data *StorageTmp)
{
	if (StorageTmp->coProtocolMachineTable_request == sa_request)
		return;
	StorageTmp->coProtocolMachineTable_request = sa_request;
}

/*
 * var_coProtocolMachineTable(): locate variables in coProtocolMachineTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_coProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct coProtocolMachineTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_coProtocolMachineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_coProtocolMachineTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(coProtocolMachineTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_coProtocolMachineTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case COPROTOCOLMACHINEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->coProtocolMachineOperationalState);
		return (u_char *) &StorageTmp->coProtocolMachineOperationalState;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_singlePeerConnectionTable(): refresh singlePeerConnectionTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_singlePeerConnectionTable(void)
{
	if (singlePeerConnectionTable_refresh == 0)
		return;
	singlePeerConnectionTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_singlePeerConnectionTable_row(): refresh singlePeerConnectionTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_singlePeerConnectionTable_row(struct singlePeerConnectionTable_data *StorageTmp)
{
	if (StorageTmp->singlePeerConnectionTable_request == sa_request)
		return;
	StorageTmp->singlePeerConnectionTable_request = sa_request;
}

/*
 * var_singlePeerConnectionTable(): locate variables in singlePeerConnectionTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_singlePeerConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct singlePeerConnectionTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_singlePeerConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_singlePeerConnectionTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(singlePeerConnectionTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_singlePeerConnectionTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case UNDERLYINGCONNECTIONNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->underlyingConnectionNamesLen;
		return (u_char *) StorageTmp->underlyingConnectionNames;
	case SUPPPORTEDCONNECTIONNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->suppportedConnectionNamesLen;
		return (u_char *) StorageTmp->suppportedConnectionNames;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_physicalEntityTable(): refresh physicalEntityTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_physicalEntityTable(void)
{
	if (physicalEntityTable_refresh == 0)
		return;
	physicalEntityTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_physicalEntityTable_row(): refresh physicalEntityTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_physicalEntityTable_row(struct physicalEntityTable_data *StorageTmp)
{
	if (StorageTmp->physicalEntityTable_request == sa_request)
		return;
	StorageTmp->physicalEntityTable_request = sa_request;
}

/*
 * var_physicalEntityTable(): locate variables in physicalEntityTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_physicalEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct physicalEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_physicalEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_physicalEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(physicalEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_physicalEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PHYSICALENTITYPHYSICALENTITYTITLES:
		*write_method = write_physicalEntityPhysicalEntityTitles;
		*var_len = StorageTmp->physicalEntityPhysicalEntityTitlesLen;
		return (u_char *) StorageTmp->physicalEntityPhysicalEntityTitles;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_physicalSAPTable(): refresh physicalSAPTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_physicalSAPTable(void)
{
	if (physicalSAPTable_refresh == 0)
		return;
	physicalSAPTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_physicalSAPTable_row(): refresh physicalSAPTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_physicalSAPTable_row(struct physicalSAPTable_data *StorageTmp)
{
	if (StorageTmp->physicalSAPTable_request == sa_request)
		return;
	StorageTmp->physicalSAPTable_request = sa_request;
}

/*
 * var_physicalSAPTable(): locate variables in physicalSAPTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_physicalSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct physicalSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_physicalSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_physicalSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(physicalSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_physicalSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_dataCircuitTable(): refresh dataCircuitTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dataCircuitTable(void)
{
	if (dataCircuitTable_refresh == 0)
		return;
	dataCircuitTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_dataCircuitTable_row(): refresh dataCircuitTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_dataCircuitTable_row(struct dataCircuitTable_data *StorageTmp)
{
	if (StorageTmp->dataCircuitTable_request == sa_request)
		return;
	StorageTmp->dataCircuitTable_request = sa_request;
}

/*
 * var_dataCircuitTable(): locate variables in dataCircuitTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_dataCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dataCircuitTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_dataCircuitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_dataCircuitTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(dataCircuitTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_dataCircuitTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DATACIRCUITBITERRORSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dataCircuitBitErrorsReceived);
		return (u_char *) &StorageTmp->dataCircuitBitErrorsReceived;
	case DATACIRCUITBITERRORSTRANSMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dataCircuitBitErrorsTransmitted);
		return (u_char *) &StorageTmp->dataCircuitBitErrorsTransmitted;
	case DATACIRCUITBITERRORSTHRESHOLD:
		*write_method = write_dataCircuitBitErrorsThreshold;
		*var_len = StorageTmp->dataCircuitBitErrorsThresholdLen;
		return (u_char *) StorageTmp->dataCircuitBitErrorsThreshold;
	case DATACIRCUITTYPE:
		*write_method = write_dataCircuitType;
		*var_len = sizeof(StorageTmp->dataCircuitType);
		return (u_char *) &StorageTmp->dataCircuitType;
	case DATACIRCUITPHYSICALMEDIANAMES:
		*write_method = write_dataCircuitPhysicalMediaNames;
		*var_len = StorageTmp->dataCircuitPhysicalMediaNamesLen;
		return (u_char *) StorageTmp->dataCircuitPhysicalMediaNames;
	case DATACIRCUITPHYSICALINTERFACETYPE:
		*write_method = write_dataCircuitPhysicalInterfaceType;
		*var_len = StorageTmp->dataCircuitPhysicalInterfaceTypeLen;
		return (u_char *) StorageTmp->dataCircuitPhysicalInterfaceType;
	case DATACIRCUITPHYSICALINTERFACESTANDARD:
		*write_method = write_dataCircuitPhysicalInterfaceStandard;
		*var_len = StorageTmp->dataCircuitPhysicalInterfaceStandardLen;
		return (u_char *) StorageTmp->dataCircuitPhysicalInterfaceStandard;
	case DATACIRCUITSYNCHRONIZATIONMODE:
		*write_method = write_dataCircuitSynchronizationMode;
		*var_len = sizeof(StorageTmp->dataCircuitSynchronizationMode);
		return (u_char *) &StorageTmp->dataCircuitSynchronizationMode;
	case DATACIRCUITTRANSMISSIONCODING:
		*write_method = write_dataCircuitTransmissionCoding;
		*var_len = StorageTmp->dataCircuitTransmissionCodingLen;
		return (u_char *) StorageTmp->dataCircuitTransmissionCoding;
	case DATACIRCUITTRANSMISSIONMODE:
		*write_method = write_dataCircuitTransmissionMode;
		*var_len = sizeof(StorageTmp->dataCircuitTransmissionMode);
		return (u_char *) &StorageTmp->dataCircuitTransmissionMode;
	case DATACIRCUITTRANSMISSIONRATE:
		*write_method = write_dataCircuitTransmissionRate;
		*var_len = StorageTmp->dataCircuitTransmissionRateLen;
		return (u_char *) StorageTmp->dataCircuitTransmissionRate;
	case DATACIRCUITROWSTATUS:
		*write_method = write_dataCircuitRowStatus;
		*var_len = sizeof(StorageTmp->dataCircuitRowStatus);
		return (u_char *) &StorageTmp->dataCircuitRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_physicalConnectionTable(): refresh physicalConnectionTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_physicalConnectionTable(void)
{
	if (physicalConnectionTable_refresh == 0)
		return;
	physicalConnectionTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_physicalConnectionTable_row(): refresh physicalConnectionTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_physicalConnectionTable_row(struct physicalConnectionTable_data *StorageTmp)
{
	if (StorageTmp->physicalConnectionTable_request == sa_request)
		return;
	StorageTmp->physicalConnectionTable_request = sa_request;
}

/*
 * var_physicalConnectionTable(): locate variables in physicalConnectionTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_physicalConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct physicalConnectionTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_physicalConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_physicalConnectionTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(physicalConnectionTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_physicalConnectionTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PHYSICALCONNECTIONENDPOINTIDENTIFIER:
		*write_method = write_physicalConnectionEndpointIdentifier;
		*var_len = StorageTmp->physicalConnectionEndpointIdentifierLen;
		return (u_char *) StorageTmp->physicalConnectionEndpointIdentifier;
	case PHYSICALCONNECTIONPORTNUMBER:
		*write_method = write_physicalConnectionPortNumber;
		*var_len = sizeof(StorageTmp->physicalConnectionPortNumber);
		return (u_char *) &StorageTmp->physicalConnectionPortNumber;
	case PHYSICALCONNECTIONROWSTATUS:
		*write_method = write_physicalConnectionRowStatus;
		*var_len = sizeof(StorageTmp->physicalConnectionRowStatus);
		return (u_char *) &StorageTmp->physicalConnectionRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_datalinkEntityTable(): refresh datalinkEntityTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_datalinkEntityTable(void)
{
	if (datalinkEntityTable_refresh == 0)
		return;
	datalinkEntityTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_datalinkEntityTable_row(): refresh datalinkEntityTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_datalinkEntityTable_row(struct datalinkEntityTable_data *StorageTmp)
{
	if (StorageTmp->datalinkEntityTable_request == sa_request)
		return;
	StorageTmp->datalinkEntityTable_request = sa_request;
}

/*
 * var_datalinkEntityTable(): locate variables in datalinkEntityTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_datalinkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct datalinkEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_datalinkEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_datalinkEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(datalinkEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_datalinkEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DATALINKENTITYPROVIDERENTITYNAMES:
		*write_method = write_datalinkEntityProviderEntityNames;
		*var_len = StorageTmp->datalinkEntityProviderEntityNamesLen;
		return (u_char *) StorageTmp->datalinkEntityProviderEntityNames;
	case DATALINKENTITYROWSTATUS:
		*write_method = write_datalinkEntityRowStatus;
		*var_len = sizeof(StorageTmp->datalinkEntityRowStatus);
		return (u_char *) &StorageTmp->datalinkEntityRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_dLSAPTable(): refresh dLSAPTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dLSAPTable(void)
{
	if (dLSAPTable_refresh == 0)
		return;
	dLSAPTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_dLSAPTable_row(): refresh dLSAPTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_dLSAPTable_row(struct dLSAPTable_data *StorageTmp)
{
	if (StorageTmp->dLSAPTable_request == sa_request)
		return;
	StorageTmp->dLSAPTable_request = sa_request;
}

/*
 * var_dLSAPTable(): locate variables in dLSAPTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_dLSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dLSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_dLSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_dLSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(dLSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_dLSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DLSAPROWSTATUS:
		*write_method = write_dLSAPRowStatus;
		*var_len = sizeof(StorageTmp->dLSAPRowStatus);
		return (u_char *) &StorageTmp->dLSAPRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lAPBDLETable(): refresh lAPBDLETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lAPBDLETable(void)
{
	if (lAPBDLETable_refresh == 0)
		return;
	lAPBDLETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lAPBDLETable_row(): refresh lAPBDLETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lAPBDLETable_row(struct lAPBDLETable_data *StorageTmp)
{
	if (StorageTmp->lAPBDLETable_request == sa_request)
		return;
	StorageTmp->lAPBDLETable_request = sa_request;
}

/*
 * var_lAPBDLETable(): locate variables in lAPBDLETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lAPBDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lAPBDLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lAPBDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lAPBDLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lAPBDLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lAPBDLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LAPBDLEMT1TIMER:
		*write_method = write_lAPBDLEmT1Timer;
		*var_len = sizeof(StorageTmp->lAPBDLEmT1Timer);
		return (u_char *) &StorageTmp->lAPBDLEmT1Timer;
	case LAPBDLEMT3TIMER:
		*write_method = write_lAPBDLEmT3Timer;
		*var_len = sizeof(StorageTmp->lAPBDLEmT3Timer);
		return (u_char *) &StorageTmp->lAPBDLEmT3Timer;
	case LAPBDLEMW:
		*write_method = write_lAPBDLEmW;
		*var_len = sizeof(StorageTmp->lAPBDLEmW);
		return (u_char *) &StorageTmp->lAPBDLEmW;
	case LAPBDLEMXSEND:
		*write_method = write_lAPBDLEmXSend;
		*var_len = sizeof(StorageTmp->lAPBDLEmXSend);
		return (u_char *) &StorageTmp->lAPBDLEmXSend;
	case LAPBDLEMXRECEIVE:
		*write_method = write_lAPBDLEmXReceive;
		*var_len = sizeof(StorageTmp->lAPBDLEmXReceive);
		return (u_char *) &StorageTmp->lAPBDLEmXReceive;
	case LAPBDLEMT2TIMER:
		*write_method = write_lAPBDLEmT2Timer;
		*var_len = sizeof(StorageTmp->lAPBDLEmT2Timer);
		return (u_char *) &StorageTmp->lAPBDLEmT2Timer;
	case LAPBDLERECEIVEDMLPRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEreceivedMlpResets);
		return (u_char *) &StorageTmp->lAPBDLEreceivedMlpResets;
	case LAPBDLETIMESMT1EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEtimesMT1Expired);
		return (u_char *) &StorageTmp->lAPBDLEtimesMT1Expired;
	case LAPBDLEIFRAMESREASSIGNMENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEIframesReassignments);
		return (u_char *) &StorageTmp->lAPBDLEIframesReassignments;
	case LAPBDLEMLPFRAMESRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesReceived);
		return (u_char *) &StorageTmp->lAPBDLEmlpFramesReceived;
	case LAPBDLEMLPFRAMESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesSent);
		return (u_char *) &StorageTmp->lAPBDLEmlpFramesSent;
	case LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard);
		return (u_char *) &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard;
	case LAPBDLERECEIVEDMLPFRAMESINGUARDREGION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion);
		return (u_char *) &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion;
	case LAPBDLEROWSTATUS:
		*write_method = write_lAPBDLERowStatus;
		*var_len = sizeof(StorageTmp->lAPBDLERowStatus);
		return (u_char *) &StorageTmp->lAPBDLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sLPPMTable(): refresh sLPPMTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sLPPMTable(void)
{
	if (sLPPMTable_refresh == 0)
		return;
	sLPPMTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sLPPMTable_row(): refresh sLPPMTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sLPPMTable_row(struct sLPPMTable_data *StorageTmp)
{
	if (StorageTmp->sLPPMTable_request == sa_request)
		return;
	StorageTmp->sLPPMTable_request = sa_request;
}

/*
 * var_sLPPMTable(): locate variables in sLPPMTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sLPPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sLPPMTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sLPPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sLPPMTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sLPPMTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sLPPMTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SLPPMADMINISTRATIVESTATE:
		*write_method = write_sLPPMadministrativeState;
		*var_len = sizeof(StorageTmp->sLPPMadministrativeState);
		return (u_char *) &StorageTmp->sLPPMadministrativeState;
	case SLPPMROWSTATUS:
		*write_method = write_sLPPMRowStatus;
		*var_len = sizeof(StorageTmp->sLPPMRowStatus);
		return (u_char *) &StorageTmp->sLPPMRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sLPConnectionTable(): refresh sLPConnectionTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sLPConnectionTable(void)
{
	if (sLPConnectionTable_refresh == 0)
		return;
	sLPConnectionTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sLPConnectionTable_row(): refresh sLPConnectionTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sLPConnectionTable_row(struct sLPConnectionTable_data *StorageTmp)
{
	if (StorageTmp->sLPConnectionTable_request == sa_request)
		return;
	StorageTmp->sLPConnectionTable_request = sa_request;
}

/*
 * var_sLPConnectionTable(): locate variables in sLPConnectionTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sLPConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sLPConnectionTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sLPConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sLPConnectionTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sLPConnectionTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SLPCONNECTIONINTERFACETYPE:
		*write_method = write_sLPConnectionInterfaceType;
		*var_len = sizeof(StorageTmp->sLPConnectionInterfaceType);
		return (u_char *) &StorageTmp->sLPConnectionInterfaceType;
	case SLPCONNECTIONK:
		*write_method = write_sLPConnectionK;
		*var_len = sizeof(StorageTmp->sLPConnectionK);
		return (u_char *) &StorageTmp->sLPConnectionK;
	case SLPCONNECTIONN1:
		*write_method = write_sLPConnectionN1;
		*var_len = sizeof(StorageTmp->sLPConnectionN1);
		return (u_char *) &StorageTmp->sLPConnectionN1;
	case SLPCONNECTIONN2:
		*write_method = write_sLPConnectionN2;
		*var_len = sizeof(StorageTmp->sLPConnectionN2);
		return (u_char *) &StorageTmp->sLPConnectionN2;
	case SLPCONNECTIONSEQUENCEMODULUS:
		*write_method = write_sLPConnectionSequenceModulus;
		*var_len = sizeof(StorageTmp->sLPConnectionSequenceModulus);
		return (u_char *) &StorageTmp->sLPConnectionSequenceModulus;
	case SLPCONNECTIONT1TIMER:
		*write_method = write_sLPConnectionT1Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT1Timer);
		return (u_char *) &StorageTmp->sLPConnectionT1Timer;
	case SLPCONNECTIONT2TIMER:
		*write_method = write_sLPConnectionT2Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT2Timer);
		return (u_char *) &StorageTmp->sLPConnectionT2Timer;
	case SLPCONNECTIONFCSERRORSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionFCSErrorsReceived);
		return (u_char *) &StorageTmp->sLPConnectionFCSErrorsReceived;
	case SLPCONNECTIONFRMRSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionFRMRsReceived);
		return (u_char *) &StorageTmp->sLPConnectionFRMRsReceived;
	case SLPCONNECTIONFRMRSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionFRMRsSent);
		return (u_char *) &StorageTmp->sLPConnectionFRMRsSent;
	case SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFrameDataOctetsReceived);
		return (u_char *) &StorageTmp->sLPConnectionIFrameDataOctetsReceived;
	case SLPCONNECTIONIFRAMEDATAOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFrameDataOctetsSent);
		return (u_char *) &StorageTmp->sLPConnectionIFrameDataOctetsSent;
	case SLPCONNECTIONIFRAMESRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFramesReceived);
		return (u_char *) &StorageTmp->sLPConnectionIFramesReceived;
	case SLPCONNECTIONIFRAMESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFramesSent);
		return (u_char *) &StorageTmp->sLPConnectionIFramesSent;
	case SLPCONNECTIONPOLLSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionPollsReceived);
		return (u_char *) &StorageTmp->sLPConnectionPollsReceived;
	case SLPCONNECTIONREJSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionREJsReceived);
		return (u_char *) &StorageTmp->sLPConnectionREJsReceived;
	case SLPCONNECTIONREJSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionREJsSent);
		return (u_char *) &StorageTmp->sLPConnectionREJsSent;
	case SLPCONNECTIONRNRSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionRNRsReceived);
		return (u_char *) &StorageTmp->sLPConnectionRNRsReceived;
	case SLPCONNECTIONRNRSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionRNRsSent);
		return (u_char *) &StorageTmp->sLPConnectionRNRsSent;
	case SLPCONNECTIONSABMSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionSABMsReceived);
		return (u_char *) &StorageTmp->sLPConnectionSABMsReceived;
	case SLPCONNECTIONSABMSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionSABMsSent);
		return (u_char *) &StorageTmp->sLPConnectionSABMsSent;
	case SLPCONNECTIONPROTOCOLSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionProtocolState);
		return (u_char *) &StorageTmp->sLPConnectionProtocolState;
	case SLPCONNECTIONTIMEST1EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT1Expired);
		return (u_char *) &StorageTmp->sLPConnectionTimesT1Expired;
	case SLPCONNECTIONT3TIMER:
		*write_method = write_sLPConnectionT3Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT3Timer);
		return (u_char *) &StorageTmp->sLPConnectionT3Timer;
	case SLPCONNECTIONTIMEST3EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT3Expired);
		return (u_char *) &StorageTmp->sLPConnectionTimesT3Expired;
	case SLPCONNECTIONT4TIMER:
		*write_method = write_sLPConnectionT4Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT4Timer);
		return (u_char *) &StorageTmp->sLPConnectionT4Timer;
	case SLPCONNECTIONTIMEST4EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT4Expired);
		return (u_char *) &StorageTmp->sLPConnectionTimesT4Expired;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived);
		return (u_char *) &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent);
		return (u_char *) &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent;
	case SLPCONNECTIONLINKRESETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionLinkResetsReceived);
		return (u_char *) &StorageTmp->sLPConnectionLinkResetsReceived;
	case SLPCONNECTIONLINKRESETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionLinkResetsSent);
		return (u_char *) &StorageTmp->sLPConnectionLinkResetsSent;
	case SLPCONNECTIONTIMESN2REACHED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesN2Reached);
		return (u_char *) &StorageTmp->sLPConnectionTimesN2Reached;
	case SLPCONNECTIONADMINISTRATIVESTATE:
		*write_method = write_sLPConnectionAdministrativeState;
		*var_len = sizeof(StorageTmp->sLPConnectionAdministrativeState);
		return (u_char *) &StorageTmp->sLPConnectionAdministrativeState;
	case SLPCONNECTIONOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionOperationalState);
		return (u_char *) &StorageTmp->sLPConnectionOperationalState;
	case SLPCONNECTIONUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionUsageState);
		return (u_char *) &StorageTmp->sLPConnectionUsageState;
	case SLPCONNECTIONPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sLPConnectionProceduralStatusLen;
		return (u_char *) StorageTmp->sLPConnectionProceduralStatus;
	case SLPCONNECTIONALARMSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sLPConnectionAlarmStatusLen;
		return (u_char *) StorageTmp->sLPConnectionAlarmStatus;
	case SLPCONNECTIONROWSTATUS:
		*write_method = write_sLPConnectionRowStatus;
		*var_len = sizeof(StorageTmp->sLPConnectionRowStatus);
		return (u_char *) &StorageTmp->sLPConnectionRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sLPConnectionIVMOTable(): refresh sLPConnectionIVMOTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sLPConnectionIVMOTable(void)
{
	if (sLPConnectionIVMOTable_refresh == 0)
		return;
	sLPConnectionIVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sLPConnectionIVMOTable_row(): refresh sLPConnectionIVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sLPConnectionIVMOTable_row(struct sLPConnectionIVMOTable_data *StorageTmp)
{
	if (StorageTmp->sLPConnectionIVMOTable_request == sa_request)
		return;
	StorageTmp->sLPConnectionIVMOTable_request = sa_request;
}

/*
 * var_sLPConnectionIVMOTable(): locate variables in sLPConnectionIVMOTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sLPConnectionIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_sLPConnectionIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sLPConnectionIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sLPConnectionIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SLPCONNECTIONIVMOID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sLPConnectionIVMOidLen;
		return (u_char *) StorageTmp->sLPConnectionIVMOid;
	case SLPCONNECTIONIVMOINTERFACETYPE:
		*write_method = write_sLPConnectionIVMOinterfaceType;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOinterfaceType);
		return (u_char *) &StorageTmp->sLPConnectionIVMOinterfaceType;
	case SLPCONNECTIONIVMOK:
		*write_method = write_sLPConnectionIVMOk;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOk);
		return (u_char *) &StorageTmp->sLPConnectionIVMOk;
	case SLPCONNECTIONIVMON1:
		*write_method = write_sLPConnectionIVMOn1;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOn1);
		return (u_char *) &StorageTmp->sLPConnectionIVMOn1;
	case SLPCONNECTIONIVMON2:
		*write_method = write_sLPConnectionIVMOn2;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOn2);
		return (u_char *) &StorageTmp->sLPConnectionIVMOn2;
	case SLPCONNECTIONIVMOSEQUENCEMODULUS:
		*write_method = write_sLPConnectionIVMOsequenceModulus;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOsequenceModulus);
		return (u_char *) &StorageTmp->sLPConnectionIVMOsequenceModulus;
	case SLPCONNECTIONIVMOT1TIMER:
		*write_method = write_sLPConnectionIVMOt1Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt1Timer);
		return (u_char *) &StorageTmp->sLPConnectionIVMOt1Timer;
	case SLPCONNECTIONIVMOT2TIMER:
		*write_method = write_sLPConnectionIVMOt2Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt2Timer);
		return (u_char *) &StorageTmp->sLPConnectionIVMOt2Timer;
	case SLPCONNECTIONIVMOT3TIMER:
		*write_method = write_sLPConnectionIVMOt3Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt3Timer);
		return (u_char *) &StorageTmp->sLPConnectionIVMOt3Timer;
	case SLPCONNECTIONIVMOT4TIMER:
		*write_method = write_sLPConnectionIVMOt4Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt4Timer);
		return (u_char *) &StorageTmp->sLPConnectionIVMOt4Timer;
	case SLPCONNECTIONIVMOROWSTATUS:
		*write_method = write_sLPConnectionIVMORowStatus;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMORowStatus);
		return (u_char *) &StorageTmp->sLPConnectionIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mACDLETable(): refresh mACDLETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mACDLETable(void)
{
	if (mACDLETable_refresh == 0)
		return;
	mACDLETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mACDLETable_row(): refresh mACDLETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mACDLETable_row(struct mACDLETable_data *StorageTmp)
{
	if (StorageTmp->mACDLETable_request == sa_request)
		return;
	StorageTmp->mACDLETable_request = sa_request;
}

/*
 * var_mACDLETable(): locate variables in mACDLETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_mACDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mACDLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_mACDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mACDLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mACDLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mACDLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MACDLEROWSTATUS:
		*write_method = write_mACDLERowStatus;
		*var_len = sizeof(StorageTmp->mACDLERowStatus);
		return (u_char *) &StorageTmp->mACDLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mACTable(): refresh mACTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mACTable(void)
{
	if (mACTable_refresh == 0)
		return;
	mACTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mACTable_row(): refresh mACTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mACTable_row(struct mACTable_data *StorageTmp)
{
	if (StorageTmp->mACTable_request == sa_request)
		return;
	StorageTmp->mACTable_request = sa_request;
}

/*
 * var_mACTable(): locate variables in mACTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_mACTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mACTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_mACTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mACTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mACTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mACTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MACOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mACOperationalState);
		return (u_char *) &StorageTmp->mACOperationalState;
	case MACROWSTATUS:
		*write_method = write_mACRowStatus;
		*var_len = sizeof(StorageTmp->mACRowStatus);
		return (u_char *) &StorageTmp->mACRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCDLETable(): refresh lLCDLETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCDLETable(void)
{
	if (lLCDLETable_refresh == 0)
		return;
	lLCDLETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCDLETable_row(): refresh lLCDLETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCDLETable_row(struct lLCDLETable_data *StorageTmp)
{
	if (StorageTmp->lLCDLETable_request == sa_request)
		return;
	StorageTmp->lLCDLETable_request = sa_request;
}

/*
 * var_lLCDLETable(): locate variables in lLCDLETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCDLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCDLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCDLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCDLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCDLEROWSTATUS:
		*write_method = write_lLCDLERowStatus;
		*var_len = sizeof(StorageTmp->lLCDLERowStatus);
		return (u_char *) &StorageTmp->lLCDLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCCLPMTable(): refresh lLCCLPMTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCCLPMTable(void)
{
	if (lLCCLPMTable_refresh == 0)
		return;
	lLCCLPMTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCCLPMTable_row(): refresh lLCCLPMTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCCLPMTable_row(struct lLCCLPMTable_data *StorageTmp)
{
	if (StorageTmp->lLCCLPMTable_request == sa_request)
		return;
	StorageTmp->lLCCLPMTable_request = sa_request;
}

/*
 * var_lLCCLPMTable(): locate variables in lLCCLPMTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCCLPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCCLPMTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCCLPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCCLPMTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCCLPMTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCCLPMTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCLPMROWSTATUS:
		*write_method = write_lLCCLPMRowStatus;
		*var_len = sizeof(StorageTmp->lLCCLPMRowStatus);
		return (u_char *) &StorageTmp->lLCCLPMRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCCOPMTable(): refresh lLCCOPMTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCCOPMTable(void)
{
	if (lLCCOPMTable_refresh == 0)
		return;
	lLCCOPMTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCCOPMTable_row(): refresh lLCCOPMTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCCOPMTable_row(struct lLCCOPMTable_data *StorageTmp)
{
	if (StorageTmp->lLCCOPMTable_request == sa_request)
		return;
	StorageTmp->lLCCOPMTable_request = sa_request;
}

/*
 * var_lLCCOPMTable(): locate variables in lLCCOPMTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCCOPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCCOPMTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCCOPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCCOPMTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCCOPMTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCCOPMTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCOPMROWSTATUS:
		*write_method = write_lLCCOPMRowStatus;
		*var_len = sizeof(StorageTmp->lLCCOPMRowStatus);
		return (u_char *) &StorageTmp->lLCCOPMRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_resourceTypeIdTable(): refresh resourceTypeIdTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_resourceTypeIdTable(void)
{
	if (resourceTypeIdTable_refresh == 0)
		return;
	resourceTypeIdTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_resourceTypeIdTable_row(): refresh resourceTypeIdTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_resourceTypeIdTable_row(struct resourceTypeIdTable_data *StorageTmp)
{
	if (StorageTmp->resourceTypeIdTable_request == sa_request)
		return;
	StorageTmp->resourceTypeIdTable_request = sa_request;
}

/*
 * var_resourceTypeIdTable(): locate variables in resourceTypeIdTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_resourceTypeIdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct resourceTypeIdTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_resourceTypeIdTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_resourceTypeIdTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(resourceTypeIdTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_resourceTypeIdTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case RESOURCETYPEIDNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceTypeIdNameLen;
		return (u_char *) StorageTmp->resourceTypeIdName;
	case RESOURCEINFOMANUFACTUREROUI:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerOUILen;
		return (u_char *) StorageTmp->resourceInfoManufacturerOUI;
	case RESOURCEINFOMANUFACTURERNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerNameLen;
		return (u_char *) StorageTmp->resourceInfoManufacturerName;
	case RESOURCEINFOMANUFACTURERPRODUCTNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerProductNameLen;
		return (u_char *) StorageTmp->resourceInfoManufacturerProductName;
	case RESOURCEINFOMANUFACTURERPRODUCTVERSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerProductVersionLen;
		return (u_char *) StorageTmp->resourceInfoManufacturerProductVersion;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCStationTable(): refresh lLCStationTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCStationTable(void)
{
	if (lLCStationTable_refresh == 0)
		return;
	lLCStationTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCStationTable_row(): refresh lLCStationTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCStationTable_row(struct lLCStationTable_data *StorageTmp)
{
	if (StorageTmp->lLCStationTable_request == sa_request)
		return;
	StorageTmp->lLCStationTable_request = sa_request;
}

/*
 * var_lLCStationTable(): locate variables in lLCStationTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCStationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCStationTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCStationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCStationTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCStationTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCStationTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCSTATIONLLCNAME:
		*write_method = write_lLCStationLLCName;
		*var_len = StorageTmp->lLCStationLLCNameLen;
		return (u_char *) StorageTmp->lLCStationLLCName;
	case LLCSTATIONMAXIMUMLSAPSCONFIGURED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationMaximumLSAPsConfigured);
		return (u_char *) &StorageTmp->lLCStationMaximumLSAPsConfigured;
	case LLCSTATIONNUMBEROFACTIVELSAPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationNumberOfActiveLSAPs);
		return (u_char *) &StorageTmp->lLCStationNumberOfActiveLSAPs;
	case LLCSTATIONSUPPORTEDSERVICESTYPES:
		*write_method = write_lLCStationSupportedServicesTypes;
		*var_len = StorageTmp->lLCStationSupportedServicesTypesLen;
		return (u_char *) StorageTmp->lLCStationSupportedServicesTypes;
	case LLCSTATIONSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationStatus);
		return (u_char *) &StorageTmp->lLCStationStatus;
	case LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType1AcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCStationType1AcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCStationType1AcknowledgeTimeoutValue;
	case LLCSTATIONTYPE1MAXIMUMRETRYCOUNT:
		*write_method = write_lLCStationType1MaximumRetryCount;
		*var_len = sizeof(StorageTmp->lLCStationType1MaximumRetryCount);
		return (u_char *) &StorageTmp->lLCStationType1MaximumRetryCount;
	case LLCSTATIONMAXIMUMPDUN3:
		*write_method = write_lLCStationMaximumPDUN3;
		*var_len = sizeof(StorageTmp->lLCStationMaximumPDUN3);
		return (u_char *) &StorageTmp->lLCStationMaximumPDUN3;
	case LLCSTATIONMAXIMUMRETRANSMISSIONS4:
		*write_method = write_lLCStationMaximumRetransmissions4;
		*var_len = sizeof(StorageTmp->lLCStationMaximumRetransmissions4);
		return (u_char *) &StorageTmp->lLCStationMaximumRetransmissions4;
	case LLCSTATIONRECEIVEVARIABLELIFETIME:
		*write_method = write_lLCStationReceiveVariableLifetime;
		*var_len = sizeof(StorageTmp->lLCStationReceiveVariableLifetime);
		return (u_char *) &StorageTmp->lLCStationReceiveVariableLifetime;
	case LLCSTATIONTRANSMITVARIABLELIFETIME:
		*write_method = write_lLCStationTransmitVariableLifetime;
		*var_len = sizeof(StorageTmp->lLCStationTransmitVariableLifetime);
		return (u_char *) &StorageTmp->lLCStationTransmitVariableLifetime;
	case LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType3AcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCStationType3AcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCStationType3AcknowledgeTimeoutValue;
	case LLCSTATIONTYPE3RETRANSMISSIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationType3Retransmissions);
		return (u_char *) &StorageTmp->lLCStationType3Retransmissions;
	case LLCSTATIONAVGBUFFERUSESIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationAvgBufferUseSize);
		return (u_char *) &StorageTmp->lLCStationAvgBufferUseSize;
	case LLCSTATIONBUFFERPROBLEMS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationBufferProblems);
		return (u_char *) &StorageTmp->lLCStationBufferProblems;
	case LLCSTATIONBUFFERSIZE:
		*write_method = write_lLCStationBufferSize;
		*var_len = sizeof(StorageTmp->lLCStationBufferSize);
		return (u_char *) &StorageTmp->lLCStationBufferSize;
	case LLCSTATIONMAXBUFFERUSESIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationMaxBufferUseSize);
		return (u_char *) &StorageTmp->lLCStationMaxBufferUseSize;
	case LLCSTATIONINACTIVELSAP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationInactiveLSAP);
		return (u_char *) &StorageTmp->lLCStationInactiveLSAP;
	case LLCSTATIONPDUSDISCARD:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationPDUsDiscard);
		return (u_char *) &StorageTmp->lLCStationPDUsDiscard;
	case LLCSTATIONSTRINDICATOR:
		*write_method = write_lLCStationSTRIndicator;
		*var_len = StorageTmp->lLCStationSTRIndicatorLen;
		return (u_char *) StorageTmp->lLCStationSTRIndicator;
	case LLCSTATIONVERSIONNUMBER:
		*write_method = write_lLCStationVersionNumber;
		*var_len = sizeof(StorageTmp->lLCStationVersionNumber);
		return (u_char *) &StorageTmp->lLCStationVersionNumber;
	case LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts);
		return (u_char *) &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCSAPTable(): refresh lLCSAPTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCSAPTable(void)
{
	if (lLCSAPTable_refresh == 0)
		return;
	lLCSAPTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCSAPTable_row(): refresh lLCSAPTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCSAPTable_row(struct lLCSAPTable_data *StorageTmp)
{
	if (StorageTmp->lLCSAPTable_request == sa_request)
		return;
	StorageTmp->lLCSAPTable_request = sa_request;
}

/*
 * var_lLCSAPTable(): locate variables in lLCSAPTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCSAPADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->lLCSAPAddressLen;
		return (u_char *) StorageTmp->lLCSAPAddress;
	case LLCSAPRDE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCSAPRDE);
		return (u_char *) &StorageTmp->lLCSAPRDE;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_rDESetupTable(): refresh rDESetupTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_rDESetupTable(void)
{
	if (rDESetupTable_refresh == 0)
		return;
	rDESetupTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_rDESetupTable_row(): refresh rDESetupTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_rDESetupTable_row(struct rDESetupTable_data *StorageTmp)
{
	if (StorageTmp->rDESetupTable_request == sa_request)
		return;
	StorageTmp->rDESetupTable_request = sa_request;
}

/*
 * var_rDESetupTable(): locate variables in rDESetupTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_rDESetupTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct rDESetupTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_rDESetupTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_rDESetupTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(rDESetupTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_rDESetupTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case RDESETUPAGINGENABLED:
		*write_method = write_rDESetupAgingEnabled;
		*var_len = sizeof(StorageTmp->rDESetupAgingEnabled);
		return (u_char *) &StorageTmp->rDESetupAgingEnabled;
	case RDESETUPAGINGVALUE:
		*write_method = write_rDESetupAgingValue;
		*var_len = sizeof(StorageTmp->rDESetupAgingValue);
		return (u_char *) &StorageTmp->rDESetupAgingValue;
	case RDESETUPENABLETYPE2RESET:
		*write_method = write_rDESetupEnableType2Reset;
		*var_len = sizeof(StorageTmp->rDESetupEnableType2Reset);
		return (u_char *) &StorageTmp->rDESetupEnableType2Reset;
	case RDESETUPMAXIMUMROUTEDESCRIPTORS:
		*write_method = write_rDESetupMaximumRouteDescriptors;
		*var_len = sizeof(StorageTmp->rDESetupMaximumRouteDescriptors);
		return (u_char *) &StorageTmp->rDESetupMaximumRouteDescriptors;
	case RDESETUPMAXIMUMRESPONSETIME:
		*write_method = write_rDESetupMaximumResponseTime;
		*var_len = sizeof(StorageTmp->rDESetupMaximumResponseTime);
		return (u_char *) &StorageTmp->rDESetupMaximumResponseTime;
	case RDESETUPMINIMUMPDUSIZE:
		*write_method = write_rDESetupMinimumPDUSize;
		*var_len = sizeof(StorageTmp->rDESetupMinimumPDUSize);
		return (u_char *) &StorageTmp->rDESetupMinimumPDUSize;
	case RDESETUPRDEHOLD:
		*write_method = write_rDESetupRDEHold;
		*var_len = sizeof(StorageTmp->rDESetupRDEHold);
		return (u_char *) &StorageTmp->rDESetupRDEHold;
	case RDESETUPRDEREPLACE:
		*write_method = write_rDESetupRDEReplace;
		*var_len = sizeof(StorageTmp->rDESetupRDEReplace);
		return (u_char *) &StorageTmp->rDESetupRDEReplace;
	case RDESETUPNAME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDESetupName);
		return (u_char *) &StorageTmp->rDESetupName;
	case RDESETUPRESETONTESTENABLED:
		*write_method = write_rDESetupResetOnTestEnabled;
		*var_len = sizeof(StorageTmp->rDESetupResetOnTestEnabled);
		return (u_char *) &StorageTmp->rDESetupResetOnTestEnabled;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_rDEPairTable(): refresh rDEPairTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_rDEPairTable(void)
{
	if (rDEPairTable_refresh == 0)
		return;
	rDEPairTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_rDEPairTable_row(): refresh rDEPairTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_rDEPairTable_row(struct rDEPairTable_data *StorageTmp)
{
	if (StorageTmp->rDEPairTable_request == sa_request)
		return;
	StorageTmp->rDEPairTable_request = sa_request;
}

/*
 * var_rDEPairTable(): locate variables in rDEPairTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_rDEPairTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct rDEPairTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_rDEPairTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_rDEPairTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(rDEPairTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_rDEPairTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case RDEPAIRDISCARDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairDiscardCounter);
		return (u_char *) &StorageTmp->rDEPairDiscardCounter;
	case RDEPAIRNSRPDUCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairNSRPDUCounter);
		return (u_char *) &StorageTmp->rDEPairNSRPDUCounter;
	case RDEPAIRNSRSELECTEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairNSRSelectedCounter);
		return (u_char *) &StorageTmp->rDEPairNSRSelectedCounter;
	case RDEPAIRRIF:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->rDEPairRIFLen;
		return (u_char *) StorageTmp->rDEPairRIF;
	case RDEPAIRSRFPDUCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairSRFPDUCounter);
		return (u_char *) &StorageTmp->rDEPairSRFPDUCounter;
	case RDEPAIRQUERYCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairQueryCounter);
		return (u_char *) &StorageTmp->rDEPairQueryCounter;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnectionLessTable(): refresh lLCConnectionLessTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionLessTable(void)
{
	if (lLCConnectionLessTable_refresh == 0)
		return;
	lLCConnectionLessTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnectionLessTable_row(): refresh lLCConnectionLessTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnectionLessTable_row(struct lLCConnectionLessTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnectionLessTable_request == sa_request)
		return;
	StorageTmp->lLCConnectionLessTable_request = sa_request;
}

/*
 * var_lLCConnectionLessTable(): locate variables in lLCConnectionLessTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnectionLessTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionLessTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnectionLessTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnectionLessTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnectionLessTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnectionLessTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTIONLESSNAME:
		*write_method = write_lLCConnectionlessName;
		*var_len = StorageTmp->lLCConnectionlessNameLen;
		return (u_char *) StorageTmp->lLCConnectionlessName;
	case LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedABBResponse;
	case LLCCONNECTIONLESSTESTRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedCommand;
	case LLCCONNECTIONLESSTESTRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedResponse;
	case LLCCONNECTIONLESSTESTSENTABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTSentABBResponse;
	case LLCCONNECTIONLESSTESTSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTSentCommand;
	case LLCCONNECTIONLESSTESTSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTSentResponse;
	case LLCCONNECTIONLESSUIRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessUIReceived);
		return (u_char *) &StorageTmp->lLCConnectionlessUIReceived;
	case LLCCONNECTIONLESSUISENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessUISent);
		return (u_char *) &StorageTmp->lLCConnectionlessUISent;
	case LLCCONNECTIONLESSXIDRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDReceivedCommand;
	case LLCCONNECTIONLESSXIDRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDReceivedResponse;
	case LLCCONNECTIONLESSXIDSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDSentCommand;
	case LLCCONNECTIONLESSXIDSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDSentResponse;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnection2Table(): refresh lLCConnection2Table
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnection2Table(void)
{
	if (lLCConnection2Table_refresh == 0)
		return;
	lLCConnection2Table_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnection2Table_row(): refresh lLCConnection2Table row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnection2Table_row(struct lLCConnection2Table_data *StorageTmp)
{
	if (StorageTmp->lLCConnection2Table_request == sa_request)
		return;
	StorageTmp->lLCConnection2Table_request = sa_request;
}

/*
 * var_lLCConnection2Table(): locate variables in lLCConnection2Table
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnection2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnection2Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnection2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnection2Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnection2Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTION2NAME:
		*write_method = write_lLCConnection2Name;
		*var_len = StorageTmp->lLCConnection2NameLen;
		return (u_char *) StorageTmp->lLCConnection2Name;
	case LLCCONNECTION2MAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2MaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2MaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2MaximumRetransmissions;
	case LLCCONNECTION2RECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2ReceivedWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedWindowSize;
	case LLCCONNECTION2SENDWINDOWSIZE:
		*write_method = write_lLCConnection2SendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2SendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2SendWindowSize;
	case LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2AcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2AcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2AcknowledgeTimeoutValue;
	case LLCCONNECTION2BUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2BusyStateTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2BusyStateTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2BusyStateTimeoutValue;
	case LLCCONNECTION2PBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2PBitTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2PBitTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2PBitTimeoutValue;
	case LLCCONNECTION2REJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2RejectTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2RejectTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2RejectTimeoutValue;
	case LLCCONNECTION2LOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2LocalBusy);
		return (u_char *) &StorageTmp->lLCConnection2LocalBusy;
	case LLCCONNECTION2REMOTEBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2RemoteBusy);
		return (u_char *) &StorageTmp->lLCConnection2RemoteBusy;
	case LLCCONNECTION2REMOTERESET:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2RemoteReset);
		return (u_char *) &StorageTmp->lLCConnection2RemoteReset;
	case LLCCONNECTION2LOCALRESET:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2LocalReset);
		return (u_char *) &StorageTmp->lLCConnection2LocalReset;
	case LLCCONNECTION2PROVIDERRESET:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ProviderReset);
		return (u_char *) &StorageTmp->lLCConnection2ProviderReset;
	case LLCCONNECTION2ROUTE:
		*write_method = write_lLCConnection2Route;
		*var_len = StorageTmp->lLCConnection2RouteLen;
		return (u_char *) StorageTmp->lLCConnection2Route;
	case LLCCONNECTION2KSTEP:
		*write_method = write_lLCConnection2KStep;
		*var_len = sizeof(StorageTmp->lLCConnection2KStep);
		return (u_char *) &StorageTmp->lLCConnection2KStep;
	case LLCCONNECTION2MAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2MaxSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2MaxSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2MaxSendWindowSize;
	case LLCCONNECTION2RECEIVEDI:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedI);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedI;
	case LLCCONNECTION2SENTI:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentI);
		return (u_char *) &StorageTmp->lLCConnection2SentI;
	case LLCCONNECTION2SENTACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentAcks);
		return (u_char *) &StorageTmp->lLCConnection2SentAcks;
	case LLCCONNECTION2RECEIVEDACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedAcks);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedAcks;
	case LLCCONNECTION2RECEIVEDFRMR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedFRMR);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedFRMR;
	case LLCCONNECTION2SENTFRMR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentFRMR);
		return (u_char *) &StorageTmp->lLCConnection2SentFRMR;
	case LLCCONNECTION2RECEIVEDRR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedRR);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedRR;
	case LLCCONNECTION2SENTRR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentRR);
		return (u_char *) &StorageTmp->lLCConnection2SentRR;
	case LLCCONNECTION2RECEIVEDRNR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedRNR);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedRNR;
	case LLCCONNECTION2SENTRNR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentRNR);
		return (u_char *) &StorageTmp->lLCConnection2SentRNR;
	case LLCCONNECTION2RECEIVEDREJ:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedREJ);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedREJ;
	case LLCCONNECTION2SENTREJ:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentREJ);
		return (u_char *) &StorageTmp->lLCConnection2SentREJ;
	case LLCCONNECTION2RECEIVEDSABME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedSABME);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedSABME;
	case LLCCONNECTION2SENTSABME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentSABME);
		return (u_char *) &StorageTmp->lLCConnection2SentSABME;
	case LLCCONNECTION2RECEIVEDUA:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedUA);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedUA;
	case LLCCONNECTION2SENTUA:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentUA);
		return (u_char *) &StorageTmp->lLCConnection2SentUA;
	case LLCCONNECTION2RECEIVEDDISC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedDISC);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedDISC;
	case LLCCONNECTION2SENTDISC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentDISC);
		return (u_char *) &StorageTmp->lLCConnection2SentDISC;
	case LLCCONNECTION2RECEIVEDDM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedDM);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedDM;
	case LLCCONNECTION2SENTDM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentDM);
		return (u_char *) &StorageTmp->lLCConnection2SentDM;
	case LLCCONNECTION2PDUSDISCARDED1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2PDUsDiscarded1);
		return (u_char *) &StorageTmp->lLCConnection2PDUsDiscarded1;
	case LLCCONNECTION2PDUSDISCARDED2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2PDUsDiscarded2);
		return (u_char *) &StorageTmp->lLCConnection2PDUsDiscarded2;
	case LLCCONNECTION2PDURETRANSMISSIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2PDURetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2PDURetransmissions;
	case LLCCONNECTION2OPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2OptionalTolerationIPDUs;
		*var_len = sizeof(StorageTmp->lLCConnection2OptionalTolerationIPDUs);
		return (u_char *) &StorageTmp->lLCConnection2OptionalTolerationIPDUs;
	case LLCCONNECTION2DUPLICATEIPDUSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2DuplicateIPDUsReceived);
		return (u_char *) &StorageTmp->lLCConnection2DuplicateIPDUsReceived;
	case LLCCONNECTION2VIOLATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2Violation);
		return (u_char *) &StorageTmp->lLCConnection2Violation;
	case LLCCONNECTION2PROTOCOLSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ProtocolState);
		return (u_char *) &StorageTmp->lLCConnection2ProtocolState;
	case LLCCONNECTION2ADMINISTRATIVESTATE:
		*write_method = write_lLCConnection2AdministrativeState;
		*var_len = sizeof(StorageTmp->lLCConnection2AdministrativeState);
		return (u_char *) &StorageTmp->lLCConnection2AdministrativeState;
	case LLCCONNECTION2OPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2OperationalState);
		return (u_char *) &StorageTmp->lLCConnection2OperationalState;
	case LLCCONNECTION2USAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2UsageState);
		return (u_char *) &StorageTmp->lLCConnection2UsageState;
	case LLCCONNECTION2PROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->lLCConnection2ProceduralStatusLen;
		return (u_char *) StorageTmp->lLCConnection2ProceduralStatus;
	case LLCCONNECTION2ALARMSTATUS:
		*write_method = write_lLCConnection2AlarmStatus;
		*var_len = StorageTmp->lLCConnection2AlarmStatusLen;
		return (u_char *) StorageTmp->lLCConnection2AlarmStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnection2IVMOTable(): refresh lLCConnection2IVMOTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnection2IVMOTable(void)
{
	if (lLCConnection2IVMOTable_refresh == 0)
		return;
	lLCConnection2IVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnection2IVMOTable_row(): refresh lLCConnection2IVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnection2IVMOTable_row(struct lLCConnection2IVMOTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnection2IVMOTable_request == sa_request)
		return;
	StorageTmp->lLCConnection2IVMOTable_request = sa_request;
}

/*
 * var_lLCConnection2IVMOTable(): locate variables in lLCConnection2IVMOTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnection2IVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnection2IVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnection2IVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnection2IVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2IVMOMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2IVMOMaximumRetransmissions;
	case LLCCONNECTION2IVMORECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOReceivedWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOReceivedWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2IVMOReceivedWindowSize;
	case LLCCONNECTION2IVMOSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2IVMOSendWindowSize;
	case LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOAcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue;
	case LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBusyStateTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue;
	case LLCCONNECTION2IVMOBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBitTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOBitTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMOBitTimeoutValue;
	case LLCCONNECTION2IVMOREJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMORejectTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMORejectTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMORejectTimeoutValue;
	case LLCCONNECTION2IVMOROUTE:
		*write_method = write_lLCConnection2IVMORoute;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMORoute);
		return (u_char *) &StorageTmp->lLCConnection2IVMORoute;
	case LLCCONNECTION2IVMOKSTEP:
		*write_method = write_lLCConnection2IVMOKStep;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOKStep);
		return (u_char *) &StorageTmp->lLCConnection2IVMOKStep;
	case LLCCONNECTION2IVMOMAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOMaxSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOMaxSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2IVMOMaxSendWindowSize;
	case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2IVMOOptionalTolerationIPDUs;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs);
		return (u_char *) &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnectionlessAckTable(): refresh lLCConnectionlessAckTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionlessAckTable(void)
{
	if (lLCConnectionlessAckTable_refresh == 0)
		return;
	lLCConnectionlessAckTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnectionlessAckTable_row(): refresh lLCConnectionlessAckTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnectionlessAckTable_row(struct lLCConnectionlessAckTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnectionlessAckTable_request == sa_request)
		return;
	StorageTmp->lLCConnectionlessAckTable_request = sa_request;
}

/*
 * var_lLCConnectionlessAckTable(): locate variables in lLCConnectionlessAckTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnectionlessAckTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnectionlessAckTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnectionlessAckTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnectionlessAckTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckMaximumRetransmissions;
	case LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse;
	case LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedCommand;
	case LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedResponse;
	case LLCCONNECTIONLESSACKTESTSENTABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentABBResponse;
	case LLCCONNECTIONLESSACKTESTSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentCommand;
	case LLCCONNECTIONLESSACKTESTSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentResponse;
	case LLCCONNECTIONLESSACKRECEIVERESOURCES:
		*write_method = write_lLCConnectionlessAckReceiveResources;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckReceiveResources);
		return (u_char *) &StorageTmp->lLCConnectionlessAckReceiveResources;
	case LLCCONNECTIONLESSACKUIRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckUIReceived);
		return (u_char *) &StorageTmp->lLCConnectionlessAckUIReceived;
	case LLCCONNECTIONLESSACKUISENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckUISent);
		return (u_char *) &StorageTmp->lLCConnectionlessAckUISent;
	case LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDReceivedCommand;
	case LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDReceivedResponse;
	case LLCCONNECTIONLESSACKXIDSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDSentCommand;
	case LLCCONNECTIONLESSACKXIDSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDSentResponse;
	case LLCCONNECTIONLESSACKRETRANSMISSIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckRetransmissions;
	case LLCCONNECTIONLESSACKNORESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckNoResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckNoResponse;
	case LLCCONNECTIONLESSACKCOMMANDIP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandIP);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandIP;
	case LLCCONNECTIONLESSACKCOMMANDIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandIT);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandIT;
	case LLCCONNECTIONLESSACKCOMMANDOK:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandOK);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandOK;
	case LLCCONNECTIONLESSACKCOMMANDPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandPE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandPE;
	case LLCCONNECTIONLESSACKCOMMANDRS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandRS);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandRS;
	case LLCCONNECTIONLESSACKCOMMANDUE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandUE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandUE;
	case LLCCONNECTIONLESSACKCOMMANDUN:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandUN);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandUN;
	case LLCCONNECTIONLESSACKRECEIVEDACCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckReceivedACCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckReceivedACCommand;
	case LLCCONNECTIONLESSACKSENTACCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckSentACCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckSentACCommand;
	case LLCCONNECTIONLESSACKRESPONSEIP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseIP);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseIP;
	case LLCCONNECTIONLESSACKRESPONSEIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseIT);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseIT;
	case LLCCONNECTIONLESSACKRESPONSENE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseNE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseNE;
	case LLCCONNECTIONLESSACKRESPONSENR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseNR);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseNR;
	case LLCCONNECTIONLESSACKRESPONSEOK:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseOK);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseOK;
	case LLCCONNECTIONLESSACKRESPONSERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseRS);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseRS;
	case LLCCONNECTIONLESSACKRESPONSEUE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseUE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseUE;
	case LLCCONNECTIONLESSACKRESPONSEUN:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseUN);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseUN;
	case LLCCONNECTIONLESSACKVIOLATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckViolation);
		return (u_char *) &StorageTmp->lLCConnectionlessAckViolation;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnectionlessAckIVMOTable(): refresh lLCConnectionlessAckIVMOTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionlessAckIVMOTable(void)
{
	if (lLCConnectionlessAckIVMOTable_refresh == 0)
		return;
	lLCConnectionlessAckIVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnectionlessAckIVMOTable_row(): refresh lLCConnectionlessAckIVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnectionlessAckIVMOTable_row(struct lLCConnectionlessAckIVMOTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnectionlessAckIVMOTable_request == sa_request)
		return;
	StorageTmp->lLCConnectionlessAckIVMOTable_request = sa_request;
}

/*
 * var_lLCConnectionlessAckIVMOTable(): locate variables in lLCConnectionlessAckIVMOTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnectionlessAckIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_lLCConnectionlessAckIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnectionlessAckIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnectionlessAckIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckIVMOMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions;
	case LLCCONNECTIONLESSACKIVMOROWSTATUS:
		*write_method = write_lLCConnectionlessAckIVMORowStatus;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMORowStatus);
		return (u_char *) &StorageTmp->lLCConnectionlessAckIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_networkEntityTable(): refresh networkEntityTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_networkEntityTable(void)
{
	if (networkEntityTable_refresh == 0)
		return;
	networkEntityTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_networkEntityTable_row(): refresh networkEntityTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_networkEntityTable_row(struct networkEntityTable_data *StorageTmp)
{
	if (StorageTmp->networkEntityTable_request == sa_request)
		return;
	StorageTmp->networkEntityTable_request = sa_request;
}

/*
 * var_networkEntityTable(): locate variables in networkEntityTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_networkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct networkEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_networkEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_networkEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(networkEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_networkEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case NETWORKENTITYTITLES:
		*write_method = write_networkEntityTitles;
		*var_len = StorageTmp->networkEntityTitlesLen;
		return (u_char *) StorageTmp->networkEntityTitles;
	case NETWORKENTITYSYSTEMTYPES:
		*write_method = write_networkEntitySystemTypes;
		*var_len = StorageTmp->networkEntitySystemTypesLen;
		return (u_char *) StorageTmp->networkEntitySystemTypes;
	case NETWORKENTITYROWSTATUS:
		*write_method = write_networkEntityRowStatus;
		*var_len = sizeof(StorageTmp->networkEntityRowStatus);
		return (u_char *) &StorageTmp->networkEntityRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_nSAPTable(): refresh nSAPTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_nSAPTable(void)
{
	if (nSAPTable_refresh == 0)
		return;
	nSAPTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_nSAPTable_row(): refresh nSAPTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_nSAPTable_row(struct nSAPTable_data *StorageTmp)
{
	if (StorageTmp->nSAPTable_request == sa_request)
		return;
	StorageTmp->nSAPTable_request = sa_request;
}

/*
 * var_nSAPTable(): locate variables in nSAPTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_nSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct nSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_nSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_nSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(nSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_nSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case NSAPROWSTATUS:
		*write_method = write_nSAPRowStatus;
		*var_len = sizeof(StorageTmp->nSAPRowStatus);
		return (u_char *) &StorageTmp->nSAPRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_cLNSTable(): refresh cLNSTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cLNSTable(void)
{
	if (cLNSTable_refresh == 0)
		return;
	cLNSTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_cLNSTable_row(): refresh cLNSTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_cLNSTable_row(struct cLNSTable_data *StorageTmp)
{
	if (StorageTmp->cLNSTable_request == sa_request)
		return;
	StorageTmp->cLNSTable_request = sa_request;
}

/*
 * var_cLNSTable(): locate variables in cLNSTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cLNSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cLNSTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_cLNSTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_cLNSTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(cLNSTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_cLNSTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CLNSADMINISTRATIVESTATE:
		*write_method = write_cLNSAdministrativeState;
		*var_len = sizeof(StorageTmp->cLNSAdministrativeState);
		return (u_char *) &StorageTmp->cLNSAdministrativeState;
	case CLNSSUPPORTEDPROTOCOLS:
		*write_method = write_cLNSSupportedProtocols;
		*var_len = StorageTmp->cLNSSupportedProtocolsLen;
		return (u_char *) StorageTmp->cLNSSupportedProtocols;
	case CLNSOPERATIONALSYSTEMTYPE:
		*write_method = write_cLNSOperationalSystemType;
		*var_len = StorageTmp->cLNSOperationalSystemTypeLen;
		return (u_char *) StorageTmp->cLNSOperationalSystemType;
	case CLNSOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSOctetsSentCounter);
		return (u_char *) &StorageTmp->cLNSOctetsSentCounter;
	case CLNSOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSOctetsReceivedCounter);
		return (u_char *) &StorageTmp->cLNSOctetsReceivedCounter;
	case CLNSSEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSSegmentsReceived);
		return (u_char *) &StorageTmp->cLNSSegmentsReceived;
	case CLNSSEGMENTSDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSSegmentsDiscarded);
		return (u_char *) &StorageTmp->cLNSSegmentsDiscarded;
	case CLNSASSEMBLINGSEGMENTSDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSAssemblingSegmentsDiscarded);
		return (u_char *) &StorageTmp->cLNSAssemblingSegmentsDiscarded;
	case CLNSERRORREPORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSErrorReportsReceived);
		return (u_char *) &StorageTmp->cLNSErrorReportsReceived;
	case CLNSPDUDISCARDS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSpDUDiscards);
		return (u_char *) &StorageTmp->cLNSpDUDiscards;
	case CLNSCONGESTIONDISCARDS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSCongestionDiscards);
		return (u_char *) &StorageTmp->cLNSCongestionDiscards;
	case CLNSMAXIMUMLIFETIME:
		*write_method = write_cLNSMaximumLifetime;
		*var_len = sizeof(StorageTmp->cLNSMaximumLifetime);
		return (u_char *) &StorageTmp->cLNSMaximumLifetime;
	case CLNSENABLECHECKSUM:
		*write_method = write_cLNSEnableChecksum;
		*var_len = sizeof(StorageTmp->cLNSEnableChecksum);
		return (u_char *) &StorageTmp->cLNSEnableChecksum;
	case CLNSROWSTATUS:
		*write_method = write_cLNSRowStatus;
		*var_len = sizeof(StorageTmp->cLNSRowStatus);
		return (u_char *) &StorageTmp->cLNSRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_cLNSISISTable(): refresh cLNSISISTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cLNSISISTable(void)
{
	if (cLNSISISTable_refresh == 0)
		return;
	cLNSISISTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_cLNSISISTable_row(): refresh cLNSISISTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_cLNSISISTable_row(struct cLNSISISTable_data *StorageTmp)
{
	if (StorageTmp->cLNSISISTable_request == sa_request)
		return;
	StorageTmp->cLNSISISTable_request = sa_request;
}

/*
 * var_cLNSISISTable(): locate variables in cLNSISISTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cLNSISISTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cLNSISISTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_cLNSISISTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_cLNSISISTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(cLNSISISTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_cLNSISISTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CLNSISISVERSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISversionLen;
		return (u_char *) StorageTmp->cLNSISISversion;
	case CLNSISISISTYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISiSType);
		return (u_char *) &StorageTmp->cLNSISISiSType;
	case CLNSISISSYSTEMID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISsystemIdLen;
		return (u_char *) StorageTmp->cLNSISISsystemId;
	case CLNSISISMAXIMUMPATHSPLITS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmaximumPathSplits);
		return (u_char *) &StorageTmp->cLNSISISmaximumPathSplits;
	case CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISminimumLSPTransmissionInterval);
		return (u_char *) &StorageTmp->cLNSISISminimumLSPTransmissionInterval;
	case CLNSISISMAXIMUMLSPGENERATIONINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmaximumLSPGenerationInterval);
		return (u_char *) &StorageTmp->cLNSISISmaximumLSPGenerationInterval;
	case CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval);
		return (u_char *) &StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval;
	case CLNSISISCOMPLETESNPINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISIScompleteSNPInterval);
		return (u_char *) &StorageTmp->cLNSISIScompleteSNPInterval;
	case CLNSISISORIGINATINGL1LSPBUFFERSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISoriginatingL1LSPBufferSize);
		return (u_char *) &StorageTmp->cLNSISISoriginatingL1LSPBufferSize;
	case CLNSISISMANUALAREAADDRESSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISmanualAreaAddressesLen;
		return (u_char *) StorageTmp->cLNSISISmanualAreaAddresses;
	case CLNSISISMAXIMUMAREAADDRESSES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmaximumAreaAddresses);
		return (u_char *) &StorageTmp->cLNSISISmaximumAreaAddresses;
	case CLNSISISMINIMUMLSPGENERATIONINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISminimumLSPGenerationInterval);
		return (u_char *) &StorageTmp->cLNSISISminimumLSPGenerationInterval;
	case CLNSISISPOLLESHELLORATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISpollESHelloRate);
		return (u_char *) &StorageTmp->cLNSISISpollESHelloRate;
	case CLNSISISPARTIALSNPINTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISpartialSNPInterval);
		return (u_char *) &StorageTmp->cLNSISISpartialSNPInterval;
	case CLNSISISWAITINGTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISwaitingTime);
		return (u_char *) &StorageTmp->cLNSISISwaitingTime;
	case CLNSISISDRISISHELLOTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISdRISISHelloTimer);
		return (u_char *) &StorageTmp->cLNSISISdRISISHelloTimer;
	case CLNSISISL1STATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISl1State);
		return (u_char *) &StorageTmp->cLNSISISl1State;
	case CLNSISISAREAADDRESSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISareaAddressesLen;
		return (u_char *) StorageTmp->cLNSISISareaAddresses;
	case CLNSISISCORRUPTEDLSPSDETECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISIScorruptedLSPsDetected);
		return (u_char *) &StorageTmp->cLNSISIScorruptedLSPsDetected;
	case CLNSISISLSPL1DATABASEOVERLOADS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISlSPL1DatabaseOverloads);
		return (u_char *) &StorageTmp->cLNSISISlSPL1DatabaseOverloads;
	case CLNSISISMANUALADDRESSESDROPPEDFROMAREAS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmanualAddressesDroppedFromAreas);
		return (u_char *) &StorageTmp->cLNSISISmanualAddressesDroppedFromAreas;
	case CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber);
		return (u_char *) &StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber;
	case CLNSISISSEQUENCENUMBERSKIPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISsequenceNumberSkips);
		return (u_char *) &StorageTmp->cLNSISISsequenceNumberSkips;
	case CLNSISISOWNLSPPURGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISownLSPPurges);
		return (u_char *) &StorageTmp->cLNSISISownLSPPurges;
	case CLNSISISIDFIELDLENGTHMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISiDFieldLengthMismatches);
		return (u_char *) &StorageTmp->cLNSISISiDFieldLengthMismatches;
	case CLNSISISMAXIMUMAREAADDRESSESMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISmaximumAreaAddressesMismatches);
		return (u_char *) &StorageTmp->cLNSISISmaximumAreaAddressesMismatches;
	case CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches);
		return (u_char *) &StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches;
	case CLNSISISLSPTOOLARGETOPROPAGATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISlSPTooLargeToPropagate);
		return (u_char *) &StorageTmp->cLNSISISlSPTooLargeToPropagate;
	case CLNSISISAREATRANSMITPASSWORD:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISareaTransmitPasswordLen;
		return (u_char *) StorageTmp->cLNSISISareaTransmitPassword;
	case CLNSISISAREARECEIVEPASSWORDS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISareaReceivePasswordsLen;
		return (u_char *) StorageTmp->cLNSISISareaReceivePasswords;
	case CLNSISISAUTHENTICATIONFAILURES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISauthenticationFailures);
		return (u_char *) &StorageTmp->cLNSISISauthenticationFailures;
	case CLNSISISROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISRowStatus);
		return (u_char *) &StorageTmp->cLNSISISRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_cLNSISISLevel2Table(): refresh cLNSISISLevel2Table
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cLNSISISLevel2Table(void)
{
	if (cLNSISISLevel2Table_refresh == 0)
		return;
	cLNSISISLevel2Table_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_cLNSISISLevel2Table_row(): refresh cLNSISISLevel2Table row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_cLNSISISLevel2Table_row(struct cLNSISISLevel2Table_data *StorageTmp)
{
	if (StorageTmp->cLNSISISLevel2Table_request == sa_request)
		return;
	StorageTmp->cLNSISISLevel2Table_request = sa_request;
}

/*
 * var_cLNSISISLevel2Table(): locate variables in cLNSISISLevel2Table
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cLNSISISLevel2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cLNSISISLevel2Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_cLNSISISLevel2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_cLNSISISLevel2Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(cLNSISISLevel2TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_cLNSISISLevel2Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies);
		return (u_char *) &StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies;
	case CLNSISISLEVEL2PARTITIONAREAADDRESSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISLevel2partitionAreaAddressesLen;
		return (u_char *) StorageTmp->cLNSISISLevel2partitionAreaAddresses;
	case CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen;
		return (u_char *) StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem;
	case CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges);
		return (u_char *) &StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges;
	case CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize);
		return (u_char *) &StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize;
	case CLNSISISLEVEL2L2STATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2l2State);
		return (u_char *) &StorageTmp->cLNSISISLevel2l2State;
	case CLNSISISLEVEL2LSPL2DATABASEOVERLOADS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads);
		return (u_char *) &StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads;
	case CLNSISISLEVEL2DOMAINTRANSMITPASSWORD:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISLevel2domainTransmitPasswordLen;
		return (u_char *) StorageTmp->cLNSISISLevel2domainTransmitPassword;
	case CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->cLNSISISLevel2domainReceivePasswordsLen;
		return (u_char *) StorageTmp->cLNSISISLevel2domainReceivePasswords;
	case CLNSISISLEVEL2ROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->cLNSISISLevel2RowStatus);
		return (u_char *) &StorageTmp->cLNSISISLevel2RowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_linkageTable(): refresh linkageTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_linkageTable(void)
{
	if (linkageTable_refresh == 0)
		return;
	linkageTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_linkageTable_row(): refresh linkageTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_linkageTable_row(struct linkageTable_data *StorageTmp)
{
	if (StorageTmp->linkageTable_request == sa_request)
		return;
	StorageTmp->linkageTable_request = sa_request;
}

/*
 * var_linkageTable(): locate variables in linkageTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_linkageTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct linkageTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_linkageTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_linkageTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(linkageTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_linkageTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LINKAGEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageOperationalState);
		return (u_char *) &StorageTmp->linkageOperationalState;
	case LINKAGEADMINISTRATIVESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageAdministrativeState);
		return (u_char *) &StorageTmp->linkageAdministrativeState;
	case LINKAGESNSERVICEPROVIDER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageSnServiceProviderLen;
		return (u_char *) StorageTmp->linkageSnServiceProvider;
	case LINKAGESNSAP:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageSnSAPLen;
		return (u_char *) StorageTmp->linkageSnSAP;
	case LINKAGEOPERATIONALPROTOCOLS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageOperationalProtocolsLen;
		return (u_char *) StorageTmp->linkageOperationalProtocols;
	case LINKAGEISISO9542OPERATIONALSUBSETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISiSO9542OperationalSubsetsLen;
		return (u_char *) StorageTmp->linkageISiSO9542OperationalSubsets;
	case LINKAGEISHOLDINGTIMERMULTIPLIER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISHoldingTimerMultiplierLen;
		return (u_char *) StorageTmp->linkageISHoldingTimerMultiplier;
	case LINKAGEISISCONFIGURATIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISConfigurationTimerLen;
		return (u_char *) StorageTmp->linkageISISConfigurationTimer;
	case LINKAGEISSUGGESTEDESCONFIGURATIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISSuggestedEsConfigurationTimerLen;
		return (u_char *) StorageTmp->linkageISSuggestedEsConfigurationTimer;
	case LINKAGEISREDIRECTHOLDINGTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISRedirectHoldingTimeLen;
		return (u_char *) StorageTmp->linkageISRedirectHoldingTime;
	case LINKAGEISESREACHABILITYCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISESReachabilityChanges);
		return (u_char *) &StorageTmp->linkageISESReachabilityChanges;
	case LINKAGEISINVALID9542PDUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISInvalid9542PDUs);
		return (u_char *) &StorageTmp->linkageISInvalid9542PDUs;
	case LINKAGEESISO9542OPERATIONALSUBSETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESiSO9542OperationalSubsetsLen;
		return (u_char *) StorageTmp->linkageESiSO9542OperationalSubsets;
	case LINKAGEESHOLDINGTIMERMULTIPLIER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESHoldingTimerMultiplierLen;
		return (u_char *) StorageTmp->linkageESHoldingTimerMultiplier;
	case LINKAGEESMANUALISSNPAADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESManualISSNPAAddressLen;
		return (u_char *) StorageTmp->linkageESManualISSNPAAddress;
	case LINKAGEESDEFAULTESCONFIGTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESDefaultESConfigTimerLen;
		return (u_char *) StorageTmp->linkageESDefaultESConfigTimer;
	case LINKAGEESACTIVEESCONFIGTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageESActiveESConfigTimerLen;
		return (u_char *) StorageTmp->linkageESActiveESConfigTimer;
	case LINKAGEESISREACHABILITYCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageESISReachabilityChanges);
		return (u_char *) &StorageTmp->linkageESISReachabilityChanges;
	case LINKAGEESINVALID9542PDUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageESInvalid9542PDUs);
		return (u_char *) &StorageTmp->linkageESInvalid9542PDUs;
	case LINKAGEENABLECHECKSUM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageEnableChecksum);
		return (u_char *) &StorageTmp->linkageEnableChecksum;
	case LINKAGEINITIALMINIMUMTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageInitialMinimumTimerLen;
		return (u_char *) StorageTmp->linkageInitialMinimumTimer;
	case LINKAGERESERVETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageReserveTimerLen;
		return (u_char *) StorageTmp->linkageReserveTimer;
	case LINKAGEIDLETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageIdleTimerLen;
		return (u_char *) StorageTmp->linkageIdleTimer;
	case LINKAGESNDCFCALLSPLACED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageSNDCFCallsPlaced);
		return (u_char *) &StorageTmp->linkageSNDCFCallsPlaced;
	case LINKAGESNDCFCALLSFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageSNDCFCallsFailed);
		return (u_char *) &StorageTmp->linkageSNDCFCallsFailed;
	case LINKAGECODLCALLSPLACED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageCODLCallsPlaced);
		return (u_char *) &StorageTmp->linkageCODLCallsPlaced;
	case LINKAGECODLCALLSFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageCODLCallsFailed);
		return (u_char *) &StorageTmp->linkageCODLCallsFailed;
	case LINKAGEISISTYPE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISTypeLen;
		return (u_char *) StorageTmp->linkageISISType;
	case LINKAGEISISISISHELLOTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISiSISHelloTimerLen;
		return (u_char *) StorageTmp->linkageISISiSISHelloTimer;
	case LINKAGEISISL1DEFAULTMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1DefaultMetricLen;
		return (u_char *) StorageTmp->linkageISISl1DefaultMetric;
	case LINKAGEISISL1DELAYMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1DelayMetricLen;
		return (u_char *) StorageTmp->linkageISISl1DelayMetric;
	case LINKAGEISISL1EXPENSEMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1ExpenseMetricLen;
		return (u_char *) StorageTmp->linkageISISl1ExpenseMetric;
	case LINKAGEISISL1ERRORMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1ErrorMetricLen;
		return (u_char *) StorageTmp->linkageISISl1ErrorMetric;
	case LINKAGEISISEXTERNALDOMAIN:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISexternalDomainLen;
		return (u_char *) StorageTmp->linkageISISexternalDomain;
	case LINKAGEISISCHANGEDINADJACENCYSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISchangedInAdjacencyState);
		return (u_char *) &StorageTmp->linkageISISchangedInAdjacencyState;
	case LINKAGEISISINITIALISATIONFAILURES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISinitialisationFailures);
		return (u_char *) &StorageTmp->linkageISISinitialisationFailures;
	case LINKAGEISISREJECTEDADJACENCIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISrejectedAdjacencies);
		return (u_char *) &StorageTmp->linkageISISrejectedAdjacencies;
	case LINKAGEISISISISCONTROLPDUSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISiSISControlPDUsSent);
		return (u_char *) &StorageTmp->linkageISISiSISControlPDUsSent;
	case LINKAGEISISISISCONTROLPDUSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISiSISControlPDUsReceived);
		return (u_char *) &StorageTmp->linkageISISiSISControlPDUsReceived;
	case LINKAGEISISIDFIELDLENTHMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISiDFieldLenthMismatches);
		return (u_char *) &StorageTmp->linkageISISiDFieldLenthMismatches;
	case LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISmaximumAreaAddressesMismatches);
		return (u_char *) &StorageTmp->linkageISISmaximumAreaAddressesMismatches;
	case LINKAGEISISCIRCUITTRANSMITPASSWORD:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScircuitTransmitPasswordLen;
		return (u_char *) StorageTmp->linkageISIScircuitTransmitPassword;
	case LINKAGEISISCIRCUITRECEIVEDPASSWORDS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScircuitReceivedPasswordsLen;
		return (u_char *) StorageTmp->linkageISIScircuitReceivedPasswords;
	case LINKAGEISISAUTHENTICATIONFAILURES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISauthenticationFailures);
		return (u_char *) &StorageTmp->linkageISISauthenticationFailures;
	case LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1IntermediateSystemPriorityLen;
		return (u_char *) StorageTmp->linkageISISl1IntermediateSystemPriority;
	case LINKAGEISISL1CIRCUITID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1CircuitIDLen;
		return (u_char *) StorageTmp->linkageISISl1CircuitID;
	case LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl1DesignatedIntermediateSystemLen;
		return (u_char *) StorageTmp->linkageISISl1DesignatedIntermediateSystem;
	case LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges);
		return (u_char *) &StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges;
	case LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrementLen;
		return (u_char *) StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement;
	case LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScallEstablishmentDelayMetricIncrementLen;
		return (u_char *) StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement;
	case LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrementLen;
		return (u_char *) StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement;
	case LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISIScallEstablishmentErrorMetricIncrementLen;
		return (u_char *) StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement;
	case LINKAGEISISPTPTCIRCUITID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISptPtCircuitIDLen;
		return (u_char *) StorageTmp->linkageISISptPtCircuitID;
	case LINKAGEISISOUTGOINGCALLIVMO:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISoutgoingCallIVMOLen;
		return (u_char *) StorageTmp->linkageISISoutgoingCallIVMO;
	case LINKAGEISISNEIGHBORSNPAADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISneighborSNPAAddressLen;
		return (u_char *) StorageTmp->linkageISISneighborSNPAAddress;
	case LINKAGEISISL2DEFAULTMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2DefaultMetricLen;
		return (u_char *) StorageTmp->linkageISISl2DefaultMetric;
	case LINKAGEISISL2DELAYMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2DelayMetricLen;
		return (u_char *) StorageTmp->linkageISISl2DelayMetric;
	case LINKAGEISISL2EXPENSEMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2ExpenseMetricLen;
		return (u_char *) StorageTmp->linkageISISl2ExpenseMetric;
	case LINKAGEISISL2ERRORMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2ErrorMetricLen;
		return (u_char *) StorageTmp->linkageISISl2ErrorMetric;
	case LINKAGEISISMANUALL2ONLYMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISmanualL2OnlyMode);
		return (u_char *) &StorageTmp->linkageISISmanualL2OnlyMode;
	case LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2IntermediateSystemPriorityLen;
		return (u_char *) StorageTmp->linkageISISl2IntermediateSystemPriority;
	case LINKAGEISISL2CIRCUITID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2CircuitIDLen;
		return (u_char *) StorageTmp->linkageISISl2CircuitID;
	case LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->linkageISISl2DesignatedIntermediateSystemLen;
		return (u_char *) StorageTmp->linkageISISl2DesignatedIntermediateSystem;
	case LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges);
		return (u_char *) &StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges;
	case LINKAGEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->linkageRowStatus);
		return (u_char *) &StorageTmp->linkageRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_cONSTable(): refresh cONSTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cONSTable(void)
{
	if (cONSTable_refresh == 0)
		return;
	cONSTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_cONSTable_row(): refresh cONSTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_cONSTable_row(struct cONSTable_data *StorageTmp)
{
	if (StorageTmp->cONSTable_request == sa_request)
		return;
	StorageTmp->cONSTable_request = sa_request;
}

/*
 * var_cONSTable(): locate variables in cONSTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cONSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cONSTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_cONSTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_cONSTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(cONSTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_cONSTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case CONSADMINISTRATIVESTATE:
		*write_method = write_cONSAdministrativeState;
		*var_len = sizeof(StorageTmp->cONSAdministrativeState);
		return (u_char *) &StorageTmp->cONSAdministrativeState;
	case CONSOPERATIONALSYSTEMTYPE:
		*write_method = write_cONSOperationalSystemType;
		*var_len = StorageTmp->cONSOperationalSystemTypeLen;
		return (u_char *) StorageTmp->cONSOperationalSystemType;
	case CONSROWSTATUS:
		*write_method = write_cONSRowStatus;
		*var_len = sizeof(StorageTmp->cONSRowStatus);
		return (u_char *) &StorageTmp->cONSRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_networkConnectionTable(): refresh networkConnectionTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_networkConnectionTable(void)
{
	if (networkConnectionTable_refresh == 0)
		return;
	networkConnectionTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_networkConnectionTable_row(): refresh networkConnectionTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_networkConnectionTable_row(struct networkConnectionTable_data *StorageTmp)
{
	if (StorageTmp->networkConnectionTable_request == sa_request)
		return;
	StorageTmp->networkConnectionTable_request = sa_request;
}

/*
 * var_networkConnectionTable(): locate variables in networkConnectionTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_networkConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct networkConnectionTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_networkConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_networkConnectionTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(networkConnectionTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_networkConnectionTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case NETWORKCONNECTIONLOCALNSAPMO:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->networkConnectionLocalNSAPMOLen;
		return (u_char *) StorageTmp->networkConnectionLocalNSAPMO;
	case NETWORKCONNECTIONREMOTENSAPADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->networkConnectionRemoteNSAPAddressLen;
		return (u_char *) StorageTmp->networkConnectionRemoteNSAPAddress;
	case NETWORKCONNECTIONROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->networkConnectionRowStatus);
		return (u_char *) &StorageTmp->networkConnectionRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLETable(): refresh x25PLETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLETable(void)
{
	if (x25PLETable_refresh == 0)
		return;
	x25PLETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLETable_row(): refresh x25PLETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLETable_row(struct x25PLETable_data *StorageTmp)
{
	if (StorageTmp->x25PLETable_request == sa_request)
		return;
	StorageTmp->x25PLETable_request = sa_request;
}

/*
 * var_x25PLETable(): locate variables in x25PLETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEoperationalState);
		return (u_char *) &StorageTmp->x25PLEoperationalState;
	case X25PLEADMINISTRATIVESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEadministrativeState);
		return (u_char *) &StorageTmp->x25PLEadministrativeState;
	case X25PLEPROTOCOLVERSIONSUPPORTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEprotocolVersionSupportedLen;
		return (u_char *) StorageTmp->x25PLEprotocolVersionSupported;
	case X25PLELOCALDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLElocalDTEAddressLen;
		return (u_char *) StorageTmp->x25PLElocalDTEAddress;
	case X25PLEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEMode);
		return (u_char *) &StorageTmp->x25PLEMode;
	case X25PLEDEFAULTTHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultThroughputClassesLen;
		return (u_char *) StorageTmp->x25PLEdefaultThroughputClasses;
	case X25PLEFLOWCONTROLPARAMETERNEGOTIATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEflowControlParameterNegotiationLen;
		return (u_char *) StorageTmp->x25PLEflowControlParameterNegotiation;
	case X25PLEDEFAULTPACKAGESIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultPackageSizesLen;
		return (u_char *) StorageTmp->x25PLEdefaultPackageSizes;
	case X25PLETHROUGHPUTCLASSNEGOTIATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEthroughputClassNegotiationLen;
		return (u_char *) StorageTmp->x25PLEthroughputClassNegotiation;
	case X25PLESNSERVICEPROVIDER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEsNserviceProviderLen;
		return (u_char *) StorageTmp->x25PLEsNserviceProvider;
	case X25PLESNSAP:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEsNsAPLen;
		return (u_char *) StorageTmp->x25PLEsNsAP;
	case X25PELOGICALCHANNELASSIGNMENTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PElogicalChannelAssignmentsLen;
		return (u_char *) StorageTmp->x25PElogicalChannelAssignments;
	case X25PLEINTERFACEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEinterfaceMode);
		return (u_char *) &StorageTmp->x25PLEinterfaceMode;
	case X25PLEDEFAULTTHROUGHPUTCLASS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultThroughputClassLen;
		return (u_char *) StorageTmp->x25PLEdefaultThroughputClass;
	case X25PLEFLOWCONTROLNEGOTIATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEflowControlNegotiationPermittedLen;
		return (u_char *) StorageTmp->x25PLEflowControlNegotiationPermitted;
	case X25PLECALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEcallDeflectionSubscription;
	case X25PLEMAXACTIVECIRCUITS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEmaxActiveCircuitsLen;
		return (u_char *) StorageTmp->x25PLEmaxActiveCircuits;
	case X25PLERESTARTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLErestartTimeLen;
		return (u_char *) StorageTmp->x25PLErestartTime;
	case X25PLEDEFAULTPACKETSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultPacketSizeLen;
		return (u_char *) StorageTmp->x25PLEdefaultPacketSize;
	case X25PLEDEFAULTWINDOWSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdefaultWindowSizeLen;
		return (u_char *) StorageTmp->x25PLEdefaultWindowSize;
	case X25PLEMINIMUMRECALLTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEminimumRecallTimerLen;
		return (u_char *) StorageTmp->x25PLEminimumRecallTimer;
	case X25PLERESTARTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLErestartCountLen;
		return (u_char *) StorageTmp->x25PLErestartCount;
	case X25PLESN - SERVICEPROVIDER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEsN - ServiceProviderLen;
		return (u_char *) StorageTmp->x25PLEsN - ServiceProvider;
	case X25PLESN - SA - P:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEsN - SA - PLen;
		return (u_char *) StorageTmp->x25PLEsN - SA - P;
	case X25PLELOGICALCHANNELASSIGNMENTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLElogicalChannelAssignmentsLen;
		return (u_char *) StorageTmp->x25PLElogicalChannelAssignments;
	case X25PLEPACKETSEQUENCING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEpacketSequencingLen;
		return (u_char *) StorageTmp->x25PLEpacketSequencing;
	case X25PLEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEoctetsSentCounterLen;
		return (u_char *) StorageTmp->x25PLEoctetsSentCounter;
	case X25PLEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEoctetsReceivedCounterLen;
		return (u_char *) StorageTmp->x25PLEoctetsReceivedCounter;
	case X25PLEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdataPacketsSentLen;
		return (u_char *) StorageTmp->x25PLEdataPacketsSent;
	case X25PLEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdataPacketsReceivedLen;
		return (u_char *) StorageTmp->x25PLEdataPacketsReceived;
	case X25PLECALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEcallAttemptsLen;
		return (u_char *) StorageTmp->x25PLEcallAttempts;
	case X25PLECALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEcallsConnectedLen;
		return (u_char *) StorageTmp->x25PLEcallsConnected;
	case X25PLEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->x25PLEproviderInitiatedDisconnects;
	case X25PLECALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEcallTimeoutsLen;
		return (u_char *) StorageTmp->x25PLEcallTimeouts;
	case X25PLECLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEclearTimeoutsLen;
		return (u_char *) StorageTmp->x25PLEclearTimeouts;
	case X25PLEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEremotelyInitiatedResetsLen;
		return (u_char *) StorageTmp->x25PLEremotelyInitiatedResets;
	case X25PLEDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEdataRetransmissionTimerExpiriesLen;
		return (u_char *) StorageTmp->x25PLEdataRetransmissionTimerExpiries;
	case X25PLEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEproviderInitiatedResetsLen;
		return (u_char *) StorageTmp->x25PLEproviderInitiatedResets;
	case X25PLERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEresetTimeoutsLen;
		return (u_char *) StorageTmp->x25PLEresetTimeouts;
	case X25PLEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEremotelyInitiatedRestartsLen;
		return (u_char *) StorageTmp->x25PLEremotelyInitiatedRestarts;
	case X25PLERESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLErestartCountsExceededLen;
		return (u_char *) StorageTmp->x25PLErestartCountsExceeded;
	case X25PLEPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEprotocolErrorsDetectedLocallyLen;
		return (u_char *) StorageTmp->x25PLEprotocolErrorsDetectedLocally;
	case X25PLEPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEprotocolErrorsAccusedOfLen;
		return (u_char *) StorageTmp->x25PLEprotocolErrorsAccusedOf;
	case X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEcallEstablishmentRetryCountsExceededLen;
		return (u_char *) StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded;
	case X25PLECLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEclearCountsExceededLen;
		return (u_char *) StorageTmp->x25PLEclearCountsExceeded;
	case X25PLEPLECLIENTMONAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEpLEClientMONameLen;
		return (u_char *) StorageTmp->x25PLEpLEClientMOName;
	case X25PLEREGISTRATIONREQUESTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEregistrationRequestTimeLen;
		return (u_char *) StorageTmp->x25PLEregistrationRequestTime;
	case X25PLEREGISTRATIONREQUESTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEregistrationRequestCountLen;
		return (u_char *) StorageTmp->x25PLEregistrationRequestCount;
	case X25PLEREGISTRATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEregistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEregistrationPermitted;
	case X25PLEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLERowStatus);
		return (u_char *) &StorageTmp->x25PLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLE-DTETable(): refresh x25PLE-DTETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_x25PLE -
DTETable(void)
{
	if (x25PLE - DTETable_refresh == 0)
		return;
	x25PLE - DTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLE-DTETable_row(): refresh x25PLE-DTETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_x25PLE -
DTETable_row(struct x25PLE -DTETable_data * StorageTmp)
{
	if (StorageTmp->x25PLE - DTETable_request == sa_request)
		return;
	StorageTmp->x25PLE - DTETable_request = sa_request;
}

/*
 * var_x25PLE-DTETable(): locate variables in x25PLE-DTETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_x25PLE -
DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLE -DTETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLE-DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLE - DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLE - DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLE - DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLE - DTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLE - DTEcallDeflectionSubscription;
	case X25PLE - DTECALLREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEcallRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTEcallRequestResponseTimer;
	case X25PLE - DTEEXTENDEDPACKETSEQUENCENUMBERING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEextendedPacketSequenceNumberingLen;
		return (u_char *) StorageTmp->x25PLE - DTEextendedPacketSequenceNumbering;
	case X25PLE - DTEMAXACTIVECIRCUITS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEmaxActiveCircuitsLen;
		return (u_char *) StorageTmp->x25PLE - DTEmaxActiveCircuits;
	case X25PLE - DTEMINIMUMRECALLTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEminimumRecallTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTEminimumRecallTimer;
	case X25PLE - DTERESETREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEresetRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTEresetRequestResponseTimer;
	case X25PLE - DTERESTARTREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTErestartRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE - DTErestartRequestRetransmissionCount;
	case X25PLE - DTERESTARTREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTErestartRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTErestartRequestResponseTimer;
	case X25PLE - DTECLEARREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEclearRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTEclearRequestResponseTimer;
	case X25PLE - DTEINTERRUPTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEinterruptResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTEinterruptResponseTimer;
	case X25PLE - DTERESETREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEresetRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE - DTEresetRequestRetransmissionCount;
	case X25PLE - DTECLEARREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEclearRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE - DTEclearRequestRetransmissionCount;
	case X25PLE - DTECALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEcallAttempts);
		return (u_char *) &StorageTmp->x25PLE - DTEcallAttempts;
	case X25PLE - DTEPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEprotocolErrorsDetectedLocally);
		return (u_char *) &StorageTmp->x25PLE - DTEprotocolErrorsDetectedLocally;
	case X25PLE - DTEPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEprotocolErrorsAccusedOf);
		return (u_char *) &StorageTmp->x25PLE - DTEprotocolErrorsAccusedOf;
	case X25PLE - DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEcallEstablishmentRetryCountsExceeded);
		return (u_char *) &StorageTmp->x25PLE - DTEcallEstablishmentRetryCountsExceeded;
	case X25PLE - DTEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->x25PLE - DTEoctetsReceivedCounter;
	case X25PLE - DTEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEoctetsSentCounter);
		return (u_char *) &StorageTmp->x25PLE - DTEoctetsSentCounter;
	case X25PLE - DTECALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEcallTimeouts);
		return (u_char *) &StorageTmp->x25PLE - DTEcallTimeouts;
	case X25PLE - DTECALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEcallsConnected);
		return (u_char *) &StorageTmp->x25PLE - DTEcallsConnected;
	case X25PLE - DTECLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEclearCountsExceeded);
		return (u_char *) &StorageTmp->x25PLE - DTEclearCountsExceeded;
	case X25PLE - DTECLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEclearTimeouts);
		return (u_char *) &StorageTmp->x25PLE - DTEclearTimeouts;
	case X25PLE - DTEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEdataPacketsReceived);
		return (u_char *) &StorageTmp->x25PLE - DTEdataPacketsReceived;
	case X25PLE - DTEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEdataPacketsSent);
		return (u_char *) &StorageTmp->x25PLE - DTEdataPacketsSent;
	case X25PLE - DTEDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEdataRetransmissionTimerExpiries);
		return (u_char *) &StorageTmp->x25PLE - DTEdataRetransmissionTimerExpiries;
	case X25PLE - DTEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEproviderInitiatedResets);
		return (u_char *) &StorageTmp->x25PLE - DTEproviderInitiatedResets;
	case X25PLE - DTEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->x25PLE - DTEproviderInitiatedDisconnects;
	case X25PLE - DTEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->x25PLE - DTEremotelyInitiatedResets;
	case X25PLE - DTEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEremotelyInitiatedRestarts);
		return (u_char *) &StorageTmp->x25PLE - DTEremotelyInitiatedRestarts;
	case X25PLE - DTERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEresetTimeouts);
		return (u_char *) &StorageTmp->x25PLE - DTEresetTimeouts;
	case X25PLE - DTERESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTErestartCountsExceeded);
		return (u_char *) &StorageTmp->x25PLE - DTErestartCountsExceeded;
	case X25PLE - DTEWINDOWSTATUSTRANSMISSIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEwindowStatusTransmissionTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTEwindowStatusTransmissionTimer;
	case X25PLE - DTEWINDOWROTATIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEwindowRotationTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTEwindowRotationTimer;
	case X25PLE - DTEDATAPACKETRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEdataPacketRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE - DTEdataPacketRetransmissionCount;
	case X25PLE - DTEREJECTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTErejectResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTErejectResponseTimer;
	case X25PLE - DTEREJECTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTErejectRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE - DTErejectRetransmissionCount;
	case X25PLE - DTEREGISTRATIONREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEregistrationRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLE - DTEregistrationRequestResponseTimer;
	case X25PLE - DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DTEregistrationRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLE - DTEregistrationRequestRetransmissionCount;
	case X25PLE - DTEREGISTRATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DTEregistrationPermitted);
		return (u_char *) &StorageTmp->x25PLE - DTEregistrationPermitted;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLE-DCETable(): refresh x25PLE-DCETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_x25PLE -
DCETable(void)
{
	if (x25PLE - DCETable_refresh == 0)
		return;
	x25PLE - DCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLE-DCETable_row(): refresh x25PLE-DCETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_x25PLE -
DCETable_row(struct x25PLE -DCETable_data * StorageTmp)
{
	if (StorageTmp->x25PLE - DCETable_request == sa_request)
		return;
	StorageTmp->x25PLE - DCETable_request = sa_request;
}

/*
 * var_x25PLE-DCETable(): locate variables in x25PLE-DCETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_x25PLE -
DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLE -DCETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLE-DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLE - DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLE - DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLE - DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLE - DCECALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEcallAttempts);
		return (u_char *) &StorageTmp->x25PLE - DCEcallAttempts;
	case X25PLE - DCECALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEcallsConnected);
		return (u_char *) &StorageTmp->x25PLE - DCEcallsConnected;
	case X25PLE - DCECUG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEcUG);
		return (u_char *) &StorageTmp->x25PLE - DCEcUG;
	case X25PLE - DCEFASTSELECTACCEPTANCE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEfastSelectAcceptance);
		return (u_char *) &StorageTmp->x25PLE - DCEfastSelectAcceptance;
	case X25PLE - DCEINCOMINGCALLSBARRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEincomingCallsBarred);
		return (u_char *) &StorageTmp->x25PLE - DCEincomingCallsBarred;
	case X25PLE - DCEONEWAYLOGICALCHANNELOUTGOING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEoneWayLogicalChannelOutgoing);
		return (u_char *) &StorageTmp->x25PLE - DCEoneWayLogicalChannelOutgoing;
	case X25PLE - DCEOUTGOINGCALLSBARRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEoutgoingCallsBarred);
		return (u_char *) &StorageTmp->x25PLE - DCEoutgoingCallsBarred;
	case X25PLE - DCEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEdataPacketsReceived);
		return (u_char *) &StorageTmp->x25PLE - DCEdataPacketsReceived;
	case X25PLE - DCEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEdataPacketsSent);
		return (u_char *) &StorageTmp->x25PLE - DCEdataPacketsSent;
	case X25PLE - DCEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEinterruptPacketsReceived);
		return (u_char *) &StorageTmp->x25PLE - DCEinterruptPacketsReceived;
	case X25PLE - DCEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEinterruptPacketsSent);
		return (u_char *) &StorageTmp->x25PLE - DCEinterruptPacketsSent;
	case X25PLE - DCEINTERRUPTTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEinterruptTimerExpiries);
		return (u_char *) &StorageTmp->x25PLE - DCEinterruptTimerExpiries;
	case X25PLE - DCEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->x25PLE - DCEoctetsReceivedCounter;
	case X25PLE - DCEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEoctetsSentCounter);
		return (u_char *) &StorageTmp->x25PLE - DCEoctetsSentCounter;
	case X25PLE - DCEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->x25PLE - DCEproviderInitiatedDisconnects;
	case X25PLE - DCEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEproviderInitiatedResets);
		return (u_char *) &StorageTmp->x25PLE - DCEproviderInitiatedResets;
	case X25PLE - DCEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEremotelyInitiatedRestarts);
		return (u_char *) &StorageTmp->x25PLE - DCEremotelyInitiatedRestarts;
	case X25PLE - DCEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->x25PLE - DCEremotelyInitiatedResets;
	case X25PLE - DCERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEresetTimeouts);
		return (u_char *) &StorageTmp->x25PLE - DCEresetTimeouts;
	case X25PLE - DCEX25SEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEx25SegmentsReceived);
		return (u_char *) &StorageTmp->x25PLE - DCEx25SegmentsReceived;
	case X25PLE - DCEX25SEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEx25SegmentsSent);
		return (u_char *) &StorageTmp->x25PLE - DCEx25SegmentsSent;
	case X25PLE - DCEBILATERALCUG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEbilateralCUG);
		return (u_char *) &StorageTmp->x25PLE - DCEbilateralCUG;
	case X25PLE - DCEBILATERALCUGWITHOUTGOINGACCESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEbilateralCUGWithOutgoingAccess);
		return (u_char *) &StorageTmp->x25PLE - DCEbilateralCUGWithOutgoingAccess;
	case X25PLE - DCECALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLE - DCEcallDeflectionSubscription;
	case X25PLE - DCECALLREDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEcallRedirection);
		return (u_char *) &StorageTmp->x25PLE - DCEcallRedirection;
	case X25PLE - DCECHARGINGINFORMATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEchargingInformation);
		return (u_char *) &StorageTmp->x25PLE - DCEchargingInformation;
	case X25PLE - DCECUGWITHINCOMINGACCESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEcUGWithIncomingAccess);
		return (u_char *) &StorageTmp->x25PLE - DCEcUGWithIncomingAccess;
	case X25PLE - DCECUGWITHOUTGOINGACCESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEcUGWithOutgoingAccess);
		return (u_char *) &StorageTmp->x25PLE - DCEcUGWithOutgoingAccess;
	case X25PLE - DCEDBITMODIFICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEdBitModification);
		return (u_char *) &StorageTmp->x25PLE - DCEdBitModification;
	case X25PLE - DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DCEdefaultThroughputClassesAssignmentLen;
		return (u_char *) StorageTmp->x25PLE - DCEdefaultThroughputClassesAssignment;
	case X25PLE - DCEEXTENDEDPACKETSEQUENCENUMBERING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DCEextendedPacketSequenceNumberingLen;
		return (u_char *) StorageTmp->x25PLE - DCEextendedPacketSequenceNumbering;
	case X25PLE - DCEHUNTGROUP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEhuntGroup);
		return (u_char *) &StorageTmp->x25PLE - DCEhuntGroup;
	case X25PLE - DCEINCOMINGCALLBARREDWITHINCUG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEincomingCallBarredWithinCUG);
		return (u_char *) &StorageTmp->x25PLE - DCEincomingCallBarredWithinCUG;
	case X25PLE - DCELOCALCHARGINGPREVENTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCElocalChargingPrevention);
		return (u_char *) &StorageTmp->x25PLE - DCElocalChargingPrevention;
	case X25PLE - DCENONSTANDARDDEFAULTPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DCEnonStandardDefaultPacketSizesLen;
		return (u_char *) StorageTmp->x25PLE - DCEnonStandardDefaultPacketSizes;
	case X25PLE - DCENONSTANDARDDEFAULTWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DCEnonStandardDefaultWindowSizesLen;
		return (u_char *) StorageTmp->x25PLE - DCEnonStandardDefaultWindowSizes;
	case X25PLE - DCENUIOVERRIDE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEnUIOverride);
		return (u_char *) &StorageTmp->x25PLE - DCEnUIOverride;
	case X25PLE - DCENUISUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEnUISubscription);
		return (u_char *) &StorageTmp->x25PLE - DCEnUISubscription;
	case X25PLE - DCEONEWAYLOGICALCHANNELINCOMING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEoneWayLogicalChannelIncoming);
		return (u_char *) &StorageTmp->x25PLE - DCEoneWayLogicalChannelIncoming;
	case X25PLE - DCEONLINEFACILITYREGISTRATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEonlineFacilityRegistration);
		return (u_char *) &StorageTmp->x25PLE - DCEonlineFacilityRegistration;
	case X25PLE - DCEOUTGOINGCALLBARREDWITHINCUG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEoutgoingCallBarredWithinCUG);
		return (u_char *) &StorageTmp->x25PLE - DCEoutgoingCallBarredWithinCUG;
	case X25PLE - DCEPACKETRETRANSMISSION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEpacketRetransmission);
		return (u_char *) &StorageTmp->x25PLE - DCEpacketRetransmission;
	case X25PLE - DCEREVERSECHARGINGACCEPTANCE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEreverseChargingAcceptance);
		return (u_char *) &StorageTmp->x25PLE - DCEreverseChargingAcceptance;
	case X25PLE - DCEROASUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCErOASubscription);
		return (u_char *) &StorageTmp->x25PLE - DCErOASubscription;
	case X25PLE - DCECLEARINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLE - DCEclearIndication);
		return (u_char *) &StorageTmp->x25PLE - DCEclearIndication;
	case X25PLE - DCEINCOMINGCALL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DCEincomingCallLen;
		return (u_char *) StorageTmp->x25PLE - DCEincomingCall;
	case X25PLE - DCERESETINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DCEresetIndicationLen;
		return (u_char *) StorageTmp->x25PLE - DCEresetIndication;
	case X25PLE - DCERESTARTINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLE - DCErestartIndicationLen;
		return (u_char *) StorageTmp->x25PLE - DCErestartIndication;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEIVMOTable(): refresh x25PLEIVMOTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMOTable(void)
{
	if (x25PLEIVMOTable_refresh == 0)
		return;
	x25PLEIVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEIVMOTable_row(): refresh x25PLEIVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEIVMOTable_row(struct x25PLEIVMOTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMOTable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMOTable_request = sa_request;
}

/*
 * var_x25PLEIVMOTable(): locate variables in x25PLEIVMOTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLEIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLEIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLEIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLEIVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMOLOCALDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOlocalDTEAddressLen;
		return (u_char *) StorageTmp->x25PLEIVMOlocalDTEAddress;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOlogicalChannelAssignmentsLen;
		return (u_char *) StorageTmp->x25PLEIVMOlogicalChannelAssignments;
	case X25PLEIVMOSN - SERVICEPROVIDER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOsN - ServiceProviderLen;
		return (u_char *) StorageTmp->x25PLEIVMOsN - ServiceProvider;
	case X25PLEIVMODEFAULTPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultPacketSizesLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultPacketSizes;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultThroughputClassesLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultThroughputClasses;
	case X25PLEIVMODEFAULTWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultWindowSizesLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultWindowSizes;
	case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOflowControlParameterNegotiationLen;
		return (u_char *) StorageTmp->x25PLEIVMOflowControlParameterNegotiation;
	case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOthroughputClassNegotiationLen;
		return (u_char *) StorageTmp->x25PLEIVMOthroughputClassNegotiation;
	case X25PLEIVMOX25PLEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOx25PLEModeLen;
		return (u_char *) StorageTmp->x25PLEIVMOx25PLEMode;
	case X25PLEIVMOINTERFACEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMOinterfaceMode);
		return (u_char *) &StorageTmp->x25PLEIVMOinterfaceMode;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultThroughputClassLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultThroughputClass;
	case X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOflowControlNegotiationPermittedLen;
		return (u_char *) StorageTmp->x25PLEIVMOflowControlNegotiationPermitted;
	case X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMOcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEIVMOcallDeflectionSubscription;
	case X25PLEIVMOMAXACTIVECIRCUITS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOmaxActiveCircuitsLen;
		return (u_char *) StorageTmp->x25PLEIVMOmaxActiveCircuits;
	case X25PLEIVMORESTARTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOrestartTimeLen;
		return (u_char *) StorageTmp->x25PLEIVMOrestartTime;
	case X25PLEIVMODEFAULTPACKETSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultPacketSizeLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultPacketSize;
	case X25PLEIVMODEFAULTWINDOWSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOdefaultWindowSizeLen;
		return (u_char *) StorageTmp->x25PLEIVMOdefaultWindowSize;
	case X25PLEIVMOMINIMUMRECALLTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOminimumRecallTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMOminimumRecallTimer;
	case X25PLEIVMORESTARTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOrestartCountLen;
		return (u_char *) StorageTmp->x25PLEIVMOrestartCount;
	case X25PLEIVMOPACKETSEQUENCING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOpacketSequencingLen;
		return (u_char *) StorageTmp->x25PLEIVMOpacketSequencing;
	case X25PLEIVMOREGISTRATIONREQUESTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOregistrationRequestTimeLen;
		return (u_char *) StorageTmp->x25PLEIVMOregistrationRequestTime;
	case X25PLEIVMOREGISTRATIONREQUESTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMOregistrationRequestCountLen;
		return (u_char *) StorageTmp->x25PLEIVMOregistrationRequestCount;
	case X25PLEIVMOREGISTRATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMOregistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEIVMOregistrationPermitted;
	case X25PLEIVMOROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMORowStatus);
		return (u_char *) &StorageTmp->x25PLEIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEIVMO-DTETable(): refresh x25PLEIVMO-DTETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_x25PLEIVMO -
DTETable(void)
{
	if (x25PLEIVMO - DTETable_refresh == 0)
		return;
	x25PLEIVMO - DTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEIVMO-DTETable_row(): refresh x25PLEIVMO-DTETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_x25PLEIVMO -
DTETable_row(struct x25PLEIVMO -DTETable_data * StorageTmp)
{
	if (StorageTmp->x25PLEIVMO - DTETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMO - DTETable_request = sa_request;
}

/*
 * var_x25PLEIVMO-DTETable(): locate variables in x25PLEIVMO-DTETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_x25PLEIVMO -
DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLEIVMO -DTETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLEIVMO-DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMO - DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLEIVMO - DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMO - DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMO - DTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEcallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEcallDeflectionSubscription;
	case X25PLEIVMO - DTECALLREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEcallRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEcallRequestResponseTimer;
	case X25PLEIVMO - DTEEXTENDEDPACKETSEQUENCENUMBERING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEextendedPacketSequenceNumberingLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEextendedPacketSequenceNumbering;
	case X25PLEIVMO - DTEMAXACTIVECIRCUITS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEmaxActiveCircuitsLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEmaxActiveCircuits;
	case X25PLEIVMO - DTEMINIMUMRECALLTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEminimumRecallTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEminimumRecallTimer;
	case X25PLEIVMO - DTERESETREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEresetRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEresetRequestResponseTimer;
	case X25PLEIVMO - DTERESTARTREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTErestartRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTErestartRequestRetransmissionCount;
	case X25PLEIVMO - DTERESTARTREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTErestartRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTErestartRequestResponseTimer;
	case X25PLEIVMO - DTECLEARREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEclearRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEclearRequestResponseTimer;
	case X25PLEIVMO - DTEINTERRUPTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEinterruptResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEinterruptResponseTimer;
	case X25PLEIVMO - DTERESETREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEresetRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEresetRequestRetransmissionCount;
	case X25PLEIVMO - DTECLEARREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEclearRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEclearRequestRetransmissionCount;
	case X25PLEIVMO - DTECALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEcallAttemptsLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEcallAttempts;
	case X25PLEIVMO - DTEPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEprotocolErrorsDetectedLocallyLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEprotocolErrorsDetectedLocally;
	case X25PLEIVMO - DTEPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEprotocolErrorsAccusedOfLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEprotocolErrorsAccusedOf;
	case X25PLEIVMO - DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEcallEstablishmentRetryCountsExceededLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEcallEstablishmentRetryCountsExceeded;
	case X25PLEIVMO - DTEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEoctetsReceivedCounter;
	case X25PLEIVMO - DTEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEoctetsSentCounter);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEoctetsSentCounter;
	case X25PLEIVMO - DTECALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEcallTimeouts);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEcallTimeouts;
	case X25PLEIVMO - DTECALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEcallsConnected);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEcallsConnected;
	case X25PLEIVMO - DTECLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEclearCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEclearCountsExceeded;
	case X25PLEIVMO - DTECLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEclearTimeouts);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEclearTimeouts;
	case X25PLEIVMO - DTEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEdataPacketsReceived);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEdataPacketsReceived;
	case X25PLEIVMO - DTEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEdataPacketsSent);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEdataPacketsSent;
	case X25PLEIVMO - DTEDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEdataRetransmissionTimerExpiries);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEdataRetransmissionTimerExpiries;
	case X25PLEIVMO - DTEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEproviderInitiatedResets);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEproviderInitiatedResets;
	case X25PLEIVMO - DTEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEproviderInitiatedDisconnects;
	case X25PLEIVMO - DTEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEremotelyInitiatedResets;
	case X25PLEIVMO - DTEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEremotelyInitiatedRestarts);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEremotelyInitiatedRestarts;
	case X25PLEIVMO - DTERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEresetTimeouts);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEresetTimeouts;
	case X25PLEIVMO - DTERESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTErestartCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTErestartCountsExceeded;
	case X25PLEIVMO - DTEWINDOWSTATUSTRANSMISSIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEwindowStatusTransmissionTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEwindowStatusTransmissionTimer;
	case X25PLEIVMO - DTEWINDOWROTATIONTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEwindowRotationTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEwindowRotationTimer;
	case X25PLEIVMO - DTEDATAPACKETRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEdataPacketRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEdataPacketRetransmissionCount;
	case X25PLEIVMO - DTEREJECTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTErejectResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTErejectResponseTimer;
	case X25PLEIVMO - DTEREJECTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTErejectRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTErejectRetransmissionCount;
	case X25PLEIVMO - DTEREGISTRATIONREQUESTRESPONSETIMER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEregistrationRequestResponseTimerLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEregistrationRequestResponseTimer;
	case X25PLEIVMO - DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEIVMO - DTEregistrationRequestRetransmissionCountLen;
		return (u_char *) StorageTmp->x25PLEIVMO - DTEregistrationRequestRetransmissionCount;
	case X25PLEIVMO - DTEREGISTRATIONPERMITTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTEregistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTEregistrationPermitted;
	case X25PLEIVMO - DTEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DTERowStatus);
		return (u_char *) &StorageTmp->x25PLEIVMO - DTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEIVMO-DCETable(): refresh x25PLEIVMO-DCETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_x25PLEIVMO -
DCETable(void)
{
	if (x25PLEIVMO - DCETable_refresh == 0)
		return;
	x25PLEIVMO - DCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEIVMO-DCETable_row(): refresh x25PLEIVMO-DCETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_x25PLEIVMO -
DCETable_row(struct x25PLEIVMO -DCETable_data * StorageTmp)
{
	if (StorageTmp->x25PLEIVMO - DCETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMO - DCETable_request = sa_request;
}

/*
 * var_x25PLEIVMO-DCETable(): locate variables in x25PLEIVMO-DCETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_x25PLEIVMO -
DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLEIVMO -DCETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_x25PLEIVMO-DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMO - DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(x25PLEIVMO - DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMO - DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMO - DCEROWSTATUS:
		*write_method = write_x25PLEIVMO - DCERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEIVMO - DCERowStatus);
		return (u_char *) &StorageTmp->x25PLEIVMO - DCERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_virtualCallTable(): refresh virtualCallTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCallTable(void)
{
	if (virtualCallTable_refresh == 0)
		return;
	virtualCallTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_virtualCallTable_row(): refresh virtualCallTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCallTable_row(struct virtualCallTable_data *StorageTmp)
{
	if (StorageTmp->virtualCallTable_request == sa_request)
		return;
	StorageTmp->virtualCallTable_request = sa_request;
}

/*
 * var_virtualCallTable(): locate variables in virtualCallTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCallTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCallTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCallTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCallTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCallTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCALLCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallChannelLen;
		return (u_char *) StorageTmp->virtualCallChannel;
	case VIRTUALCALLPACKETSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallPacketSizeLen;
		return (u_char *) StorageTmp->virtualCallPacketSize;
	case VIRTUALCALLWINDOWSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallWindowSizeLen;
		return (u_char *) StorageTmp->virtualCallWindowSize;
	case VIRTUALCALLOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallOctetsSentCounterLen;
		return (u_char *) StorageTmp->virtualCallOctetsSentCounter;
	case VIRTUALCALLOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallOctetsReceivedCounterLen;
		return (u_char *) StorageTmp->virtualCallOctetsReceivedCounter;
	case VIRTUALCALLDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallDataPacketsSentLen;
		return (u_char *) StorageTmp->virtualCallDataPacketsSent;
	case VIRTUALCALLDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallDataPacketsReceivedLen;
		return (u_char *) StorageTmp->virtualCallDataPacketsReceived;
	case VIRTUALCALLREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallRemotelyInitiatedResetsLen;
		return (u_char *) StorageTmp->virtualCallRemotelyInitiatedResets;
	case VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallDataRetransmissionTimerExpiriesLen;
		return (u_char *) StorageTmp->virtualCallDataRetransmissionTimerExpiries;
	case VIRTUALCALLPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallProviderInitiatedResetsLen;
		return (u_char *) StorageTmp->virtualCallProviderInitiatedResets;
	case VIRTUALCALLRESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallResetTimeoutsLen;
		return (u_char *) StorageTmp->virtualCallResetTimeouts;
	case VIRTUALCALLINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallInterruptPacketsSentLen;
		return (u_char *) StorageTmp->virtualCallInterruptPacketsSent;
	case VIRTUALCALLINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallInterruptPacketsReceivedLen;
		return (u_char *) StorageTmp->virtualCallInterruptPacketsReceived;
	case VIRTUALCALLINTERRUPTTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallInterruptTimerExpiriesLen;
		return (u_char *) StorageTmp->virtualCallInterruptTimerExpiries;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_virtualCircuitTable(): refresh virtualCircuitTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCircuitTable(void)
{
	if (virtualCircuitTable_refresh == 0)
		return;
	virtualCircuitTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_virtualCircuitTable_row(): refresh virtualCircuitTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCircuitTable_row(struct virtualCircuitTable_data *StorageTmp)
{
	if (StorageTmp->virtualCircuitTable_request == sa_request)
		return;
	StorageTmp->virtualCircuitTable_request = sa_request;
}

/*
 * var_virtualCircuitTable(): locate variables in virtualCircuitTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCircuitTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCircuitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCircuitTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCircuitTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCircuitTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCIRCUITLOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCircuitLogicalChannelLen;
		return (u_char *) StorageTmp->virtualCircuitLogicalChannel;
	case VIRTUALCIRCUITPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCircuitPacketSizesLen;
		return (u_char *) StorageTmp->virtualCircuitPacketSizes;
	case VIRTUALCIRCUITTHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCircuitThroughputClassesLen;
		return (u_char *) StorageTmp->virtualCircuitThroughputClasses;
	case VIRTUALCIRCUITWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCircuitWindowSizesLen;
		return (u_char *) StorageTmp->virtualCircuitWindowSizes;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_virtualCircuit-DTETable(): refresh virtualCircuit-DTETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_virtualCircuit -
DTETable(void)
{
	if (virtualCircuit - DTETable_refresh == 0)
		return;
	virtualCircuit - DTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_virtualCircuit-DTETable_row(): refresh virtualCircuit-DTETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_virtualCircuit -
DTETable_row(struct virtualCircuit -DTETable_data * StorageTmp)
{
	if (StorageTmp->virtualCircuit - DTETable_request == sa_request)
		return;
	StorageTmp->virtualCircuit - DTETable_request = sa_request;
}

/*
 * var_virtualCircuit-DTETable(): locate variables in virtualCircuit-DTETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_virtualCircuit -
DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCircuit -DTETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCircuit-DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCircuit - DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCircuit - DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCircuit - DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCIRCUIT - DTEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEoctetsSentCounter);
		return (u_char *) &StorageTmp->virtualCircuit - DTEoctetsSentCounter;
	case VIRTUALCIRCUIT - DTEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->virtualCircuit - DTEoctetsReceivedCounter;
	case VIRTUALCIRCUIT - DTEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEdataPacketsReceived);
		return (u_char *) &StorageTmp->virtualCircuit - DTEdataPacketsReceived;
	case VIRTUALCIRCUIT - DTEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEdataPacketsSent);
		return (u_char *) &StorageTmp->virtualCircuit - DTEdataPacketsSent;
	case VIRTUALCIRCUIT - DTEDATARETRANSMISSIONTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEdataRetransmissionTimerExpiries);
		return (u_char *) &StorageTmp->virtualCircuit - DTEdataRetransmissionTimerExpiries;
	case VIRTUALCIRCUIT - DTEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEinterruptPacketsReceived);
		return (u_char *) &StorageTmp->virtualCircuit - DTEinterruptPacketsReceived;
	case VIRTUALCIRCUIT - DTEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEinterruptPacketsSent);
		return (u_char *) &StorageTmp->virtualCircuit - DTEinterruptPacketsSent;
	case VIRTUALCIRCUIT - DTEINTERRUPTTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEinterruptTimerExpiries);
		return (u_char *) &StorageTmp->virtualCircuit - DTEinterruptTimerExpiries;
	case VIRTUALCIRCUIT - DTEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEproviderInitiatedResets);
		return (u_char *) &StorageTmp->virtualCircuit - DTEproviderInitiatedResets;
	case VIRTUALCIRCUIT - DTEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->virtualCircuit - DTEremotelyInitiatedResets;
	case VIRTUALCIRCUIT - DTERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DTEresetTimeouts);
		return (u_char *) &StorageTmp->virtualCircuit - DTEresetTimeouts;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_virtualCircuit-DCETable(): refresh virtualCircuit-DCETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_virtualCircuit -
DCETable(void)
{
	if (virtualCircuit - DCETable_refresh == 0)
		return;
	virtualCircuit - DCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_virtualCircuit-DCETable_row(): refresh virtualCircuit-DCETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_virtualCircuit -
DCETable_row(struct virtualCircuit -DCETable_data * StorageTmp)
{
	if (StorageTmp->virtualCircuit - DCETable_request == sa_request)
		return;
	StorageTmp->virtualCircuit - DCETable_request = sa_request;
}

/*
 * var_virtualCircuit-DCETable(): locate variables in virtualCircuit-DCETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_virtualCircuit -
DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCircuit -DCETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCircuit-DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCircuit - DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCircuit - DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCircuit - DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCIRCUIT - DCEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEdataPacketsReceived);
		return (u_char *) &StorageTmp->virtualCircuit - DCEdataPacketsReceived;
	case VIRTUALCIRCUIT - DCEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEdataPacketsSent);
		return (u_char *) &StorageTmp->virtualCircuit - DCEdataPacketsSent;
	case VIRTUALCIRCUIT - DCEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEinterruptPacketsReceived);
		return (u_char *) &StorageTmp->virtualCircuit - DCEinterruptPacketsReceived;
	case VIRTUALCIRCUIT - DCEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEinterruptPacketsSent);
		return (u_char *) &StorageTmp->virtualCircuit - DCEinterruptPacketsSent;
	case VIRTUALCIRCUIT - DCEINTERRUPTTIMEREXPIRIES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEinterruptTimerExpiries);
		return (u_char *) &StorageTmp->virtualCircuit - DCEinterruptTimerExpiries;
	case VIRTUALCIRCUIT - DCEOCTETSRECEIVEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEoctetsReceivedCounter);
		return (u_char *) &StorageTmp->virtualCircuit - DCEoctetsReceivedCounter;
	case VIRTUALCIRCUIT - DCEOCTETSSENTCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEoctetsSentCounter);
		return (u_char *) &StorageTmp->virtualCircuit - DCEoctetsSentCounter;
	case VIRTUALCIRCUIT - DCEPROVIDERINITIATEDDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEproviderInitiatedDisconnects);
		return (u_char *) &StorageTmp->virtualCircuit - DCEproviderInitiatedDisconnects;
	case VIRTUALCIRCUIT - DCEPROVIDERINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEproviderInitiatedResets);
		return (u_char *) &StorageTmp->virtualCircuit - DCEproviderInitiatedResets;
	case VIRTUALCIRCUIT - DCEREMOTELYINITIATEDRESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEremotelyInitiatedRestarts);
		return (u_char *) &StorageTmp->virtualCircuit - DCEremotelyInitiatedRestarts;
	case VIRTUALCIRCUIT - DCEREMOTELYINITIATEDRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEremotelyInitiatedResets);
		return (u_char *) &StorageTmp->virtualCircuit - DCEremotelyInitiatedResets;
	case VIRTUALCIRCUIT - DCERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEresetTimeouts);
		return (u_char *) &StorageTmp->virtualCircuit - DCEresetTimeouts;
	case VIRTUALCIRCUIT - DCEX25SEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEx25SegmentsReceived);
		return (u_char *) &StorageTmp->virtualCircuit - DCEx25SegmentsReceived;
	case VIRTUALCIRCUIT - DCEX25SEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCircuit - DCEx25SegmentsSent);
		return (u_char *) &StorageTmp->virtualCircuit - DCEx25SegmentsSent;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_permanentVirtualCircuitTable(): refresh permanentVirtualCircuitTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_permanentVirtualCircuitTable(void)
{
	if (permanentVirtualCircuitTable_refresh == 0)
		return;
	permanentVirtualCircuitTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_permanentVirtualCircuitTable_row(): refresh permanentVirtualCircuitTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_permanentVirtualCircuitTable_row(struct permanentVirtualCircuitTable_data *StorageTmp)
{
	if (StorageTmp->permanentVirtualCircuitTable_request == sa_request)
		return;
	StorageTmp->permanentVirtualCircuitTable_request = sa_request;
}

/*
 * var_permanentVirtualCircuitTable(): locate variables in permanentVirtualCircuitTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_permanentVirtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct permanentVirtualCircuitTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_permanentVirtualCircuitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_permanentVirtualCircuitTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(permanentVirtualCircuitTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_permanentVirtualCircuitTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PERMANENTVIRTUALCIRCUITCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuitChannelLen;
		return (u_char *) StorageTmp->permanentVirtualCircuitChannel;
	case PERMANENTVIRTUALCIRCUITROWSTATUS:
		*write_method = write_permanentVirtualCircuitRowStatus;
		*var_len = sizeof(StorageTmp->permanentVirtualCircuitRowStatus);
		return (u_char *) &StorageTmp->permanentVirtualCircuitRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_permanentVirtualCircuit-DTETable(): refresh permanentVirtualCircuit-DTETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_permanentVirtualCircuit -
DTETable(void)
{
	if (permanentVirtualCircuit - DTETable_refresh == 0)
		return;
	permanentVirtualCircuit - DTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_permanentVirtualCircuit-DTETable_row(): refresh permanentVirtualCircuit-DTETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_permanentVirtualCircuit -
DTETable_row(struct permanentVirtualCircuit -DTETable_data * StorageTmp)
{
	if (StorageTmp->permanentVirtualCircuit - DTETable_request == sa_request)
		return;
	StorageTmp->permanentVirtualCircuit - DTETable_request = sa_request;
}

/*
 * var_permanentVirtualCircuit-DTETable(): locate variables in permanentVirtualCircuit-DTETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_permanentVirtualCircuit -
DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct permanentVirtualCircuit -DTETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_permanentVirtualCircuit-DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_permanentVirtualCircuit - DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(permanentVirtualCircuit - DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_permanentVirtualCircuit - DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PERMANENTVIRTUALCIRCUIT - DTELOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DTElogicalChannelLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DTElogicalChannel;
	case PERMANENTVIRTUALCIRCUIT - DTEPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DTEpacketSizesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DTEpacketSizes;
	case PERMANENTVIRTUALCIRCUIT - DTETHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DTEthroughputClassesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DTEthroughputClasses;
	case PERMANENTVIRTUALCIRCUIT - DTEWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DTEwindowSizesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DTEwindowSizes;
	case PERMANENTVIRTUALCIRCUIT - DTEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->permanentVirtualCircuit - DTERowStatus);
		return (u_char *) &StorageTmp->permanentVirtualCircuit - DTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_permanentVirtualCircuit-DCETable(): refresh permanentVirtualCircuit-DCETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_permanentVirtualCircuit -
DCETable(void)
{
	if (permanentVirtualCircuit - DCETable_refresh == 0)
		return;
	permanentVirtualCircuit - DCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_permanentVirtualCircuit-DCETable_row(): refresh permanentVirtualCircuit-DCETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_permanentVirtualCircuit -
DCETable_row(struct permanentVirtualCircuit -DCETable_data * StorageTmp)
{
	if (StorageTmp->permanentVirtualCircuit - DCETable_request == sa_request)
		return;
	StorageTmp->permanentVirtualCircuit - DCETable_request = sa_request;
}

/*
 * var_permanentVirtualCircuit-DCETable(): locate variables in permanentVirtualCircuit-DCETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_permanentVirtualCircuit -
DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct permanentVirtualCircuit -DCETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_permanentVirtualCircuit-DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_permanentVirtualCircuit - DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(permanentVirtualCircuit - DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_permanentVirtualCircuit - DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case PERMANENTVIRTUALCIRCUIT - DCECHARGINGDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DCEchargingDirectionLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DCEchargingDirection;
	case PERMANENTVIRTUALCIRCUIT - DCELOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DCElogicalChannelLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DCElogicalChannel;
	case PERMANENTVIRTUALCIRCUIT - DCEPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DCEpacketSizesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DCEpacketSizes;
	case PERMANENTVIRTUALCIRCUIT - DCETHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DCEthroughputClassesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DCEthroughputClasses;
	case PERMANENTVIRTUALCIRCUIT - DCEWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DCEwindowSizesLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DCEwindowSizes;
	case PERMANENTVIRTUALCIRCUIT - DCEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->permanentVirtualCircuit - DCEoperationalState);
		return (u_char *) &StorageTmp->permanentVirtualCircuit - DCEoperationalState;
	case PERMANENTVIRTUALCIRCUIT - DCEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DCEremoteDTEAddressLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DCEremoteDTEAddress;
	case PERMANENTVIRTUALCIRCUIT - DCEREMOTELOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->permanentVirtualCircuit - DCEremoteLogicalChannelLen;
		return (u_char *) StorageTmp->permanentVirtualCircuit - DCEremoteLogicalChannel;
	case PERMANENTVIRTUALCIRCUIT - DCEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->permanentVirtualCircuit - DCERowStatus);
		return (u_char *) &StorageTmp->permanentVirtualCircuit - DCERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_virtualCallIVMOTable(): refresh virtualCallIVMOTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCallIVMOTable(void)
{
	if (virtualCallIVMOTable_refresh == 0)
		return;
	virtualCallIVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_virtualCallIVMOTable_row(): refresh virtualCallIVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualCallIVMOTable_row(struct virtualCallIVMOTable_data *StorageTmp)
{
	if (StorageTmp->virtualCallIVMOTable_request == sa_request)
		return;
	StorageTmp->virtualCallIVMOTable_request = sa_request;
}

/*
 * var_virtualCallIVMOTable(): locate variables in virtualCallIVMOTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCallIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCallIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCallIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCallIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCallIVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCallIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCALLIVMOFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCallIVMOfastSelect);
		return (u_char *) &StorageTmp->virtualCallIVMOfastSelect;
	case VIRTUALCALLIVMOPACKETSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOpacketSizesLen;
		return (u_char *) StorageTmp->virtualCallIVMOpacketSizes;
	case VIRTUALCALLIVMOREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOreverseChargingLen;
		return (u_char *) StorageTmp->virtualCallIVMOreverseCharging;
	case VIRTUALCALLIVMOTHROUGHPUTCLASSES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOthroughputClassesLen;
		return (u_char *) StorageTmp->virtualCallIVMOthroughputClasses;
	case VIRTUALCALLIVMOWINDOWSIZES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOwindowSizesLen;
		return (u_char *) StorageTmp->virtualCallIVMOwindowSizes;
	case VIRTUALCALLIVMOPROPOSEDPACKETSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOproposedPacketSizeLen;
		return (u_char *) StorageTmp->virtualCallIVMOproposedPacketSize;
	case VIRTUALCALLIVMOPROPOSEDWINDOWSIZE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOproposedWindowSizeLen;
		return (u_char *) StorageTmp->virtualCallIVMOproposedWindowSize;
	case VIRTUALCALLIVMOACCEPTREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOacceptReverseChargingLen;
		return (u_char *) StorageTmp->virtualCallIVMOacceptReverseCharging;
	case VIRTUALCALLIVMOPROPOSEREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOproposeReverseChargingLen;
		return (u_char *) StorageTmp->virtualCallIVMOproposeReverseCharging;
	case VIRTUALCALLIVMOCALLTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOcallTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOcallTime;
	case VIRTUALCALLIVMORESETTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOresetTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOresetTime;
	case VIRTUALCALLIVMOCLEARTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOclearTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOclearTime;
	case VIRTUALCALLIVMOINTERRUPTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOinterruptTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOinterruptTime;
	case VIRTUALCALLIVMORESETCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOresetCountLen;
		return (u_char *) StorageTmp->virtualCallIVMOresetCount;
	case VIRTUALCALLIVMOCLEARCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOclearCountLen;
		return (u_char *) StorageTmp->virtualCallIVMOclearCount;
	case VIRTUALCALLIVMOWINDOWTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOwindowTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOwindowTime;
	case VIRTUALCALLIVMODATARETRANSMISSIONTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOdataRetransmissionTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOdataRetransmissionTime;
	case VIRTUALCALLIVMODATARETRANSMISSIONCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOdataRetransmissionCountLen;
		return (u_char *) StorageTmp->virtualCallIVMOdataRetransmissionCount;
	case VIRTUALCALLIVMOREJECTTIME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOrejectTimeLen;
		return (u_char *) StorageTmp->virtualCallIVMOrejectTime;
	case VIRTUALCALLIVMOREJECTCOUNT:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCallIVMOrejectCountLen;
		return (u_char *) StorageTmp->virtualCallIVMOrejectCount;
	case VIRTUALCALLIVMOROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCallIVMORowStatus);
		return (u_char *) &StorageTmp->virtualCallIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_switchedVirtualCallTable(): refresh switchedVirtualCallTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_switchedVirtualCallTable(void)
{
	if (switchedVirtualCallTable_refresh == 0)
		return;
	switchedVirtualCallTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_switchedVirtualCallTable_row(): refresh switchedVirtualCallTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_switchedVirtualCallTable_row(struct switchedVirtualCallTable_data *StorageTmp)
{
	if (StorageTmp->switchedVirtualCallTable_request == sa_request)
		return;
	StorageTmp->switchedVirtualCallTable_request = sa_request;
}

/*
 * var_switchedVirtualCallTable(): locate variables in switchedVirtualCallTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_switchedVirtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct switchedVirtualCallTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_switchedVirtualCallTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_switchedVirtualCallTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(switchedVirtualCallTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_switchedVirtualCallTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SWITCHEDVIRTUALCALLDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCalldirectionLen;
		return (u_char *) StorageTmp->switchedVirtualCalldirection;
	case SWITCHEDVIRTUALCALLREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallremoteDTEAddressLen;
		return (u_char *) StorageTmp->switchedVirtualCallremoteDTEAddress;
	case SWITCHEDVIRTUALCALLTHROUGHPUTCLASS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallthroughputClassLen;
		return (u_char *) StorageTmp->switchedVirtualCallthroughputClass;
	case SWITCHEDVIRTUALCALLREDIRECTREASON:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallredirectReasonLen;
		return (u_char *) StorageTmp->switchedVirtualCallredirectReason;
	case SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCalloriginallyCalledAddressLen;
		return (u_char *) StorageTmp->switchedVirtualCalloriginallyCalledAddress;
	case SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallcallingAddressExtensionLen;
		return (u_char *) StorageTmp->switchedVirtualCallcallingAddressExtension;
	case SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->switchedVirtualCallcalledAddressExtensionLen;
		return (u_char *) StorageTmp->switchedVirtualCallcalledAddressExtension;
	case SWITCHEDVIRTUALCALLROWSTATUS:
		*write_method = write_switchedVirtualCallRowStatus;
		*var_len = sizeof(StorageTmp->switchedVirtualCallRowStatus);
		return (u_char *) &StorageTmp->switchedVirtualCallRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_virtualCall-DTETable(): refresh virtualCall-DTETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_virtualCall -
DTETable(void)
{
	if (virtualCall - DTETable_refresh == 0)
		return;
	virtualCall - DTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_virtualCall-DTETable_row(): refresh virtualCall-DTETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_virtualCall -
DTETable_row(struct virtualCall -DTETable_data * StorageTmp)
{
	if (StorageTmp->virtualCall - DTETable_request == sa_request)
		return;
	StorageTmp->virtualCall - DTETable_request = sa_request;
}

/*
 * var_virtualCall-DTETable(): locate variables in virtualCall-DTETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_virtualCall -
DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCall -DTETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCall-DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCall - DTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCall - DTETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCall - DTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCALL - DTECALLINGADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DTEcallingAddressExtensionLen;
		return (u_char *) StorageTmp->virtualCall - DTEcallingAddressExtension;
	case VIRTUALCALL - DTECALLEDADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DTEcalledAddressExtensionLen;
		return (u_char *) StorageTmp->virtualCall - DTEcalledAddressExtension;
	case VIRTUALCALL - DTEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DTEdirectionLen;
		return (u_char *) StorageTmp->virtualCall - DTEdirection;
	case VIRTUALCALL - DTEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall - DTEfastSelect);
		return (u_char *) &StorageTmp->virtualCall - DTEfastSelect;
	case VIRTUALCALL - DTEORIGINALLYCALLEDADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DTEoriginallyCalledAddressLen;
		return (u_char *) StorageTmp->virtualCall - DTEoriginallyCalledAddress;
	case VIRTUALCALL - DTEREDIRECTREASON:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DTEredirectReasonLen;
		return (u_char *) StorageTmp->virtualCall - DTEredirectReason;
	case VIRTUALCALL - DTEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DTEremoteDTEAddressLen;
		return (u_char *) StorageTmp->virtualCall - DTEremoteDTEAddress;
	case VIRTUALCALL - DTEREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DTEreverseChargingLen;
		return (u_char *) StorageTmp->virtualCall - DTEreverseCharging;
	case VIRTUALCALL - DTEROWSTATUS:
		*write_method = write_virtualCall - DTERowStatus;
		*var_len = sizeof(StorageTmp->virtualCall - DTERowStatus);
		return (u_char *) &StorageTmp->virtualCall - DTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_virtualCall-DCETable(): refresh virtualCall-DCETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
 refresh_virtualCall -
DCETable(void)
{
	if (virtualCall - DCETable_refresh == 0)
		return;
	virtualCall - DCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_virtualCall-DCETable_row(): refresh virtualCall-DCETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
 refresh_virtualCall -
DCETable_row(struct virtualCall -DCETable_data * StorageTmp)
{
	if (StorageTmp->virtualCall - DCETable_request == sa_request)
		return;
	StorageTmp->virtualCall - DCETable_request = sa_request;
}

/*
 * var_virtualCall-DCETable(): locate variables in virtualCall-DCETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *var_virtualCall -
DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCall -DCETable_data * StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualCall-DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualCall - DCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualCall - DCETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualCall - DCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALCALL - DCECHARGINGDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCEchargingDirectionLen;
		return (u_char *) StorageTmp->virtualCall - DCEchargingDirection;
	case VIRTUALCALL - DCECUGSELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCEcUGSelectionLen;
		return (u_char *) StorageTmp->virtualCall - DCEcUGSelection;
	case VIRTUALCALL - DCEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCEdirectionLen;
		return (u_char *) StorageTmp->virtualCall - DCEdirection;
	case VIRTUALCALL - DCEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall - DCEfastSelect);
		return (u_char *) &StorageTmp->virtualCall - DCEfastSelect;
	case VIRTUALCALL - DCEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCEremoteDTEAddressLen;
		return (u_char *) StorageTmp->virtualCall - DCEremoteDTEAddress;
	case VIRTUALCALL - DCETRANSITDELAYSELECTIONANDINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCEtransitDelaySelectionAndIndicationLen;
		return (u_char *) StorageTmp->virtualCall - DCEtransitDelaySelectionAndIndication;
	case VIRTUALCALL - DCEBILATERALCUGSELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCEbilateralCUGSelectionLen;
		return (u_char *) StorageTmp->virtualCall - DCEbilateralCUGSelection;
	case VIRTUALCALL - DCECALLREDIRECTIONDEFLECTIONNOTIFICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall - DCEcallRedirectionDeflectionNotification);
		return (u_char *) &StorageTmp->virtualCall - DCEcallRedirectionDeflectionNotification;
	case VIRTUALCALL - DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall - DCEcalledLineAddressModifiedNotification);
		return (u_char *) &StorageTmp->virtualCall - DCEcalledLineAddressModifiedNotification;
	case VIRTUALCALL - DCECUGWITHOUTGOINGACCESSSELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCEcUGWithOutgoingAccessSelectionLen;
		return (u_char *) StorageTmp->virtualCall - DCEcUGWithOutgoingAccessSelection;
	case VIRTUALCALL - DCENUISELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCEnUISelectionLen;
		return (u_char *) StorageTmp->virtualCall - DCEnUISelection;
	case VIRTUALCALL - DCEREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCEreverseChargingLen;
		return (u_char *) StorageTmp->virtualCall - DCEreverseCharging;
	case VIRTUALCALL - DCEROASELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->virtualCall - DCErOASelectionLen;
		return (u_char *) StorageTmp->virtualCall - DCErOASelection;
	case VIRTUALCALL - DCEROWSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualCall - DCERowStatus);
		return (u_char *) &StorageTmp->virtualCall - DCERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_dSeriesCountsTable(): refresh dSeriesCountsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dSeriesCountsTable(void)
{
	if (dSeriesCountsTable_refresh == 0)
		return;
	dSeriesCountsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_dSeriesCountsTable_row(): refresh dSeriesCountsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_dSeriesCountsTable_row(struct dSeriesCountsTable_data *StorageTmp)
{
	if (StorageTmp->dSeriesCountsTable_request == sa_request)
		return;
	StorageTmp->dSeriesCountsTable_request = sa_request;
}

/*
 * var_dSeriesCountsTable(): locate variables in dSeriesCountsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_dSeriesCountsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dSeriesCountsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_dSeriesCountsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_dSeriesCountsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(dSeriesCountsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_dSeriesCountsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DSERIESRESETREQUESTINDICATIONPACKETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dSeriesResetRequestIndicationPackets);
		return (u_char *) &StorageTmp->dSeriesResetRequestIndicationPackets;
	case DSERIESSEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dSeriesSegmentsSent);
		return (u_char *) &StorageTmp->dSeriesSegmentsSent;
	case DSERIESSEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dSeriesSegmentsReceived);
		return (u_char *) &StorageTmp->dSeriesSegmentsReceived;
	case DSERIESROWSTATUS:
		*write_method = write_dSeriesRowStatus;
		*var_len = sizeof(StorageTmp->dSeriesRowStatus);
		return (u_char *) &StorageTmp->dSeriesRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_adjacencyTable(): refresh adjacencyTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_adjacencyTable(void)
{
	if (adjacencyTable_refresh == 0)
		return;
	adjacencyTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_adjacencyTable_row(): refresh adjacencyTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_adjacencyTable_row(struct adjacencyTable_data *StorageTmp)
{
	if (StorageTmp->adjacencyTable_request == sa_request)
		return;
	StorageTmp->adjacencyTable_request = sa_request;
}

/*
 * var_adjacencyTable(): locate variables in adjacencyTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_adjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct adjacencyTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_adjacencyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_adjacencyTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(adjacencyTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_adjacencyTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case ADJACENCYSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->adjacencyState);
		return (u_char *) &StorageTmp->adjacencyState;
	case NEIGHBOURSNPAADDRESS:
		*write_method = write_neighbourSNPAAddress;
		*var_len = StorageTmp->neighbourSNPAAddressLen;
		return (u_char *) StorageTmp->neighbourSNPAAddress;
	case NEIGHBOURSYSTEMTYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->neighbourSystemType);
		return (u_char *) &StorageTmp->neighbourSystemType;
	case NEIGHBOURSYSTEMIDS:
		*write_method = write_neighbourSystemIds;
		*var_len = StorageTmp->neighbourSystemIdsLen;
		return (u_char *) StorageTmp->neighbourSystemIds;
	case ADJACENCYUSAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->adjacencyUsage);
		return (u_char *) &StorageTmp->adjacencyUsage;
	case AREAADDRESSESOFNEIGHBOUR:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->areaAddressesOfNeighbourLen;
		return (u_char *) StorageTmp->areaAddressesOfNeighbour;
	case HOLDINGTIMER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->holdingTimer);
		return (u_char *) &StorageTmp->holdingTimer;
	case PRIORITYOFNEIGHBOUR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->priorityOfNeighbour);
		return (u_char *) &StorageTmp->priorityOfNeighbour;
	case ADJACENCYROWSTATUS:
		*write_method = write_adjacencyRowStatus;
		*var_len = sizeof(StorageTmp->adjacencyRowStatus);
		return (u_char *) &StorageTmp->adjacencyRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_virtualAdjacencyTable(): refresh virtualAdjacencyTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualAdjacencyTable(void)
{
	if (virtualAdjacencyTable_refresh == 0)
		return;
	virtualAdjacencyTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_virtualAdjacencyTable_row(): refresh virtualAdjacencyTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_virtualAdjacencyTable_row(struct virtualAdjacencyTable_data *StorageTmp)
{
	if (StorageTmp->virtualAdjacencyTable_request == sa_request)
		return;
	StorageTmp->virtualAdjacencyTable_request = sa_request;
}

/*
 * var_virtualAdjacencyTable(): locate variables in virtualAdjacencyTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualAdjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualAdjacencyTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_virtualAdjacencyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_virtualAdjacencyTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(virtualAdjacencyTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_virtualAdjacencyTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case VIRTUALADJACENCYMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->virtualAdjacencyMetric);
		return (u_char *) &StorageTmp->virtualAdjacencyMetric;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_destinationTable(): refresh destinationTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_destinationTable(void)
{
	if (destinationTable_refresh == 0)
		return;
	destinationTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_destinationTable_row(): refresh destinationTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_destinationTable_row(struct destinationTable_data *StorageTmp)
{
	if (StorageTmp->destinationTable_request == sa_request)
		return;
	StorageTmp->destinationTable_request = sa_request;
}

/*
 * var_destinationTable(): locate variables in destinationTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_destinationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct destinationTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_destinationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_destinationTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(destinationTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_destinationTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DESTINATIONDEFAULTMETRICPATHCOST:
		*write_method = write_destinationDefaultMetricPathCost;
		*var_len = sizeof(StorageTmp->destinationDefaultMetricPathCost);
		return (u_char *) &StorageTmp->destinationDefaultMetricPathCost;
	case DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationDefaultMetricOutputAdjacencies;
		*var_len = StorageTmp->destinationDefaultMetricOutputAdjacenciesLen;
		return (u_char *) StorageTmp->destinationDefaultMetricOutputAdjacencies;
	case DESTINATIONDELAYMETRICPATHCOST:
		*write_method = write_destinationDelayMetricPathCost;
		*var_len = sizeof(StorageTmp->destinationDelayMetricPathCost);
		return (u_char *) &StorageTmp->destinationDelayMetricPathCost;
	case DESTINATIONDELAYMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationDelayMetricOutputAdjacencies;
		*var_len = StorageTmp->destinationDelayMetricOutputAdjacenciesLen;
		return (u_char *) StorageTmp->destinationDelayMetricOutputAdjacencies;
	case DESTINATIONEXPENSEMETRICPATHCOST:
		*write_method = write_destinationExpenseMetricPathCost;
		*var_len = sizeof(StorageTmp->destinationExpenseMetricPathCost);
		return (u_char *) &StorageTmp->destinationExpenseMetricPathCost;
	case DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationExpenseMetricOutputAdjacencies;
		*var_len = StorageTmp->destinationExpenseMetricOutputAdjacenciesLen;
		return (u_char *) StorageTmp->destinationExpenseMetricOutputAdjacencies;
	case DESTINATIONERRORMETRICPATHCOST:
		*write_method = write_destinationErrorMetricPathCost;
		*var_len = sizeof(StorageTmp->destinationErrorMetricPathCost);
		return (u_char *) &StorageTmp->destinationErrorMetricPathCost;
	case DESTINATIONERRORMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationErrorMetricOutputAdjacencies;
		*var_len = StorageTmp->destinationErrorMetricOutputAdjacenciesLen;
		return (u_char *) StorageTmp->destinationErrorMetricOutputAdjacencies;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_destinationSystemTable(): refresh destinationSystemTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_destinationSystemTable(void)
{
	if (destinationSystemTable_refresh == 0)
		return;
	destinationSystemTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_destinationSystemTable_row(): refresh destinationSystemTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_destinationSystemTable_row(struct destinationSystemTable_data *StorageTmp)
{
	if (StorageTmp->destinationSystemTable_request == sa_request)
		return;
	StorageTmp->destinationSystemTable_request = sa_request;
}

/*
 * var_destinationSystemTable(): locate variables in destinationSystemTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_destinationSystemTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct destinationSystemTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_destinationSystemTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_destinationSystemTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(destinationSystemTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_destinationSystemTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DESINTATIONSYSTEMMETRIC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->desintationSystemMetric);
		return (u_char *) &StorageTmp->desintationSystemMetric;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_destinationAreaTable(): refresh destinationAreaTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_destinationAreaTable(void)
{
	if (destinationAreaTable_refresh == 0)
		return;
	destinationAreaTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_destinationAreaTable_row(): refresh destinationAreaTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_destinationAreaTable_row(struct destinationAreaTable_data *StorageTmp)
{
	if (StorageTmp->destinationAreaTable_request == sa_request)
		return;
	StorageTmp->destinationAreaTable_request = sa_request;
}

/*
 * var_destinationAreaTable(): locate variables in destinationAreaTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_destinationAreaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct destinationAreaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_destinationAreaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_destinationAreaTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(destinationAreaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_destinationAreaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DESTINATIONAREAID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->destinationAreaIdLen;
		return (u_char *) StorageTmp->destinationAreaId;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_reachableAddressTable(): refresh reachableAddressTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_reachableAddressTable(void)
{
	if (reachableAddressTable_refresh == 0)
		return;
	reachableAddressTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_reachableAddressTable_row(): refresh reachableAddressTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_reachableAddressTable_row(struct reachableAddressTable_data *StorageTmp)
{
	if (StorageTmp->reachableAddressTable_request == sa_request)
		return;
	StorageTmp->reachableAddressTable_request = sa_request;
}

/*
 * var_reachableAddressTable(): locate variables in reachableAddressTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_reachableAddressTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct reachableAddressTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("dlMIB", "var_reachableAddressTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_reachableAddressTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(reachableAddressTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_reachableAddressTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case REACHABLEADDRESSPREFIX:
		*write_method = write_reachableAddressPrefix;
		*var_len = StorageTmp->reachableAddressPrefixLen;
		return (u_char *) StorageTmp->reachableAddressPrefix;
	case REACHABLEADDRESSMAPPINGTYPE:
		*write_method = write_reachableAddressMappingType;
		*var_len = sizeof(StorageTmp->reachableAddressMappingType);
		return (u_char *) &StorageTmp->reachableAddressMappingType;
	case REACHABLEADDRESSDEFAULTMETRIC:
		*write_method = write_reachableAddressDefaultMetric;
		*var_len = sizeof(StorageTmp->reachableAddressDefaultMetric);
		return (u_char *) &StorageTmp->reachableAddressDefaultMetric;
	case REACHABLEADDRESSDELAYMETRIC:
		*write_method = write_reachableAddressDelayMetric;
		*var_len = sizeof(StorageTmp->reachableAddressDelayMetric);
		return (u_char *) &StorageTmp->reachableAddressDelayMetric;
	case REACHABLEADDRESSEXPENSEMETRIC:
		*write_method = write_reachableAddressExpenseMetric;
		*var_len = sizeof(StorageTmp->reachableAddressExpenseMetric);
		return (u_char *) &StorageTmp->reachableAddressExpenseMetric;
	case REACHABLEADDRESSERRORMETRIC:
		*write_method = write_reachableAddressErrorMetric;
		*var_len = sizeof(StorageTmp->reachableAddressErrorMetric);
		return (u_char *) &StorageTmp->reachableAddressErrorMetric;
	case REACHABLEADDRESSDEFAULTMETRICTYPE:
		*write_method = write_reachableAddressDefaultMetricType;
		*var_len = sizeof(StorageTmp->reachableAddressDefaultMetricType);
		return (u_char *) &StorageTmp->reachableAddressDefaultMetricType;
	case REACHABLEADDRESSDELAYMETRICTYPE:
		*write_method = write_reachableAddressDelayMetricType;
		*var_len = sizeof(StorageTmp->reachableAddressDelayMetricType);
		return (u_char *) &StorageTmp->reachableAddressDelayMetricType;
	case REACHABLEADDRESSEXPENSEMETRICTYPE:
		*write_method = write_reachableAddressExpenseMetricType;
		*var_len = sizeof(StorageTmp->reachableAddressExpenseMetricType);
		return (u_char *) &StorageTmp->reachableAddressExpenseMetricType;
	case REACHABLEADDRESSERRORMETRICTYPE:
		*write_method = write_reachableAddressErrorMetricType;
		*var_len = sizeof(StorageTmp->reachableAddressErrorMetricType);
		return (u_char *) &StorageTmp->reachableAddressErrorMetricType;
	case REACHABLEADDRESSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->reachableAddressOperationalState);
		return (u_char *) &StorageTmp->reachableAddressOperationalState;
	case REACHABLEADDRESSADMINISTRATIVESTATE:
		*write_method = write_reachableAddressAdministrativeState;
		*var_len = sizeof(StorageTmp->reachableAddressAdministrativeState);
		return (u_char *) &StorageTmp->reachableAddressAdministrativeState;
	case REACHABLEADDRESSSNPAADDRESSES:
		*write_method = write_reachableAddressSNPAAddresses;
		*var_len = StorageTmp->reachableAddressSNPAAddressesLen;
		return (u_char *) StorageTmp->reachableAddressSNPAAddresses;
	case REACHABLEADDRESSSNPAMASK:
		*write_method = write_reachableAddressSNPAMask;
		*var_len = StorageTmp->reachableAddressSNPAMaskLen;
		return (u_char *) StorageTmp->reachableAddressSNPAMask;
	case REACHABLEADDRESSSNPAPREFIX:
		*write_method = write_reachableAddressSNPAPrefix;
		*var_len = StorageTmp->reachableAddressSNPAPrefixLen;
		return (u_char *) StorageTmp->reachableAddressSNPAPrefix;
	case REACHABLEADDRESSROWSTATUS:
		*write_method = write_reachableAddressRowStatus;
		*var_len = sizeof(StorageTmp->reachableAddressRowStatus);
		return (u_char *) &StorageTmp->reachableAddressRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_physicalEntityPhysicalEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct physicalEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("dlMIB", "write_physicalEntityPhysicalEntityTitles entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(physicalEntityTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalEntityPhysicalEntityTitles not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalEntityPhysicalEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->physicalEntityPhysicalEntityTitles;
		old_length = StorageTmp->physicalEntityPhysicalEntityTitlesLen;
		StorageTmp->physicalEntityPhysicalEntityTitles = objid;
		StorageTmp->physicalEntityPhysicalEntityTitlesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->physicalEntityPhysicalEntityTitles = old_value;
		StorageTmp->physicalEntityPhysicalEntityTitlesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitBitErrorsThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitBitErrorsThreshold entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OPAQUE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 7..7 */
		if (string != 7) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitBitErrorsThreshold;
		old_length = StorageTmp->dataCircuitBitErrorsThresholdLen;
		StorageTmp->dataCircuitBitErrorsThreshold = string;
		StorageTmp->dataCircuitBitErrorsThresholdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitBitErrorsThreshold = old_value;
		StorageTmp->dataCircuitBitErrorsThresholdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_dataCircuitType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DATACIRCUITTYPE_END_SYSTEM:
		case DATACIRCUITTYPE_RELAY_SYSTEM:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitType;
		StorageTmp->dataCircuitType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitPhysicalMediaNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitPhysicalMediaNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalMediaNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalMediaNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitPhysicalMediaNames;
		old_length = StorageTmp->dataCircuitPhysicalMediaNamesLen;
		StorageTmp->dataCircuitPhysicalMediaNames = string;
		StorageTmp->dataCircuitPhysicalMediaNamesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitPhysicalMediaNames = old_value;
		StorageTmp->dataCircuitPhysicalMediaNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitPhysicalInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitPhysicalInterfaceType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitPhysicalInterfaceType;
		old_length = StorageTmp->dataCircuitPhysicalInterfaceTypeLen;
		StorageTmp->dataCircuitPhysicalInterfaceType = string;
		StorageTmp->dataCircuitPhysicalInterfaceTypeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitPhysicalInterfaceType = old_value;
		StorageTmp->dataCircuitPhysicalInterfaceTypeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitPhysicalInterfaceStandard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitPhysicalInterfaceStandard entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceStandard not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceStandard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitPhysicalInterfaceStandard;
		old_length = StorageTmp->dataCircuitPhysicalInterfaceStandardLen;
		StorageTmp->dataCircuitPhysicalInterfaceStandard = string;
		StorageTmp->dataCircuitPhysicalInterfaceStandardLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitPhysicalInterfaceStandard = old_value;
		StorageTmp->dataCircuitPhysicalInterfaceStandardLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitSynchronizationMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_dataCircuitSynchronizationMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DATACIRCUITSYNCHRONIZATIONMODE_SYNCHRONOUS:
		case DATACIRCUITSYNCHRONIZATIONMODE_ASYNCHRONOUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitSynchronizationMode;
		StorageTmp->dataCircuitSynchronizationMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitSynchronizationMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitTransmissionCoding(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitTransmissionCoding entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionCoding not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionCoding: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitTransmissionCoding;
		old_length = StorageTmp->dataCircuitTransmissionCodingLen;
		StorageTmp->dataCircuitTransmissionCoding = string;
		StorageTmp->dataCircuitTransmissionCodingLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitTransmissionCoding = old_value;
		StorageTmp->dataCircuitTransmissionCodingLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitTransmissionMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_dataCircuitTransmissionMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DATACIRCUITTRANSMISSIONMODE_SIMPLEX:
		case DATACIRCUITTRANSMISSIONMODE_DUPLEX:
		case DATACIRCUITTRANSMISSIONMODE_HALF_DUPLEX:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitTransmissionMode;
		StorageTmp->dataCircuitTransmissionMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitTransmissionMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OPAQUE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 7..7 */
		if (string != 7) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dataCircuitTransmissionRate;
		old_length = StorageTmp->dataCircuitTransmissionRateLen;
		StorageTmp->dataCircuitTransmissionRate = string;
		StorageTmp->dataCircuitTransmissionRateLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitTransmissionRate = old_value;
		StorageTmp->dataCircuitTransmissionRateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalConnectionEndpointIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct physicalConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_physicalConnectionEndpointIdentifier entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(physicalConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionEndpointIdentifier not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionEndpointIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->physicalConnectionEndpointIdentifier;
		old_length = StorageTmp->physicalConnectionEndpointIdentifierLen;
		StorageTmp->physicalConnectionEndpointIdentifier = string;
		StorageTmp->physicalConnectionEndpointIdentifierLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->physicalConnectionEndpointIdentifier = old_value;
		StorageTmp->physicalConnectionEndpointIdentifierLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalConnectionPortNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct physicalConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_physicalConnectionPortNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(physicalConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionPortNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionPortNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->physicalConnectionPortNumber;
		StorageTmp->physicalConnectionPortNumber = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->physicalConnectionPortNumber = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_datalinkEntityProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct datalinkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("dlMIB", "write_datalinkEntityProviderEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(datalinkEntityTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->datalinkEntityProviderEntityNames;
		old_length = StorageTmp->datalinkEntityProviderEntityNamesLen;
		StorageTmp->datalinkEntityProviderEntityNames = objid;
		StorageTmp->datalinkEntityProviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->datalinkEntityProviderEntityNames = old_value;
		StorageTmp->datalinkEntityProviderEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmT1Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmT1Timer;
		StorageTmp->lAPBDLEmT1Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT1Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmT3Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmT3Timer;
		StorageTmp->lAPBDLEmT3Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT3Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmW(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmW entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmW not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmW: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmW;
		StorageTmp->lAPBDLEmW = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmW = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXSend(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmXSend entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXSend not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXSend: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmXSend;
		StorageTmp->lAPBDLEmXSend = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmXSend = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXReceive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmXReceive entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXReceive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXReceive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmXReceive;
		StorageTmp->lAPBDLEmXReceive = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmXReceive = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmT2Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lAPBDLEmT2Timer;
		StorageTmp->lAPBDLEmT2Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT2Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMadministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPPMTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPPMadministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPPMTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPPMADMINISTRATIVESTATE_LOCKED:
		case SLPPMADMINISTRATIVESTATE_UNLOCKED:
		case SLPPMADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPPMadministrativeState;
		StorageTmp->sLPPMadministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPPMadministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionInterfaceType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPCONNECTIONINTERFACETYPE_DTE:
		case SLPCONNECTIONINTERFACETYPE_DCE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionInterfaceType;
		StorageTmp->sLPConnectionInterfaceType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionInterfaceType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionK entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionK;
		StorageTmp->sLPConnectionK = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionK = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionN1;
		StorageTmp->sLPConnectionN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionN2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionN2;
		StorageTmp->sLPConnectionN2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionN2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionSequenceModulus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 128..128 */
		if (set_value != 8 && set_value != 128) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionSequenceModulus;
		StorageTmp->sLPConnectionSequenceModulus = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionSequenceModulus = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT1Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionT1Timer;
		StorageTmp->sLPConnectionT1Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT1Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT2Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionT2Timer;
		StorageTmp->sLPConnectionT2Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT2Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT3Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionT3Timer;
		StorageTmp->sLPConnectionT3Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT3Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT4Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionT4Timer;
		StorageTmp->sLPConnectionT4Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT4Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPCONNECTIONADMINISTRATIVESTATE_LOCKED:
		case SLPCONNECTIONADMINISTRATIVESTATE_UNLOCKED:
		case SLPCONNECTIONADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionAdministrativeState;
		StorageTmp->sLPConnectionAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOinterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOinterfaceType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPCONNECTIONIVMOINTERFACETYPE_DTE:
		case SLPCONNECTIONIVMOINTERFACETYPE_DCE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOinterfaceType;
		StorageTmp->sLPConnectionIVMOinterfaceType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOinterfaceType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOk(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOk entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOk not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOk: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOk;
		StorageTmp->sLPConnectionIVMOk = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOk = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOn1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOn1;
		StorageTmp->sLPConnectionIVMOn1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOn1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOn2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOn2;
		StorageTmp->sLPConnectionIVMOn2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOn2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOsequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOsequenceModulus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 128..128 */
		if (set_value != 8 && set_value != 128) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOsequenceModulus;
		StorageTmp->sLPConnectionIVMOsequenceModulus = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOsequenceModulus = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt1Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOt1Timer;
		StorageTmp->sLPConnectionIVMOt1Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt1Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt2Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOt2Timer;
		StorageTmp->sLPConnectionIVMOt2Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt2Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt3Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOt3Timer;
		StorageTmp->sLPConnectionIVMOt3Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt3Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt4Timer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionIVMOt4Timer;
		StorageTmp->sLPConnectionIVMOt4Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt4Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationLLCName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCStationLLCName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationLLCName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationLLCName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationLLCName;
		old_length = StorageTmp->lLCStationLLCNameLen;
		StorageTmp->lLCStationLLCName = string;
		StorageTmp->lLCStationLLCNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationLLCName = old_value;
		StorageTmp->lLCStationLLCNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSupportedServicesTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCStationSupportedServicesTypes entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationSupportedServicesTypes;
		old_length = StorageTmp->lLCStationSupportedServicesTypesLen;
		StorageTmp->lLCStationSupportedServicesTypes = string;
		StorageTmp->lLCStationSupportedServicesTypesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationSupportedServicesTypes = old_value;
		StorageTmp->lLCStationSupportedServicesTypesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationType1AcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType1AcknowledgeTimeoutValue;
		StorageTmp->lLCStationType1AcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType1AcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1MaximumRetryCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationType1MaximumRetryCount entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1MaximumRetryCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1MaximumRetryCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType1MaximumRetryCount;
		StorageTmp->lLCStationType1MaximumRetryCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType1MaximumRetryCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumPDUN3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationMaximumPDUN3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumPDUN3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumPDUN3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationMaximumPDUN3;
		StorageTmp->lLCStationMaximumPDUN3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationMaximumPDUN3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumRetransmissions4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationMaximumRetransmissions4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumRetransmissions4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumRetransmissions4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationMaximumRetransmissions4;
		StorageTmp->lLCStationMaximumRetransmissions4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationMaximumRetransmissions4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationReceiveVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationReceiveVariableLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationReceiveVariableLifetime;
		StorageTmp->lLCStationReceiveVariableLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationReceiveVariableLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationTransmitVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationTransmitVariableLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationTransmitVariableLifetime;
		StorageTmp->lLCStationTransmitVariableLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationTransmitVariableLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType3AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationType3AcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType3AcknowledgeTimeoutValue;
		StorageTmp->lLCStationType3AcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType3AcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationBufferSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationBufferSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationBufferSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationBufferSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationBufferSize;
		StorageTmp->lLCStationBufferSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationBufferSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSTRIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCStationSTRIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationSTRIndicator;
		old_length = StorageTmp->lLCStationSTRIndicatorLen;
		StorageTmp->lLCStationSTRIndicator = string;
		StorageTmp->lLCStationSTRIndicatorLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationSTRIndicator = old_value;
		StorageTmp->lLCStationSTRIndicatorLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationVersionNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationVersionNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationVersionNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationVersionNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationVersionNumber;
		StorageTmp->lLCStationVersionNumber = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationVersionNumber = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupAgingEnabled entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case RDESETUPAGINGENABLED_TRUE:
		case RDESETUPAGINGENABLED_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupAgingEnabled;
		StorageTmp->rDESetupAgingEnabled = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupAgingEnabled = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupAgingValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupAgingValue;
		StorageTmp->rDESetupAgingValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupAgingValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupEnableType2Reset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupEnableType2Reset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupEnableType2Reset not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupEnableType2Reset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupEnableType2Reset;
		StorageTmp->rDESetupEnableType2Reset = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupEnableType2Reset = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumRouteDescriptors(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupMaximumRouteDescriptors entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumRouteDescriptors not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumRouteDescriptors: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMaximumRouteDescriptors;
		StorageTmp->rDESetupMaximumRouteDescriptors = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMaximumRouteDescriptors = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumResponseTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupMaximumResponseTime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMaximumResponseTime;
		StorageTmp->rDESetupMaximumResponseTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMaximumResponseTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMinimumPDUSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupMinimumPDUSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMinimumPDUSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMinimumPDUSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMinimumPDUSize;
		StorageTmp->rDESetupMinimumPDUSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMinimumPDUSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEHold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupRDEHold entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case RDESETUPRDEHOLD_TRUE:
		case RDESETUPRDEHOLD_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupRDEHold;
		StorageTmp->rDESetupRDEHold = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupRDEHold = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEReplace(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupRDEReplace entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case RDESETUPRDEREPLACE_TRUE:
		case RDESETUPRDEREPLACE_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupRDEReplace;
		StorageTmp->rDESetupRDEReplace = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupRDEReplace = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupResetOnTestEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupResetOnTestEnabled entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case RDESETUPRESETONTESTENABLED_TRUE:
		case RDESETUPRESETONTESTENABLED_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupResetOnTestEnabled;
		StorageTmp->rDESetupResetOnTestEnabled = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupResetOnTestEnabled = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnectionLessTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionLessTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessName;
		old_length = StorageTmp->lLCConnectionlessNameLen;
		StorageTmp->lLCConnectionlessName = string;
		StorageTmp->lLCConnectionlessNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessName = old_value;
		StorageTmp->lLCConnectionlessNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionLessTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionLessTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2Name entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2Name;
		old_length = StorageTmp->lLCConnection2NameLen;
		StorageTmp->lLCConnection2Name = string;
		StorageTmp->lLCConnection2NameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2Name = old_value;
		StorageTmp->lLCConnection2NameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2MaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2MaximumRetransmissions;
		StorageTmp->lLCConnection2MaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2MaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2ReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedWindowSize;
		StorageTmp->lLCConnection2ReceivedWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2SendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SendWindowSize;
		StorageTmp->lLCConnection2SendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2AcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2AcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2BusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2BusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2BusyStateTimeoutValue;
		StorageTmp->lLCConnection2BusyStateTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2BusyStateTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2PBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2PBitTimeoutValue;
		StorageTmp->lLCConnection2PBitTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2PBitTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2RejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2RejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2RejectTimeoutValue;
		StorageTmp->lLCConnection2RejectTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2RejectTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Route(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2Route entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Route not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Route: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2Route;
		old_length = StorageTmp->lLCConnection2RouteLen;
		StorageTmp->lLCConnection2Route = string;
		StorageTmp->lLCConnection2RouteLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2Route = old_value;
		StorageTmp->lLCConnection2RouteLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2KStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2KStep entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2KStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2KStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2KStep;
		StorageTmp->lLCConnection2KStep = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2KStep = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2MaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2MaxSendWindowSize;
		StorageTmp->lLCConnection2MaxSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2MaxSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2OptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2OptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2OPTIONALTOLERATIONIPDUS_TRUE:
		case LLCCONNECTION2OPTIONALTOLERATIONIPDUS_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2OptionalTolerationIPDUs;
		StorageTmp->lLCConnection2OptionalTolerationIPDUs = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2OptionalTolerationIPDUs = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2AdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2ADMINISTRATIVESTATE_LOCKED:
		case LLCCONNECTION2ADMINISTRATIVESTATE_UNLOCKED:
		case LLCCONNECTION2ADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AdministrativeState;
		StorageTmp->lLCConnection2AdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2AlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AlarmStatus;
		old_length = StorageTmp->lLCConnection2AlarmStatusLen;
		StorageTmp->lLCConnection2AlarmStatus = string;
		StorageTmp->lLCConnection2AlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AlarmStatus = old_value;
		StorageTmp->lLCConnection2AlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaximumRetransmissions not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOMaximumRetransmissions;
		StorageTmp->lLCConnection2IVMOMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOReceivedWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOReceivedWindowSize;
		StorageTmp->lLCConnection2IVMOReceivedWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOReceivedWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOSendWindowSize;
		StorageTmp->lLCConnection2IVMOSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOAcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOBusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue;
		StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOBitTimeoutValue;
		StorageTmp->lLCConnection2IVMOBitTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOBitTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMORejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMORejectTimeoutValue;
		StorageTmp->lLCConnection2IVMORejectTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMORejectTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMORoute entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORoute not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMORoute;
		StorageTmp->lLCConnection2IVMORoute = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMORoute = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOKStep entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOKStep not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOKStep;
		StorageTmp->lLCConnection2IVMOKStep = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOKStep = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOMaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaxSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOMaxSendWindowSize;
		StorageTmp->lLCConnection2IVMOMaxSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOMaxSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOOptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS_TRUE:
		case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs;
		StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckReceiveResources(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckReceiveResources entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTIONLESSACKRECEIVERESOURCES_TRUE:
		case LLCCONNECTIONLESSACKRECEIVERESOURCES_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckReceiveResources;
		StorageTmp->lLCConnectionlessAckReceiveResources = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckReceiveResources = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckIVMOMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct networkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_networkEntityTitles entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(networkEntityTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityTitles not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->networkEntityTitles;
		old_length = StorageTmp->networkEntityTitlesLen;
		StorageTmp->networkEntityTitles = string;
		StorageTmp->networkEntityTitlesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->networkEntityTitles = old_value;
		StorageTmp->networkEntityTitlesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkEntitySystemTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct networkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_networkEntitySystemTypes entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(networkEntityTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->networkEntitySystemTypes;
		old_length = StorageTmp->networkEntitySystemTypesLen;
		StorageTmp->networkEntitySystemTypes = string;
		StorageTmp->networkEntitySystemTypesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->networkEntitySystemTypes = old_value;
		StorageTmp->networkEntitySystemTypesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cLNSAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case CLNSADMINISTRATIVESTATE_LOCKED:
		case CLNSADMINISTRATIVESTATE_UNLOCKED:
		case CLNSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSAdministrativeState;
		StorageTmp->cLNSAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSSupportedProtocols(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_cLNSSupportedProtocols entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSSupportedProtocols not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSSupportedProtocols: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSSupportedProtocols;
		old_length = StorageTmp->cLNSSupportedProtocolsLen;
		StorageTmp->cLNSSupportedProtocols = string;
		StorageTmp->cLNSSupportedProtocolsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSSupportedProtocols = old_value;
		StorageTmp->cLNSSupportedProtocolsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_cLNSOperationalSystemType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSOperationalSystemType;
		old_length = StorageTmp->cLNSOperationalSystemTypeLen;
		StorageTmp->cLNSOperationalSystemType = string;
		StorageTmp->cLNSOperationalSystemTypeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSOperationalSystemType = old_value;
		StorageTmp->cLNSOperationalSystemTypeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSMaximumLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cLNSMaximumLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..255 */
		if ((1 > set_value || set_value > 255)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSMaximumLifetime;
		StorageTmp->cLNSMaximumLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSMaximumLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSEnableChecksum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cLNSEnableChecksum entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case CLNSENABLECHECKSUM_TRUE:
		case CLNSENABLECHECKSUM_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cLNSEnableChecksum;
		StorageTmp->cLNSEnableChecksum = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSEnableChecksum = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cONSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct cONSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cONSAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cONSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case CONSADMINISTRATIVESTATE_LOCKED:
		case CONSADMINISTRATIVESTATE_UNLOCKED:
		case CONSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cONSAdministrativeState;
		StorageTmp->cONSAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cONSAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cONSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct cONSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_cONSOperationalSystemType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(cONSTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->cONSOperationalSystemType;
		old_length = StorageTmp->cONSOperationalSystemTypeLen;
		StorageTmp->cONSOperationalSystemType = string;
		StorageTmp->cONSOperationalSystemTypeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cONSOperationalSystemType = old_value;
		StorageTmp->cONSOperationalSystemTypeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_neighbourSNPAAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct adjacencyTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_neighbourSNPAAddress entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(adjacencyTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSNPAAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSNPAAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->neighbourSNPAAddress;
		old_length = StorageTmp->neighbourSNPAAddressLen;
		StorageTmp->neighbourSNPAAddress = string;
		StorageTmp->neighbourSNPAAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->neighbourSNPAAddress = old_value;
		StorageTmp->neighbourSNPAAddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_neighbourSystemIds(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct adjacencyTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_neighbourSystemIds entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(adjacencyTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSystemIds not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSystemIds: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->neighbourSystemIds;
		old_length = StorageTmp->neighbourSystemIdsLen;
		StorageTmp->neighbourSystemIds = string;
		StorageTmp->neighbourSystemIdsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->neighbourSystemIds = old_value;
		StorageTmp->neighbourSystemIdsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDefaultMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationDefaultMetricPathCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDefaultMetricPathCost;
		StorageTmp->destinationDefaultMetricPathCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDefaultMetricPathCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDefaultMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationDefaultMetricOutputAdjacencies entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDefaultMetricOutputAdjacencies;
		old_length = StorageTmp->destinationDefaultMetricOutputAdjacenciesLen;
		StorageTmp->destinationDefaultMetricOutputAdjacencies = string;
		StorageTmp->destinationDefaultMetricOutputAdjacenciesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDefaultMetricOutputAdjacencies = old_value;
		StorageTmp->destinationDefaultMetricOutputAdjacenciesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDelayMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationDelayMetricPathCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDelayMetricPathCost;
		StorageTmp->destinationDelayMetricPathCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDelayMetricPathCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDelayMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationDelayMetricOutputAdjacencies entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDelayMetricOutputAdjacencies;
		old_length = StorageTmp->destinationDelayMetricOutputAdjacenciesLen;
		StorageTmp->destinationDelayMetricOutputAdjacencies = string;
		StorageTmp->destinationDelayMetricOutputAdjacenciesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDelayMetricOutputAdjacencies = old_value;
		StorageTmp->destinationDelayMetricOutputAdjacenciesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationExpenseMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationExpenseMetricPathCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationExpenseMetricPathCost;
		StorageTmp->destinationExpenseMetricPathCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationExpenseMetricPathCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationExpenseMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationExpenseMetricOutputAdjacencies entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationExpenseMetricOutputAdjacencies;
		old_length = StorageTmp->destinationExpenseMetricOutputAdjacenciesLen;
		StorageTmp->destinationExpenseMetricOutputAdjacencies = string;
		StorageTmp->destinationExpenseMetricOutputAdjacenciesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationExpenseMetricOutputAdjacencies = old_value;
		StorageTmp->destinationExpenseMetricOutputAdjacenciesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationErrorMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationErrorMetricPathCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationErrorMetricPathCost;
		StorageTmp->destinationErrorMetricPathCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationErrorMetricPathCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationErrorMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationErrorMetricOutputAdjacencies entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(destinationTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationErrorMetricOutputAdjacencies;
		old_length = StorageTmp->destinationErrorMetricOutputAdjacenciesLen;
		StorageTmp->destinationErrorMetricOutputAdjacencies = string;
		StorageTmp->destinationErrorMetricOutputAdjacenciesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationErrorMetricOutputAdjacencies = old_value;
		StorageTmp->destinationErrorMetricOutputAdjacenciesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressPrefix entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..21 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 21))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressPrefix;
		old_length = StorageTmp->reachableAddressPrefixLen;
		StorageTmp->reachableAddressPrefix = string;
		StorageTmp->reachableAddressPrefixLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressPrefix = old_value;
		StorageTmp->reachableAddressPrefixLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressMappingType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressMappingType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case REACHABLEADDRESSMAPPINGTYPE_NONE:
		case REACHABLEADDRESSMAPPINGTYPE_EXPLICIT:
		case REACHABLEADDRESSMAPPINGTYPE_EXTRACTIDI:
		case REACHABLEADDRESSMAPPINGTYPE_EXTRACTDSP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressMappingType;
		StorageTmp->reachableAddressMappingType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressMappingType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDefaultMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDefaultMetric entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 1..63 */
		if ((1 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressDefaultMetric;
		StorageTmp->reachableAddressDefaultMetric = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDefaultMetric = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDelayMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDelayMetric entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressDelayMetric;
		StorageTmp->reachableAddressDelayMetric = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDelayMetric = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressExpenseMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressExpenseMetric entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressExpenseMetric;
		StorageTmp->reachableAddressExpenseMetric = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressExpenseMetric = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressErrorMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressErrorMetric entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressErrorMetric;
		StorageTmp->reachableAddressErrorMetric = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressErrorMetric = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDefaultMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDefaultMetricType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSDEFAULTMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSDEFAULTMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressDefaultMetricType;
		StorageTmp->reachableAddressDefaultMetricType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDefaultMetricType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDelayMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDelayMetricType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSDELAYMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSDELAYMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressDelayMetricType;
		StorageTmp->reachableAddressDelayMetricType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDelayMetricType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressExpenseMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressExpenseMetricType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSEXPENSEMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSEXPENSEMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressExpenseMetricType;
		StorageTmp->reachableAddressExpenseMetricType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressExpenseMetricType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressErrorMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressErrorMetricType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSERRORMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSERRORMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressErrorMetricType;
		StorageTmp->reachableAddressErrorMetricType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressErrorMetricType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case REACHABLEADDRESSADMINISTRATIVESTATE_LOCKED:
		case REACHABLEADDRESSADMINISTRATIVESTATE_UNLOCKED:
		case REACHABLEADDRESSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressAdministrativeState;
		StorageTmp->reachableAddressAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressSNPAAddresses(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressSNPAAddresses entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAAddresses not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAAddresses: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressSNPAAddresses;
		old_length = StorageTmp->reachableAddressSNPAAddressesLen;
		StorageTmp->reachableAddressSNPAAddresses = string;
		StorageTmp->reachableAddressSNPAAddressesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressSNPAAddresses = old_value;
		StorageTmp->reachableAddressSNPAAddressesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressSNPAMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressSNPAMask entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAMask not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressSNPAMask;
		old_length = StorageTmp->reachableAddressSNPAMaskLen;
		StorageTmp->reachableAddressSNPAMask = string;
		StorageTmp->reachableAddressSNPAMaskLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressSNPAMask = old_value;
		StorageTmp->reachableAddressSNPAMaskLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressSNPAPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressSNPAPrefix entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(dlMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..21 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 21))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->reachableAddressSNPAPrefix;
		old_length = StorageTmp->reachableAddressSNPAPrefixLen;
		StorageTmp->reachableAddressSNPAPrefix = string;
		StorageTmp->reachableAddressSNPAPrefixLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressSNPAPrefix = old_value;
		StorageTmp->reachableAddressSNPAPrefixLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultInterfaceType entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value dTE */
		switch (set_value) {
		case SLPCONNECTIONDEFAULTINTERFACETYPE_DTE:
		case SLPCONNECTIONDEFAULTINTERFACETYPE_DCE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultInterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultInterfaceType;
		StorageTmp->sLPConnectionDefaultInterfaceType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultInterfaceType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultK entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultK;
		StorageTmp->sLPConnectionDefaultK = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultK = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultN1 entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultN1;
		StorageTmp->sLPConnectionDefaultN1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultN1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultN2 entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultN2;
		StorageTmp->sLPConnectionDefaultN2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultN2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultSequenceModulus entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 128..128 */
		if (set_value != 8 && set_value != 128) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultSequenceModulus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultSequenceModulus;
		StorageTmp->sLPConnectionDefaultSequenceModulus = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultSequenceModulus = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT1Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT1Timer;
		StorageTmp->sLPConnectionDefaultT1Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT1Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT2Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT2Timer;
		StorageTmp->sLPConnectionDefaultT2Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT2Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT3Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT3Timer;
		StorageTmp->sLPConnectionDefaultT3Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT3Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT4Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT4Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT4Timer;
		StorageTmp->sLPConnectionDefaultT4Timer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT4Timer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultMaximumRetransmissions;
		StorageTmp->lLCConnection2DefaultMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultReceivedWindowSize;
		StorageTmp->lLCConnection2DefaultReceivedWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultReceivedWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultSendWindowSize;
		StorageTmp->lLCConnection2DefaultSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultAcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultBusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue;
		StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultPBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultPBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultPBitTimeoutValue;
		StorageTmp->lLCConnection2DefaultPBitTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultPBitTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultRejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultRejectTimeoutValue;
		StorageTmp->lLCConnection2DefaultRejectTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultRejectTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dlMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultRoute entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRoute not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultRoute;
		old_length = StorageTmp->lLCConnection2DefaultRouteLen;
		StorageTmp->lLCConnection2DefaultRoute = string;
		StorageTmp->lLCConnection2DefaultRouteLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultRoute = old_value;
		StorageTmp->lLCConnection2DefaultRouteLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultKStep entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultKStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultKStep;
		StorageTmp->lLCConnection2DefaultKStep = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultKStep = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultMaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultMaxSendWindowSize;
		StorageTmp->lLCConnection2DefaultMaxSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultMaxSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultOptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS_TRUE:
		case LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs;
		StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckDefaultMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct physicalSAPTable_data *StorageTmp = NULL;
	static struct physicalSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(physicalSAPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(physicalSAPTableStorage, NULL, &name[sizeof(physicalSAPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->physicalSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->physicalSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->physicalSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* sapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(physicalSAPTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(physicalSAPTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sapId, vp->val.string, vp->val_len);
			StorageNew->sapIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->physicalSAPRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			physicalSAPTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			physicalSAPTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->physicalSAPRowStatus;
			StorageTmp->physicalSAPRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(physicalSAPTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&physicalSAPTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(physicalSAPTableStorage, StorageNew);
			header_complex_extract_entry(&physicalSAPTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->physicalSAPRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			physicalSAPTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->physicalSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->physicalSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			physicalSAPTable_del(&StorageDel);
			/* physicalSAPTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dataCircuitTable_data *StorageTmp = NULL;
	static struct dataCircuitTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(dataCircuitTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[sizeof(dataCircuitTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dataCircuitRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dataCircuitTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dataCircuitTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(dataCircuitTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(dataCircuitTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->dataCircuitRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			dataCircuitTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			dataCircuitTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dataCircuitRowStatus;
			StorageTmp->dataCircuitRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(dataCircuitTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&dataCircuitTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(dataCircuitTableStorage, StorageNew);
			header_complex_extract_entry(&dataCircuitTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dataCircuitRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			dataCircuitTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dataCircuitRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dataCircuitRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dataCircuitTable_del(&StorageDel);
			/* dataCircuitTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct physicalConnectionTable_data *StorageTmp = NULL;
	static struct physicalConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(physicalConnectionTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(physicalConnectionTableStorage, NULL, &name[sizeof(physicalConnectionTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->physicalConnectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->physicalConnectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->physicalConnectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* connectionId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(physicalConnectionTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(physicalConnectionTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->physicalConnectionRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			physicalConnectionTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			physicalConnectionTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->physicalConnectionRowStatus;
			StorageTmp->physicalConnectionRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(physicalConnectionTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&physicalConnectionTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(physicalConnectionTableStorage, StorageNew);
			header_complex_extract_entry(&physicalConnectionTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->physicalConnectionRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			physicalConnectionTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->physicalConnectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->physicalConnectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			physicalConnectionTable_del(&StorageDel);
			/* physicalConnectionTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_datalinkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct datalinkEntityTable_data *StorageTmp = NULL;
	static struct datalinkEntityTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(datalinkEntityTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(datalinkEntityTableStorage, NULL, &name[sizeof(datalinkEntityTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->datalinkEntityRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->datalinkEntityTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->datalinkEntityTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(datalinkEntityTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(datalinkEntityTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->datalinkEntityRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			datalinkEntityTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			datalinkEntityTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->datalinkEntityRowStatus;
			StorageTmp->datalinkEntityRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(datalinkEntityTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&datalinkEntityTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(datalinkEntityTableStorage, StorageNew);
			header_complex_extract_entry(&datalinkEntityTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->datalinkEntityRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			datalinkEntityTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->datalinkEntityRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->datalinkEntityRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			datalinkEntityTable_del(&StorageDel);
			/* datalinkEntityTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dLSAPTable_data *StorageTmp = NULL;
	static struct dLSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(dLSAPTableStorage, NULL, &name[sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dLSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dLSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dLSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* sapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(dLSAPTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sapId, vp->val.string, vp->val_len);
			StorageNew->sapIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->dLSAPRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			dLSAPTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			dLSAPTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dLSAPRowStatus;
			StorageTmp->dLSAPRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(dLSAPTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&dLSAPTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(dLSAPTableStorage, StorageNew);
			header_complex_extract_entry(&dLSAPTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dLSAPRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			dLSAPTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dLSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dLSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dLSAPTable_del(&StorageDel);
			/* dLSAPTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lAPBDLETable_data *StorageTmp = NULL;
	static struct lAPBDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lAPBDLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[sizeof(lAPBDLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lAPBDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lAPBDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lAPBDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lAPBDLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(lAPBDLETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->lAPBDLERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lAPBDLETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lAPBDLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lAPBDLERowStatus;
			StorageTmp->lAPBDLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(lAPBDLETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&lAPBDLETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lAPBDLETableStorage, StorageNew);
			header_complex_extract_entry(&lAPBDLETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lAPBDLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lAPBDLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lAPBDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lAPBDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lAPBDLETable_del(&StorageDel);
			/* lAPBDLETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sLPPMTable_data *StorageTmp = NULL;
	static struct sLPPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sLPPMTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sLPPMTableStorage, NULL, &name[sizeof(sLPPMTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sLPPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sLPPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sLPPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sLPPMTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(sLPPMTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->sLPPMRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sLPPMTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sLPPMTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sLPPMRowStatus;
			StorageTmp->sLPPMRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(sLPPMTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&sLPPMTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sLPPMTableStorage, StorageNew);
			header_complex_extract_entry(&sLPPMTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sLPPMRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sLPPMTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sLPPMTable_del(&StorageDel);
			/* sLPPMTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static struct sLPConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sLPConnectionTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[sizeof(sLPConnectionTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sLPConnectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sLPConnectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sLPConnectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* connectionId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sLPConnectionTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->sLPConnectionRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sLPConnectionTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sLPConnectionTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sLPConnectionRowStatus;
			StorageTmp->sLPConnectionRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(sLPConnectionTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&sLPConnectionTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sLPConnectionTableStorage, StorageNew);
			header_complex_extract_entry(&sLPConnectionTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sLPConnectionRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sLPConnectionTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPConnectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPConnectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sLPConnectionTable_del(&StorageDel);
			/* sLPConnectionTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static struct sLPConnectionIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sLPConnectionIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[sizeof(sLPConnectionIVMOTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sLPConnectionIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sLPConnectionIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sLPConnectionIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* connectionId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sLPConnectionIVMOTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionIVMOTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->sLPConnectionIVMORowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sLPConnectionIVMOTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sLPConnectionIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sLPConnectionIVMORowStatus;
			StorageTmp->sLPConnectionIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(sLPConnectionIVMOTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&sLPConnectionIVMOTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sLPConnectionIVMOTableStorage, StorageNew);
			header_complex_extract_entry(&sLPConnectionIVMOTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sLPConnectionIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sLPConnectionIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPConnectionIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sLPConnectionIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sLPConnectionIVMOTable_del(&StorageDel);
			/* sLPConnectionIVMOTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mACDLETable_data *StorageTmp = NULL;
	static struct mACDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mACDLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mACDLETableStorage, NULL, &name[sizeof(mACDLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mACDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mACDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mACDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mACDLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mACDLETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mACDLERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mACDLETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mACDLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mACDLERowStatus;
			StorageTmp->mACDLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mACDLETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mACDLETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mACDLETableStorage, StorageNew);
			header_complex_extract_entry(&mACDLETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mACDLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mACDLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mACDLETable_del(&StorageDel);
			/* mACDLETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mACTable_data *StorageTmp = NULL;
	static struct mACTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mACTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mACTableStorage, NULL, &name[sizeof(mACTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mACRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mACTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mACTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* mACId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mACTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mACTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mACId, vp->val.string, vp->val_len);
			StorageNew->mACIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mACRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mACTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mACTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mACRowStatus;
			StorageTmp->mACRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mACTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mACTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mACTableStorage, StorageNew);
			header_complex_extract_entry(&mACTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mACRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mACTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mACTable_del(&StorageDel);
			/* mACTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCDLETable_data *StorageTmp = NULL;
	static struct lLCDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCDLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(lLCDLETableStorage, NULL, &name[sizeof(lLCDLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCDLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(lLCDLETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->lLCDLERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCDLETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCDLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCDLERowStatus;
			StorageTmp->lLCDLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(lLCDLETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&lLCDLETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lLCDLETableStorage, StorageNew);
			header_complex_extract_entry(&lLCDLETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCDLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCDLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCDLETable_del(&StorageDel);
			/* lLCDLETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCLPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCCLPMTable_data *StorageTmp = NULL;
	static struct lLCCLPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCCLPMTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(lLCCLPMTableStorage, NULL, &name[sizeof(lLCCLPMTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCLPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCCLPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCCLPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCCLPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* clProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCCLPMTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(lLCCLPMTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->lLCCLPMRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCCLPMTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCCLPMTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCCLPMRowStatus;
			StorageTmp->lLCCLPMRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(lLCCLPMTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&lLCCLPMTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lLCCLPMTableStorage, StorageNew);
			header_complex_extract_entry(&lLCCLPMTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCCLPMRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCCLPMTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCLPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCLPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCCLPMTable_del(&StorageDel);
			/* lLCCLPMTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCOPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCCOPMTable_data *StorageTmp = NULL;
	static struct lLCCOPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCCOPMTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(lLCCOPMTableStorage, NULL, &name[sizeof(lLCCOPMTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCOPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCCOPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCCOPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCCOPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCCOPMTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(lLCCOPMTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->lLCCOPMRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCCOPMTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCCOPMTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCCOPMRowStatus;
			StorageTmp->lLCCOPMRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(lLCCOPMTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&lLCCOPMTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lLCCOPMTableStorage, StorageNew);
			header_complex_extract_entry(&lLCCOPMTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCCOPMRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCCOPMTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCOPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCOPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCCOPMTable_del(&StorageDel);
			/* lLCCOPMTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	static struct lLCConnectionlessAckIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCConnectionlessAckIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[sizeof(lLCConnectionlessAckIVMOTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCConnectionlessAckIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCConnectionlessAckIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCConnectionlessAckIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* lLCConnectionlessAckIVMOName */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCConnectionlessAckIVMOTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionlessAckIVMOTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->lLCConnectionlessAckIVMOName, vp->val.string, vp->val_len);
			StorageNew->lLCConnectionlessAckIVMONameLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->lLCConnectionlessAckIVMORowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCConnectionlessAckIVMOTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCConnectionlessAckIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCConnectionlessAckIVMORowStatus;
			StorageTmp->lLCConnectionlessAckIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(lLCConnectionlessAckIVMOTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&lLCConnectionlessAckIVMOTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lLCConnectionlessAckIVMOTableStorage, StorageNew);
			header_complex_extract_entry(&lLCConnectionlessAckIVMOTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCConnectionlessAckIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCConnectionlessAckIVMOTable_del(&StorageDel);
			/* lLCConnectionlessAckIVMOTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct networkEntityTable_data *StorageTmp = NULL;
	static struct networkEntityTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(networkEntityTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(networkEntityTableStorage, NULL, &name[sizeof(networkEntityTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->networkEntityRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->networkEntityTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->networkEntityTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(networkEntityTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(networkEntityTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->networkEntityRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			networkEntityTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			networkEntityTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->networkEntityRowStatus;
			StorageTmp->networkEntityRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(networkEntityTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&networkEntityTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(networkEntityTableStorage, StorageNew);
			header_complex_extract_entry(&networkEntityTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->networkEntityRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			networkEntityTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->networkEntityRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->networkEntityRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			networkEntityTable_del(&StorageDel);
			/* networkEntityTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_nSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct nSAPTable_data *StorageTmp = NULL;
	static struct nSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(nSAPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(nSAPTableStorage, NULL, &name[sizeof(nSAPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to nSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->nSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->nSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->nSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(nSAPTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(nSAPTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->sapId, vp->val.string, vp->val_len);
			StorageNew->sapIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->nSAPRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			nSAPTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			nSAPTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->nSAPRowStatus;
			StorageTmp->nSAPRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(nSAPTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&nSAPTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(nSAPTableStorage, StorageNew);
			header_complex_extract_entry(&nSAPTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->nSAPRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			nSAPTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->nSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->nSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			nSAPTable_del(&StorageDel);
			/* nSAPTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cLNSTable_data *StorageTmp = NULL;
	static struct cLNSTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(cLNSTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(cLNSTableStorage, NULL, &name[sizeof(cLNSTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cLNSRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cLNSTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cLNSTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* clProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(cLNSTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(cLNSTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->cLNSEnableChecksum = false;
			StorageNew->cLNSRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			cLNSTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			cLNSTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cLNSRowStatus;
			StorageTmp->cLNSRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(cLNSTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&cLNSTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(cLNSTableStorage, StorageNew);
			header_complex_extract_entry(&cLNSTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cLNSRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			cLNSTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cLNSTable_del(&StorageDel);
			/* cLNSTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSISISRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cLNSISISTable_data *StorageTmp = NULL;
	static struct cLNSISISTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(cLNSISISTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(cLNSISISTableStorage, NULL, &name[sizeof(cLNSISISTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cLNSISISRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cLNSISISTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cLNSISISTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* clProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(cLNSISISTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(cLNSISISTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->cLNSISISRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			cLNSISISTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			cLNSISISTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cLNSISISRowStatus;
			StorageTmp->cLNSISISRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(cLNSISISTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&cLNSISISTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(cLNSISISTableStorage, StorageNew);
			header_complex_extract_entry(&cLNSISISTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cLNSISISRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			cLNSISISTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSISISRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSISISRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cLNSISISTable_del(&StorageDel);
			/* cLNSISISTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSISISLevel2RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cLNSISISLevel2Table_data *StorageTmp = NULL;
	static struct cLNSISISLevel2Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(cLNSISISLevel2Table_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(cLNSISISLevel2TableStorage, NULL, &name[sizeof(cLNSISISLevel2Table_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISLevel2RowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cLNSISISLevel2RowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cLNSISISLevel2Table_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cLNSISISLevel2Table_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(cLNSISISLevel2Table_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(cLNSISISLevel2Table_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->cLNSISISLevel2RowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			cLNSISISLevel2Table_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			cLNSISISLevel2Table_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cLNSISISLevel2RowStatus;
			StorageTmp->cLNSISISLevel2RowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(cLNSISISLevel2TableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&cLNSISISLevel2TableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(cLNSISISLevel2TableStorage, StorageNew);
			header_complex_extract_entry(&cLNSISISLevel2TableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cLNSISISLevel2RowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			cLNSISISLevel2Table_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSISISLevel2RowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cLNSISISLevel2RowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cLNSISISLevel2Table_del(&StorageDel);
			/* cLNSISISLevel2Table_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_linkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct linkageTable_data *StorageTmp = NULL;
	static struct linkageTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(linkageTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(linkageTableStorage, NULL, &name[sizeof(linkageTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to linkageRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->linkageRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->linkageTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->linkageTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* protocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* linkageId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(linkageTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(linkageTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->protocolMachineId, vp->val.string, vp->val_len);
			StorageNew->protocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->linkageId, vp->val.string, vp->val_len);
			StorageNew->linkageIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->linkageRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			linkageTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			linkageTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->linkageRowStatus;
			StorageTmp->linkageRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(linkageTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&linkageTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(linkageTableStorage, StorageNew);
			header_complex_extract_entry(&linkageTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->linkageRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			linkageTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->linkageRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->linkageRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			linkageTable_del(&StorageDel);
			/* linkageTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cONSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cONSTable_data *StorageTmp = NULL;
	static struct cONSTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(cONSTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(cONSTableStorage, NULL, &name[sizeof(cONSTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cONSRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cONSTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cONSTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(cONSTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(cONSTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->cONSRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			cONSTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			cONSTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cONSRowStatus;
			StorageTmp->cONSRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(cONSTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&cONSTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(cONSTableStorage, StorageNew);
			header_complex_extract_entry(&cONSTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cONSRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			cONSTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cONSRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->cONSRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cONSTable_del(&StorageDel);
			/* cONSTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct networkConnectionTable_data *StorageTmp = NULL;
	static struct networkConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(networkConnectionTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(networkConnectionTableStorage, NULL, &name[sizeof(networkConnectionTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->networkConnectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->networkConnectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->networkConnectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* coProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* connectionId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(networkConnectionTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(networkConnectionTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->networkConnectionRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			networkConnectionTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			networkConnectionTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->networkConnectionRowStatus;
			StorageTmp->networkConnectionRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(networkConnectionTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&networkConnectionTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(networkConnectionTableStorage, StorageNew);
			header_complex_extract_entry(&networkConnectionTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->networkConnectionRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			networkConnectionTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->networkConnectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->networkConnectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			networkConnectionTable_del(&StorageDel);
			/* networkConnectionTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLETable_data *StorageTmp = NULL;
	static struct x25PLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(x25PLETableStorage, NULL, &name[sizeof(x25PLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(x25PLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(x25PLETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->x25PLERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLERowStatus;
			StorageTmp->x25PLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(x25PLETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&x25PLETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PLETableStorage, StorageNew);
			header_complex_extract_entry(&x25PLETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLETable_del(&StorageDel);
			/* x25PLETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static struct x25PLEIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(x25PLEIVMOTableStorage, NULL, &name[sizeof(x25PLEIVMOTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(x25PLEIVMOTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMOTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->x25PLEIVMORowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEIVMOTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMORowStatus;
			StorageTmp->x25PLEIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(x25PLEIVMOTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&x25PLEIVMOTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PLEIVMOTableStorage, StorageNew);
			header_complex_extract_entry(&x25PLEIVMOTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMOTable_del(&StorageDel);
			/* x25PLEIVMOTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
 write_x25PLEIVMO -
DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMO -DTETable_data * StorageTmp = NULL;
	static struct x25PLEIVMO -DTETable_data * StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMO - DTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(x25PLEIVMO - DTETableStorage, NULL, &name[sizeof(x25PLEIVMO - DTETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO-DTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMO - DTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMO - DTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMO - DTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(x25PLEIVMO - DTETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMO - DTETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->x25PLEIVMO - DTERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEIVMO - DTETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEIVMO - DTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMO - DTERowStatus;
			StorageTmp->x25PLEIVMO - DTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(x25PLEIVMO - DTETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&x25PLEIVMO - DTETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PLEIVMO - DTETableStorage, StorageNew);
			header_complex_extract_entry(&x25PLEIVMO - DTETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMO - DTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEIVMO - DTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMO - DTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMO - DTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMO - DTETable_del(&StorageDel);
			/* x25PLEIVMO-DTETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
 write_x25PLEIVMO -
DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMO -DCETable_data * StorageTmp = NULL;
	static struct x25PLEIVMO -DCETable_data * StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMO - DCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(x25PLEIVMO - DCETableStorage, NULL, &name[sizeof(x25PLEIVMO - DCETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO-DCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMO - DCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMO - DCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMO - DCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(x25PLEIVMO - DCETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMO - DCETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->x25PLEIVMO - DCERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEIVMO - DCETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEIVMO - DCETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMO - DCERowStatus;
			StorageTmp->x25PLEIVMO - DCERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(x25PLEIVMO - DCETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&x25PLEIVMO - DCETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PLEIVMO - DCETableStorage, StorageNew);
			header_complex_extract_entry(&x25PLEIVMO - DCETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMO - DCERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEIVMO - DCETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMO - DCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMO - DCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMO - DCETable_del(&StorageDel);
			/* x25PLEIVMO-DCETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_permanentVirtualCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct permanentVirtualCircuitTable_data *StorageTmp = NULL;
	static struct permanentVirtualCircuitTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(permanentVirtualCircuitTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(permanentVirtualCircuitTableStorage, NULL, &name[sizeof(permanentVirtualCircuitTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuitRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->permanentVirtualCircuitRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->permanentVirtualCircuitTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->permanentVirtualCircuitTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCallId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(permanentVirtualCircuitTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuitTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCallId, vp->val.string, vp->val_len);
			StorageNew->virtualCallIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->permanentVirtualCircuitRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			permanentVirtualCircuitTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			permanentVirtualCircuitTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->permanentVirtualCircuitRowStatus;
			StorageTmp->permanentVirtualCircuitRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(permanentVirtualCircuitTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&permanentVirtualCircuitTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(permanentVirtualCircuitTableStorage, StorageNew);
			header_complex_extract_entry(&permanentVirtualCircuitTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->permanentVirtualCircuitRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			permanentVirtualCircuitTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuitRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuitRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			permanentVirtualCircuitTable_del(&StorageDel);
			/* permanentVirtualCircuitTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
 write_permanentVirtualCircuit -
DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct permanentVirtualCircuit -DTETable_data * StorageTmp = NULL;
	static struct permanentVirtualCircuit -DTETable_data * StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(permanentVirtualCircuit - DTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(permanentVirtualCircuit - DTETableStorage, NULL, &name[sizeof(permanentVirtualCircuit - DTETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit-DTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->permanentVirtualCircuit - DTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->permanentVirtualCircuit - DTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->permanentVirtualCircuit - DTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(permanentVirtualCircuit - DTETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuit - DTETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->permanentVirtualCircuit - DTERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			permanentVirtualCircuit - DTETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			permanentVirtualCircuit - DTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->permanentVirtualCircuit - DTERowStatus;
			StorageTmp->permanentVirtualCircuit - DTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(permanentVirtualCircuit - DTETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&permanentVirtualCircuit - DTETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(permanentVirtualCircuit - DTETableStorage, StorageNew);
			header_complex_extract_entry(&permanentVirtualCircuit - DTETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->permanentVirtualCircuit - DTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			permanentVirtualCircuit - DTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuit - DTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuit - DTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			permanentVirtualCircuit - DTETable_del(&StorageDel);
			/* permanentVirtualCircuit-DTETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
 write_permanentVirtualCircuit -
DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct permanentVirtualCircuit -DCETable_data * StorageTmp = NULL;
	static struct permanentVirtualCircuit -DCETable_data * StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(permanentVirtualCircuit - DCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(permanentVirtualCircuit - DCETableStorage, NULL, &name[sizeof(permanentVirtualCircuit - DCETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit-DCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->permanentVirtualCircuit - DCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->permanentVirtualCircuit - DCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->permanentVirtualCircuit - DCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(permanentVirtualCircuit - DCETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuit - DCETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->permanentVirtualCircuit - DCERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			permanentVirtualCircuit - DCETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			permanentVirtualCircuit - DCETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->permanentVirtualCircuit - DCERowStatus;
			StorageTmp->permanentVirtualCircuit - DCERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(permanentVirtualCircuit - DCETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&permanentVirtualCircuit - DCETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(permanentVirtualCircuit - DCETableStorage, StorageNew);
			header_complex_extract_entry(&permanentVirtualCircuit - DCETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->permanentVirtualCircuit - DCERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			permanentVirtualCircuit - DCETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuit - DCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->permanentVirtualCircuit - DCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			permanentVirtualCircuit - DCETable_del(&StorageDel);
			/* permanentVirtualCircuit-DCETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_virtualCallIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct virtualCallIVMOTable_data *StorageTmp = NULL;
	static struct virtualCallIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(virtualCallIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(virtualCallIVMOTableStorage, NULL, &name[sizeof(virtualCallIVMOTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCallIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->virtualCallIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->virtualCallIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->virtualCallIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCallIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(virtualCallIVMOTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(virtualCallIVMOTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCallIVMOId, vp->val.string, vp->val_len);
			StorageNew->virtualCallIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->virtualCallIVMORowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			virtualCallIVMOTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			virtualCallIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->virtualCallIVMORowStatus;
			StorageTmp->virtualCallIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(virtualCallIVMOTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&virtualCallIVMOTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(virtualCallIVMOTableStorage, StorageNew);
			header_complex_extract_entry(&virtualCallIVMOTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->virtualCallIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			virtualCallIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCallIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCallIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			virtualCallIVMOTable_del(&StorageDel);
			/* virtualCallIVMOTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_switchedVirtualCallRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct switchedVirtualCallTable_data *StorageTmp = NULL;
	static struct switchedVirtualCallTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(switchedVirtualCallTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(switchedVirtualCallTableStorage, NULL, &name[sizeof(switchedVirtualCallTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to switchedVirtualCallRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->switchedVirtualCallRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->switchedVirtualCallTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->switchedVirtualCallTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCallId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(switchedVirtualCallTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(switchedVirtualCallTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCallId, vp->val.string, vp->val_len);
			StorageNew->virtualCallIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->switchedVirtualCallRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			switchedVirtualCallTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			switchedVirtualCallTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->switchedVirtualCallRowStatus;
			StorageTmp->switchedVirtualCallRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(switchedVirtualCallTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&switchedVirtualCallTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(switchedVirtualCallTableStorage, StorageNew);
			header_complex_extract_entry(&switchedVirtualCallTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->switchedVirtualCallRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			switchedVirtualCallTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->switchedVirtualCallRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->switchedVirtualCallRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			switchedVirtualCallTable_del(&StorageDel);
			/* switchedVirtualCallTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
 write_virtualCall -
DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct virtualCall -DTETable_data * StorageTmp = NULL;
	static struct virtualCall -DTETable_data * StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(virtualCall - DTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(virtualCall - DTETableStorage, NULL, &name[sizeof(virtualCall - DTETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall-DTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->virtualCall - DTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->virtualCall - DTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->virtualCall - DTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(virtualCall - DTETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(virtualCall - DTETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->virtualCall - DTERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			virtualCall - DTETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			virtualCall - DTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->virtualCall - DTERowStatus;
			StorageTmp->virtualCall - DTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(virtualCall - DTETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&virtualCall - DTETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(virtualCall - DTETableStorage, StorageNew);
			header_complex_extract_entry(&virtualCall - DTETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->virtualCall - DTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			virtualCall - DTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCall - DTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCall - DTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			virtualCall - DTETable_del(&StorageDel);
			/* virtualCall-DTETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
 write_virtualCall -
DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct virtualCall -DCETable_data * StorageTmp = NULL;
	static struct virtualCall -DCETable_data * StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(virtualCall - DCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(virtualCall - DCETableStorage, NULL, &name[sizeof(virtualCall - DCETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall-DCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->virtualCall - DCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->virtualCall - DCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->virtualCall - DCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(virtualCall - DCETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(virtualCall - DCETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->virtualCall - DCERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			virtualCall - DCETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			virtualCall - DCETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->virtualCall - DCERowStatus;
			StorageTmp->virtualCall - DCERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(virtualCall - DCETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&virtualCall - DCETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(virtualCall - DCETableStorage, StorageNew);
			header_complex_extract_entry(&virtualCall - DCETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->virtualCall - DCERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			virtualCall - DCETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCall - DCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->virtualCall - DCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			virtualCall - DCETable_del(&StorageDel);
			/* virtualCall-DCETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dSeriesRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dSeriesCountsTable_data *StorageTmp = NULL;
	static struct dSeriesCountsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(dSeriesCountsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(dSeriesCountsTableStorage, NULL, &name[sizeof(dSeriesCountsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dSeriesRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dSeriesRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dSeriesCountsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dSeriesCountsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* virtualCircuitId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* dSeriesId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(dSeriesCountsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(dSeriesCountsTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->dSeriesId, vp->val.string, vp->val_len);
			StorageNew->dSeriesIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->dSeriesRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			dSeriesCountsTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			dSeriesCountsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dSeriesRowStatus;
			StorageTmp->dSeriesRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(dSeriesCountsTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&dSeriesCountsTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(dSeriesCountsTableStorage, StorageNew);
			header_complex_extract_entry(&dSeriesCountsTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dSeriesRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			dSeriesCountsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dSeriesRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dSeriesRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dSeriesCountsTable_del(&StorageDel);
			/* dSeriesCountsTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_adjacencyRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct adjacencyTable_data *StorageTmp = NULL;
	static struct adjacencyTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(adjacencyTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(adjacencyTableStorage, NULL, &name[sizeof(adjacencyTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to adjacencyRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->adjacencyRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->adjacencyTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->adjacencyTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* clProtocolMachineId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* linkageId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* adjacencyId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(adjacencyTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(adjacencyTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->linkageId, vp->val.string, vp->val_len);
			StorageNew->linkageIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->adjacencyId, vp->val.string, vp->val_len);
			StorageNew->adjacencyIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->adjacencyUsage = undefined;
			StorageNew->adjacencyRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			adjacencyTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			adjacencyTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->adjacencyRowStatus;
			StorageTmp->adjacencyRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(adjacencyTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&adjacencyTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(adjacencyTableStorage, StorageNew);
			header_complex_extract_entry(&adjacencyTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->adjacencyRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			adjacencyTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->adjacencyRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->adjacencyRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			adjacencyTable_del(&StorageDel);
			/* adjacencyTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct reachableAddressTable_data *StorageTmp = NULL;
	static struct reachableAddressTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(reachableAddressTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[sizeof(reachableAddressTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->reachableAddressRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->reachableAddressTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->reachableAddressTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* reachableAddressId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(reachableAddressTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(reachableAddressTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->reachableAddressId, vp->val.string, vp->val_len);
			StorageNew->reachableAddressIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->reachableAddressDefaultMetric = 20;
			StorageNew->reachableAddressDefaultMetricType = internal;
			StorageNew->reachableAddressDelayMetricType = internal;
			StorageNew->reachableAddressExpenseMetricType = internal;
			StorageNew->reachableAddressErrorMetricType = internal;
			StorageNew->reachableAddressSNPAMask = strdup("\"\"");
			StorageNew->reachableAddressSNPAMaskLen = strlen("\"\"");
			StorageNew->reachableAddressSNPAPrefix = strdup("\"\"");
			StorageNew->reachableAddressSNPAPrefixLen = strlen("\"\"");
			StorageNew->reachableAddressRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			reachableAddressTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			reachableAddressTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->reachableAddressRowStatus;
			StorageTmp->reachableAddressRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(reachableAddressTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&reachableAddressTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(reachableAddressTableStorage, StorageNew);
			header_complex_extract_entry(&reachableAddressTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->reachableAddressRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			reachableAddressTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->reachableAddressRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->reachableAddressRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			reachableAddressTable_del(&StorageDel);
			/* reachableAddressTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

#if !defined MODULE
static void
sa_version(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
%2$s\n\
Copyright (c) 2001-2008  OpenSS7 Corporation.  All Rights Reserved.\n\
Distributed under Affero GPL Version 3, included here by reference.\n\
See `%1$s --copying' for copying permissions.\n\
", argv[0], ident);
}
static void
sa_usage(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stderr, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-H|--help-directives}\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
", argv[0]);
}
static void
sa_help(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
Arguments:\n\
    None.\n\
Options:\n\
    -a, --log-addresses\n\
        log addresses of connecting management stations.\n\
    -A, --append\n\
        append to logfiles without truncating.\n\
    -c, --config-file CONFIGFILE\n\
        use configuration file CONFIGFILE.\n\
    -C, --config-only\n\
        only load configuration given by -c option.\n\
    -d, --dump\n\
        dump sent and received PDUs.\n\
    -D, --debug [LEVEL]\n\
        set debugging verbosity to LEVEL.\n\
    -D, --debug-tokens [TOKEN[,TOKEN]*]\n\
        debug specified TOKEN's.\n\
    -f, --dont-fork\n\
        run in the foreground.\n\
    -g, --gid, --groupid GID\n\
        become group GID after listening.\n\
    -h, --help, -?, --?\n\
        print usage information and exit.\n\
    -H, --help-directives\n\
        print config directives and exit.\n\
    -I, --initialize [-]MODULE[,MODULE]*\n\
        initialize (or not, '-') these MODULE's.\n\
    -k, --keep-open\n\
        keep system files open between requests.\n\
    -l, --log-file [LOGFILE]\n\
        log to log file name LOGFILE.  [default: /var/log/dlmib.log]\n\
    -L, --log-stderr\n\
        log to controlling terminal standard error.\n\
    -m, --mibs [+]MIB[,MIB]*\n\
        load these (additional '+') MIBs.\n\
    -M, --master\n\
        run as SNMP master instead of AgentX sub-agent.\n\
    -M, --mibdirs [+]MIBDIR[:MIBDIR]*\n\
        search these (additional, '+') colon separated directories for MIBs.\n\
    -n, --nodaemon\n\
        run in the foreground.\n\
    -n, --name NAME\n\
        use NAME for configuration file base.  [default: dlmib]\n\
    -p, --port PORTNUM\n\
        listen on port number PORTNUM.  [default: 161]\n\
    -p, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/dlmib.pid]\n\
    -P, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/dlmib.pid]\n\
    -q, --quiet\n\
        suppress normal output.\n\
    -q, --quick\n\
        abbreviate output for machine readability.\n\
    -r, --noroot\n\
        do not require root privilege.\n\
    -s, --log-syslog\n\
        log to system logs.\n\
    -S, --sysctl-file FILENAME\n\
        write sysctl config file FILENAME.  [default: /etc/streams.conf]\n\
    -t, --agent-alarms\n\
        agent blocks {SIGALARM}.\n\
    -T, --transport [TRANSPORT]\n\
        default transport TRANSPORT.  [default: udp]\n\
    -u, --uid, --userid UID\n\
        become user UID after listening.\n\
    -U, --dont-remove-pidfile\n\
        do not remove PIDFILE when shutting down.\n\
    -v, --version\n\
        print version information and exit.\n\
    -V, --verbose [LEVEL]\n\
        be verbose to LEVEL.  [default: 1]\n\
    -x, --agentx-socket [SOCKET]\n\
        master AgentX on SOCKET.  [default: /var/agentx/master]\n\
    -X, --agentx\n\
        run as AgentX sub-agent instead of master (the default).\n\
    -y, --copying\n\
        print copying information and exit.\n\
", argv[0]);
}
static void
sa_copying(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
--------------------------------------------------------------------------------\n\
%1$s\n\
--------------------------------------------------------------------------------\n\
Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com>\n\
Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>\n\
\n\
All Rights Reserved.\n\
--------------------------------------------------------------------------------\n\
This program is free software; you can  redistribute  it and/or modify  it under\n\
the terms of the GNU Affero General Public License as published by the Free\n\
Software Foundation; Version 3 of the License.\n\
\n\
This program is distributed in the hope that it will  be useful, but WITHOUT ANY\n\
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A\n\
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.\n\
\n\
You should have received a copy of the GNU  Affero  General Public License along\n\
with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the\n\
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
--------------------------------------------------------------------------------\n\
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\n\
of the U.S. Government (\"Government\"), the following provisions apply to you. If\n\
the Software is supplied by the  Department of Defense (\"DoD\"), it is classified\n\
as \"Commercial  Computer  Software\"  under  paragraph  252.227-7014  of the  DoD\n\
Supplement  to the  Federal Acquisition Regulations  (\"DFARS\") (or any successor\n\
regulations) and the  Government  is acquiring  only the  license rights granted\n\
herein (the license rights customarily provided to non-Government users). If the\n\
Software is supplied to any unit or agency of the Government  other than DoD, it\n\
is  classified as  \"Restricted Computer Software\" and the Government's rights in\n\
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition\n\
Regulations (\"FAR\")  (or any successor regulations) or, in the cases of NASA, in\n\
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor\n\
regulations).\n\
--------------------------------------------------------------------------------\n\
Commercial  licensing  and  support of this  software is  available from OpenSS7\n\
Corporation at a fee.  See http://www.openss7.com/\n\
--------------------------------------------------------------------------------\n\
", ident);
}

void
sa_help_directives(int argc, char *argv[])
{
	ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
	init_agent("dlMIB");
	// init_mib_modules();
	init_mib();
	init_snmp("dlMIB");
	snmp_log(MY_FACILITY(LOG_INFO), "Configuration directives understood:\n");
	/* Unfortunately, read_config_print_usage() uses snmp_log(), meaning that it can only be
	   writen to standard error and not standard output. */
	read_config_print_usage("    ");
}
static int
sa_sig_register(int signum, RETSIGTYPE(*handler) (int))
{
	sigset_t mask;
	struct sigaction act;

	act.sa_handler = handler ? handler : SIG_DFL;
	act.sa_flags = handler ? SA_RESTART : 0;
	sigemptyset(&act.sa_mask);
	if (sigaction(signum, &act, NULL))
		return (-1);
	sigemptyset(&mask);
	sigaddset(&mask, signum);
	sigprocmask(handler ? SIG_UNBLOCK : SIG_BLOCK, &mask, NULL);
	return (0);
}
static int sa_alm_signal = 0;
static int sa_pol_signal = 0;
static int sa_hup_signal = 0;
static int sa_int_signal = 0;
static int sa_trm_signal = 0;
static int sa_alm_handle = 0;
void
sa_alm_callback(uint req, void *arg)
{
	if (req == sa_alm_handle)
		sa_alm_handle = 0;
	sa_alm_signal = 1;
	return;
}

static RETSIGTYPE
sa_alm_handler(int signum)
{
	sa_alm_signal = 1;
	return (RETSIGTYPE) (0);
}
static void
sa_snmp_alm_handler(uint reg, void *clientarg)
{
	sa_alm_signal = 1;
	return;
}
static int
sa_alm_catch(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, &sa_alm_handler);
	return (-1);
}
static int
sa_alm_block(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, NULL);
	if (sa_alm_handle) {
		uint handle = sa_alm_handle;

		sa_alm_handle = 0;
		snmp_alarm_unregister(handle);
	}
	return (0);
}
static int
sa_alm_action(void)
{
	sa_alm_signal = 0;
	return (0);
}

static RETSIGTYPE
sa_pol_handler(int signum)
{
	sa_pol_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_pol_catch(void)
{
	return sa_sig_register(SIGPOLL, &sa_pol_handler);
}
static int
sa_pol_block(void)
{
	return sa_sig_register(SIGPOLL, NULL);
}

/*
 * Both the sc(4) module and sad(4) driver issue an M_PCSIG message with
 * SIGPOLL to the stream head whenever the STREAMS configuration or autopush
 * configuration changes, indicating to the agent which has the sc(4) or
 * sad(4) Stream open that it is necessary to reread information from the
 * kernel.  This fact is merely recorded, as this information is not read each
 * time that a configuration change occurs, but only after a request from some
 * portion of that information occurs. This condition is also set when the
 * sc(4) and sad(4) Streams are first opened. The SIGPOLL will also deliver in
 * siginfo the file descriptor issuing the signal, so we could distiguish
 * between sc(4) and sad(4) signals, but since one can be pushed over the
 * other, there is little point in distinguishing.
 *
 * sc(4) or sad(4) also should be modified to provide the general streams
 * statistics supported here; even though they are available through the /proc
 * filesystem on Linux Fast-STREAMS.
 */
static int
sa_pol_action(void)
{
	sa_pol_signal = 0;
	snmp_log(MY_FACILITY(LOG_INFO), "%s: Caught SIGPOLL, will re-read data structures", sa_program);
	sa_changed = 1;
	return (0);
}

static RETSIGTYPE
sa_hup_handler(int signum)
{
	sa_hup_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_hup_catch(void)
{
	if (sa_agentx)
		return sa_sig_register(SIGHUP, &sa_hup_handler);
	return (-1);
}
static int
sa_hup_block(void)
{
	return sa_sig_register(SIGHUP, NULL);
}
static int
sa_hup_action(void)
{
	/* There are several times that we might be sent a SIGHUP.  We might be sent a SIGHUP by
	   logrotate asking us to close and reopen our log files. */
	sa_hup_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "Caught SIGHUP, reopening files.");
	if (sa_output > 1)
		snmp_log(MY_FACILITY(LOG_NOTICE), "Reopening output file %s", sa_logfile);
	if (sa_logfillog != 0) {
		fflush(stdlog);
		fclose(stdlog);
		snmp_disable_filelog();
		if ((stdlog = freopen(sa_logfile, sa_appendlog ? "a" : "w", stdlog)) == NULL) {
			/* I hope we have another log sink. */
			snmp_log(MY_FACILITY(LOG_ERR), "%s", strerror(errno));
			snmp_log(MY_FACILITY(LOG_ERR), "Could not reopen log file %s", sa_logfile);
		}
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	return (0);
}

static RETSIGTYPE
sa_int_handler(int signum)
{
	sa_int_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_int_catch(void)
{
	return sa_sig_register(SIGINT, &sa_int_handler);
}
static int
sa_int_block(void)
{
	return sa_sig_register(SIGINT, NULL);
}
static void sa_exit(int retval);
static int
sa_int_action(void)
{
	sa_int_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGINT, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}

static RETSIGTYPE
sa_trm_handler(int signum)
{
	sa_trm_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_trm_catch(void)
{
	return sa_sig_register(SIGTERM, &sa_trm_handler);
}
static int
sa_trm_block(void)
{
	return sa_sig_register(SIGTERM, NULL);
}
static void sa_exit(int retval);
static int
sa_trm_action(void)
{
	sa_trm_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGTERM, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}
static void
sa_sig_catch(void)
{
	sa_alm_catch();
	sa_pol_catch();
	sa_hup_catch();
	sa_int_catch();
	sa_trm_catch();
}
static void
sa_sig_block(void)
{
	sa_alm_block();
	sa_pol_block();
	sa_hup_block();
	sa_int_block();
	sa_trm_block();
}

int
sa_start_timer(long duration)
{
	if (sa_alarms) {
		struct itimerval setting = {
			{0, 0},
			{duration / 1000, (duration % 1000) * 1000}
		};
		if (sa_alm_catch())
			return (-1);
		if (setitimer(ITIMER_REAL, &setting, NULL))
			return (-1);
		sa_alm_signal = 0;
		return (0);
	} else {
#if defined NETSNMP_DS_APPLICATION_ID
		struct timeval setting = {
			duration / 1000, (duration % 1000) * 1000
		};
		sa_alm_handle = snmp_alarm_register_hr(setting, 0, sa_snmp_alm_handler, NULL);
#else
		sa_alm_handle = snmp_alarm_register((duration + 999) / 1000, 0, sa_snmp_alm_handler, NULL);
#endif
		return (sa_alm_handle ? 0 : -1);
	}
}
static void
sa_exit(int retval)
{
	if (retval)
		snmp_log(MY_FACILITY(LOG_ERR), "%s: Exiting %d", sa_program, retval);
	else
		snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Exiting %d", sa_program, retval);
	fflush(stdout);
	fflush(stderr);
	sa_sig_block();
	closelog();
	exit(retval);
}
static void
sa_init_logging(int argc, char *argv[])
{
	static char progname[256];

	/* The purpose of this function is to bring logging up before forking (and while still in
	   the foreground) so that we can use the snmp_log() function before and during forking if
	   necessary.  Note that the default configuration for snmp_log() is to send all logs to
	   standard error. */
	strncpy(progname, basename(argv[0]), sizeof(progname));
	snmp_disable_log();
	if (sa_logfillog) {
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	if (sa_logstderr | sa_logstdout) {
#if defined LOG_PERROR
		/* Note that when we have Linux LOG_PERROR, and logs go both to syslog and stderr,
		   it is better to use the LOG_PERROR than to use snmp_log()'s print to stderr, as
		   the former is better formated. */
		if (!sa_logsyslog)
			snmp_enable_stderrlog();
#else				/* defined LOG_PERROR */
		snmp_enable_stderrlog();
#endif				/* defined LOG_PERROR */
	}
	if (sa_logsyslog) {
#if !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT
		snmp_enable_syslog();
#else				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		snmp_enable_syslog_ident("dlMIB", LOG_DAEMON);
#endif				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		/* Note that the way that snmp sets up the logger is not really the way we want it,
		   so close the log and reopen it the way we want. */
		closelog();
#if defined LOG_PERROR
		openlog("dlMIB", LOG_PID | LOG_CONS | LOG_NDELAY | (sa_logstderr ? LOG_PERROR : 0), MY_FACILITY(0));
#else				/* defined LOG_PERROR */
		openlog("dlMIB", LOG_PID | LOG_CONS | LOG_NDELAY, MY_FACILITY(0));
#endif				/* defined LOG_PERROR */
	}
	if (sa_logcallog) {
		snmp_enable_calllog();
	}
}
static void
sa_enter(int argc, char *argv[])
{
	if (sa_nomead) {
		pid_t pid;

		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent exits */
			exit(0);
		}
		setsid();	/* become a session leader */
		/* fork once more for SVR4 */
		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent responsible for writing pid file */
			if (sa_nomead || sa_pidfile[0] != '\0') {
				FILE *pidf;

				/* initialize default filename */
				if (sa_pidfile[0] == '\0')
					snprintf(sa_pidfile, sizeof(sa_pidfile), "/var/run/%s.pid", sa_program);
				if (sa_output > 1) {
					snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Writing daemon pid to file %s", sa_program, sa_pidfile);
				}
				if ((pidf = fopen(sa_pidfile, "w+"))) {
					fprintf(pidf, "%d", (int) pid);
					fflush(pidf);
					fclose(pidf);
				} else {
					snmp_log(MY_FACILITY(LOG_ERR), "%s: %m", sa_program);
					snmp_log(MY_FACILITY(LOG_ERR), "%s: Could not write pid to file %s", sa_program, sa_pidfile);
					sa_exit(2);
					/* no return */
				}
			}
			/* parent exits */
			exit(0);
		}
		/* child continues */
		/* release current directory */
		if (chdir("/") < 0) {
			perror(argv[0]);
			exit(2);
		}
		umask(0);	/* clear file creation mask */
		/* rearrange file streams */
		fclose(stdin);
	}
	/* continue as foreground or background */
	sa_init_logging(argc, argv);
	sa_sig_catch();
	snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Startup complete.", sa_program);
}
static void
sa_mloop(int argc, char *argv[])
{
	if (sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as AgentX client\n", argv[0]);
		/* run as an AgentX client */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
	} else {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master agent\n", argv[0]);
		/* run as SNMP master */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
	}
	if (sa_alarms) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using application alarms\n", argv[0]);
		/* use application alarms */
		ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
	}
	/* initialize agent */
	init_agent("dlMIB");
	/* initialize MIB */
	init_dlMIB();
	/* initialize SNMP */
	init_snmp("dlMIB");
	if (!sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master\n", argv[0]);
#if !defined NETSNMP_DS_APPLICATION_ID
		init_master_agent(710, NULL, NULL);
#else
		init_master_agent();
#endif
	}
	for (;;) {
		int retval;

		/* to use select or poll you need to use the snmp_select_info() to obtain the fd of
		   the agentx socket and add it to the fdset. */
		/* note that SIGALRM is used by snmp: use the snmp_alarm() api instead */
#if 0
		if (snmp_select() == 0) {
			if (sa_alarms == 0)
				run_alarms();
		}
#endif
		retval = agent_check_and_process(1);	/* 0 == don't block */
		if (retval == 0) {
			/* alarm occurred, alarm conditions checked */
		} else if (retval == -1) {
			/* error (or signal) ocurred */
			if (sa_alm_signal) {
				sa_alm_action();
			}
			if (sa_pol_signal) {
				sa_pol_action();
			}
			if (sa_hup_signal) {
				sa_hup_action();
			}
			if (sa_int_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("dlMIB");
				sa_int_action();	/* no return */
			}
			if (sa_trm_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("dlMIB");
				sa_trm_action();	/* no return */
			}
		} else if (retval > 0) {
			/* processed packets */
			if (sa_fclose) {
				/* close files after each request */
				if (sa_fd != 0) {
					int fd = sa_fd;

					sa_fd = 0;
					close(fd);
				}
			}
			sa_stats_refresh = 1;
			sa_request++;
		}
	}
	if (sa_debug)
		snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
	snmp_shutdown("dlMIB");
}

int
main(int argc, char *argv[])
{
	for (;;) {
		int c, val, fd;
		char *cptr;
		struct passwd *pw;
		struct group *gr;
		struct stat st;

#if defined _GNU_SOURCE
		int option_index = 0;
                /* *INDENT-OFF* */
                static struct option long_options[] = {
                        {"log-addresses",	no_argument,		NULL, 'a'},
                        {"append",		no_argument,		NULL, 'A'},
                        {"config-file",		required_argument,	NULL, 'c'},
                        {"no-configs",		no_argument,		NULL, 'C'},
                        {"dump",		no_argument,		NULL, 'd'},
                        {"debug",		optional_argument,	NULL, 'D'},
                        {"debug-tokens",	optional_argument,	NULL, 'D'},
                        {"dont-fork",		no_argument,		NULL, 'f'},
                        {"gid",			required_argument,	NULL, 'g'},
                        {"groupid",		required_argument,	NULL, 'g'},
                        {"help",		no_argument,		NULL, 'h'},
                        {"?",			no_argument,		NULL, 'h'},
                        {"help-directives",	no_argument,		NULL, 'H'},
                        {"initialize",		required_argument,	NULL, 'I'},
                        {"init-modules",	required_argument,	NULL, 'I'},
                        {"keep-open",		no_argument,		NULL, 'k'},
                        {"log-file",		optional_argument,	NULL, 'l'},
                        {"logfile",		optional_argument,	NULL, 'l'},
                        {"Lf",			optional_argument,	NULL, 'l'},
                        {"LF",			required_argument,	NULL, 'l'},
                        {"log-stderr",		no_argument,		NULL, 'L'},
                        {"Le",			no_argument,		NULL, 'L'},
                        {"LE",			required_argument,	NULL, 'L'},
                        {"mibs",		required_argument,	NULL, 'm'},
                        {"master",		no_argument,		NULL, 'M'},
                        {"mibdirs",		required_argument,	NULL, 'M'},
                        {"nodaemon",		no_argument,		NULL, 'n'},
                        {"name",		required_argument,	NULL, 'n'},
                        {"dry-run",		no_argument,		NULL, 'N'},
                        {"log-stdout",		no_argument,		NULL, 'o'},
                        {"Lo",			no_argument,		NULL, 'o'},
                        {"LO",			required_argument,	NULL, 'o'},
                        {"port",		required_argument,	NULL, 'p'},
                        {"pidfile",		required_argument,	NULL, 'P'},
                        {"quiet",		no_argument,		NULL, 'q'},
                        {"quick",		no_argument,		NULL, 'q'},
                        {"noroot",		no_argument,		NULL, 'r'},
                        {"log-syslog",		no_argument,		NULL, 's'},
                        {"Ls",			no_argument,		NULL, 's'},
                        {"LS",			required_argument,	NULL, 's'},
                        {"syslog",		no_argument,		NULL, 's'},
                        {"sysctl-file",		required_argument,	NULL, 'S'},
                        {"agent-alarms",	no_argument,		NULL, 't'},
                        {"transport",		optional_argument,	NULL, 'T'},
                        {"uid",			required_argument,	NULL, 'u'},
                        {"userid",		required_argument,	NULL, 'u'},
                        {"dont-remove-pidfile",	no_argument,		NULL, 'U'},
                        {"leave-pidfile",	no_argument,		NULL, 'U'},
                        {"version",		no_argument,		NULL, 'v'},
                        {"verbose",		optional_argument,	NULL, 'V'},
                        {"agentx-socket",	required_argument,	NULL, 'x'},
                        {"agentx",		no_argument,		NULL, 'X'},
                        {"copying",		no_argument,		NULL, 'y'},
#if 0
                        {"directory",		required_argument,	NULL, 'd'},
                        {"basename",		required_argument,	NULL, 'b'},
                        {"outfile",		required_argument,	NULL, 'o'},
                        {"errfile",		required_argument,	NULL, 'e'},
#endif
                        { 0, }
                };
                /* *INDENT-ON* */

		c = getopt_long_only(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy", long_options, &option_index);
#else				/* defined _GNU_SOURCE */
		c = getopt(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy");
#endif				/* defined _GNU_SOURCE */
		if (c == -1) {
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: done options processing\n", argv[0]);
			break;
		}
		switch (c) {
		case 0:
			goto bad_usage;
		case 'a':	/* -a, --log-addresses */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging addresses\n", argv[0]);
			sa_logaddr++;
			break;
		case 'A':	/* -A, --append */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will not truncate logfile\n", argv[0]);
#if defined NETSNMP_DS_LIB_APPEND_LOGFILES
			ds_set_boolean(DS_LIBRARY_ID, NETSNMP_DS_LIB_APPEND_LOGFILES, 1);
#endif				/* defined NETSNMP_DS_LIB_APPEND_LOGFILES */
			sa_appendlog = 1;
			break;
		case 'c':	/* -c, --config-file CONFIGFILE */
			if (optarg == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using configuration file %s\n", argv[0], optarg);
			ds_set_string(DS_LIBRARY_ID, DS_LIB_OPTIONALCONFIG, optarg);
			break;
		case 'C':	/* -C, --no-configs */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: not reading default config files\n", argv[0]);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DONT_READ_CONFIGS, 1);
			break;
		case 'd':	/* -d, --dump */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting packet dump\n", argv[0]);
			sa_dump = 1;
			// snmp_set_dump_packet(sa_dump);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DUMP_PACKET, sa_dump);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, sa_dump);
			break;
		case 'D':	/* -D, --debug [LEVEL], --debug-tokens [TOKENS] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing debug verbosity\n", argv[0]);
			if (optarg == NULL) {
				/* no option: must be -D, --debug */
				sa_debug++;
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging all tokens\n", argv[0]);
				if (sa_debug)
					debug_register_tokens("ALL");
			} else {
				cptr = optarg;
				if ((val = strtol(optarg, &cptr, 0)) < 0)
					goto bad_option;
				if (*cptr == '\0') {
					/* it is just a number, must be -D, --debug [LEVEL] */
					sa_debug = val;
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				} else {
					/* not a number, must be -D, --debug-tokens TOKENS */
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging tokens %s\n", argv[0], optarg);
					debug_register_tokens(optarg);
				}
			}
			break;
		case 'f':	/* -f, --dont-fork */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing daemon mode\n", argv[0]);
			sa_nomead = 0;
			break;
		case 'u':	/* -u, --uid, --userid UID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* UID can be name or number */
			if ((pw = (*cptr == '\0') ? getpwuid((uid_t) val) : getpwnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as uid %s(%d)\n", argv[0], pw->pw_name, pw->pw_uid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_USERID, pw->pw_uid);
			break;
		case 'g':	/* -g, --gid, --groupdid GID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* GID can be name or number */
			if ((gr = (*cptr == '\0') ? getgrgid((gid_t) val) : getgrnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as gid %s(%d)\n", argv[0], gr->gr_name, gr->gr_gid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_GROUPID, gr->gr_gid);
			break;
		case 'h':	/* -h, --help, -?, --? */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing help message\n", argv[0]);
			sa_help(argc, argv);
			exit(0);
		case 'H':	/* -H, --help-directives */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing config directives\n", argv[0]);
			sa_help_directives(argc, argv);
			exit(0);
		case 'I':	/* -I, --init-modules, --initialize MODULE[{,| |:}MODULE]* */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will initialize modules: %s\n", argv[0], optarg);
			add_to_init_list(optarg);
			break;
		case 'k':	/* -k, --keep-open */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: keeping files open\n", argv[0]);
			sa_fclose = 0;
			break;
		case 'l':	/* -l, --log-file, --logfile, -Lf, -LF p1[-p2] [LOGFILE] */
			if (optarg != NULL)
				strncpy(sa_logfile, optarg, sizeof(sa_logfile));
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will log to file %s\n", argv[0], sa_logfile);
			sa_logfillog = 1;
			break;
		case 'L':	/* -L, --log-stderr, -Le, -LE p1[-p2] */
			/* Note that the recent NET-SNMP version of this option is far more
			   complicated: -Le is the same as the old version of the option; -Lf
			   LOGFILE is like the -l option; -Ls is like the -s option; -Lo logs
			   messages to standard output; -LX p1[-p2] [LOGFILE], where X = E, F, S or
			   O, logs priority p1 and above to X, or p1 thru p2 to X. */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to standard error\n", argv[0]);
			sa_logstderr = 1;
			break;
		case 'm':	/* -m, --mibs MIBS */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBS %s\n", argv[0], optarg);
			break;
		case 'M':	/* -M, --master or -M, --mibdirs MIBDIRS */
			if (optarg) {
				/* -M, --mibdirs MIBDIRS */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBDIRS %s\n", argv[0], optarg);
			} else {
				/* -M, --master */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting SNMP master\n", argv[0]);
				sa_agentx = 0;
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
			}
			break;
		case 'n':	/* -n, --nodaemon or -n, --name NAME */
			if (optarg) {
				/* -n, --name NAME */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using name %s\n", argv[0], optarg);
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, optarg);
			} else {
				/* -n, --nodaemon */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing deamon mode\n", argv[0]);
				sa_nomead = 0;
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, basename(argv[0]));
			}
			break;
		case 'N':	/* -N, --dry-run */
#if defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for dry-runs startup\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_QUIT_IMMEDIATELY, 1);
			break;
#else				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -N option not supported\n", argv[0]);
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
		case 'o':	/* -o, --log-stdout, -Lo, -LO p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to stdout\n", argv[0]);
			sa_logstdout = 1;
			break;
		case 'p':	/* -p, --port PORTNUM or -p, --pidfile PIDFILE */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0 || val > 16383)
				goto bad_option;
			if (*cptr == '\0') {
				char buf[4096];

				/* -p, --port PORTNUM */
				if ((cptr = ds_get_string(DS_APPLICATION_ID, DS_AGENT_PORTS)))
					snprintf(buf, sizeof(buf), "%s,%s", cptr, optarg);
				else
					strncpy(buf, optarg, sizeof(buf));
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PORTS, buf);
				break;
			}
			/* fall through */
		case 'P':	/* -p, -P, --pidfile PIDFILE */
			if (optarg) {
				/* either it exists */
				if (stat(optarg, &st) == -1) {
					/* or we can create it */
					if ((fd = open(optarg, O_CREAT, 0600)) == -1) {
						perror(argv[0]);
						goto bad_option;
					}
					close(fd);
				}
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting pid file to %s\n", argv[0], optarg);
				strncpy(sa_pidfile, optarg, sizeof(sa_pidfile));
			}
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using pidfile %s\n", argv[0], sa_pidfile);
			break;
		case 'q':	/* -q, --quiet, --quick */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing normal output\n", argv[0]);
			sa_debug = 0;
			sa_output = 0;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			// snmp_set_quick_print();
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_QUICK_PRINT, 1);
			break;
		case 'r':	/* -r, --noroot */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for non-root access\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
			break;
		case 's':	/* -s, --log-syslog, -Ls, -LS p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to system logs\n", argv[0]);
			sa_logsyslog = 1;
			break;
		case 'S':	/* -S, -sysctl-file FILENAME */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using %s for backing\n", argv[0], optarg);
			strncpy(sa_sysctlf, optarg, sizeof(sa_sysctlf));
			break;
		case 't':	/* -t, --agent-alarms */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting agent alarms\n", argv[0]);
			sa_alarms = 0;
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
			break;
		case 'T':	/* -T, --transport [TRANSPORT] */
			if (optarg == NULL)
				goto udp_transport;
			if (!strcasecmp("TCP", optarg)) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to TCP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val |= SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else if (!strcasecmp("UDP", optarg)) {
			      udp_transport:
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to UDP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val &= ~SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else
				goto bad_option;
			break;
		case 'U':
#if defined NETSNMP_DS_AGENT_LEAVE_PIDFILE
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will leave pidfile after shutdown\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_LEAVE_PIDFILE, 1);
#else
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -U option not supported\n");
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_LEAVE_PIDFILE */
			break;
		case 'v':	/* -v, --version */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing version message\n", argv[0]);
			sa_version(argc, argv);
			exit(0);
		case 'V':	/* -V, --verbose [LEVEL] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing output verbosity\n", argv[0]);
			if (optarg == NULL) {
				sa_output++;
			} else {
				if ((val = strtol(optarg, NULL, 0)) < 0)
					goto bad_option;
				sa_output = val;
			}
			if (sa_output > 1)
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 1);
			else
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			break;
		case 'x':	/* -x, --agentx-socket SOCKET */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX socket to %s\n", argv[0], optarg);
			ds_set_string(DS_APPLICATION_ID, DS_AGENT_X_SOCKET, optarg);
			// ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_AGENTX_MASTER, 1);
			break;
		case 'X':	/* -X, --agentx */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX sub-agent\n", argv[0]);
			sa_agentx = 1;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
			break;
		case 'y':	/* -y, --copying */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing copying message\n", argv[0]);
			sa_copying(argc, argv);
			exit(0);
		case '?':
		case ':':
		default:
		      bad_option:
			optind--;
			goto bad_nonopt;
		      bad_nonopt:
			if (sa_output || sa_debug) {
				if (optind < argc) {
					fprintf(stderr, "%s: syntax error near '", argv[0]);
					while (optind < argc)
						fprintf(stderr, "%s ", argv[optind++]);
					fprintf(stderr, "'\n");
				} else {
					fprintf(stderr, "%s: missing option or argument", argv[0]);
					fprintf(stderr, "\n");
				}
				fflush(stderr);
			      bad_usage:
				sa_usage(argc, argv);
			}
			exit(2);
		}
	}
	if (optind < argc) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: excess non-option arguments\n", argv[0]);
		goto bad_nonopt;
	}
	sa_enter(argc, argv);	/* daemonize if necessary */
	sa_mloop(argc, argv);	/* execute main loop */
	exit(0);
}
#endif				/* !defined MODULE */
