/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "llcMIB_simple.h"

/* 
 * llcMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid llcMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 23 };

/* 
 * variable7 llcMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the llcMIB_simple mib section 
 */

struct variable7 llcMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   MACDLELOCALSAPNAMES   4
	{MACDLELOCALSAPNAMES, ASN_OBJECT_ID, RWRITE, var_mACDLETable, 6, {1, 1, 1, 1, 1, 2}},
#define   MACDLEOPERATIONALSTATE  5
	{MACDLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mACDLETable, 6, {1, 1, 1, 1, 1, 3}},
#define   MACDLEPROVIDERENTITYNAMES  6
	{MACDLEPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_mACDLETable, 6, {1, 1, 1, 1, 1, 4}},
#define   MACDLEROWSTATUS       7
	{MACDLEROWSTATUS, ASN_INTEGER, RWRITE, var_mACDLETable, 6, {1, 1, 1, 1, 1, 5}},
#define   MACOPERATIONALSTATE   11
	{MACOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mACTable, 6, {1, 1, 2, 1, 1, 1}},
#define   MACROWSTATUS          13
	{MACROWSTATUS, ASN_INTEGER, RWRITE, var_mACTable, 6, {1, 1, 2, 1, 1, 3}},
#define   RESOURCETYPEIDNAME    17
	{RESOURCETYPEIDNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 1}},
#define   RESOURCEINFOMANUFACTUREROUI  18
	{RESOURCEINFOMANUFACTUREROUI, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 2}},
#define   RESOURCEINFOMANUFACTURERNAME  19
	{RESOURCEINFOMANUFACTURERNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 3}},
#define   RESOURCEINFOMANUFACTURERPRODUCTNAME  20
	{RESOURCEINFOMANUFACTURERPRODUCTNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 4}},
#define   RESOURCEINFOMANUFACTURERPRODUCTVERSION  21
	{RESOURCEINFOMANUFACTURERPRODUCTVERSION, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 5}},
#define   DLSAPSAP1ADDRESS      26
	{DLSAPSAP1ADDRESS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 4, 1, 1, 2}},
#define   DLSAPUSERENTITYNAMES  27
	{DLSAPUSERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_dLSAPTable, 6, {1, 1, 4, 1, 1, 3}},
#define   DLSAPROWSTATUS        28
	{DLSAPROWSTATUS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 4, 1, 1, 4}},
#define   LLCDLELOCALSAPNAMES   32
	{LLCDLELOCALSAPNAMES, ASN_OBJECT_ID, RWRITE, var_lLCDLETable, 6, {1, 1, 5, 1, 1, 2}},
#define   LLCDLEOPERATIONALSTATE  33
	{LLCDLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCDLETable, 6, {1, 1, 5, 1, 1, 3}},
#define   LLCDLEPROVIDERENTITYNAMES  34
	{LLCDLEPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_lLCDLETable, 6, {1, 1, 5, 1, 1, 4}},
#define   LLCDLEROWSTATUS       35
	{LLCDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lLCDLETable, 6, {1, 1, 5, 1, 1, 5}},
#define   LLCSTATIONLLCNAME     40
	{LLCSTATIONLLCNAME, ASN_OCTET_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 1}},
#define   LLCSTATIONMAXIMUMLSAPSCONFIGURED  41
	{LLCSTATIONMAXIMUMLSAPSCONFIGURED, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 2}},
#define   LLCSTATIONNUMBEROFACTIVELSAPS  42
	{LLCSTATIONNUMBEROFACTIVELSAPS, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 3}},
#define   LLCSTATIONSUPPORTEDSERVICESTYPES  43
	{LLCSTATIONSUPPORTEDSERVICESTYPES, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 4}},
#define   LLCSTATIONSTATUS      44
	{LLCSTATIONSTATUS, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 5}},
#define   LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE  45
	{LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 6}},
#define   LLCSTATIONTYPE1MAXIMUMRETRYCOUNT  46
	{LLCSTATIONTYPE1MAXIMUMRETRYCOUNT, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 7}},
#define   LLCSTATIONMAXIMUMPDUN3  47
	{LLCSTATIONMAXIMUMPDUN3, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 8}},
#define   LLCSTATIONMAXIMUMRETRANSMISSIONS4  48
	{LLCSTATIONMAXIMUMRETRANSMISSIONS4, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 9}},
#define   LLCSTATIONRECEIVEVARIABLELIFETIME  49
	{LLCSTATIONRECEIVEVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 10}},
#define   LLCSTATIONTRANSMITVARIABLELIFETIME  50
	{LLCSTATIONTRANSMITVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 11}},
#define   LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE  51
	{LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 12}},
#define   LLCSTATIONTYPE3RETRANSMISSIONS  52
	{LLCSTATIONTYPE3RETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 13}},
#define   LLCSTATIONAVGBUFFERUSESIZE  53
	{LLCSTATIONAVGBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 14}},
#define   LLCSTATIONBUFFERPROBLEMS  54
	{LLCSTATIONBUFFERPROBLEMS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 15}},
#define   LLCSTATIONBUFFERSIZE  55
	{LLCSTATIONBUFFERSIZE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 16}},
#define   LLCSTATIONMAXBUFFERUSESIZE  56
	{LLCSTATIONMAXBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 17}},
#define   LLCSTATIONINACTIVELSAP  57
	{LLCSTATIONINACTIVELSAP, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 18}},
#define   LLCSTATIONPDUSDISCARD  58
	{LLCSTATIONPDUSDISCARD, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 19}},
#define   LLCSTATIONSTRINDICATOR  59
	{LLCSTATIONSTRINDICATOR, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 20}},
#define   LLCSTATIONVERSIONNUMBER  60
	{LLCSTATIONVERSIONNUMBER, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 21}},
#define   LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS  61
	{LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 22}},
#define   LLCSAPADDRESS         67
	{LLCSAPADDRESS, ASN_OCTET_STR, RONLY, var_lLCSAPTable, 6, {1, 1, 7, 1, 1, 2}},
#define   LLCSAPRDE             68
	{LLCSAPRDE, ASN_INTEGER, RONLY, var_lLCSAPTable, 6, {1, 1, 7, 1, 1, 3}},
#define   RDESETUPAGINGENABLED  73
	{RDESETUPAGINGENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 1}},
#define   RDESETUPAGINGVALUE    74
	{RDESETUPAGINGVALUE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 2}},
#define   RDESETUPENABLETYPE2RESET  75
	{RDESETUPENABLETYPE2RESET, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 3}},
#define   RDESETUPMAXIMUMROUTEDESCRIPTORS  76
	{RDESETUPMAXIMUMROUTEDESCRIPTORS, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 4}},
#define   RDESETUPMAXIMUMRESPONSETIME  77
	{RDESETUPMAXIMUMRESPONSETIME, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 5}},
#define   RDESETUPMINIMUMPDUSIZE  78
	{RDESETUPMINIMUMPDUSIZE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 6}},
#define   RDESETUPRDEHOLD       79
	{RDESETUPRDEHOLD, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 7}},
#define   RDESETUPRDEREPLACE    80
	{RDESETUPRDEREPLACE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 8}},
#define   RDESETUPNAME          81
	{RDESETUPNAME, ASN_INTEGER, RONLY, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 9}},
#define   RDESETUPRESETONTESTENABLED  82
	{RDESETUPRESETONTESTENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 10}},
#define   RDEPAIRDISCARDCOUNTER  88
	{RDEPAIRDISCARDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 2}},
#define   RDEPAIRNSRPDUCOUNTER  89
	{RDEPAIRNSRPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 3}},
#define   RDEPAIRNSRSELECTEDCOUNTER  90
	{RDEPAIRNSRSELECTEDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 4}},
#define   RDEPAIRRIF            91
	{RDEPAIRRIF, ASN_OCTET_STR, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 5}},
#define   RDEPAIRSRFPDUCOUNTER  92
	{RDEPAIRSRFPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 6}},
#define   RDEPAIRQUERYCOUNTER   93
	{RDEPAIRQUERYCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 7}},
#define   LLCCLPMOPERATIONALSTATE  97
	{LLCCLPMOPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCCLPMTable, 6, {1, 1, 10, 1, 1, 2}},
#define   LLCCLPMTOTALREMOTESAPS  98
	{LLCCLPMTOTALREMOTESAPS, ASN_COUNTER, RONLY, var_lLCCLPMTable, 6, {1, 1, 10, 1, 1, 3}},
#define   LLCCLPMROWSTATUS      99
	{LLCCLPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCLPMTable, 6, {1, 1, 10, 1, 1, 4}},
#define   LLCCONNECTIONLESSNAME  102
	{LLCCONNECTIONLESSNAME, ASN_OCTET_STR, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 1}},
#define   LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE  103
	{LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 2}},
#define   LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE  104
	{LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 3}},
#define   LLCCONNECTIONLESSTESTRECEIVEDCOMMAND  105
	{LLCCONNECTIONLESSTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 4}},
#define   LLCCONNECTIONLESSTESTRECEIVEDRESPONSE  106
	{LLCCONNECTIONLESSTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 5}},
#define   LLCCONNECTIONLESSTESTSENTABBRESPONSE  107
	{LLCCONNECTIONLESSTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 6}},
#define   LLCCONNECTIONLESSTESTSENTCOMMAND  108
	{LLCCONNECTIONLESSTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 7}},
#define   LLCCONNECTIONLESSTESTSENTRESPONSE  109
	{LLCCONNECTIONLESSTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 8}},
#define   LLCCONNECTIONLESSUIRECEIVED  110
	{LLCCONNECTIONLESSUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 9}},
#define   LLCCONNECTIONLESSUISENT  111
	{LLCCONNECTIONLESSUISENT, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 10}},
#define   LLCCONNECTIONLESSXIDRECEIVEDCOMMAND  112
	{LLCCONNECTIONLESSXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 11}},
#define   LLCCONNECTIONLESSXIDRECEIVEDRESPONSE  113
	{LLCCONNECTIONLESSXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 12}},
#define   LLCCONNECTIONLESSXIDSENTCOMMAND  114
	{LLCCONNECTIONLESSXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 13}},
#define   LLCCONNECTIONLESSXIDSENTRESPONSE  115
	{LLCCONNECTIONLESSXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 14}},
#define   LLCCOPMOPERATIONALSTATE  119
	{LLCCOPMOPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCCOPMTable, 6, {1, 1, 12, 1, 1, 2}},
#define   LLCCOPMROWSTATUS      120
	{LLCCOPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCOPMTable, 6, {1, 1, 12, 1, 1, 3}},
#define   LLCCONNECTION2NAME    123
	{LLCCONNECTION2NAME, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 1}},
#define   LLCCONNECTION2MAXIMUMRETRANSMISSIONS  124
	{LLCCONNECTION2MAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 2}},
#define   LLCCONNECTION2RECEIVEDWINDOWSIZE  125
	{LLCCONNECTION2RECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 3}},
#define   LLCCONNECTION2SENDWINDOWSIZE  126
	{LLCCONNECTION2SENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 4}},
#define   LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE  127
	{LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 5}},
#define   LLCCONNECTION2BUSYSTATETIMEOUTVALUE  128
	{LLCCONNECTION2BUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 6}},
#define   LLCCONNECTION2PBITTIMEOUTVALUE  129
	{LLCCONNECTION2PBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 7}},
#define   LLCCONNECTION2REJECTTIMEOUTVALUE  130
	{LLCCONNECTION2REJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 8}},
#define   LLCCONNECTION2LOCALBUSY  131
	{LLCCONNECTION2LOCALBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 9}},
#define   LLCCONNECTION2REMOTEBUSY  132
	{LLCCONNECTION2REMOTEBUSY, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 10}},
#define   LLCCONNECTION2REMOTERESET  133
	{LLCCONNECTION2REMOTERESET, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 11}},
#define   LLCCONNECTION2LOCALRESET  134
	{LLCCONNECTION2LOCALRESET, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 12}},
#define   LLCCONNECTION2PROVIDERRESET  135
	{LLCCONNECTION2PROVIDERRESET, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 13}},
#define   LLCCONNECTION2ROUTE   136
	{LLCCONNECTION2ROUTE, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 14}},
#define   LLCCONNECTION2KSTEP   137
	{LLCCONNECTION2KSTEP, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 15}},
#define   LLCCONNECTION2MAXSENDWINDOWSIZE  138
	{LLCCONNECTION2MAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 16}},
#define   LLCCONNECTION2RECEIVEDI  139
	{LLCCONNECTION2RECEIVEDI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 17}},
#define   LLCCONNECTION2SENTI   140
	{LLCCONNECTION2SENTI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 18}},
#define   LLCCONNECTION2SENTACKS  141
	{LLCCONNECTION2SENTACKS, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 19}},
#define   LLCCONNECTION2RECEIVEDACKS  142
	{LLCCONNECTION2RECEIVEDACKS, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 20}},
#define   LLCCONNECTION2RECEIVEDFRMR  143
	{LLCCONNECTION2RECEIVEDFRMR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 21}},
#define   LLCCONNECTION2SENTFRMR  144
	{LLCCONNECTION2SENTFRMR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 22}},
#define   LLCCONNECTION2RECEIVEDRR  145
	{LLCCONNECTION2RECEIVEDRR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 23}},
#define   LLCCONNECTION2SENTRR  146
	{LLCCONNECTION2SENTRR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 24}},
#define   LLCCONNECTION2RECEIVEDRNR  147
	{LLCCONNECTION2RECEIVEDRNR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 25}},
#define   LLCCONNECTION2SENTRNR  148
	{LLCCONNECTION2SENTRNR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 26}},
#define   LLCCONNECTION2RECEIVEDREJ  149
	{LLCCONNECTION2RECEIVEDREJ, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 27}},
#define   LLCCONNECTION2SENTREJ  150
	{LLCCONNECTION2SENTREJ, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 28}},
#define   LLCCONNECTION2RECEIVEDSABME  151
	{LLCCONNECTION2RECEIVEDSABME, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 29}},
#define   LLCCONNECTION2SENTSABME  152
	{LLCCONNECTION2SENTSABME, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 30}},
#define   LLCCONNECTION2RECEIVEDUA  153
	{LLCCONNECTION2RECEIVEDUA, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 31}},
#define   LLCCONNECTION2SENTUA  154
	{LLCCONNECTION2SENTUA, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 32}},
#define   LLCCONNECTION2RECEIVEDDISC  155
	{LLCCONNECTION2RECEIVEDDISC, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 33}},
#define   LLCCONNECTION2SENTDISC  156
	{LLCCONNECTION2SENTDISC, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 34}},
#define   LLCCONNECTION2RECEIVEDDM  157
	{LLCCONNECTION2RECEIVEDDM, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 35}},
#define   LLCCONNECTION2SENTDM  158
	{LLCCONNECTION2SENTDM, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 36}},
#define   LLCCONNECTION2PDUSDISCARDED1  159
	{LLCCONNECTION2PDUSDISCARDED1, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 37}},
#define   LLCCONNECTION2PDUSDISCARDED2  160
	{LLCCONNECTION2PDUSDISCARDED2, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 38}},
#define   LLCCONNECTION2PDURETRANSMISSIONS  161
	{LLCCONNECTION2PDURETRANSMISSIONS, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 39}},
#define   LLCCONNECTION2OPTIONALTOLERATIONIPDUS  162
	{LLCCONNECTION2OPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 40}},
#define   LLCCONNECTION2DUPLICATEIPDUSRECEIVED  163
	{LLCCONNECTION2DUPLICATEIPDUSRECEIVED, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 41}},
#define   LLCCONNECTION2VIOLATION  164
	{LLCCONNECTION2VIOLATION, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 42}},
#define   LLCCONNECTION2PROTOCOLSTATE  165
	{LLCCONNECTION2PROTOCOLSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 43}},
#define   LLCCONNECTION2ADMINISTRATIVESTATE  166
	{LLCCONNECTION2ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 44}},
#define   LLCCONNECTION2OPERATIONALSTATE  167
	{LLCCONNECTION2OPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 45}},
#define   LLCCONNECTION2USAGESTATE  168
	{LLCCONNECTION2USAGESTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 46}},
#define   LLCCONNECTION2PROCEDURALSTATUS  169
	{LLCCONNECTION2PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 47}},
#define   LLCCONNECTION2ALARMSTATUS  170
	{LLCCONNECTION2ALARMSTATUS, ASN_BIT_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 48}},
#define   LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS  174
	{LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 2}},
#define   LLCCONNECTION2IVMORECEIVEDWINDOWSIZE  175
	{LLCCONNECTION2IVMORECEIVEDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 3}},
#define   LLCCONNECTION2IVMOSENDWINDOWSIZE  176
	{LLCCONNECTION2IVMOSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 4}},
#define   LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE  177
	{LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 5}},
#define   LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE  178
	{LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 6}},
#define   LLCCONNECTION2IVMOBITTIMEOUTVALUE  179
	{LLCCONNECTION2IVMOBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 7}},
#define   LLCCONNECTION2IVMOREJECTTIMEOUTVALUE  180
	{LLCCONNECTION2IVMOREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 8}},
#define   LLCCONNECTION2IVMOROUTE  181
	{LLCCONNECTION2IVMOROUTE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 9}},
#define   LLCCONNECTION2IVMOKSTEP  182
	{LLCCONNECTION2IVMOKSTEP, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 10}},
#define   LLCCONNECTION2IVMOMAXSENDWINDOWSIZE  183
	{LLCCONNECTION2IVMOMAXSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 11}},
#define   LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS  184
	{LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKNAME  187
	{LLCCONNECTIONLESSACKNAME, ASN_OCTET_STR, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 1}},
#define   LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE  188
	{LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS  189
	{LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE  190
	{LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 4}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND  191
	{LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 5}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE  192
	{LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 6}},
#define   LLCCONNECTIONLESSACKTESTSENTABBRESPONSE  193
	{LLCCONNECTIONLESSACKTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 7}},
#define   LLCCONNECTIONLESSACKTESTSENTCOMMAND  194
	{LLCCONNECTIONLESSACKTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 8}},
#define   LLCCONNECTIONLESSACKTESTSENTRESPONSE  195
	{LLCCONNECTIONLESSACKTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 9}},
#define   LLCCONNECTIONLESSACKRECEIVERESOURCES  196
	{LLCCONNECTIONLESSACKRECEIVERESOURCES, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 10}},
#define   LLCCONNECTIONLESSACKUIRECEIVED  197
	{LLCCONNECTIONLESSACKUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 11}},
#define   LLCCONNECTIONLESSACKUISENT  198
	{LLCCONNECTIONLESSACKUISENT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND  199
	{LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 13}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE  200
	{LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 14}},
#define   LLCCONNECTIONLESSACKXIDSENTCOMMAND  201
	{LLCCONNECTIONLESSACKXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 15}},
#define   LLCCONNECTIONLESSACKXIDSENTRESPONSE  202
	{LLCCONNECTIONLESSACKXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 16}},
#define   LLCCONNECTIONLESSACKRETRANSMISSIONS  203
	{LLCCONNECTIONLESSACKRETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 17}},
#define   LLCCONNECTIONLESSACKNORESPONSE  204
	{LLCCONNECTIONLESSACKNORESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 18}},
#define   LLCCONNECTIONLESSACKCOMMANDIP  205
	{LLCCONNECTIONLESSACKCOMMANDIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 19}},
#define   LLCCONNECTIONLESSACKCOMMANDIT  206
	{LLCCONNECTIONLESSACKCOMMANDIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 20}},
#define   LLCCONNECTIONLESSACKCOMMANDOK  207
	{LLCCONNECTIONLESSACKCOMMANDOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 21}},
#define   LLCCONNECTIONLESSACKCOMMANDPE  208
	{LLCCONNECTIONLESSACKCOMMANDPE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 22}},
#define   LLCCONNECTIONLESSACKCOMMANDRS  209
	{LLCCONNECTIONLESSACKCOMMANDRS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 23}},
#define   LLCCONNECTIONLESSACKCOMMANDUE  210
	{LLCCONNECTIONLESSACKCOMMANDUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 24}},
#define   LLCCONNECTIONLESSACKCOMMANDUN  211
	{LLCCONNECTIONLESSACKCOMMANDUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 25}},
#define   LLCCONNECTIONLESSACKRECEIVEDACCOMMAND  212
	{LLCCONNECTIONLESSACKRECEIVEDACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 26}},
#define   LLCCONNECTIONLESSACKSENTACCOMMAND  213
	{LLCCONNECTIONLESSACKSENTACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 27}},
#define   LLCCONNECTIONLESSACKRESPONSEIP  214
	{LLCCONNECTIONLESSACKRESPONSEIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 28}},
#define   LLCCONNECTIONLESSACKRESPONSEIT  215
	{LLCCONNECTIONLESSACKRESPONSEIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 29}},
#define   LLCCONNECTIONLESSACKRESPONSENE  216
	{LLCCONNECTIONLESSACKRESPONSENE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 30}},
#define   LLCCONNECTIONLESSACKRESPONSENR  217
	{LLCCONNECTIONLESSACKRESPONSENR, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 31}},
#define   LLCCONNECTIONLESSACKRESPONSEOK  218
	{LLCCONNECTIONLESSACKRESPONSEOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 32}},
#define   LLCCONNECTIONLESSACKRESPONSERS  219
	{LLCCONNECTIONLESSACKRESPONSERS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 33}},
#define   LLCCONNECTIONLESSACKRESPONSEUE  220
	{LLCCONNECTIONLESSACKRESPONSEUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 34}},
#define   LLCCONNECTIONLESSACKRESPONSEUN  221
	{LLCCONNECTIONLESSACKRESPONSEUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 35}},
#define   LLCCONNECTIONLESSACKVIOLATION  222
	{LLCCONNECTIONLESSACKVIOLATION, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 36}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE  226
	{LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS  227
	{LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 16, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKIVMOROWSTATUS  228
	{LLCCONNECTIONLESSACKIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 16, 1, 1, 4}},
#define   LLCDISCONTINUITYTIME  229
	{LLCDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_llcMIB, 4, {1, 2, 1, 1}},
#define   LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS  230
	{LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 1}},
#define   LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE  231
	{LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 2}},
#define   LLCCONNECTION2DEFAULTSENDWINDOWSIZE  232
	{LLCCONNECTION2DEFAULTSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 3}},
#define   LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE  233
	{LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 4}},
#define   LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE  234
	{LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 5}},
#define   LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE  235
	{LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 6}},
#define   LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE  236
	{LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 7}},
#define   LLCCONNECTION2DEFAULTROUTE  237
	{LLCCONNECTION2DEFAULTROUTE, ASN_OCTET_STR, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 8}},
#define   LLCCONNECTION2DEFAULTKSTEP  238
	{LLCCONNECTION2DEFAULTKSTEP, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 9}},
#define   LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE  239
	{LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 10}},
#define   LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS  240
	{LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 11}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE  241
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 2, 1}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS  242
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 2, 2}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_llcMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_llcMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("llcMIB_simple", llcMIB_simple_variables, variable7, llcMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_llcMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_llcMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_mACDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_mACDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case MACDLELOCALSAPNAMES:
		*write_method = write_mACDLELocalSapNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case MACDLEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case MACDLEPROVIDERENTITYNAMES:
		*write_method = write_mACDLEProviderEntityNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case MACDLEROWSTATUS:
		*write_method = write_mACDLERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_mACTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_mACTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case MACOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case MACROWSTATUS:
		*write_method = write_mACRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_resourceTypeIdTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_resourceTypeIdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case RESOURCETYPEIDNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTUREROUI:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTURERNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTURERPRODUCTNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTURERPRODUCTVERSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_dLSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_dLSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DLSAPSAP1ADDRESS:
		*write_method = write_dLSAPSap1Address;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DLSAPUSERENTITYNAMES:
		*write_method = write_dLSAPUserEntityNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case DLSAPROWSTATUS:
		*write_method = write_dLSAPRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCDLELOCALSAPNAMES:
		*write_method = write_lLCDLELocalSapNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case LLCDLEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCDLEPROVIDERENTITYNAMES:
		*write_method = write_lLCDLEProviderEntityNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case LLCDLEROWSTATUS:
		*write_method = write_lLCDLERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCStationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCStationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCSTATIONLLCNAME:
		*write_method = write_lLCStationLLCName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSTATIONMAXIMUMLSAPSCONFIGURED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONNUMBEROFACTIVELSAPS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONSUPPORTEDSERVICESTYPES:
		*write_method = write_lLCStationSupportedServicesTypes;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSTATIONSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType1AcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE1MAXIMUMRETRYCOUNT:
		*write_method = write_lLCStationType1MaximumRetryCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONMAXIMUMPDUN3:
		*write_method = write_lLCStationMaximumPDUN3;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONMAXIMUMRETRANSMISSIONS4:
		*write_method = write_lLCStationMaximumRetransmissions4;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONRECEIVEVARIABLELIFETIME:
		*write_method = write_lLCStationReceiveVariableLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTRANSMITVARIABLELIFETIME:
		*write_method = write_lLCStationTransmitVariableLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType3AcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE3RETRANSMISSIONS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONAVGBUFFERUSESIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONBUFFERPROBLEMS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONBUFFERSIZE:
		*write_method = write_lLCStationBufferSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONMAXBUFFERUSESIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONINACTIVELSAP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONPDUSDISCARD:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONSTRINDICATOR:
		*write_method = write_lLCStationSTRIndicator;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSTATIONVERSIONNUMBER:
		*write_method = write_lLCStationVersionNumber;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCSAPADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSAPRDE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_rDESetupTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_rDESetupTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case RDESETUPAGINGENABLED:
		*write_method = write_rDESetupAgingEnabled;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPAGINGVALUE:
		*write_method = write_rDESetupAgingValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPENABLETYPE2RESET:
		*write_method = write_rDESetupEnableType2Reset;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPMAXIMUMROUTEDESCRIPTORS:
		*write_method = write_rDESetupMaximumRouteDescriptors;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPMAXIMUMRESPONSETIME:
		*write_method = write_rDESetupMaximumResponseTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPMINIMUMPDUSIZE:
		*write_method = write_rDESetupMinimumPDUSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPRDEHOLD:
		*write_method = write_rDESetupRDEHold;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPRDEREPLACE:
		*write_method = write_rDESetupRDEReplace;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPNAME:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPRESETONTESTENABLED:
		*write_method = write_rDESetupResetOnTestEnabled;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_rDEPairTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_rDEPairTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case RDEPAIRDISCARDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRNSRPDUCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRNSRSELECTEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRRIF:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RDEPAIRSRFPDUCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRQUERYCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCCLPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCCLPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCLPMOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCLPMTOTALREMOTESAPS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCLPMROWSTATUS:
		*write_method = write_lLCCLPMRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnectionLessTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCConnectionLessTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTIONLESSNAME:
		*write_method = write_lLCConnectionlessName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessMaximumLLCInformationFieldSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTSENTABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSUIRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSUISENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCCOPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCCOPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCOPMOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCOPMROWSTATUS:
		*write_method = write_lLCCOPMRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnection2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCConnection2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTION2NAME:
		*write_method = write_lLCConnection2Name;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTION2MAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2MaximumRetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2ReceivedWindowSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENDWINDOWSIZE:
		*write_method = write_lLCConnection2SendWindowSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2AcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2BUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2BusyStateTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2PBitTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2REJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2RejectTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2LOCALBUSY:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2REMOTEBUSY:
		*write_method = write_lLCConnection2RemoteBusy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2REMOTERESET:
		*write_method = write_lLCConnection2RemoteReset;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2LOCALRESET:
		*write_method = write_lLCConnection2LocalReset;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PROVIDERRESET:
		*write_method = write_lLCConnection2ProviderReset;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2ROUTE:
		*write_method = write_lLCConnection2Route;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTION2KSTEP:
		*write_method = write_lLCConnection2KStep;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2MAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2MaxSendWindowSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDI:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTI:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTACKS:
		*write_method = write_lLCConnection2SentAcks;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDACKS:
		*write_method = write_lLCConnection2ReceivedAcks;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDFRMR:
		*write_method = write_lLCConnection2ReceivedFRMR;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTFRMR:
		*write_method = write_lLCConnection2SentFRMR;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDRR:
		*write_method = write_lLCConnection2ReceivedRR;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTRR:
		*write_method = write_lLCConnection2SentRR;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDRNR:
		*write_method = write_lLCConnection2ReceivedRNR;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTRNR:
		*write_method = write_lLCConnection2SentRNR;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDREJ:
		*write_method = write_lLCConnection2ReceivedREJ;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTREJ:
		*write_method = write_lLCConnection2SentREJ;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDSABME:
		*write_method = write_lLCConnection2ReceivedSABME;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTSABME:
		*write_method = write_lLCConnection2SentSABME;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDUA:
		*write_method = write_lLCConnection2ReceivedUA;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTUA:
		*write_method = write_lLCConnection2SentUA;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDDISC:
		*write_method = write_lLCConnection2ReceivedDISC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTDISC:
		*write_method = write_lLCConnection2SentDISC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDDM:
		*write_method = write_lLCConnection2ReceivedDM;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTDM:
		*write_method = write_lLCConnection2SentDM;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PDUSDISCARDED1:
		*write_method = write_lLCConnection2PDUsDiscarded1;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PDUSDISCARDED2:
		*write_method = write_lLCConnection2PDUsDiscarded2;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PDURETRANSMISSIONS:
		*write_method = write_lLCConnection2PDURetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2OPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2OptionalTolerationIPDUs;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2DUPLICATEIPDUSRECEIVED:
		*write_method = write_lLCConnection2DuplicateIPDUsReceived;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2VIOLATION:
		*write_method = write_lLCConnection2Violation;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PROTOCOLSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2ADMINISTRATIVESTATE:
		*write_method = write_lLCConnection2AdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2OPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2USAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTION2ALARMSTATUS:
		*write_method = write_lLCConnection2AlarmStatus;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnection2IVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCConnection2IVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2IVMOMaximumRetransmissions;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMORECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOReceivedWindowSize;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOSendWindowSize;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOAcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBusyStateTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBitTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOREJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMORejectTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOROUTE:
		*write_method = write_lLCConnection2IVMORoute;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOKSTEP:
		*write_method = write_lLCConnection2IVMOKStep;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOMAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOMaxSendWindowSize;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2IVMOOptionalTolerationIPDUs;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnectionlessAckTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCConnectionlessAckTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTIONLESSACKNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckMaximumLLCInformationFieldSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckMaximumRetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTSENTABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRECEIVERESOURCES:
		*write_method = write_lLCConnectionlessAckReceiveResources;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKUIRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKUISENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRETRANSMISSIONS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKNORESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDIP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDIT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDOK:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDPE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDRS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDUE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDUN:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRECEIVEDACCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKSENTACCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEIP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEIT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSENE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSENR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEOK:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSERS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEUE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEUN:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKVIOLATION:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnectionlessAckIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_llcMIB_simple above.
 */
unsigned char *
var_lLCConnectionlessAckIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckIVMOMaximumRetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKIVMOROWSTATUS:
		*write_method = write_lLCConnectionlessAckIVMORowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_mACDLELocalSapNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to mACDLELocalSapNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to mACDLELocalSapNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACDLEProviderEntityNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to mACDLEProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to mACDLEProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACDLERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to mACDLERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to mACDLERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to mACRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to mACRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPSap1Address(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dLSAPSap1Address not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dLSAPSap1Address: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPUserEntityNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to dLSAPUserEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to dLSAPUserEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dLSAPRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dLSAPRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCDLELocalSapNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to lLCDLELocalSapNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to lLCDLELocalSapNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCDLEProviderEntityNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to lLCDLEProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to lLCDLEProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCDLERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCDLERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCDLERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationLLCName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCStationLLCName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCStationLLCName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSupportedServicesTypes(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to lLCStationSupportedServicesTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCStationSupportedServicesTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1AcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationType1AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationType1AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1MaximumRetryCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationType1MaximumRetryCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationType1MaximumRetryCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumPDUN3(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationMaximumPDUN3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationMaximumPDUN3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumRetransmissions4(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationMaximumRetransmissions4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationMaximumRetransmissions4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationReceiveVariableLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationReceiveVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationReceiveVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationTransmitVariableLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationTransmitVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationTransmitVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType3AcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationType3AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationType3AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationBufferSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationBufferSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationBufferSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSTRIndicator(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to lLCStationSTRIndicator not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCStationSTRIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationVersionNumber(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationVersionNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationVersionNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingEnabled(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupAgingEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupAgingEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupAgingValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupAgingValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupEnableType2Reset(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupEnableType2Reset not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupEnableType2Reset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumRouteDescriptors(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupMaximumRouteDescriptors not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupMaximumRouteDescriptors: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumResponseTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupMaximumResponseTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupMaximumResponseTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMinimumPDUSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupMinimumPDUSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupMinimumPDUSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEHold(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupRDEHold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupRDEHold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEReplace(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupRDEReplace not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupRDEReplace: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupResetOnTestEnabled(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupResetOnTestEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupResetOnTestEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCLPMRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCCLPMRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCCLPMRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnectionlessName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnectionlessName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCOPMRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCCOPMRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCCOPMRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Name(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnection2Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2MaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2MaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2ReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2SendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2BusyStateTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2BusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2BusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PBitTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2PBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2PBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2RejectTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2RejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2RejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2RemoteBusy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2RemoteBusy not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2RemoteBusy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2RemoteReset(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2RemoteReset not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2RemoteReset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2LocalReset(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2LocalReset not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2LocalReset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ProviderReset(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ProviderReset not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ProviderReset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Route(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnection2Route not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2Route: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2KStep(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2KStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2KStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaxSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2MaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2MaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentAcks(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2SentAcks not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SentAcks: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedAcks(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ReceivedAcks not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedAcks: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedFRMR(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ReceivedFRMR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedFRMR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentFRMR(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2SentFRMR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SentFRMR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedRR(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ReceivedRR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedRR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentRR(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2SentRR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SentRR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedRNR(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ReceivedRNR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedRNR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentRNR(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2SentRNR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SentRNR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedREJ(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ReceivedREJ not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedREJ: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentREJ(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2SentREJ not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SentREJ: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedSABME(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ReceivedSABME not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedSABME: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentSABME(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2SentSABME not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SentSABME: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedUA(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ReceivedUA not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedUA: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentUA(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2SentUA not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SentUA: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedDISC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ReceivedDISC not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedDISC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentDISC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2SentDISC not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SentDISC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedDM(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2ReceivedDM not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedDM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentDM(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2SentDM not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SentDM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PDUsDiscarded1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2PDUsDiscarded1 not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2PDUsDiscarded1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PDUsDiscarded2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2PDUsDiscarded2 not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2PDUsDiscarded2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PDURetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2PDURetransmissions not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2PDURetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2OptionalTolerationIPDUs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2OptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2OptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DuplicateIPDUsReceived(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2DuplicateIPDUsReceived not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DuplicateIPDUsReceived: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Violation(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			fprintf(stderr, "write to lLCConnection2Violation not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2Violation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AlarmStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to lLCConnection2AlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2AlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOMaximumRetransmissions not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOReceivedWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOReceivedWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOAcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBusyStateTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBitTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORejectTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMORejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMORejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORoute(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMORoute not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMORoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOKStep(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOKStep not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaxSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOMaxSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOOptionalTolerationIPDUs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckReceiveResources(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckReceiveResources not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckReceiveResources: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMORowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMORowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMORowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultReceivedWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultAcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultBusyStateTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultPBitTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultPBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultPBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRejectTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultRejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultRejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRoute(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnection2DefaultRoute not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2DefaultRoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultKStep(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultKStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaxSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultMaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultOptionalTolerationIPDUs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
