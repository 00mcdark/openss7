/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "lapbMIB_simple.h"

/* 
 * lapbMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid lapbMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 22 };

/* 
 * variable7 lapbMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the lapbMIB_simple mib section 
 */

struct variable7 lapbMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   LAPBDLELOCALSAPNAMES  4
	{LAPBDLELOCALSAPNAMES, ASN_OBJECT_ID, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 2}},
#define   LAPBDLEOPERATIONALSTATE  5
	{LAPBDLEOPERATIONALSTATE, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 3}},
#define   LAPBDLEPROVIDERENTITYNAMES  6
	{LAPBDLEPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 4}},
#define   LAPBDLEMT1TIMER       7
	{LAPBDLEMT1TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 5}},
#define   LAPBDLEMT3TIMER       8
	{LAPBDLEMT3TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 6}},
#define   LAPBDLEMW             9
	{LAPBDLEMW, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 7}},
#define   LAPBDLEMXSEND         10
	{LAPBDLEMXSEND, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 8}},
#define   LAPBDLEMXRECEIVE      11
	{LAPBDLEMXRECEIVE, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 9}},
#define   LAPBDLEMT2TIMER       12
	{LAPBDLEMT2TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 10}},
#define   LAPBDLERECEIVEDMLPRESETS  13
	{LAPBDLERECEIVEDMLPRESETS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 11}},
#define   LAPBDLETIMESMT1EXPIRED  14
	{LAPBDLETIMESMT1EXPIRED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 12}},
#define   LAPBDLEIFRAMESREASSIGNMENTS  15
	{LAPBDLEIFRAMESREASSIGNMENTS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 13}},
#define   LAPBDLEMLPFRAMESRECEIVED  16
	{LAPBDLEMLPFRAMESRECEIVED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 14}},
#define   LAPBDLEMLPFRAMESSENT  17
	{LAPBDLEMLPFRAMESSENT, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 15}},
#define   LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD  18
	{LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 16}},
#define   LAPBDLERECEIVEDMLPFRAMESINGUARDREGION  19
	{LAPBDLERECEIVEDMLPFRAMESINGUARDREGION, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 17}},
#define   LAPBDLEROWSTATUS      20
	{LAPBDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 18}},
#define   DLSAPSAP1ADDRESS      25
	{DLSAPSAP1ADDRESS, ASN_UNSIGNED, RONLY, var_dLSAPTable, 6, {1, 1, 2, 1, 1, 2}},
#define   DLSAPUSERENTITYNAMES  26
	{DLSAPUSERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_dLSAPTable, 6, {1, 1, 2, 1, 1, 3}},
#define   DLSAPROWSTATUS        27
	{DLSAPROWSTATUS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 2, 1, 1, 4}},
#define   SLPPMOPERATIONALSTATE  32
	{SLPPMOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sLPPMTable, 6, {1, 1, 3, 1, 1, 2}},
#define   SLPPMADMINISTRATIVESTATE  33
	{SLPPMADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 3, 1, 1, 3}},
#define   SLPPMROWSTATUS        34
	{SLPPMROWSTATUS, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 3, 1, 1, 4}},
#define   SLPCONNECTIONUNDERLYINGCONNECTIONNAMES  38
	{SLPCONNECTIONUNDERLYINGCONNECTIONNAMES, ASN_OBJECT_ID, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 2}},
#define   SLPCONNECTIONSUPPORTEDCONNECTIONNAMES  39
	{SLPCONNECTIONSUPPORTEDCONNECTIONNAMES, ASN_OBJECT_ID, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 3}},
#define   SLPCONNECTIONINTERFACETYPE  40
	{SLPCONNECTIONINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 4}},
#define   SLPCONNECTIONK        41
	{SLPCONNECTIONK, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 5}},
#define   SLPCONNECTIONN1       42
	{SLPCONNECTIONN1, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 6}},
#define   SLPCONNECTIONN2       43
	{SLPCONNECTIONN2, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 7}},
#define   SLPCONNECTIONSEQUENCEMODULUS  44
	{SLPCONNECTIONSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 8}},
#define   SLPCONNECTIONT1TIMER  45
	{SLPCONNECTIONT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 9}},
#define   SLPCONNECTIONT2TIMER  46
	{SLPCONNECTIONT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 10}},
#define   SLPCONNECTIONFCSERRORSRECEIVED  47
	{SLPCONNECTIONFCSERRORSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 11}},
#define   SLPCONNECTIONFRMRSRECEIVED  48
	{SLPCONNECTIONFRMRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 12}},
#define   SLPCONNECTIONFRMRSSENT  49
	{SLPCONNECTIONFRMRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 13}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED  50
	{SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 14}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSSENT  51
	{SLPCONNECTIONIFRAMEDATAOCTETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 15}},
#define   SLPCONNECTIONIFRAMESRECEIVED  52
	{SLPCONNECTIONIFRAMESRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 16}},
#define   SLPCONNECTIONIFRAMESSENT  53
	{SLPCONNECTIONIFRAMESSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 17}},
#define   SLPCONNECTIONPOLLSRECEIVED  54
	{SLPCONNECTIONPOLLSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 18}},
#define   SLPCONNECTIONREJSRECEIVED  55
	{SLPCONNECTIONREJSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 19}},
#define   SLPCONNECTIONREJSSENT  56
	{SLPCONNECTIONREJSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 20}},
#define   SLPCONNECTIONRNRSRECEIVED  57
	{SLPCONNECTIONRNRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 21}},
#define   SLPCONNECTIONRNRSSENT  58
	{SLPCONNECTIONRNRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 22}},
#define   SLPCONNECTIONSABMSRECEIVED  59
	{SLPCONNECTIONSABMSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 23}},
#define   SLPCONNECTIONSABMSSENT  60
	{SLPCONNECTIONSABMSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 24}},
#define   SLPCONNECTIONPROTOCOLSTATE  61
	{SLPCONNECTIONPROTOCOLSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 25}},
#define   SLPCONNECTIONTIMEST1EXPIRED  62
	{SLPCONNECTIONTIMEST1EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 26}},
#define   SLPCONNECTIONT3TIMER  63
	{SLPCONNECTIONT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 27}},
#define   SLPCONNECTIONTIMEST3EXPIRED  64
	{SLPCONNECTIONTIMEST3EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 28}},
#define   SLPCONNECTIONT4TIMER  65
	{SLPCONNECTIONT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 29}},
#define   SLPCONNECTIONTIMEST4EXPIRED  66
	{SLPCONNECTIONTIMEST4EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 30}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED  67
	{SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 31}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSSENT  68
	{SLPCONNECTIONABNORMALLINKDISCONNECTSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 32}},
#define   SLPCONNECTIONLINKRESETSRECEIVED  69
	{SLPCONNECTIONLINKRESETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 33}},
#define   SLPCONNECTIONLINKRESETSSENT  70
	{SLPCONNECTIONLINKRESETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 34}},
#define   SLPCONNECTIONTIMESN2REACHED  71
	{SLPCONNECTIONTIMESN2REACHED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 35}},
#define   SLPCONNECTIONADMINISTRATIVESTATE  72
	{SLPCONNECTIONADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 36}},
#define   SLPCONNECTIONOPERATIONALSTATE  73
	{SLPCONNECTIONOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 37}},
#define   SLPCONNECTIONUSAGESTATE  74
	{SLPCONNECTIONUSAGESTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 38}},
#define   SLPCONNECTIONPROCEDURALSTATUS  75
	{SLPCONNECTIONPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 39}},
#define   SLPCONNECTIONALARMSTATUS  76
	{SLPCONNECTIONALARMSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 40}},
#define   SLPCONNECTIONROWSTATUS  77
	{SLPCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 41}},
#define   SLPCONNECTIONIVMOID   81
	{SLPCONNECTIONIVMOID, ASN_OCTET_STR, RONLY, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 1}},
#define   SLPCONNECTIONIVMOINTERFACETYPE  82
	{SLPCONNECTIONIVMOINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 2}},
#define   SLPCONNECTIONIVMOK    83
	{SLPCONNECTIONIVMOK, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 3}},
#define   SLPCONNECTIONIVMON1   84
	{SLPCONNECTIONIVMON1, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 4}},
#define   SLPCONNECTIONIVMON2   85
	{SLPCONNECTIONIVMON2, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 5}},
#define   SLPCONNECTIONIVMOSEQUENCEMODULUS  86
	{SLPCONNECTIONIVMOSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 6}},
#define   SLPCONNECTIONIVMOT1TIMER  87
	{SLPCONNECTIONIVMOT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 7}},
#define   SLPCONNECTIONIVMOT2TIMER  88
	{SLPCONNECTIONIVMOT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 8}},
#define   SLPCONNECTIONIVMOT3TIMER  89
	{SLPCONNECTIONIVMOT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 9}},
#define   SLPCONNECTIONIVMOT4TIMER  90
	{SLPCONNECTIONIVMOT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 10}},
#define   SLPCONNECTIONIVMOROWSTATUS  91
	{SLPCONNECTIONIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 5, 1, 1, 11}},
#define   LAPBDISCONTINUITYTIME  92
	{LAPBDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_lapbMIB, 4, {1, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTINTERFACETYPE  93
	{SLPCONNECTIONDEFAULTINTERFACETYPE, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTK  94
	{SLPCONNECTIONDEFAULTK, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 2}},
#define   SLPCONNECTIONDEFAULTN1  95
	{SLPCONNECTIONDEFAULTN1, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 3}},
#define   SLPCONNECTIONDEFAULTN2  96
	{SLPCONNECTIONDEFAULTN2, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 4}},
#define   SLPCONNECTIONDEFAULTSEQUENCEMODULUS  97
	{SLPCONNECTIONDEFAULTSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 5}},
#define   SLPCONNECTIONDEFAULTT1TIMER  98
	{SLPCONNECTIONDEFAULTT1TIMER, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 6}},
#define   SLPCONNECTIONDEFAULTT2TIMER  99
	{SLPCONNECTIONDEFAULTT2TIMER, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 7}},
#define   SLPCONNECTIONDEFAULTT3TIMER  100
	{SLPCONNECTIONDEFAULTT3TIMER, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 8}},
#define   SLPCONNECTIONDEFAULTT4TIMER  101
	{SLPCONNECTIONDEFAULTT4TIMER, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 9}},
#define   FRMR                  102
	{FRMR, ASN_OCTET_STR,, var_lapbMIB, 3, {1, 3, 1}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_lapbMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_lapbMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("lapbMIB_simple", lapbMIB_simple_variables, variable7, lapbMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_lapbMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_lapbMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lAPBDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB_simple above.
 */
unsigned char *
var_lAPBDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LAPBDLELOCALSAPNAMES:
		*write_method = write_lAPBDLElocalSapNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case LAPBDLEOPERATIONALSTATE:
		*write_method = write_lAPBDLEoperationalState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEPROVIDERENTITYNAMES:
		*write_method = write_lAPBDLEproviderEntityNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case LAPBDLEMT1TIMER:
		*write_method = write_lAPBDLEmT1Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMT3TIMER:
		*write_method = write_lAPBDLEmT3Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMW:
		*write_method = write_lAPBDLEmW;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMXSEND:
		*write_method = write_lAPBDLEmXSend;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMXRECEIVE:
		*write_method = write_lAPBDLEmXReceive;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMT2TIMER:
		*write_method = write_lAPBDLEmT2Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLERECEIVEDMLPRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLETIMESMT1EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEIFRAMESREASSIGNMENTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMLPFRAMESRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMLPFRAMESSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLERECEIVEDMLPFRAMESINGUARDREGION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEROWSTATUS:
		*write_method = write_lAPBDLERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_dLSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB_simple above.
 */
unsigned char *
var_dLSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DLSAPSAP1ADDRESS:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case DLSAPUSERENTITYNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case DLSAPROWSTATUS:
		*write_method = write_dLSAPRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sLPPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB_simple above.
 */
unsigned char *
var_sLPPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SLPPMOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPPMADMINISTRATIVESTATE:
		*write_method = write_sLPPMadministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPPMROWSTATUS:
		*write_method = write_sLPPMRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sLPConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB_simple above.
 */
unsigned char *
var_sLPConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SLPCONNECTIONUNDERLYINGCONNECTIONNAMES:
		*write_method = write_sLPConnectionUnderlyingConnectionNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case SLPCONNECTIONSUPPORTEDCONNECTIONNAMES:
		*write_method = write_sLPConnectionSupportedConnectionNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case SLPCONNECTIONINTERFACETYPE:
		*write_method = write_sLPConnectionInterfaceType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONK:
		*write_method = write_sLPConnectionK;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONN1:
		*write_method = write_sLPConnectionN1;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONN2:
		*write_method = write_sLPConnectionN2;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONSEQUENCEMODULUS:
		*write_method = write_sLPConnectionSequenceModulus;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT1TIMER:
		*write_method = write_sLPConnectionT1Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT2TIMER:
		*write_method = write_sLPConnectionT2Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONFCSERRORSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONFRMRSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONFRMRSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMEDATAOCTETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMESRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMESSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONPOLLSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONREJSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONREJSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONRNRSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONRNRSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONSABMSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONSABMSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONPROTOCOLSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMEST1EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT3TIMER:
		*write_method = write_sLPConnectionT3Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMEST3EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT4TIMER:
		*write_method = write_sLPConnectionT4Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMEST4EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONLINKRESETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONLINKRESETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMESN2REACHED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONADMINISTRATIVESTATE:
		*write_method = write_sLPConnectionAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SLPCONNECTIONALARMSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SLPCONNECTIONROWSTATUS:
		*write_method = write_sLPConnectionRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sLPConnectionIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB_simple above.
 */
unsigned char *
var_sLPConnectionIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SLPCONNECTIONIVMOID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SLPCONNECTIONIVMOINTERFACETYPE:
		*write_method = write_sLPConnectionIVMOinterfaceType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOK:
		*write_method = write_sLPConnectionIVMOk;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMON1:
		*write_method = write_sLPConnectionIVMOn1;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMON2:
		*write_method = write_sLPConnectionIVMOn2;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOSEQUENCEMODULUS:
		*write_method = write_sLPConnectionIVMOsequenceModulus;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT1TIMER:
		*write_method = write_sLPConnectionIVMOt1Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT2TIMER:
		*write_method = write_sLPConnectionIVMOt2Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT3TIMER:
		*write_method = write_sLPConnectionIVMOt3Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT4TIMER:
		*write_method = write_sLPConnectionIVMOt4Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOROWSTATUS:
		*write_method = write_sLPConnectionIVMORowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_lAPBDLElocalSapNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to lAPBDLElocalSapNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to lAPBDLElocalSapNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEoperationalState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEoperationalState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEoperationalState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEproviderEntityNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to lAPBDLEproviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to lAPBDLEproviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmW(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmW not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmW: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXSend(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmXSend not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmXSend: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXReceive(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmXReceive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmXReceive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dLSAPRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dLSAPRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMadministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPPMadministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPPMadministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPPMRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPPMRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionUnderlyingConnectionNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to sLPConnectionUnderlyingConnectionNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to sLPConnectionUnderlyingConnectionNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionSupportedConnectionNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to sLPConnectionSupportedConnectionNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to sLPConnectionSupportedConnectionNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionInterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionK(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionSequenceModulus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT4Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOinterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOinterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOinterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOk(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOk not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOk: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOn1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOn1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOn2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOn2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOsequenceModulus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOsequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOsequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt4Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMORowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMORowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMORowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultInterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultK(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultSequenceModulus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT4Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
