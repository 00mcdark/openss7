/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "dlMIB_simple.h"

/* 
 * dlMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dlMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212 };

/* 
 * variable7 dlMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the dlMIB_simple mib section 
 */

struct variable7 dlMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   COMMUNICATIONSENTITYLOCALSAPNAMES  4
	{COMMUNICATIONSENTITYLOCALSAPNAMES, ASN_OBJECT_ID, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 2}},
#define   COMMUNICATIONSENTITYOPERATIONALSTATE  5
	{COMMUNICATIONSENTITYOPERATIONALSTATE, ASN_INTEGER, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 3}},
#define   SAP1ADDRESS           10
	{SAP1ADDRESS, ASN_UNSIGNED, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 2}},
#define   SAP1USERENTITYNAMES   11
	{SAP1USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 3}},
#define   SAP2ADDRESS           15
	{SAP2ADDRESS, ASN_OCTET_STR, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 1}},
#define   SAP2USERENTITYNAMES   16
	{SAP2USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 2}},
#define   SAP2PROVIDERENTITYNAMES  17
	{SAP2PROVIDERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 3}},
#define   CLPROTOCOLMACHINEOPERATIONALSTATE  22
	{CLPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 2}},
#define   CLPROTOCOLMACHINETOTALREMOTESAPS  23
	{CLPROTOCOLMACHINETOTALREMOTESAPS, ASN_COUNTER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 3}},
#define   COPROTOCOLMACHINEOPERATIONALSTATE  28
	{COPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_coProtocolMachineTable, 6, {1, 1, 5, 1, 1, 2}},
#define   UNDERLYINGCONNECTIONNAMES  34
	{UNDERLYINGCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 2}},
#define   SUPPPORTEDCONNECTIONNAMES  35
	{SUPPPORTEDCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 3}},
#define   PHYSICALENTITYPHYSICALENTITYTITLES  39
	{PHYSICALENTITYPHYSICALENTITYTITLES, ASN_OBJECT_ID, RWRITE, var_physicalEntityTable, 6, {1, 1, 7, 1, 1, 1}},
#define   DATACIRCUITBITERRORSRECEIVED  49
	{DATACIRCUITBITERRORSRECEIVED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 1}},
#define   DATACIRCUITBITERRORSTRANSMITTED  50
	{DATACIRCUITBITERRORSTRANSMITTED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 2}},
#define   DATACIRCUITBITERRORSTHRESHOLD  51
	{DATACIRCUITBITERRORSTHRESHOLD, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 3}},
#define   DATACIRCUITTYPE       52
	{DATACIRCUITTYPE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 4}},
#define   DATACIRCUITPHYSICALMEDIANAMES  53
	{DATACIRCUITPHYSICALMEDIANAMES, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 5}},
#define   DATACIRCUITPHYSICALINTERFACETYPE  54
	{DATACIRCUITPHYSICALINTERFACETYPE, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 6}},
#define   DATACIRCUITPHYSICALINTERFACESTANDARD  55
	{DATACIRCUITPHYSICALINTERFACESTANDARD, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 7}},
#define   DATACIRCUITSYNCHRONIZATIONMODE  56
	{DATACIRCUITSYNCHRONIZATIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 8}},
#define   DATACIRCUITTRANSMISSIONCODING  57
	{DATACIRCUITTRANSMISSIONCODING, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 9}},
#define   DATACIRCUITTRANSMISSIONMODE  58
	{DATACIRCUITTRANSMISSIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 10}},
#define   DATACIRCUITTRANSMISSIONRATE  59
	{DATACIRCUITTRANSMISSIONRATE, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 11}},
#define   DATACIRCUITROWSTATUS  60
	{DATACIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 12}},
#define   PHYSICALCONNECTIONENDPOINTIDENTIFIER  66
	{PHYSICALCONNECTIONENDPOINTIDENTIFIER, ASN_OCTET_STR, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 1}},
#define   PHYSICALCONNECTIONPORTNUMBER  67
	{PHYSICALCONNECTIONPORTNUMBER, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 2}},
#define   PHYSICALCONNECTIONROWSTATUS  68
	{PHYSICALCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 3}},
#define   DATALINKENTITYPROVIDERENTITYNAMES  72
	{DATALINKENTITYPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 1}},
#define   DATALINKENTITYROWSTATUS  73
	{DATALINKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 2}},
#define   DLSAPROWSTATUS        78
	{DLSAPROWSTATUS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 12, 1, 1, 1}},
#define   LAPBDLEMT1TIMER       82
	{LAPBDLEMT1TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 1}},
#define   LAPBDLEMT3TIMER       83
	{LAPBDLEMT3TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 2}},
#define   LAPBDLEMW             84
	{LAPBDLEMW, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 3}},
#define   LAPBDLEMXSEND         85
	{LAPBDLEMXSEND, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 4}},
#define   LAPBDLEMXRECEIVE      86
	{LAPBDLEMXRECEIVE, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 5}},
#define   LAPBDLEMT2TIMER       87
	{LAPBDLEMT2TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 6}},
#define   LAPBDLERECEIVEDMLPRESETS  88
	{LAPBDLERECEIVEDMLPRESETS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 7}},
#define   LAPBDLETIMESMT1EXPIRED  89
	{LAPBDLETIMESMT1EXPIRED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 8}},
#define   LAPBDLEIFRAMESREASSIGNMENTS  90
	{LAPBDLEIFRAMESREASSIGNMENTS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 9}},
#define   LAPBDLEMLPFRAMESRECEIVED  91
	{LAPBDLEMLPFRAMESRECEIVED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 10}},
#define   LAPBDLEMLPFRAMESSENT  92
	{LAPBDLEMLPFRAMESSENT, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 11}},
#define   LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD  93
	{LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 12}},
#define   LAPBDLERECEIVEDMLPFRAMESINGUARDREGION  94
	{LAPBDLERECEIVEDMLPFRAMESINGUARDREGION, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 13}},
#define   LAPBDLEROWSTATUS      95
	{LAPBDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 14}},
#define   SLPPMADMINISTRATIVESTATE  100
	{SLPPMADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 3}},
#define   SLPPMROWSTATUS        101
	{SLPPMROWSTATUS, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 4}},
#define   SLPCONNECTIONINTERFACETYPE  107
	{SLPCONNECTIONINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 1}},
#define   SLPCONNECTIONK        108
	{SLPCONNECTIONK, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 2}},
#define   SLPCONNECTIONN1       109
	{SLPCONNECTIONN1, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 3}},
#define   SLPCONNECTIONN2       110
	{SLPCONNECTIONN2, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 4}},
#define   SLPCONNECTIONSEQUENCEMODULUS  111
	{SLPCONNECTIONSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 5}},
#define   SLPCONNECTIONT1TIMER  112
	{SLPCONNECTIONT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 6}},
#define   SLPCONNECTIONT2TIMER  113
	{SLPCONNECTIONT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 7}},
#define   SLPCONNECTIONFCSERRORSRECEIVED  114
	{SLPCONNECTIONFCSERRORSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 8}},
#define   SLPCONNECTIONFRMRSRECEIVED  115
	{SLPCONNECTIONFRMRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 9}},
#define   SLPCONNECTIONFRMRSSENT  116
	{SLPCONNECTIONFRMRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 10}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED  117
	{SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 11}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSSENT  118
	{SLPCONNECTIONIFRAMEDATAOCTETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 12}},
#define   SLPCONNECTIONIFRAMESRECEIVED  119
	{SLPCONNECTIONIFRAMESRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 13}},
#define   SLPCONNECTIONIFRAMESSENT  120
	{SLPCONNECTIONIFRAMESSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 14}},
#define   SLPCONNECTIONPOLLSRECEIVED  121
	{SLPCONNECTIONPOLLSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 15}},
#define   SLPCONNECTIONREJSRECEIVED  122
	{SLPCONNECTIONREJSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 16}},
#define   SLPCONNECTIONREJSSENT  123
	{SLPCONNECTIONREJSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 17}},
#define   SLPCONNECTIONRNRSRECEIVED  124
	{SLPCONNECTIONRNRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 18}},
#define   SLPCONNECTIONRNRSSENT  125
	{SLPCONNECTIONRNRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 19}},
#define   SLPCONNECTIONSABMSRECEIVED  126
	{SLPCONNECTIONSABMSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 20}},
#define   SLPCONNECTIONSABMSSENT  127
	{SLPCONNECTIONSABMSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 21}},
#define   SLPCONNECTIONPROTOCOLSTATE  128
	{SLPCONNECTIONPROTOCOLSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 22}},
#define   SLPCONNECTIONTIMEST1EXPIRED  129
	{SLPCONNECTIONTIMEST1EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 23}},
#define   SLPCONNECTIONT3TIMER  130
	{SLPCONNECTIONT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 24}},
#define   SLPCONNECTIONTIMEST3EXPIRED  131
	{SLPCONNECTIONTIMEST3EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 25}},
#define   SLPCONNECTIONT4TIMER  132
	{SLPCONNECTIONT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 26}},
#define   SLPCONNECTIONTIMEST4EXPIRED  133
	{SLPCONNECTIONTIMEST4EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 27}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED  134
	{SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 28}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSSENT  135
	{SLPCONNECTIONABNORMALLINKDISCONNECTSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 29}},
#define   SLPCONNECTIONLINKRESETSRECEIVED  136
	{SLPCONNECTIONLINKRESETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 30}},
#define   SLPCONNECTIONLINKRESETSSENT  137
	{SLPCONNECTIONLINKRESETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 31}},
#define   SLPCONNECTIONTIMESN2REACHED  138
	{SLPCONNECTIONTIMESN2REACHED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 32}},
#define   SLPCONNECTIONADMINISTRATIVESTATE  139
	{SLPCONNECTIONADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 33}},
#define   SLPCONNECTIONOPERATIONALSTATE  140
	{SLPCONNECTIONOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 34}},
#define   SLPCONNECTIONUSAGESTATE  141
	{SLPCONNECTIONUSAGESTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 35}},
#define   SLPCONNECTIONPROCEDURALSTATUS  142
	{SLPCONNECTIONPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 36}},
#define   SLPCONNECTIONALARMSTATUS  143
	{SLPCONNECTIONALARMSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 37}},
#define   SLPCONNECTIONROWSTATUS  144
	{SLPCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 38}},
#define   SLPCONNECTIONIVMOID   150
	{SLPCONNECTIONIVMOID, ASN_OCTET_STR, RONLY, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 1}},
#define   SLPCONNECTIONIVMOINTERFACETYPE  151
	{SLPCONNECTIONIVMOINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   SLPCONNECTIONIVMOK    152
	{SLPCONNECTIONIVMOK, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 3}},
#define   SLPCONNECTIONIVMON1   153
	{SLPCONNECTIONIVMON1, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 4}},
#define   SLPCONNECTIONIVMON2   154
	{SLPCONNECTIONIVMON2, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 5}},
#define   SLPCONNECTIONIVMOSEQUENCEMODULUS  155
	{SLPCONNECTIONIVMOSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 6}},
#define   SLPCONNECTIONIVMOT1TIMER  156
	{SLPCONNECTIONIVMOT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 7}},
#define   SLPCONNECTIONIVMOT2TIMER  157
	{SLPCONNECTIONIVMOT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 8}},
#define   SLPCONNECTIONIVMOT3TIMER  158
	{SLPCONNECTIONIVMOT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 9}},
#define   SLPCONNECTIONIVMOT4TIMER  159
	{SLPCONNECTIONIVMOT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 10}},
#define   SLPCONNECTIONIVMOROWSTATUS  160
	{SLPCONNECTIONIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 11}},
#define   MACDLEROWSTATUS       164
	{MACDLEROWSTATUS, ASN_INTEGER, RWRITE, var_mACDLETable, 6, {1, 1, 17, 1, 1, 1}},
#define   MACOPERATIONALSTATE   168
	{MACOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mACTable, 6, {1, 1, 18, 1, 1, 1}},
#define   MACROWSTATUS          170
	{MACROWSTATUS, ASN_INTEGER, RWRITE, var_mACTable, 6, {1, 1, 18, 1, 1, 3}},
#define   LLCDLEROWSTATUS       174
	{LLCDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lLCDLETable, 6, {1, 1, 19, 1, 1, 1}},
#define   LLCCLPMROWSTATUS      179
	{LLCCLPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCLPMTable, 6, {1, 1, 20, 1, 1, 1}},
#define   LLCCOPMROWSTATUS      184
	{LLCCOPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCOPMTable, 6, {1, 1, 21, 1, 1, 1}},
#define   RESOURCETYPEIDNAME    188
	{RESOURCETYPEIDNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 1}},
#define   RESOURCEINFOMANUFACTUREROUI  189
	{RESOURCEINFOMANUFACTUREROUI, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 2}},
#define   RESOURCEINFOMANUFACTURERNAME  190
	{RESOURCEINFOMANUFACTURERNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 3}},
#define   RESOURCEINFOMANUFACTURERPRODUCTNAME  191
	{RESOURCEINFOMANUFACTURERPRODUCTNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 4}},
#define   RESOURCEINFOMANUFACTURERPRODUCTVERSION  192
	{RESOURCEINFOMANUFACTURERPRODUCTVERSION, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 5}},
#define   LLCSTATIONLLCNAME     197
	{LLCSTATIONLLCNAME, ASN_OCTET_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 1}},
#define   LLCSTATIONMAXIMUMLSAPSCONFIGURED  198
	{LLCSTATIONMAXIMUMLSAPSCONFIGURED, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 2}},
#define   LLCSTATIONNUMBEROFACTIVELSAPS  199
	{LLCSTATIONNUMBEROFACTIVELSAPS, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 3}},
#define   LLCSTATIONSUPPORTEDSERVICESTYPES  200
	{LLCSTATIONSUPPORTEDSERVICESTYPES, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 4}},
#define   LLCSTATIONSTATUS      201
	{LLCSTATIONSTATUS, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 5}},
#define   LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE  202
	{LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 6}},
#define   LLCSTATIONTYPE1MAXIMUMRETRYCOUNT  203
	{LLCSTATIONTYPE1MAXIMUMRETRYCOUNT, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 7}},
#define   LLCSTATIONMAXIMUMPDUN3  204
	{LLCSTATIONMAXIMUMPDUN3, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 8}},
#define   LLCSTATIONMAXIMUMRETRANSMISSIONS4  205
	{LLCSTATIONMAXIMUMRETRANSMISSIONS4, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 9}},
#define   LLCSTATIONRECEIVEVARIABLELIFETIME  206
	{LLCSTATIONRECEIVEVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 10}},
#define   LLCSTATIONTRANSMITVARIABLELIFETIME  207
	{LLCSTATIONTRANSMITVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 11}},
#define   LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE  208
	{LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 12}},
#define   LLCSTATIONTYPE3RETRANSMISSIONS  209
	{LLCSTATIONTYPE3RETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 13}},
#define   LLCSTATIONAVGBUFFERUSESIZE  210
	{LLCSTATIONAVGBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 14}},
#define   LLCSTATIONBUFFERPROBLEMS  211
	{LLCSTATIONBUFFERPROBLEMS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 15}},
#define   LLCSTATIONBUFFERSIZE  212
	{LLCSTATIONBUFFERSIZE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 16}},
#define   LLCSTATIONMAXBUFFERUSESIZE  213
	{LLCSTATIONMAXBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 17}},
#define   LLCSTATIONINACTIVELSAP  214
	{LLCSTATIONINACTIVELSAP, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 18}},
#define   LLCSTATIONPDUSDISCARD  215
	{LLCSTATIONPDUSDISCARD, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 19}},
#define   LLCSTATIONSTRINDICATOR  216
	{LLCSTATIONSTRINDICATOR, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 20}},
#define   LLCSTATIONVERSIONNUMBER  217
	{LLCSTATIONVERSIONNUMBER, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 21}},
#define   LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS  218
	{LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 22}},
#define   LLCSAPADDRESS         224
	{LLCSAPADDRESS, ASN_OCTET_STR, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 2}},
#define   LLCSAPRDE             225
	{LLCSAPRDE, ASN_INTEGER, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 3}},
#define   RDESETUPAGINGENABLED  230
	{RDESETUPAGINGENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 1}},
#define   RDESETUPAGINGVALUE    231
	{RDESETUPAGINGVALUE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 2}},
#define   RDESETUPENABLETYPE2RESET  232
	{RDESETUPENABLETYPE2RESET, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 3}},
#define   RDESETUPMAXIMUMROUTEDESCRIPTORS  233
	{RDESETUPMAXIMUMROUTEDESCRIPTORS, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 4}},
#define   RDESETUPMAXIMUMRESPONSETIME  234
	{RDESETUPMAXIMUMRESPONSETIME, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 5}},
#define   RDESETUPMINIMUMPDUSIZE  235
	{RDESETUPMINIMUMPDUSIZE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 6}},
#define   RDESETUPRDEHOLD       236
	{RDESETUPRDEHOLD, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 7}},
#define   RDESETUPRDEREPLACE    237
	{RDESETUPRDEREPLACE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 8}},
#define   RDESETUPNAME          238
	{RDESETUPNAME, ASN_INTEGER, RONLY, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 9}},
#define   RDESETUPRESETONTESTENABLED  239
	{RDESETUPRESETONTESTENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 10}},
#define   RDEPAIRDISCARDCOUNTER  245
	{RDEPAIRDISCARDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 2}},
#define   RDEPAIRNSRPDUCOUNTER  246
	{RDEPAIRNSRPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 3}},
#define   RDEPAIRNSRSELECTEDCOUNTER  247
	{RDEPAIRNSRSELECTEDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 4}},
#define   RDEPAIRRIF            248
	{RDEPAIRRIF, ASN_OCTET_STR, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 5}},
#define   RDEPAIRSRFPDUCOUNTER  249
	{RDEPAIRSRFPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 6}},
#define   RDEPAIRQUERYCOUNTER   250
	{RDEPAIRQUERYCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 7}},
#define   LLCCONNECTIONLESSNAME  256
	{LLCCONNECTIONLESSNAME, ASN_OCTET_STR, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 1}},
#define   LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE  257
	{LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 2}},
#define   LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE  258
	{LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 3}},
#define   LLCCONNECTIONLESSTESTRECEIVEDCOMMAND  259
	{LLCCONNECTIONLESSTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 4}},
#define   LLCCONNECTIONLESSTESTRECEIVEDRESPONSE  260
	{LLCCONNECTIONLESSTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 5}},
#define   LLCCONNECTIONLESSTESTSENTABBRESPONSE  261
	{LLCCONNECTIONLESSTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 6}},
#define   LLCCONNECTIONLESSTESTSENTCOMMAND  262
	{LLCCONNECTIONLESSTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 7}},
#define   LLCCONNECTIONLESSTESTSENTRESPONSE  263
	{LLCCONNECTIONLESSTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 8}},
#define   LLCCONNECTIONLESSUIRECEIVED  264
	{LLCCONNECTIONLESSUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 9}},
#define   LLCCONNECTIONLESSUISENT  265
	{LLCCONNECTIONLESSUISENT, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 10}},
#define   LLCCONNECTIONLESSXIDRECEIVEDCOMMAND  266
	{LLCCONNECTIONLESSXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 11}},
#define   LLCCONNECTIONLESSXIDRECEIVEDRESPONSE  267
	{LLCCONNECTIONLESSXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 12}},
#define   LLCCONNECTIONLESSXIDSENTCOMMAND  268
	{LLCCONNECTIONLESSXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 13}},
#define   LLCCONNECTIONLESSXIDSENTRESPONSE  269
	{LLCCONNECTIONLESSXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 14}},
#define   LLCCONNECTION2NAME    275
	{LLCCONNECTION2NAME, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 1}},
#define   LLCCONNECTION2MAXIMUMRETRANSMISSIONS  276
	{LLCCONNECTION2MAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 2}},
#define   LLCCONNECTION2RECEIVEDWINDOWSIZE  277
	{LLCCONNECTION2RECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 3}},
#define   LLCCONNECTION2SENDWINDOWSIZE  278
	{LLCCONNECTION2SENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 4}},
#define   LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE  279
	{LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 5}},
#define   LLCCONNECTION2BUSYSTATETIMEOUTVALUE  280
	{LLCCONNECTION2BUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 6}},
#define   LLCCONNECTION2PBITTIMEOUTVALUE  281
	{LLCCONNECTION2PBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 7}},
#define   LLCCONNECTION2REJECTTIMEOUTVALUE  282
	{LLCCONNECTION2REJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 8}},
#define   LLCCONNECTION2LOCALBUSY  283
	{LLCCONNECTION2LOCALBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 9}},
#define   LLCCONNECTION2REMOTEBUSY  284
	{LLCCONNECTION2REMOTEBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 10}},
#define   LLCCONNECTION2REMOTERESET  285
	{LLCCONNECTION2REMOTERESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 11}},
#define   LLCCONNECTION2LOCALRESET  286
	{LLCCONNECTION2LOCALRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 12}},
#define   LLCCONNECTION2PROVIDERRESET  287
	{LLCCONNECTION2PROVIDERRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 13}},
#define   LLCCONNECTION2ROUTE   288
	{LLCCONNECTION2ROUTE, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 14}},
#define   LLCCONNECTION2KSTEP   289
	{LLCCONNECTION2KSTEP, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 15}},
#define   LLCCONNECTION2MAXSENDWINDOWSIZE  290
	{LLCCONNECTION2MAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 16}},
#define   LLCCONNECTION2RECEIVEDI  291
	{LLCCONNECTION2RECEIVEDI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 17}},
#define   LLCCONNECTION2SENTI   292
	{LLCCONNECTION2SENTI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 18}},
#define   LLCCONNECTION2SENTACKS  293
	{LLCCONNECTION2SENTACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 19}},
#define   LLCCONNECTION2RECEIVEDACKS  294
	{LLCCONNECTION2RECEIVEDACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 20}},
#define   LLCCONNECTION2RECEIVEDFRMR  295
	{LLCCONNECTION2RECEIVEDFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 21}},
#define   LLCCONNECTION2SENTFRMR  296
	{LLCCONNECTION2SENTFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 22}},
#define   LLCCONNECTION2RECEIVEDRR  297
	{LLCCONNECTION2RECEIVEDRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 23}},
#define   LLCCONNECTION2SENTRR  298
	{LLCCONNECTION2SENTRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 24}},
#define   LLCCONNECTION2RECEIVEDRNR  299
	{LLCCONNECTION2RECEIVEDRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 25}},
#define   LLCCONNECTION2SENTRNR  300
	{LLCCONNECTION2SENTRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 26}},
#define   LLCCONNECTION2RECEIVEDREJ  301
	{LLCCONNECTION2RECEIVEDREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 27}},
#define   LLCCONNECTION2SENTREJ  302
	{LLCCONNECTION2SENTREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 28}},
#define   LLCCONNECTION2RECEIVEDSABME  303
	{LLCCONNECTION2RECEIVEDSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 29}},
#define   LLCCONNECTION2SENTSABME  304
	{LLCCONNECTION2SENTSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 30}},
#define   LLCCONNECTION2RECEIVEDUA  305
	{LLCCONNECTION2RECEIVEDUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 31}},
#define   LLCCONNECTION2SENTUA  306
	{LLCCONNECTION2SENTUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 32}},
#define   LLCCONNECTION2RECEIVEDDISC  307
	{LLCCONNECTION2RECEIVEDDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 33}},
#define   LLCCONNECTION2SENTDISC  308
	{LLCCONNECTION2SENTDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 34}},
#define   LLCCONNECTION2RECEIVEDDM  309
	{LLCCONNECTION2RECEIVEDDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 35}},
#define   LLCCONNECTION2SENTDM  310
	{LLCCONNECTION2SENTDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 36}},
#define   LLCCONNECTION2PDUSDISCARDED1  311
	{LLCCONNECTION2PDUSDISCARDED1, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 37}},
#define   LLCCONNECTION2PDUSDISCARDED2  312
	{LLCCONNECTION2PDUSDISCARDED2, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 38}},
#define   LLCCONNECTION2PDURETRANSMISSIONS  313
	{LLCCONNECTION2PDURETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 39}},
#define   LLCCONNECTION2OPTIONALTOLERATIONIPDUS  314
	{LLCCONNECTION2OPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 40}},
#define   LLCCONNECTION2DUPLICATEIPDUSRECEIVED  315
	{LLCCONNECTION2DUPLICATEIPDUSRECEIVED, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 41}},
#define   LLCCONNECTION2VIOLATION  316
	{LLCCONNECTION2VIOLATION, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 42}},
#define   LLCCONNECTION2PROTOCOLSTATE  317
	{LLCCONNECTION2PROTOCOLSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 43}},
#define   LLCCONNECTION2ADMINISTRATIVESTATE  318
	{LLCCONNECTION2ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 44}},
#define   LLCCONNECTION2OPERATIONALSTATE  319
	{LLCCONNECTION2OPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 45}},
#define   LLCCONNECTION2USAGESTATE  320
	{LLCCONNECTION2USAGESTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 46}},
#define   LLCCONNECTION2PROCEDURALSTATUS  321
	{LLCCONNECTION2PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 47}},
#define   LLCCONNECTION2ALARMSTATUS  322
	{LLCCONNECTION2ALARMSTATUS, ASN_BIT_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 48}},
#define   LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS  329
	{LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 2}},
#define   LLCCONNECTION2IVMORECEIVEDWINDOWSIZE  330
	{LLCCONNECTION2IVMORECEIVEDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 3}},
#define   LLCCONNECTION2IVMOSENDWINDOWSIZE  331
	{LLCCONNECTION2IVMOSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 4}},
#define   LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE  332
	{LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 5}},
#define   LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE  333
	{LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 6}},
#define   LLCCONNECTION2IVMOBITTIMEOUTVALUE  334
	{LLCCONNECTION2IVMOBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 7}},
#define   LLCCONNECTION2IVMOREJECTTIMEOUTVALUE  335
	{LLCCONNECTION2IVMOREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 8}},
#define   LLCCONNECTION2IVMOROUTE  336
	{LLCCONNECTION2IVMOROUTE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 9}},
#define   LLCCONNECTION2IVMOKSTEP  337
	{LLCCONNECTION2IVMOKSTEP, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 10}},
#define   LLCCONNECTION2IVMOMAXSENDWINDOWSIZE  338
	{LLCCONNECTION2IVMOMAXSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 11}},
#define   LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS  339
	{LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE  346
	{LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS  347
	{LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE  348
	{LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 4}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND  349
	{LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 5}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE  350
	{LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 6}},
#define   LLCCONNECTIONLESSACKTESTSENTABBRESPONSE  351
	{LLCCONNECTIONLESSACKTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 7}},
#define   LLCCONNECTIONLESSACKTESTSENTCOMMAND  352
	{LLCCONNECTIONLESSACKTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 8}},
#define   LLCCONNECTIONLESSACKTESTSENTRESPONSE  353
	{LLCCONNECTIONLESSACKTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 9}},
#define   LLCCONNECTIONLESSACKRECEIVERESOURCES  354
	{LLCCONNECTIONLESSACKRECEIVERESOURCES, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 10}},
#define   LLCCONNECTIONLESSACKUIRECEIVED  355
	{LLCCONNECTIONLESSACKUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 11}},
#define   LLCCONNECTIONLESSACKUISENT  356
	{LLCCONNECTIONLESSACKUISENT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND  357
	{LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 13}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE  358
	{LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 14}},
#define   LLCCONNECTIONLESSACKXIDSENTCOMMAND  359
	{LLCCONNECTIONLESSACKXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 15}},
#define   LLCCONNECTIONLESSACKXIDSENTRESPONSE  360
	{LLCCONNECTIONLESSACKXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 16}},
#define   LLCCONNECTIONLESSACKRETRANSMISSIONS  361
	{LLCCONNECTIONLESSACKRETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 17}},
#define   LLCCONNECTIONLESSACKNORESPONSE  362
	{LLCCONNECTIONLESSACKNORESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 18}},
#define   LLCCONNECTIONLESSACKCOMMANDIP  363
	{LLCCONNECTIONLESSACKCOMMANDIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 19}},
#define   LLCCONNECTIONLESSACKCOMMANDIT  364
	{LLCCONNECTIONLESSACKCOMMANDIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 20}},
#define   LLCCONNECTIONLESSACKCOMMANDOK  365
	{LLCCONNECTIONLESSACKCOMMANDOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 21}},
#define   LLCCONNECTIONLESSACKCOMMANDPE  366
	{LLCCONNECTIONLESSACKCOMMANDPE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 22}},
#define   LLCCONNECTIONLESSACKCOMMANDRS  367
	{LLCCONNECTIONLESSACKCOMMANDRS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 23}},
#define   LLCCONNECTIONLESSACKCOMMANDUE  368
	{LLCCONNECTIONLESSACKCOMMANDUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 24}},
#define   LLCCONNECTIONLESSACKCOMMANDUN  369
	{LLCCONNECTIONLESSACKCOMMANDUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 25}},
#define   LLCCONNECTIONLESSACKRECEIVEDACCOMMAND  370
	{LLCCONNECTIONLESSACKRECEIVEDACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 26}},
#define   LLCCONNECTIONLESSACKSENTACCOMMAND  371
	{LLCCONNECTIONLESSACKSENTACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 27}},
#define   LLCCONNECTIONLESSACKRESPONSEIP  372
	{LLCCONNECTIONLESSACKRESPONSEIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 28}},
#define   LLCCONNECTIONLESSACKRESPONSEIT  373
	{LLCCONNECTIONLESSACKRESPONSEIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 29}},
#define   LLCCONNECTIONLESSACKRESPONSENE  374
	{LLCCONNECTIONLESSACKRESPONSENE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 30}},
#define   LLCCONNECTIONLESSACKRESPONSENR  375
	{LLCCONNECTIONLESSACKRESPONSENR, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 31}},
#define   LLCCONNECTIONLESSACKRESPONSEOK  376
	{LLCCONNECTIONLESSACKRESPONSEOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 32}},
#define   LLCCONNECTIONLESSACKRESPONSERS  377
	{LLCCONNECTIONLESSACKRESPONSERS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 33}},
#define   LLCCONNECTIONLESSACKRESPONSEUE  378
	{LLCCONNECTIONLESSACKRESPONSEUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 34}},
#define   LLCCONNECTIONLESSACKRESPONSEUN  379
	{LLCCONNECTIONLESSACKRESPONSEUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 35}},
#define   LLCCONNECTIONLESSACKVIOLATION  380
	{LLCCONNECTIONLESSACKVIOLATION, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 36}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE  386
	{LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS  387
	{LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKIVMOROWSTATUS  388
	{LLCCONNECTIONLESSACKIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 4}},
#define   NETWORKENTITYTITLES   392
	{NETWORKENTITYTITLES, ASN_OCTET_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 1}},
#define   NETWORKENTITYSYSTEMTYPES  393
	{NETWORKENTITYSYSTEMTYPES, ASN_BIT_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 2}},
#define   NETWORKENTITYROWSTATUS  394
	{NETWORKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 3}},
#define   NSAPROWSTATUS         398
	{NSAPROWSTATUS, ASN_INTEGER, RWRITE, var_nSAPTable, 6, {1, 1, 33, 1, 1, 1}},
#define   CLNSADMINISTRATIVESTATE  403
	{CLNSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 1}},
#define   CLNSSUPPORTEDPROTOCOLS  404
	{CLNSSUPPORTEDPROTOCOLS, ASN_OCTET_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 2}},
#define   CLNSOPERATIONALSYSTEMTYPE  405
	{CLNSOPERATIONALSYSTEMTYPE, ASN_BIT_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 3}},
#define   CLNSOCTETSSENTCOUNTER  406
	{CLNSOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 4}},
#define   CLNSOCTETSRECEIVEDCOUNTER  407
	{CLNSOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 5}},
#define   CLNSSEGMENTSRECEIVED  408
	{CLNSSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 6}},
#define   CLNSSEGMENTSDISCARDED  409
	{CLNSSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 7}},
#define   CLNSASSEMBLINGSEGMENTSDISCARDED  410
	{CLNSASSEMBLINGSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 8}},
#define   CLNSERRORREPORTSRECEIVED  411
	{CLNSERRORREPORTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 9}},
#define   CLNSPDUDISCARDS       412
	{CLNSPDUDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 10}},
#define   CLNSCONGESTIONDISCARDS  413
	{CLNSCONGESTIONDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 11}},
#define   CLNSMAXIMUMLIFETIME   414
	{CLNSMAXIMUMLIFETIME, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 12}},
#define   CLNSENABLECHECKSUM    415
	{CLNSENABLECHECKSUM, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 13}},
#define   CLNSROWSTATUS         416
	{CLNSROWSTATUS, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 14}},
#define   CLNSISISVERSION       421
	{CLNSISISVERSION, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 1}},
#define   CLNSISISISTYPE        422
	{CLNSISISISTYPE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 2}},
#define   CLNSISISSYSTEMID      423
	{CLNSISISSYSTEMID, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 3}},
#define   CLNSISISMAXIMUMPATHSPLITS  424
	{CLNSISISMAXIMUMPATHSPLITS, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 4}},
#define   CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL  425
	{CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 5}},
#define   CLNSISISMAXIMUMLSPGENERATIONINTERVAL  426
	{CLNSISISMAXIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 6}},
#define   CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL  427
	{CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 7}},
#define   CLNSISISCOMPLETESNPINTERVAL  428
	{CLNSISISCOMPLETESNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 8}},
#define   CLNSISISORIGINATINGL1LSPBUFFERSIZE  429
	{CLNSISISORIGINATINGL1LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 9}},
#define   CLNSISISMANUALAREAADDRESSES  430
	{CLNSISISMANUALAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 10}},
#define   CLNSISISMAXIMUMAREAADDRESSES  431
	{CLNSISISMAXIMUMAREAADDRESSES, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 11}},
#define   CLNSISISMINIMUMLSPGENERATIONINTERVAL  432
	{CLNSISISMINIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 12}},
#define   CLNSISISPOLLESHELLORATE  433
	{CLNSISISPOLLESHELLORATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 13}},
#define   CLNSISISPARTIALSNPINTERVAL  434
	{CLNSISISPARTIALSNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 14}},
#define   CLNSISISWAITINGTIME   435
	{CLNSISISWAITINGTIME, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 15}},
#define   CLNSISISDRISISHELLOTIMER  436
	{CLNSISISDRISISHELLOTIMER, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 16}},
#define   CLNSISISL1STATE       437
	{CLNSISISL1STATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 17}},
#define   CLNSISISAREAADDRESSES  438
	{CLNSISISAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 18}},
#define   CLNSISISCORRUPTEDLSPSDETECTED  439
	{CLNSISISCORRUPTEDLSPSDETECTED, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 19}},
#define   CLNSISISLSPL1DATABASEOVERLOADS  440
	{CLNSISISLSPL1DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 20}},
#define   CLNSISISMANUALADDRESSESDROPPEDFROMAREAS  441
	{CLNSISISMANUALADDRESSESDROPPEDFROMAREAS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 21}},
#define   CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER  442
	{CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 22}},
#define   CLNSISISSEQUENCENUMBERSKIPS  443
	{CLNSISISSEQUENCENUMBERSKIPS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 23}},
#define   CLNSISISOWNLSPPURGES  444
	{CLNSISISOWNLSPPURGES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 24}},
#define   CLNSISISIDFIELDLENGTHMISMATCHES  445
	{CLNSISISIDFIELDLENGTHMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 25}},
#define   CLNSISISMAXIMUMAREAADDRESSESMISMATCHES  446
	{CLNSISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 26}},
#define   CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES  447
	{CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 27}},
#define   CLNSISISLSPTOOLARGETOPROPAGATE  448
	{CLNSISISLSPTOOLARGETOPROPAGATE, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 28}},
#define   CLNSISISAREATRANSMITPASSWORD  449
	{CLNSISISAREATRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 29}},
#define   CLNSISISAREARECEIVEPASSWORDS  450
	{CLNSISISAREARECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 30}},
#define   CLNSISISAUTHENTICATIONFAILURES  451
	{CLNSISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 31}},
#define   CLNSISISROWSTATUS     452
	{CLNSISISROWSTATUS, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 32}},
#define   CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES  456
	{CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 1}},
#define   CLNSISISLEVEL2PARTITIONAREAADDRESSES  457
	{CLNSISISLEVEL2PARTITIONAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 2}},
#define   CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM  458
	{CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 3}},
#define   CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES  459
	{CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 4}},
#define   CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE  460
	{CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 5}},
#define   CLNSISISLEVEL2L2STATE  461
	{CLNSISISLEVEL2L2STATE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 6}},
#define   CLNSISISLEVEL2LSPL2DATABASEOVERLOADS  462
	{CLNSISISLEVEL2LSPL2DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 7}},
#define   CLNSISISLEVEL2DOMAINTRANSMITPASSWORD  463
	{CLNSISISLEVEL2DOMAINTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 8}},
#define   CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS  464
	{CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 9}},
#define   CLNSISISLEVEL2ROWSTATUS  465
	{CLNSISISLEVEL2ROWSTATUS, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 10}},
#define   LINKAGEOPERATIONALSTATE  471
	{LINKAGEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 3}},
#define   LINKAGEADMINISTRATIVESTATE  472
	{LINKAGEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 4}},
#define   LINKAGESNSERVICEPROVIDER  473
	{LINKAGESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 5}},
#define   LINKAGESNSAP          474
	{LINKAGESNSAP, ASN_OBJECT_ID, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 6}},
#define   LINKAGEOPERATIONALPROTOCOLS  475
	{LINKAGEOPERATIONALPROTOCOLS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 7}},
#define   LINKAGEISISO9542OPERATIONALSUBSETS  476
	{LINKAGEISISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 8}},
#define   LINKAGEISHOLDINGTIMERMULTIPLIER  477
	{LINKAGEISHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 9}},
#define   LINKAGEISISCONFIGURATIONTIMER  478
	{LINKAGEISISCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 10}},
#define   LINKAGEISSUGGESTEDESCONFIGURATIONTIMER  479
	{LINKAGEISSUGGESTEDESCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 11}},
#define   LINKAGEISREDIRECTHOLDINGTIME  480
	{LINKAGEISREDIRECTHOLDINGTIME, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 12}},
#define   LINKAGEISESREACHABILITYCHANGES  481
	{LINKAGEISESREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 13}},
#define   LINKAGEISINVALID9542PDUS  482
	{LINKAGEISINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 14}},
#define   LINKAGEESISO9542OPERATIONALSUBSETS  483
	{LINKAGEESISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 15}},
#define   LINKAGEESHOLDINGTIMERMULTIPLIER  484
	{LINKAGEESHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 16}},
#define   LINKAGEESMANUALISSNPAADDRESS  485
	{LINKAGEESMANUALISSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 17}},
#define   LINKAGEESDEFAULTESCONFIGTIMER  486
	{LINKAGEESDEFAULTESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 18}},
#define   LINKAGEESACTIVEESCONFIGTIMER  487
	{LINKAGEESACTIVEESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 19}},
#define   LINKAGEESISREACHABILITYCHANGES  488
	{LINKAGEESISREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 20}},
#define   LINKAGEESINVALID9542PDUS  489
	{LINKAGEESINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 21}},
#define   LINKAGEENABLECHECKSUM  490
	{LINKAGEENABLECHECKSUM, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 22}},
#define   LINKAGEINITIALMINIMUMTIMER  491
	{LINKAGEINITIALMINIMUMTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 23}},
#define   LINKAGERESERVETIMER   492
	{LINKAGERESERVETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 24}},
#define   LINKAGEIDLETIMER      493
	{LINKAGEIDLETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 25}},
#define   LINKAGESNDCFCALLSPLACED  494
	{LINKAGESNDCFCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 26}},
#define   LINKAGESNDCFCALLSFAILED  495
	{LINKAGESNDCFCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 27}},
#define   LINKAGECODLCALLSPLACED  496
	{LINKAGECODLCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 28}},
#define   LINKAGECODLCALLSFAILED  497
	{LINKAGECODLCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 29}},
#define   LINKAGEISISTYPE       498
	{LINKAGEISISTYPE, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 30}},
#define   LINKAGEISISISISHELLOTIMER  499
	{LINKAGEISISISISHELLOTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 31}},
#define   LINKAGEISISL1DEFAULTMETRIC  500
	{LINKAGEISISL1DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 32}},
#define   LINKAGEISISL1DELAYMETRIC  501
	{LINKAGEISISL1DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 33}},
#define   LINKAGEISISL1EXPENSEMETRIC  502
	{LINKAGEISISL1EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 34}},
#define   LINKAGEISISL1ERRORMETRIC  503
	{LINKAGEISISL1ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 35}},
#define   LINKAGEISISEXTERNALDOMAIN  504
	{LINKAGEISISEXTERNALDOMAIN, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 36}},
#define   LINKAGEISISCHANGEDINADJACENCYSTATE  505
	{LINKAGEISISCHANGEDINADJACENCYSTATE, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 37}},
#define   LINKAGEISISINITIALISATIONFAILURES  506
	{LINKAGEISISINITIALISATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 38}},
#define   LINKAGEISISREJECTEDADJACENCIES  507
	{LINKAGEISISREJECTEDADJACENCIES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 39}},
#define   LINKAGEISISISISCONTROLPDUSSENT  508
	{LINKAGEISISISISCONTROLPDUSSENT, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 40}},
#define   LINKAGEISISISISCONTROLPDUSRECEIVED  509
	{LINKAGEISISISISCONTROLPDUSRECEIVED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 41}},
#define   LINKAGEISISIDFIELDLENTHMISMATCHES  510
	{LINKAGEISISIDFIELDLENTHMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 42}},
#define   LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES  511
	{LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 43}},
#define   LINKAGEISISCIRCUITTRANSMITPASSWORD  512
	{LINKAGEISISCIRCUITTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 44}},
#define   LINKAGEISISCIRCUITRECEIVEDPASSWORDS  513
	{LINKAGEISISCIRCUITRECEIVEDPASSWORDS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 45}},
#define   LINKAGEISISAUTHENTICATIONFAILURES  514
	{LINKAGEISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 46}},
#define   LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY  515
	{LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 47}},
#define   LINKAGEISISL1CIRCUITID  516
	{LINKAGEISISL1CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 48}},
#define   LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM  517
	{LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 49}},
#define   LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES  518
	{LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 50}},
#define   LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT  519
	{LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 51}},
#define   LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT  520
	{LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 52}},
#define   LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT  521
	{LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 53}},
#define   LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT  522
	{LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 54}},
#define   LINKAGEISISPTPTCIRCUITID  523
	{LINKAGEISISPTPTCIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 55}},
#define   LINKAGEISISOUTGOINGCALLIVMO  524
	{LINKAGEISISOUTGOINGCALLIVMO, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 56}},
#define   LINKAGEISISNEIGHBORSNPAADDRESS  525
	{LINKAGEISISNEIGHBORSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 57}},
#define   LINKAGEISISL2DEFAULTMETRIC  526
	{LINKAGEISISL2DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 58}},
#define   LINKAGEISISL2DELAYMETRIC  527
	{LINKAGEISISL2DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 59}},
#define   LINKAGEISISL2EXPENSEMETRIC  528
	{LINKAGEISISL2EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 60}},
#define   LINKAGEISISL2ERRORMETRIC  529
	{LINKAGEISISL2ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 61}},
#define   LINKAGEISISMANUALL2ONLYMODE  530
	{LINKAGEISISMANUALL2ONLYMODE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 62}},
#define   LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY  531
	{LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 63}},
#define   LINKAGEISISL2CIRCUITID  532
	{LINKAGEISISL2CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 64}},
#define   LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM  533
	{LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 65}},
#define   LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES  534
	{LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 66}},
#define   LINKAGEROWSTATUS      535
	{LINKAGEROWSTATUS, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 67}},
#define   CONSADMINISTRATIVESTATE  540
	{CONSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 1}},
#define   CONSOPERATIONALSYSTEMTYPE  541
	{CONSOPERATIONALSYSTEMTYPE, ASN_BIT_STR, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 2}},
#define   CONSROWSTATUS         542
	{CONSROWSTATUS, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 3}},
#define   NETWORKCONNECTIONLOCALNSAPMO  548
	{NETWORKCONNECTIONLOCALNSAPMO, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 1}},
#define   NETWORKCONNECTIONREMOTENSAPADDRESS  549
	{NETWORKCONNECTIONREMOTENSAPADDRESS, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 2}},
#define   NETWORKCONNECTIONROWSTATUS  550
	{NETWORKCONNECTIONROWSTATUS, ASN_INTEGER, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 3}},
#define   X25PLEOPERATIONALSTATE  554
	{X25PLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 2}},
#define   X25PLEADMINISTRATIVESTATE  555
	{X25PLEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 3}},
#define   X25PLEPROTOCOLVERSIONSUPPORTED  556
	{X25PLEPROTOCOLVERSIONSUPPORTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 4}},
#define   X25PLELOCALDTEADDRESS  557
	{X25PLELOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 5}},
#define   X25PLEMODE            558
	{X25PLEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 6}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSES  559
	{X25PLEDEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 7}},
#define   X25PLEFLOWCONTROLPARAMETERNEGOTIATION  560
	{X25PLEFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 8}},
#define   X25PLEDEFAULTPACKAGESIZES  561
	{X25PLEDEFAULTPACKAGESIZES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 9}},
#define   X25PLETHROUGHPUTCLASSNEGOTIATION  562
	{X25PLETHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 10}},
#define   X25PLESNSERVICEPROVIDER  563
	{X25PLESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 11}},
#define   X25PLESNSAP           564
	{X25PLESNSAP, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 12}},
#define   X25PELOGICALCHANNELASSIGNMENTS  565
	{X25PELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 13}},
#define   X25PLEINTERFACEMODE   566
	{X25PLEINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 14}},
#define   X25PLEDEFAULTTHROUGHPUTCLASS  567
	{X25PLEDEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 15}},
#define   X25PLEFLOWCONTROLNEGOTIATIONPERMITTED  568
	{X25PLEFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 16}},
#define   X25PLECALLDEFLECTIONSUBSCRIPTION  569
	{X25PLECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 17}},
#define   X25PLEMAXACTIVECIRCUITS  570
	{X25PLEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 18}},
#define   X25PLERESTARTTIME     571
	{X25PLERESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 19}},
#define   X25PLEDEFAULTPACKETSIZE  572
	{X25PLEDEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 20}},
#define   X25PLEDEFAULTWINDOWSIZE  573
	{X25PLEDEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 21}},
#define   X25PLEMINIMUMRECALLTIMER  574
	{X25PLEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 22}},
#define   X25PLERESTARTCOUNT    575
	{X25PLERESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 23}},
#define   X25PLESN_SERVICEPROVIDER  576
	{X25PLESN_SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 24}},
#define   X25PLESN_SA_P         577
	{X25PLESN_SA_P, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 25}},
#define   X25PLELOGICALCHANNELASSIGNMENTS  578
	{X25PLELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 26}},
#define   X25PLEPACKETSEQUENCING  579
	{X25PLEPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 27}},
#define   X25PLEOCTETSSENTCOUNTER  580
	{X25PLEOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 28}},
#define   X25PLEOCTETSRECEIVEDCOUNTER  581
	{X25PLEOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 29}},
#define   X25PLEDATAPACKETSSENT  582
	{X25PLEDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 30}},
#define   X25PLEDATAPACKETSRECEIVED  583
	{X25PLEDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 31}},
#define   X25PLECALLATTEMPTS    584
	{X25PLECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 32}},
#define   X25PLECALLSCONNECTED  585
	{X25PLECALLSCONNECTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 33}},
#define   X25PLEPROVIDERINITIATEDDISCONNECTS  586
	{X25PLEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 34}},
#define   X25PLECALLTIMEOUTS    587
	{X25PLECALLTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 35}},
#define   X25PLECLEARTIMEOUTS   588
	{X25PLECLEARTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 36}},
#define   X25PLEREMOTELYINITIATEDRESETS  589
	{X25PLEREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 37}},
#define   X25PLEDATARETRANSMISSIONTIMEREXPIRIES  590
	{X25PLEDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 38}},
#define   X25PLEPROVIDERINITIATEDRESETS  591
	{X25PLEPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 39}},
#define   X25PLERESETTIMEOUTS   592
	{X25PLERESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 40}},
#define   X25PLEREMOTELYINITIATEDRESTARTS  593
	{X25PLEREMOTELYINITIATEDRESTARTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 41}},
#define   X25PLERESTARTCOUNTSEXCEEDED  594
	{X25PLERESTARTCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 42}},
#define   X25PLEPROTOCOLERRORSDETECTEDLOCALLY  595
	{X25PLEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 43}},
#define   X25PLEPROTOCOLERRORSACCUSEDOF  596
	{X25PLEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 44}},
#define   X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  597
	{X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 45}},
#define   X25PLECLEARCOUNTSEXCEEDED  598
	{X25PLECLEARCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 46}},
#define   X25PLEPLECLIENTMONAME  599
	{X25PLEPLECLIENTMONAME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 47}},
#define   X25PLEREGISTRATIONREQUESTTIME  600
	{X25PLEREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 48}},
#define   X25PLEREGISTRATIONREQUESTCOUNT  601
	{X25PLEREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 49}},
#define   X25PLEREGISTRATIONPERMITTED  602
	{X25PLEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 50}},
#define   X25PLEROWSTATUS       603
	{X25PLEROWSTATUS, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 51}},
#define   X25PLE_DTECALLDEFLECTIONSUBSCRIPTION  607
	{X25PLE_DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 1}},
#define   X25PLE_DTECALLREQUESTRESPONSETIMER  608
	{X25PLE_DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 2}},
#define   X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING  609
	{X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 3}},
#define   X25PLE_DTEMAXACTIVECIRCUITS  610
	{X25PLE_DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 4}},
#define   X25PLE_DTEMINIMUMRECALLTIMER  611
	{X25PLE_DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 5}},
#define   X25PLE_DTERESETREQUESTRESPONSETIMER  612
	{X25PLE_DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 6}},
#define   X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT  613
	{X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 7}},
#define   X25PLE_DTERESTARTREQUESTRESPONSETIMER  614
	{X25PLE_DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 8}},
#define   X25PLE_DTECLEARREQUESTRESPONSETIMER  615
	{X25PLE_DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 9}},
#define   X25PLE_DTEINTERRUPTRESPONSETIMER  616
	{X25PLE_DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 10}},
#define   X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT  617
	{X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 11}},
#define   X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT  618
	{X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 12}},
#define   X25PLE_DTECALLATTEMPTS  619
	{X25PLE_DTECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 13}},
#define   X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY  620
	{X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 14}},
#define   X25PLE_DTEPROTOCOLERRORSACCUSEDOF  621
	{X25PLE_DTEPROTOCOLERRORSACCUSEDOF, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 15}},
#define   X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  622
	{X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 16}},
#define   X25PLE_DTEOCTETSRECEIVEDCOUNTER  623
	{X25PLE_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 17}},
#define   X25PLE_DTEOCTETSSENTCOUNTER  624
	{X25PLE_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 18}},
#define   X25PLE_DTECALLTIMEOUTS  625
	{X25PLE_DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 19}},
#define   X25PLE_DTECALLSCONNECTED  626
	{X25PLE_DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 20}},
#define   X25PLE_DTECLEARCOUNTSEXCEEDED  627
	{X25PLE_DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 21}},
#define   X25PLE_DTECLEARTIMEOUTS  628
	{X25PLE_DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 22}},
#define   X25PLE_DTEDATAPACKETSRECEIVED  629
	{X25PLE_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 23}},
#define   X25PLE_DTEDATAPACKETSSENT  630
	{X25PLE_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 24}},
#define   X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES  631
	{X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 25}},
#define   X25PLE_DTEPROVIDERINITIATEDRESETS  632
	{X25PLE_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 26}},
#define   X25PLE_DTEPROVIDERINITIATEDDISCONNECTS  633
	{X25PLE_DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 27}},
#define   X25PLE_DTEREMOTELYINITIATEDRESETS  634
	{X25PLE_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 28}},
#define   X25PLE_DTEREMOTELYINITIATEDRESTARTS  635
	{X25PLE_DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 29}},
#define   X25PLE_DTERESETTIMEOUTS  636
	{X25PLE_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 30}},
#define   X25PLE_DTERESTARTCOUNTSEXCEEDED  637
	{X25PLE_DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 31}},
#define   X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER  638
	{X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 32}},
#define   X25PLE_DTEWINDOWROTATIONTIMER  639
	{X25PLE_DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 33}},
#define   X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT  640
	{X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 34}},
#define   X25PLE_DTEREJECTRESPONSETIMER  641
	{X25PLE_DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 35}},
#define   X25PLE_DTEREJECTRETRANSMISSIONCOUNT  642
	{X25PLE_DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 36}},
#define   X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER  643
	{X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 37}},
#define   X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  644
	{X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 38}},
#define   X25PLE_DTEREGISTRATIONPERMITTED  645
	{X25PLE_DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 39}},
#define   X25PLE_DCECALLATTEMPTS  649
	{X25PLE_DCECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 1}},
#define   X25PLE_DCECALLSCONNECTED  650
	{X25PLE_DCECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 2}},
#define   X25PLE_DCECUG         651
	{X25PLE_DCECUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 3}},
#define   X25PLE_DCEFASTSELECTACCEPTANCE  652
	{X25PLE_DCEFASTSELECTACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 4}},
#define   X25PLE_DCEINCOMINGCALLSBARRED  653
	{X25PLE_DCEINCOMINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 5}},
#define   X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING  654
	{X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 6}},
#define   X25PLE_DCEOUTGOINGCALLSBARRED  655
	{X25PLE_DCEOUTGOINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 7}},
#define   X25PLE_DCEDATAPACKETSRECEIVED  656
	{X25PLE_DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 8}},
#define   X25PLE_DCEDATAPACKETSSENT  657
	{X25PLE_DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 9}},
#define   X25PLE_DCEINTERRUPTPACKETSRECEIVED  658
	{X25PLE_DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 10}},
#define   X25PLE_DCEINTERRUPTPACKETSSENT  659
	{X25PLE_DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 11}},
#define   X25PLE_DCEINTERRUPTTIMEREXPIRIES  660
	{X25PLE_DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 12}},
#define   X25PLE_DCEOCTETSRECEIVEDCOUNTER  661
	{X25PLE_DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 13}},
#define   X25PLE_DCEOCTETSSENTCOUNTER  662
	{X25PLE_DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 14}},
#define   X25PLE_DCEPROVIDERINITIATEDDISCONNECTS  663
	{X25PLE_DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 15}},
#define   X25PLE_DCEPROVIDERINITIATEDRESETS  664
	{X25PLE_DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 16}},
#define   X25PLE_DCEREMOTELYINITIATEDRESTARTS  665
	{X25PLE_DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 17}},
#define   X25PLE_DCEREMOTELYINITIATEDRESETS  666
	{X25PLE_DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 18}},
#define   X25PLE_DCERESETTIMEOUTS  667
	{X25PLE_DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 19}},
#define   X25PLE_DCEX25SEGMENTSRECEIVED  668
	{X25PLE_DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 20}},
#define   X25PLE_DCEX25SEGMENTSSENT  669
	{X25PLE_DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 21}},
#define   X25PLE_DCEBILATERALCUG  670
	{X25PLE_DCEBILATERALCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 22}},
#define   X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS  671
	{X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 23}},
#define   X25PLE_DCECALLDEFLECTIONSUBSCRIPTION  672
	{X25PLE_DCECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 24}},
#define   X25PLE_DCECALLREDIRECTION  673
	{X25PLE_DCECALLREDIRECTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 25}},
#define   X25PLE_DCECHARGINGINFORMATION  674
	{X25PLE_DCECHARGINGINFORMATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 26}},
#define   X25PLE_DCECUGWITHINCOMINGACCESS  675
	{X25PLE_DCECUGWITHINCOMINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 27}},
#define   X25PLE_DCECUGWITHOUTGOINGACCESS  676
	{X25PLE_DCECUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 28}},
#define   X25PLE_DCEDBITMODIFICATION  677
	{X25PLE_DCEDBITMODIFICATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 29}},
#define   X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT  678
	{X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 30}},
#define   X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING  679
	{X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 31}},
#define   X25PLE_DCEHUNTGROUP   680
	{X25PLE_DCEHUNTGROUP, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 32}},
#define   X25PLE_DCEINCOMINGCALLBARREDWITHINCUG  681
	{X25PLE_DCEINCOMINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 33}},
#define   X25PLE_DCELOCALCHARGINGPREVENTION  682
	{X25PLE_DCELOCALCHARGINGPREVENTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 34}},
#define   X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES  683
	{X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 35}},
#define   X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES  684
	{X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 36}},
#define   X25PLE_DCENUIOVERRIDE  685
	{X25PLE_DCENUIOVERRIDE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 37}},
#define   X25PLE_DCENUISUBSCRIPTION  686
	{X25PLE_DCENUISUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 38}},
#define   X25PLE_DCEONEWAYLOGICALCHANNELINCOMING  687
	{X25PLE_DCEONEWAYLOGICALCHANNELINCOMING, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 39}},
#define   X25PLE_DCEONLINEFACILITYREGISTRATION  688
	{X25PLE_DCEONLINEFACILITYREGISTRATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 40}},
#define   X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG  689
	{X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 41}},
#define   X25PLE_DCEPACKETRETRANSMISSION  690
	{X25PLE_DCEPACKETRETRANSMISSION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 42}},
#define   X25PLE_DCEREVERSECHARGINGACCEPTANCE  691
	{X25PLE_DCEREVERSECHARGINGACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 43}},
#define   X25PLE_DCEROASUBSCRIPTION  692
	{X25PLE_DCEROASUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 44}},
#define   X25PLE_DCECLEARINDICATION  693
	{X25PLE_DCECLEARINDICATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 45}},
#define   X25PLE_DCEINCOMINGCALL  694
	{X25PLE_DCEINCOMINGCALL, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 46}},
#define   X25PLE_DCERESETINDICATION  695
	{X25PLE_DCERESETINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 47}},
#define   X25PLE_DCERESTARTINDICATION  696
	{X25PLE_DCERESTARTINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 48}},
#define   X25PLEIVMOLOCALDTEADDRESS  700
	{X25PLEIVMOLOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 2}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTS  701
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 3}},
#define   X25PLEIVMOSN_SERVICEPROVIDER  702
	{X25PLEIVMOSN_SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 4}},
#define   X25PLEIVMODEFAULTPACKETSIZES  703
	{X25PLEIVMODEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 5}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSES  704
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 6}},
#define   X25PLEIVMODEFAULTWINDOWSIZES  705
	{X25PLEIVMODEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 7}},
#define   X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION  706
	{X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 8}},
#define   X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION  707
	{X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 9}},
#define   X25PLEIVMOX25PLEMODE  708
	{X25PLEIVMOX25PLEMODE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 10}},
#define   X25PLEIVMOINTERFACEMODE  709
	{X25PLEIVMOINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 11}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASS  710
	{X25PLEIVMODEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 12}},
#define   X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED  711
	{X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 13}},
#define   X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION  712
	{X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 14}},
#define   X25PLEIVMOMAXACTIVECIRCUITS  713
	{X25PLEIVMOMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 15}},
#define   X25PLEIVMORESTARTTIME  714
	{X25PLEIVMORESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 16}},
#define   X25PLEIVMODEFAULTPACKETSIZE  715
	{X25PLEIVMODEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 17}},
#define   X25PLEIVMODEFAULTWINDOWSIZE  716
	{X25PLEIVMODEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 18}},
#define   X25PLEIVMOMINIMUMRECALLTIMER  717
	{X25PLEIVMOMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 19}},
#define   X25PLEIVMORESTARTCOUNT  718
	{X25PLEIVMORESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 20}},
#define   X25PLEIVMOPACKETSEQUENCING  719
	{X25PLEIVMOPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 21}},
#define   X25PLEIVMOREGISTRATIONREQUESTTIME  720
	{X25PLEIVMOREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 22}},
#define   X25PLEIVMOREGISTRATIONREQUESTCOUNT  721
	{X25PLEIVMOREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 23}},
#define   X25PLEIVMOREGISTRATIONPERMITTED  722
	{X25PLEIVMOREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 24}},
#define   X25PLEIVMOROWSTATUS   723
	{X25PLEIVMOROWSTATUS, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 25}},
#define   X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION  727
	{X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 1}},
#define   X25PLEIVMO_DTECALLREQUESTRESPONSETIMER  728
	{X25PLEIVMO_DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 2}},
#define   X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING  729
	{X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 3}},
#define   X25PLEIVMO_DTEMAXACTIVECIRCUITS  730
	{X25PLEIVMO_DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 4}},
#define   X25PLEIVMO_DTEMINIMUMRECALLTIMER  731
	{X25PLEIVMO_DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 5}},
#define   X25PLEIVMO_DTERESETREQUESTRESPONSETIMER  732
	{X25PLEIVMO_DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 6}},
#define   X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT  733
	{X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 7}},
#define   X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER  734
	{X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 8}},
#define   X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER  735
	{X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 9}},
#define   X25PLEIVMO_DTEINTERRUPTRESPONSETIMER  736
	{X25PLEIVMO_DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 10}},
#define   X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT  737
	{X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 11}},
#define   X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT  738
	{X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 12}},
#define   X25PLEIVMO_DTECALLATTEMPTS  739
	{X25PLEIVMO_DTECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 13}},
#define   X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY  740
	{X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 14}},
#define   X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF  741
	{X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 15}},
#define   X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  742
	{X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 16}},
#define   X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER  743
	{X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 17}},
#define   X25PLEIVMO_DTEOCTETSSENTCOUNTER  744
	{X25PLEIVMO_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 18}},
#define   X25PLEIVMO_DTECALLTIMEOUTS  745
	{X25PLEIVMO_DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 19}},
#define   X25PLEIVMO_DTECALLSCONNECTED  746
	{X25PLEIVMO_DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 20}},
#define   X25PLEIVMO_DTECLEARCOUNTSEXCEEDED  747
	{X25PLEIVMO_DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 21}},
#define   X25PLEIVMO_DTECLEARTIMEOUTS  748
	{X25PLEIVMO_DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 22}},
#define   X25PLEIVMO_DTEDATAPACKETSRECEIVED  749
	{X25PLEIVMO_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 23}},
#define   X25PLEIVMO_DTEDATAPACKETSSENT  750
	{X25PLEIVMO_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 24}},
#define   X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES  751
	{X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 25}},
#define   X25PLEIVMO_DTEPROVIDERINITIATEDRESETS  752
	{X25PLEIVMO_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 26}},
#define   X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS  753
	{X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 27}},
#define   X25PLEIVMO_DTEREMOTELYINITIATEDRESETS  754
	{X25PLEIVMO_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 28}},
#define   X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS  755
	{X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 29}},
#define   X25PLEIVMO_DTERESETTIMEOUTS  756
	{X25PLEIVMO_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 30}},
#define   X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED  757
	{X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 31}},
#define   X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER  758
	{X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 32}},
#define   X25PLEIVMO_DTEWINDOWROTATIONTIMER  759
	{X25PLEIVMO_DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 33}},
#define   X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT  760
	{X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 34}},
#define   X25PLEIVMO_DTEREJECTRESPONSETIMER  761
	{X25PLEIVMO_DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 35}},
#define   X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT  762
	{X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 36}},
#define   X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER  763
	{X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 37}},
#define   X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  764
	{X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 38}},
#define   X25PLEIVMO_DTEREGISTRATIONPERMITTED  765
	{X25PLEIVMO_DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 39}},
#define   X25PLEIVMO_DTEROWSTATUS  766
	{X25PLEIVMO_DTEROWSTATUS, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 40}},
#define   X25PLEIVMO_DCEROWSTATUS  770
	{X25PLEIVMO_DCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMO_DCETable, 6, {1, 1, 45, 1, 1, 1}},
#define   VIRTUALCALLCHANNEL    774
	{VIRTUALCALLCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 2}},
#define   VIRTUALCALLPACKETSIZE  775
	{VIRTUALCALLPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 3}},
#define   VIRTUALCALLWINDOWSIZE  776
	{VIRTUALCALLWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 4}},
#define   VIRTUALCALLOCTETSSENTCOUNTER  777
	{VIRTUALCALLOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 5}},
#define   VIRTUALCALLOCTETSRECEIVEDCOUNTER  778
	{VIRTUALCALLOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 6}},
#define   VIRTUALCALLDATAPACKETSSENT  779
	{VIRTUALCALLDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 7}},
#define   VIRTUALCALLDATAPACKETSRECEIVED  780
	{VIRTUALCALLDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 8}},
#define   VIRTUALCALLREMOTELYINITIATEDRESETS  781
	{VIRTUALCALLREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 9}},
#define   VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES  782
	{VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 10}},
#define   VIRTUALCALLPROVIDERINITIATEDRESETS  783
	{VIRTUALCALLPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 11}},
#define   VIRTUALCALLRESETTIMEOUTS  784
	{VIRTUALCALLRESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 12}},
#define   VIRTUALCALLINTERRUPTPACKETSSENT  785
	{VIRTUALCALLINTERRUPTPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 13}},
#define   VIRTUALCALLINTERRUPTPACKETSRECEIVED  786
	{VIRTUALCALLINTERRUPTPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 14}},
#define   VIRTUALCALLINTERRUPTTIMEREXPIRIES  787
	{VIRTUALCALLINTERRUPTTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 15}},
#define   VIRTUALCIRCUITLOGICALCHANNEL  791
	{VIRTUALCIRCUITLOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 2}},
#define   VIRTUALCIRCUITPACKETSIZES  792
	{VIRTUALCIRCUITPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 3}},
#define   VIRTUALCIRCUITTHROUGHPUTCLASSES  793
	{VIRTUALCIRCUITTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 4}},
#define   VIRTUALCIRCUITWINDOWSIZES  794
	{VIRTUALCIRCUITWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER  798
	{VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 1}},
#define   VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER  799
	{VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 2}},
#define   VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED  800
	{VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 3}},
#define   VIRTUALCIRCUIT_DTEDATAPACKETSSENT  801
	{VIRTUALCIRCUIT_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 4}},
#define   VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES  802
	{VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED  803
	{VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 6}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT  804
	{VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 7}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES  805
	{VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 8}},
#define   VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS  806
	{VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 9}},
#define   VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS  807
	{VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 10}},
#define   VIRTUALCIRCUIT_DTERESETTIMEOUTS  808
	{VIRTUALCIRCUIT_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 11}},
#define   VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED  812
	{VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 1}},
#define   VIRTUALCIRCUIT_DCEDATAPACKETSSENT  813
	{VIRTUALCIRCUIT_DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 2}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED  814
	{VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 3}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT  815
	{VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 4}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES  816
	{VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER  817
	{VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 6}},
#define   VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER  818
	{VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 7}},
#define   VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS  819
	{VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 8}},
#define   VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS  820
	{VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 9}},
#define   VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS  821
	{VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 10}},
#define   VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS  822
	{VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 11}},
#define   VIRTUALCIRCUIT_DCERESETTIMEOUTS  823
	{VIRTUALCIRCUIT_DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 12}},
#define   VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED  824
	{VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 13}},
#define   VIRTUALCIRCUIT_DCEX25SEGMENTSSENT  825
	{VIRTUALCIRCUIT_DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 14}},
#define   PERMANENTVIRTUALCIRCUITCHANNEL  830
	{PERMANENTVIRTUALCIRCUITCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUITROWSTATUS  831
	{PERMANENTVIRTUALCIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL  836
	{PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES  837
	{PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES  838
	{PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES  839
	{PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS  840
	{PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION  845
	{PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL  846
	{PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES  847
	{PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES  848
	{PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES  849
	{PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE  850
	{PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 6}},
#define   PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS  851
	{PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 7}},
#define   PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL  852
	{PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 8}},
#define   PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS  853
	{PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 9}},
#define   VIRTUALCALLIVMOFASTSELECT  858
	{VIRTUALCALLIVMOFASTSELECT, ASN_INTEGER, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 2}},
#define   VIRTUALCALLIVMOPACKETSIZES  859
	{VIRTUALCALLIVMOPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 3}},
#define   VIRTUALCALLIVMOREVERSECHARGING  860
	{VIRTUALCALLIVMOREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 4}},
#define   VIRTUALCALLIVMOTHROUGHPUTCLASSES  861
	{VIRTUALCALLIVMOTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 5}},
#define   VIRTUALCALLIVMOWINDOWSIZES  862
	{VIRTUALCALLIVMOWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 6}},
#define   VIRTUALCALLIVMOPROPOSEDPACKETSIZE  863
	{VIRTUALCALLIVMOPROPOSEDPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 7}},
#define   VIRTUALCALLIVMOPROPOSEDWINDOWSIZE  864
	{VIRTUALCALLIVMOPROPOSEDWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 8}},
#define   VIRTUALCALLIVMOACCEPTREVERSECHARGING  865
	{VIRTUALCALLIVMOACCEPTREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 9}},
#define   VIRTUALCALLIVMOPROPOSEREVERSECHARGING  866
	{VIRTUALCALLIVMOPROPOSEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 10}},
#define   VIRTUALCALLIVMOCALLTIME  867
	{VIRTUALCALLIVMOCALLTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 11}},
#define   VIRTUALCALLIVMORESETTIME  868
	{VIRTUALCALLIVMORESETTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 12}},
#define   VIRTUALCALLIVMOCLEARTIME  869
	{VIRTUALCALLIVMOCLEARTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 13}},
#define   VIRTUALCALLIVMOINTERRUPTTIME  870
	{VIRTUALCALLIVMOINTERRUPTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 14}},
#define   VIRTUALCALLIVMORESETCOUNT  871
	{VIRTUALCALLIVMORESETCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 15}},
#define   VIRTUALCALLIVMOCLEARCOUNT  872
	{VIRTUALCALLIVMOCLEARCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 16}},
#define   VIRTUALCALLIVMOWINDOWTIME  873
	{VIRTUALCALLIVMOWINDOWTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 17}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONTIME  874
	{VIRTUALCALLIVMODATARETRANSMISSIONTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 18}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONCOUNT  875
	{VIRTUALCALLIVMODATARETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 19}},
#define   VIRTUALCALLIVMOREJECTTIME  876
	{VIRTUALCALLIVMOREJECTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 20}},
#define   VIRTUALCALLIVMOREJECTCOUNT  877
	{VIRTUALCALLIVMOREJECTCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 21}},
#define   VIRTUALCALLIVMOROWSTATUS  878
	{VIRTUALCALLIVMOROWSTATUS, ASN_INTEGER, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 22}},
#define   SWITCHEDVIRTUALCALLDIRECTION  883
	{SWITCHEDVIRTUALCALLDIRECTION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 1}},
#define   SWITCHEDVIRTUALCALLREMOTEDTEADDRESS  884
	{SWITCHEDVIRTUALCALLREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 2}},
#define   SWITCHEDVIRTUALCALLTHROUGHPUTCLASS  885
	{SWITCHEDVIRTUALCALLTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 3}},
#define   SWITCHEDVIRTUALCALLREDIRECTREASON  886
	{SWITCHEDVIRTUALCALLREDIRECTREASON, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 4}},
#define   SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS  887
	{SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 5}},
#define   SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION  888
	{SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 6}},
#define   SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION  889
	{SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 7}},
#define   SWITCHEDVIRTUALCALLROWSTATUS  890
	{SWITCHEDVIRTUALCALLROWSTATUS, ASN_INTEGER, RWRITE, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 8}},
#define   VIRTUALCALL_DTECALLINGADDRESSEXTENSION  895
	{VIRTUALCALL_DTECALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 1}},
#define   VIRTUALCALL_DTECALLEDADDRESSEXTENSION  896
	{VIRTUALCALL_DTECALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 2}},
#define   VIRTUALCALL_DTEDIRECTION  897
	{VIRTUALCALL_DTEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 3}},
#define   VIRTUALCALL_DTEFASTSELECT  898
	{VIRTUALCALL_DTEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 4}},
#define   VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS  899
	{VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 5}},
#define   VIRTUALCALL_DTEREDIRECTREASON  900
	{VIRTUALCALL_DTEREDIRECTREASON, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 6}},
#define   VIRTUALCALL_DTEREMOTEDTEADDRESS  901
	{VIRTUALCALL_DTEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 7}},
#define   VIRTUALCALL_DTEREVERSECHARGING  902
	{VIRTUALCALL_DTEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 8}},
#define   VIRTUALCALL_DTEROWSTATUS  903
	{VIRTUALCALL_DTEROWSTATUS, ASN_INTEGER, RWRITE, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 9}},
#define   VIRTUALCALL_DCECHARGINGDIRECTION  908
	{VIRTUALCALL_DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 1}},
#define   VIRTUALCALL_DCECUGSELECTION  909
	{VIRTUALCALL_DCECUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 2}},
#define   VIRTUALCALL_DCEDIRECTION  910
	{VIRTUALCALL_DCEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 3}},
#define   VIRTUALCALL_DCEFASTSELECT  911
	{VIRTUALCALL_DCEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 4}},
#define   VIRTUALCALL_DCEREMOTEDTEADDRESS  912
	{VIRTUALCALL_DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 5}},
#define   VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION  913
	{VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 6}},
#define   VIRTUALCALL_DCEBILATERALCUGSELECTION  914
	{VIRTUALCALL_DCEBILATERALCUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 7}},
#define   VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION  915
	{VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 8}},
#define   VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION  916
	{VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 9}},
#define   VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION  917
	{VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 10}},
#define   VIRTUALCALL_DCENUISELECTION  918
	{VIRTUALCALL_DCENUISELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 11}},
#define   VIRTUALCALL_DCEREVERSECHARGING  919
	{VIRTUALCALL_DCEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 12}},
#define   VIRTUALCALL_DCEROASELECTION  920
	{VIRTUALCALL_DCEROASELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 13}},
#define   VIRTUALCALL_DCEROWSTATUS  921
	{VIRTUALCALL_DCEROWSTATUS, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 14}},
#define   DSERIESRESETREQUESTINDICATIONPACKETS  927
	{DSERIESRESETREQUESTINDICATIONPACKETS, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 2}},
#define   DSERIESSEGMENTSSENT   928
	{DSERIESSEGMENTSSENT, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 3}},
#define   DSERIESSEGMENTSRECEIVED  929
	{DSERIESSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 4}},
#define   DSERIESROWSTATUS      930
	{DSERIESROWSTATUS, ASN_INTEGER, RWRITE, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 5}},
#define   ADJACENCYSTATE        937
	{ADJACENCYSTATE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 2}},
#define   NEIGHBOURSNPAADDRESS  938
	{NEIGHBOURSNPAADDRESS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 3}},
#define   NEIGHBOURSYSTEMTYPE   939
	{NEIGHBOURSYSTEMTYPE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 4}},
#define   NEIGHBOURSYSTEMIDS    940
	{NEIGHBOURSYSTEMIDS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 5}},
#define   ADJACENCYUSAGE        941
	{ADJACENCYUSAGE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 6}},
#define   AREAADDRESSESOFNEIGHBOUR  942
	{AREAADDRESSESOFNEIGHBOUR, ASN_OCTET_STR, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 7}},
#define   HOLDINGTIMER          943
	{HOLDINGTIMER, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 8}},
#define   PRIORITYOFNEIGHBOUR   944
	{PRIORITYOFNEIGHBOUR, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 9}},
#define   ADJACENCYROWSTATUS    945
	{ADJACENCYROWSTATUS, ASN_INTEGER, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 10}},
#define   VIRTUALADJACENCYMETRIC  951
	{VIRTUALADJACENCYMETRIC, ASN_INTEGER, RONLY, var_virtualAdjacencyTable, 6, {1, 1, 59, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICPATHCOST  957
	{DESTINATIONDEFAULTMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES  958
	{DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 3}},
#define   DESTINATIONDELAYMETRICPATHCOST  959
	{DESTINATIONDELAYMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 4}},
#define   DESTINATIONDELAYMETRICOUTPUTADJACENCIES  960
	{DESTINATIONDELAYMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 5}},
#define   DESTINATIONEXPENSEMETRICPATHCOST  961
	{DESTINATIONEXPENSEMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 6}},
#define   DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES  962
	{DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 7}},
#define   DESTINATIONERRORMETRICPATHCOST  963
	{DESTINATIONERRORMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 8}},
#define   DESTINATIONERRORMETRICOUTPUTADJACENCIES  964
	{DESTINATIONERRORMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 9}},
#define   DESINTATIONSYSTEMMETRIC  971
	{DESINTATIONSYSTEMMETRIC, ASN_INTEGER, RONLY, var_destinationSystemTable, 6, {1, 1, 61, 1, 1, 3}},
#define   DESTINATIONAREAID     975
	{DESTINATIONAREAID, ASN_OCTET_STR, RONLY, var_destinationAreaTable, 6, {1, 1, 62, 1, 1, 1}},
#define   REACHABLEADDRESSPREFIX  979
	{REACHABLEADDRESSPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 2}},
#define   REACHABLEADDRESSMAPPINGTYPE  980
	{REACHABLEADDRESSMAPPINGTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 3}},
#define   REACHABLEADDRESSDEFAULTMETRIC  981
	{REACHABLEADDRESSDEFAULTMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 4}},
#define   REACHABLEADDRESSDELAYMETRIC  982
	{REACHABLEADDRESSDELAYMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 5}},
#define   REACHABLEADDRESSEXPENSEMETRIC  983
	{REACHABLEADDRESSEXPENSEMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 6}},
#define   REACHABLEADDRESSERRORMETRIC  984
	{REACHABLEADDRESSERRORMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 7}},
#define   REACHABLEADDRESSDEFAULTMETRICTYPE  985
	{REACHABLEADDRESSDEFAULTMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 8}},
#define   REACHABLEADDRESSDELAYMETRICTYPE  986
	{REACHABLEADDRESSDELAYMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 9}},
#define   REACHABLEADDRESSEXPENSEMETRICTYPE  987
	{REACHABLEADDRESSEXPENSEMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 10}},
#define   REACHABLEADDRESSERRORMETRICTYPE  988
	{REACHABLEADDRESSERRORMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 11}},
#define   REACHABLEADDRESSOPERATIONALSTATE  989
	{REACHABLEADDRESSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 12}},
#define   REACHABLEADDRESSADMINISTRATIVESTATE  990
	{REACHABLEADDRESSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 13}},
#define   REACHABLEADDRESSSNPAADDRESSES  991
	{REACHABLEADDRESSSNPAADDRESSES, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 14}},
#define   REACHABLEADDRESSSNPAMASK  992
	{REACHABLEADDRESSSNPAMASK, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 15}},
#define   REACHABLEADDRESSSNPAPREFIX  993
	{REACHABLEADDRESSSNPAPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 16}},
#define   REACHABLEADDRESSROWSTATUS  994
	{REACHABLEADDRESSROWSTATUS, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 17}},
#define   LLCDISCONTINUITYTIME  995
	{LLCDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_dlMIB, 4, {1, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTINTERFACETYPE  996
	{SLPCONNECTIONDEFAULTINTERFACETYPE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTK  997
	{SLPCONNECTIONDEFAULTK, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 2}},
#define   SLPCONNECTIONDEFAULTN1  998
	{SLPCONNECTIONDEFAULTN1, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 3}},
#define   SLPCONNECTIONDEFAULTN2  999
	{SLPCONNECTIONDEFAULTN2, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 4}},
#define   SLPCONNECTIONDEFAULTSEQUENCEMODULUS  1000
	{SLPCONNECTIONDEFAULTSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 5}},
#define   SLPCONNECTIONDEFAULTT1TIMER  1001
	{SLPCONNECTIONDEFAULTT1TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 6}},
#define   SLPCONNECTIONDEFAULTT2TIMER  1002
	{SLPCONNECTIONDEFAULTT2TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 7}},
#define   SLPCONNECTIONDEFAULTT3TIMER  1003
	{SLPCONNECTIONDEFAULTT3TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 8}},
#define   SLPCONNECTIONDEFAULTT4TIMER  1004
	{SLPCONNECTIONDEFAULTT4TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 9}},
#define   LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS  1005
	{LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 1}},
#define   LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE  1006
	{LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 2}},
#define   LLCCONNECTION2DEFAULTSENDWINDOWSIZE  1007
	{LLCCONNECTION2DEFAULTSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 3}},
#define   LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE  1008
	{LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 4}},
#define   LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE  1009
	{LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 5}},
#define   LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE  1010
	{LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 6}},
#define   LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE  1011
	{LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 7}},
#define   LLCCONNECTION2DEFAULTROUTE  1012
	{LLCCONNECTION2DEFAULTROUTE, ASN_OCTET_STR, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 8}},
#define   LLCCONNECTION2DEFAULTKSTEP  1013
	{LLCCONNECTION2DEFAULTKSTEP, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 9}},
#define   LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE  1014
	{LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 10}},
#define   LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS  1015
	{LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 11}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE  1016
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 1}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS  1017
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 2}},
#define   PHYSICALBITERRORTHRESHOLDREACHED  1018
	{PHYSICALBITERRORTHRESHOLDREACHED, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 1}},
#define   PHYSICALCONNECTIONERROR  1019
	{PHYSICALCONNECTIONERROR, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 2}},
#define   PHSYICALCONNECTIONESTABLISHED  1020
	{PHSYICALCONNECTIONESTABLISHED, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 3}},
#define   PHYSICALLOSSOFSIGNAL  1021
	{PHYSICALLOSSOFSIGNAL, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 4}},
#define   PHYSICALLOSSOFSYNCHRONIZATION  1022
	{PHYSICALLOSSOFSYNCHRONIZATION, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 5}},
#define   FRMR                  1023
	{FRMR, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 6}},
#define   PDUSDISCARDED1        1024
	{PDUSDISCARDED1, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 7}},
#define   PDUSDISCARDED2        1025
	{PDUSDISCARDED2, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 8}},
#define   PDURETRANSMISSIONS    1026
	{PDURETRANSMISSIONS, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 9}},
#define   ACKNOWLEDGETIMEOUT    1027
	{ACKNOWLEDGETIMEOUT, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 10}},
#define   BUSYSTATETIMEOUT      1028
	{BUSYSTATETIMEOUT, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 11}},
#define   REJECTTIMEOUT         1029
	{REJECTTIMEOUT, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 12}},
#define   PBITTIMEOUT           1030
	{PBITTIMEOUT, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 13}},
#define   TYPE2VIOLATION        1031
	{TYPE2VIOLATION, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 14}},
#define   RETRANMISSIONS        1032
	{RETRANMISSIONS, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 15}},
#define   TYPE3VIOLATION        1033
	{TYPE3VIOLATION, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 16}},
#define   NORESPONSE            1034
	{NORESPONSE, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 17}},
#define   PDUSDISCARDED         1035
	{PDUSDISCARDED, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 18}},
#define   BUFFERPROBLEMS        1036
	{BUFFERPROBLEMS, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 19}},
#define   NOTIFICATIONPDUHEADER  1037
	{NOTIFICATIONPDUHEADER, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 20}},
#define   REACHABILITYCHANGE    1038
	{REACHABILITYCHANGE, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 21}},
#define   NOTIFICATIONDATA      1039
	{NOTIFICATIONDATA, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 22}},
#define   CONSTRAINTVIOLATION   1040
	{CONSTRAINTVIOLATION, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 23}},
#define   NOTIFICATIONRECEIVINGADJACENCY  1041
	{NOTIFICATIONRECEIVINGADJACENCY, ASN_OBJECT_ID,, var_dlMIB, 3, {1, 3, 24}},
#define   NOTIFICATIONIDLENGTH  1042
	{NOTIFICATIONIDLENGTH, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 25}},
#define   NOTIFICATIONAREAADDRESS  1043
	{NOTIFICATIONAREAADDRESS, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 26}},
#define   NOTIFICATIONAREAADDRESSES  1044
	{NOTIFICATIONAREAADDRESSES, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 27}},
#define   NOTIFICATIONSOURCEID  1045
	{NOTIFICATIONSOURCEID, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 28}},
#define   NOTIFICATIONMAXIMUMAREAADDRESSES  1046
	{NOTIFICATIONMAXIMUMAREAADDRESSES, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 29}},
#define   NOTIFICATIONVIRTUALLINKCHANGE  1047
	{NOTIFICATIONVIRTUALLINKCHANGE, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 30}},
#define   NOTIFICATIONVIRTUALLINKADDRESS  1048
	{NOTIFICATIONVIRTUALLINKADDRESS, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 31}},
#define   NOTIFICATIONSYSTEMID  1049
	{NOTIFICATIONSYSTEMID, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 32}},
#define   NOTIFICATIONVERSION   1050
	{NOTIFICATIONVERSION, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 33}},
#define   NOTIFICATIONDESIGNATEDINTERMEDIATESYSTEMCHANGE  1051
	{NOTIFICATIONDESIGNATEDINTERMEDIATESYSTEMCHANGE, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 34}},
#define   NOTIFICATIONOVERLOADSTATECHANGE  1052
	{NOTIFICATIONOVERLOADSTATECHANGE, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 35}},
#define   RESERVEDNAME          1053
	{RESERVEDNAME, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 36}},
#define   NOTIFICATIONLSPHEADER  1054
	{NOTIFICATIONLSPHEADER, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 37}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_dlMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_dlMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("dlMIB_simple", dlMIB_simple_variables, variable7, dlMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_dlMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_dlMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_communicationsEntityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_communicationsEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case COMMUNICATIONSENTITYLOCALSAPNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case COMMUNICATIONSENTITYOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sap1Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sap1Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SAP1ADDRESS:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SAP1USERENTITYNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sap2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sap2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SAP2ADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SAP2USERENTITYNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case SAP2PROVIDERENTITYNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_clProtocolMachineTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_clProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CLPROTOCOLMACHINEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLPROTOCOLMACHINETOTALREMOTESAPS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_coProtocolMachineTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_coProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case COPROTOCOLMACHINEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_singlePeerConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_singlePeerConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case UNDERLYINGCONNECTIONNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case SUPPPORTEDCONNECTIONNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_physicalEntityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_physicalEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PHYSICALENTITYPHYSICALENTITYTITLES:
		*write_method = write_physicalEntityPhysicalEntityTitles;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_physicalSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_physicalSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_dataCircuitTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_dataCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DATACIRCUITBITERRORSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITBITERRORSTRANSMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITBITERRORSTHRESHOLD:
		*write_method = write_dataCircuitBitErrorsThreshold;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITTYPE:
		*write_method = write_dataCircuitType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITPHYSICALMEDIANAMES:
		*write_method = write_dataCircuitPhysicalMediaNames;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITPHYSICALINTERFACETYPE:
		*write_method = write_dataCircuitPhysicalInterfaceType;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITPHYSICALINTERFACESTANDARD:
		*write_method = write_dataCircuitPhysicalInterfaceStandard;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITSYNCHRONIZATIONMODE:
		*write_method = write_dataCircuitSynchronizationMode;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITTRANSMISSIONCODING:
		*write_method = write_dataCircuitTransmissionCoding;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITTRANSMISSIONMODE:
		*write_method = write_dataCircuitTransmissionMode;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITTRANSMISSIONRATE:
		*write_method = write_dataCircuitTransmissionRate;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITROWSTATUS:
		*write_method = write_dataCircuitRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_physicalConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_physicalConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PHYSICALCONNECTIONENDPOINTIDENTIFIER:
		*write_method = write_physicalConnectionEndpointIdentifier;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PHYSICALCONNECTIONPORTNUMBER:
		*write_method = write_physicalConnectionPortNumber;
		long_ret = 0;
		return (u_char *) &long_ret;
	case PHYSICALCONNECTIONROWSTATUS:
		*write_method = write_physicalConnectionRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_datalinkEntityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_datalinkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DATALINKENTITYPROVIDERENTITYNAMES:
		*write_method = write_datalinkEntityProviderEntityNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case DATALINKENTITYROWSTATUS:
		*write_method = write_datalinkEntityRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_dLSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_dLSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DLSAPROWSTATUS:
		*write_method = write_dLSAPRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lAPBDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lAPBDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LAPBDLEMT1TIMER:
		*write_method = write_lAPBDLEmT1Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMT3TIMER:
		*write_method = write_lAPBDLEmT3Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMW:
		*write_method = write_lAPBDLEmW;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMXSEND:
		*write_method = write_lAPBDLEmXSend;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMXRECEIVE:
		*write_method = write_lAPBDLEmXReceive;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMT2TIMER:
		*write_method = write_lAPBDLEmT2Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLERECEIVEDMLPRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLETIMESMT1EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEIFRAMESREASSIGNMENTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMLPFRAMESRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMLPFRAMESSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLERECEIVEDMLPFRAMESINGUARDREGION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEROWSTATUS:
		*write_method = write_lAPBDLERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sLPPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sLPPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SLPPMADMINISTRATIVESTATE:
		*write_method = write_sLPPMadministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPPMROWSTATUS:
		*write_method = write_sLPPMRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sLPConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sLPConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SLPCONNECTIONINTERFACETYPE:
		*write_method = write_sLPConnectionInterfaceType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONK:
		*write_method = write_sLPConnectionK;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONN1:
		*write_method = write_sLPConnectionN1;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONN2:
		*write_method = write_sLPConnectionN2;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONSEQUENCEMODULUS:
		*write_method = write_sLPConnectionSequenceModulus;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT1TIMER:
		*write_method = write_sLPConnectionT1Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT2TIMER:
		*write_method = write_sLPConnectionT2Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONFCSERRORSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONFRMRSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONFRMRSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMEDATAOCTETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMESRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMESSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONPOLLSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONREJSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONREJSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONRNRSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONRNRSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONSABMSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONSABMSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONPROTOCOLSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMEST1EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT3TIMER:
		*write_method = write_sLPConnectionT3Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMEST3EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT4TIMER:
		*write_method = write_sLPConnectionT4Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMEST4EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONLINKRESETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONLINKRESETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMESN2REACHED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONADMINISTRATIVESTATE:
		*write_method = write_sLPConnectionAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SLPCONNECTIONALARMSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SLPCONNECTIONROWSTATUS:
		*write_method = write_sLPConnectionRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sLPConnectionIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sLPConnectionIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SLPCONNECTIONIVMOID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SLPCONNECTIONIVMOINTERFACETYPE:
		*write_method = write_sLPConnectionIVMOinterfaceType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOK:
		*write_method = write_sLPConnectionIVMOk;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMON1:
		*write_method = write_sLPConnectionIVMOn1;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMON2:
		*write_method = write_sLPConnectionIVMOn2;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOSEQUENCEMODULUS:
		*write_method = write_sLPConnectionIVMOsequenceModulus;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT1TIMER:
		*write_method = write_sLPConnectionIVMOt1Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT2TIMER:
		*write_method = write_sLPConnectionIVMOt2Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT3TIMER:
		*write_method = write_sLPConnectionIVMOt3Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT4TIMER:
		*write_method = write_sLPConnectionIVMOt4Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOROWSTATUS:
		*write_method = write_sLPConnectionIVMORowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_mACDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_mACDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case MACDLEROWSTATUS:
		*write_method = write_mACDLERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_mACTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_mACTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case MACOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case MACROWSTATUS:
		*write_method = write_mACRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCDLEROWSTATUS:
		*write_method = write_lLCDLERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCCLPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCCLPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCLPMROWSTATUS:
		*write_method = write_lLCCLPMRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCCOPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCCOPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCOPMROWSTATUS:
		*write_method = write_lLCCOPMRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_resourceTypeIdTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_resourceTypeIdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case RESOURCETYPEIDNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTUREROUI:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTURERNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTURERPRODUCTNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTURERPRODUCTVERSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCStationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCStationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCSTATIONLLCNAME:
		*write_method = write_lLCStationLLCName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSTATIONMAXIMUMLSAPSCONFIGURED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONNUMBEROFACTIVELSAPS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONSUPPORTEDSERVICESTYPES:
		*write_method = write_lLCStationSupportedServicesTypes;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSTATIONSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType1AcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE1MAXIMUMRETRYCOUNT:
		*write_method = write_lLCStationType1MaximumRetryCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONMAXIMUMPDUN3:
		*write_method = write_lLCStationMaximumPDUN3;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONMAXIMUMRETRANSMISSIONS4:
		*write_method = write_lLCStationMaximumRetransmissions4;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONRECEIVEVARIABLELIFETIME:
		*write_method = write_lLCStationReceiveVariableLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTRANSMITVARIABLELIFETIME:
		*write_method = write_lLCStationTransmitVariableLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType3AcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE3RETRANSMISSIONS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONAVGBUFFERUSESIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONBUFFERPROBLEMS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONBUFFERSIZE:
		*write_method = write_lLCStationBufferSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONMAXBUFFERUSESIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONINACTIVELSAP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONPDUSDISCARD:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONSTRINDICATOR:
		*write_method = write_lLCStationSTRIndicator;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSTATIONVERSIONNUMBER:
		*write_method = write_lLCStationVersionNumber;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCSAPADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSAPRDE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_rDESetupTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_rDESetupTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case RDESETUPAGINGENABLED:
		*write_method = write_rDESetupAgingEnabled;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPAGINGVALUE:
		*write_method = write_rDESetupAgingValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPENABLETYPE2RESET:
		*write_method = write_rDESetupEnableType2Reset;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPMAXIMUMROUTEDESCRIPTORS:
		*write_method = write_rDESetupMaximumRouteDescriptors;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPMAXIMUMRESPONSETIME:
		*write_method = write_rDESetupMaximumResponseTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPMINIMUMPDUSIZE:
		*write_method = write_rDESetupMinimumPDUSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPRDEHOLD:
		*write_method = write_rDESetupRDEHold;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPRDEREPLACE:
		*write_method = write_rDESetupRDEReplace;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPNAME:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPRESETONTESTENABLED:
		*write_method = write_rDESetupResetOnTestEnabled;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_rDEPairTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_rDEPairTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case RDEPAIRDISCARDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRNSRPDUCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRNSRSELECTEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRRIF:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RDEPAIRSRFPDUCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRQUERYCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnectionLessTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnectionLessTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTIONLESSNAME:
		*write_method = write_lLCConnectionlessName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessMaximumLLCInformationFieldSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTSENTABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSUIRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSUISENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnection2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnection2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTION2NAME:
		*write_method = write_lLCConnection2Name;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTION2MAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2MaximumRetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2ReceivedWindowSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENDWINDOWSIZE:
		*write_method = write_lLCConnection2SendWindowSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2AcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2BUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2BusyStateTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2PBitTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2REJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2RejectTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2LOCALBUSY:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2REMOTEBUSY:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2REMOTERESET:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2LOCALRESET:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PROVIDERRESET:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2ROUTE:
		*write_method = write_lLCConnection2Route;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTION2KSTEP:
		*write_method = write_lLCConnection2KStep;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2MAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2MaxSendWindowSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDI:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTI:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTACKS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDACKS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDFRMR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTFRMR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDRR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTRR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDRNR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTRNR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDREJ:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTREJ:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDSABME:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTSABME:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDUA:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTUA:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDDISC:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTDISC:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDDM:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTDM:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PDUSDISCARDED1:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PDUSDISCARDED2:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PDURETRANSMISSIONS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2OPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2OptionalTolerationIPDUs;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2DUPLICATEIPDUSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2VIOLATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PROTOCOLSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2ADMINISTRATIVESTATE:
		*write_method = write_lLCConnection2AdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2OPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2USAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTION2ALARMSTATUS:
		*write_method = write_lLCConnection2AlarmStatus;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnection2IVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnection2IVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2IVMOMaximumRetransmissions;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMORECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOReceivedWindowSize;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOSendWindowSize;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOAcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBusyStateTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBitTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOREJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMORejectTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOROUTE:
		*write_method = write_lLCConnection2IVMORoute;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOKSTEP:
		*write_method = write_lLCConnection2IVMOKStep;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOMAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOMaxSendWindowSize;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2IVMOOptionalTolerationIPDUs;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnectionlessAckTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnectionlessAckTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckMaximumLLCInformationFieldSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckMaximumRetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTSENTABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRECEIVERESOURCES:
		*write_method = write_lLCConnectionlessAckReceiveResources;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKUIRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKUISENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRETRANSMISSIONS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKNORESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDIP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDIT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDOK:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDPE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDRS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDUE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDUN:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRECEIVEDACCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKSENTACCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEIP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEIT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSENE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSENR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEOK:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSERS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEUE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEUN:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKVIOLATION:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnectionlessAckIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnectionlessAckIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckIVMOMaximumRetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKIVMOROWSTATUS:
		*write_method = write_lLCConnectionlessAckIVMORowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_networkEntityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_networkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case NETWORKENTITYTITLES:
		*write_method = write_networkEntityTitles;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NETWORKENTITYSYSTEMTYPES:
		*write_method = write_networkEntitySystemTypes;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NETWORKENTITYROWSTATUS:
		*write_method = write_networkEntityRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_nSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_nSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case NSAPROWSTATUS:
		*write_method = write_nSAPRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_cLNSTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_cLNSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CLNSADMINISTRATIVESTATE:
		*write_method = write_cLNSAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSSUPPORTEDPROTOCOLS:
		*write_method = write_cLNSSupportedProtocols;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSOPERATIONALSYSTEMTYPE:
		*write_method = write_cLNSOperationalSystemType;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSSEGMENTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSSEGMENTSDISCARDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSASSEMBLINGSEGMENTSDISCARDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSERRORREPORTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSPDUDISCARDS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSCONGESTIONDISCARDS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSMAXIMUMLIFETIME:
		*write_method = write_cLNSMaximumLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSENABLECHECKSUM:
		*write_method = write_cLNSEnableChecksum;
		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSROWSTATUS:
		*write_method = write_cLNSRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_cLNSISISTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_cLNSISISTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CLNSISISVERSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISISTYPE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISSYSTEMID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISMAXIMUMPATHSPLITS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMAXIMUMLSPGENERATIONINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISCOMPLETESNPINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISORIGINATINGL1LSPBUFFERSIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMANUALAREAADDRESSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISMAXIMUMAREAADDRESSES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMINIMUMLSPGENERATIONINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISPOLLESHELLORATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISPARTIALSNPINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISWAITINGTIME:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISDRISISHELLOTIMER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISL1STATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISAREAADDRESSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISCORRUPTEDLSPSDETECTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLSPL1DATABASEOVERLOADS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMANUALADDRESSESDROPPEDFROMAREAS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISSEQUENCENUMBERSKIPS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISOWNLSPPURGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISIDFIELDLENGTHMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMAXIMUMAREAADDRESSESMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLSPTOOLARGETOPROPAGATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISAREATRANSMITPASSWORD:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISAREARECEIVEPASSWORDS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISAUTHENTICATIONFAILURES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_cLNSISISLevel2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_cLNSISISLevel2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2PARTITIONAREAADDRESSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2L2STATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2LSPL2DATABASEOVERLOADS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2DOMAINTRANSMITPASSWORD:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISLEVEL2ROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_linkageTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_linkageTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LINKAGEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEADMINISTRATIVESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGESNSERVICEPROVIDER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGESNSAP:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case LINKAGEOPERATIONALPROTOCOLS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISO9542OPERATIONALSUBSETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISHOLDINGTIMERMULTIPLIER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCONFIGURATIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISSUGGESTEDESCONFIGURATIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISREDIRECTHOLDINGTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISESREACHABILITYCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISINVALID9542PDUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEESISO9542OPERATIONALSUBSETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESHOLDINGTIMERMULTIPLIER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESMANUALISSNPAADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESDEFAULTESCONFIGTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESACTIVEESCONFIGTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESISREACHABILITYCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEESINVALID9542PDUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEENABLECHECKSUM:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEINITIALMINIMUMTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGERESERVETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEIDLETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGESNDCFCALLSPLACED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGESNDCFCALLSFAILED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGECODLCALLSPLACED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGECODLCALLSFAILED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISTYPE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISISISHELLOTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1DEFAULTMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1DELAYMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1EXPENSEMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1ERRORMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISEXTERNALDOMAIN:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCHANGEDINADJACENCYSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISINITIALISATIONFAILURES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISREJECTEDADJACENCIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISISISCONTROLPDUSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISISISCONTROLPDUSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISIDFIELDLENTHMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISCIRCUITTRANSMITPASSWORD:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCIRCUITRECEIVEDPASSWORDS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISAUTHENTICATIONFAILURES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1CIRCUITID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISPTPTCIRCUITID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISOUTGOINGCALLIVMO:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISNEIGHBORSNPAADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2DEFAULTMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2DELAYMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2EXPENSEMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2ERRORMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISMANUALL2ONLYMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2CIRCUITID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_cONSTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_cONSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CONSADMINISTRATIVESTATE:
		*write_method = write_cONSAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case CONSOPERATIONALSYSTEMTYPE:
		*write_method = write_cONSOperationalSystemType;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CONSROWSTATUS:
		*write_method = write_cONSRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_networkConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_networkConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case NETWORKCONNECTIONLOCALNSAPMO:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NETWORKCONNECTIONREMOTENSAPADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NETWORKCONNECTIONROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEADMINISTRATIVESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEPROTOCOLVERSIONSUPPORTED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLELOCALDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTTHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEFLOWCONTROLPARAMETERNEGOTIATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDEFAULTPACKAGESIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLETHROUGHPUTCLASSNEGOTIATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLESNSERVICEPROVIDER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLESNSAP:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PELOGICALCHANNELASSIGNMENTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEINTERFACEMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTTHROUGHPUTCLASS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEFLOWCONTROLNEGOTIATIONPERMITTED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEMAXACTIVECIRCUITS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLERESTARTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDEFAULTPACKETSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDEFAULTWINDOWSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEMINIMUMRECALLTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLERESTARTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLESN_SERVICEPROVIDER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLESN_SA_P:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLELOGICALCHANNELASSIGNMENTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPACKETSEQUENCING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEOCTETSSENTCOUNTER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEOCTETSRECEIVEDCOUNTER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDATAPACKETSSENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDATAPACKETSRECEIVED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECALLATTEMPTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECALLSCONNECTED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLECALLTIMEOUTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECLEARTIMEOUTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREMOTELYINITIATEDRESETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDATARETRANSMISSIONTIMEREXPIRIES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPROVIDERINITIATEDRESETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLERESETTIMEOUTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREMOTELYINITIATEDRESTARTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLERESTARTCOUNTSEXCEEDED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPROTOCOLERRORSDETECTEDLOCALLY:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPROTOCOLERRORSACCUSEDOF:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECLEARCOUNTSEXCEEDED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPLECLIENTMONAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREGISTRATIONREQUESTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREGISTRATIONREQUESTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREGISTRATIONPERMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLE_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLE_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLE_DTECALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECALLREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEMAXACTIVECIRCUITS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEMINIMUMRECALLTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTERESETREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTERESTARTREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTECLEARREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEINTERRUPTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTECALLATTEMPTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEPROTOCOLERRORSACCUSEDOF:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECALLTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECALLSCONNECTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECLEARCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECLEARTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEREMOTELYINITIATEDRESTARTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTERESTARTCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEWINDOWROTATIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREJECTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREJECTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREGISTRATIONPERMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLE_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLE_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLE_DCECALLATTEMPTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECALLSCONNECTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECUG:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEFASTSELECTACCEPTANCE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINCOMINGCALLSBARRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEOUTGOINGCALLSBARRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINTERRUPTPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINTERRUPTPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINTERRUPTTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEREMOTELYINITIATEDRESTARTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEX25SEGMENTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEX25SEGMENTSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEBILATERALCUG:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECALLREDIRECTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECHARGINGINFORMATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECUGWITHINCOMINGACCESS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECUGWITHOUTGOINGACCESS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEDBITMODIFICATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCEHUNTGROUP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINCOMINGCALLBARREDWITHINCUG:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCELOCALCHARGINGPREVENTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCENUIOVERRIDE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCENUISUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEONEWAYLOGICALCHANNELINCOMING:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEONLINEFACILITYREGISTRATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEPACKETRETRANSMISSION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEREVERSECHARGINGACCEPTANCE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEROASUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECLEARINDICATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINCOMINGCALL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCERESETINDICATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCERESTARTINDICATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLEIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMOLOCALDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOSN_SERVICEPROVIDER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOX25PLEMODE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOINTERFACEMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOMAXACTIVECIRCUITS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMORESTARTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTPACKETSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTWINDOWSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOMINIMUMRECALLTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMORESTARTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOPACKETSEQUENCING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOREGISTRATIONREQUESTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOREGISTRATIONREQUESTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOREGISTRATIONPERMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMO_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLEIVMO_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECALLREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEMAXACTIVECIRCUITS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEMINIMUMRECALLTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTERESETREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEINTERRUPTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTECALLATTEMPTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECALLTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECALLSCONNECTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECLEARCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECLEARTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEWINDOWROTATIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREJECTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREGISTRATIONPERMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMO_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLEIVMO_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMO_DCEROWSTATUS:
		*write_method = write_x25PLEIVMO - DCERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCallTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCALLCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLPACKETSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLWINDOWSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLOCTETSSENTCOUNTER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLOCTETSRECEIVEDCOUNTER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLDATAPACKETSSENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLDATAPACKETSRECEIVED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLREMOTELYINITIATEDRESETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLPROVIDERINITIATEDRESETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLRESETTIMEOUTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLINTERRUPTPACKETSSENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLINTERRUPTPACKETSRECEIVED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLINTERRUPTTIMEREXPIRIES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCircuitTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCIRCUITLOGICALCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCIRCUITPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCIRCUITTHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCIRCUITWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCircuit_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCircuit_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCircuit_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCircuit_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEX25SEGMENTSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_permanentVirtualCircuitTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_permanentVirtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PERMANENTVIRTUALCIRCUITCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUITROWSTATUS:
		*write_method = write_permanentVirtualCircuitRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_permanentVirtualCircuit_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_permanentVirtualCircuit_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_permanentVirtualCircuit_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_permanentVirtualCircuit_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCallIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCallIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCALLIVMOFASTSELECT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALLIVMOPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOTHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOPROPOSEDPACKETSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOPROPOSEDWINDOWSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOACCEPTREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOPROPOSEREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOCALLTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMORESETTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOCLEARTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOINTERRUPTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMORESETCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOCLEARCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOWINDOWTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMODATARETRANSMISSIONTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMODATARETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOREJECTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOREJECTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_switchedVirtualCallTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_switchedVirtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SWITCHEDVIRTUALCALLDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLTHROUGHPUTCLASS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLREDIRECTREASON:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLROWSTATUS:
		*write_method = write_switchedVirtualCallRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCall_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCall_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCALL_DTECALLINGADDRESSEXTENSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTECALLEDADDRESSEXTENSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEFASTSELECT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEREDIRECTREASON:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEROWSTATUS:
		*write_method = write_virtualCall - DTERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCall_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCall_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCALL_DCECHARGINGDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCECUGSELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEFASTSELECT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALL_DCEREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEBILATERALCUGSELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCENUISELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEROASELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_dSeriesCountsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_dSeriesCountsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DSERIESRESETREQUESTINDICATIONPACKETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DSERIESSEGMENTSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DSERIESSEGMENTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DSERIESROWSTATUS:
		*write_method = write_dSeriesRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_adjacencyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_adjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case ADJACENCYSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case NEIGHBOURSNPAADDRESS:
		*write_method = write_neighbourSNPAAddress;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NEIGHBOURSYSTEMTYPE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case NEIGHBOURSYSTEMIDS:
		*write_method = write_neighbourSystemIds;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case ADJACENCYUSAGE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case AREAADDRESSESOFNEIGHBOUR:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case HOLDINGTIMER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case PRIORITYOFNEIGHBOUR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case ADJACENCYROWSTATUS:
		*write_method = write_adjacencyRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualAdjacencyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualAdjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALADJACENCYMETRIC:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_destinationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_destinationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DESTINATIONDEFAULTMETRICPATHCOST:
		*write_method = write_destinationDefaultMetricPathCost;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationDefaultMetricOutputAdjacencies;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DESTINATIONDELAYMETRICPATHCOST:
		*write_method = write_destinationDelayMetricPathCost;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DESTINATIONDELAYMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationDelayMetricOutputAdjacencies;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DESTINATIONEXPENSEMETRICPATHCOST:
		*write_method = write_destinationExpenseMetricPathCost;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationExpenseMetricOutputAdjacencies;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DESTINATIONERRORMETRICPATHCOST:
		*write_method = write_destinationErrorMetricPathCost;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DESTINATIONERRORMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationErrorMetricOutputAdjacencies;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_destinationSystemTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_destinationSystemTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DESINTATIONSYSTEMMETRIC:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_destinationAreaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_destinationAreaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DESTINATIONAREAID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_reachableAddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_reachableAddressTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case REACHABLEADDRESSPREFIX:
		*write_method = write_reachableAddressPrefix;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case REACHABLEADDRESSMAPPINGTYPE:
		*write_method = write_reachableAddressMappingType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSDEFAULTMETRIC:
		*write_method = write_reachableAddressDefaultMetric;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSDELAYMETRIC:
		*write_method = write_reachableAddressDelayMetric;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSEXPENSEMETRIC:
		*write_method = write_reachableAddressExpenseMetric;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSERRORMETRIC:
		*write_method = write_reachableAddressErrorMetric;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSDEFAULTMETRICTYPE:
		*write_method = write_reachableAddressDefaultMetricType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSDELAYMETRICTYPE:
		*write_method = write_reachableAddressDelayMetricType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSEXPENSEMETRICTYPE:
		*write_method = write_reachableAddressExpenseMetricType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSERRORMETRICTYPE:
		*write_method = write_reachableAddressErrorMetricType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSADMINISTRATIVESTATE:
		*write_method = write_reachableAddressAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSSNPAADDRESSES:
		*write_method = write_reachableAddressSNPAAddresses;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case REACHABLEADDRESSSNPAMASK:
		*write_method = write_reachableAddressSNPAMask;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case REACHABLEADDRESSSNPAPREFIX:
		*write_method = write_reachableAddressSNPAPrefix;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case REACHABLEADDRESSROWSTATUS:
		*write_method = write_reachableAddressRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_physicalEntityPhysicalEntityTitles(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to physicalEntityPhysicalEntityTitles not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to physicalEntityPhysicalEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitBitErrorsThreshold(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OPAQUE) {
			fprintf(stderr, "write to dataCircuitBitErrorsThreshold not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitBitErrorsThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dataCircuitType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dataCircuitType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitPhysicalMediaNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to dataCircuitPhysicalMediaNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitPhysicalMediaNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitPhysicalInterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to dataCircuitPhysicalInterfaceType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitPhysicalInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitPhysicalInterfaceStandard(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to dataCircuitPhysicalInterfaceStandard not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitPhysicalInterfaceStandard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitSynchronizationMode(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dataCircuitSynchronizationMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dataCircuitSynchronizationMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitTransmissionCoding(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to dataCircuitTransmissionCoding not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitTransmissionCoding: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitTransmissionMode(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dataCircuitTransmissionMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dataCircuitTransmissionMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitTransmissionRate(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OPAQUE) {
			fprintf(stderr, "write to dataCircuitTransmissionRate not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dataCircuitRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dataCircuitRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalConnectionEndpointIdentifier(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to physicalConnectionEndpointIdentifier not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to physicalConnectionEndpointIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalConnectionPortNumber(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to physicalConnectionPortNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to physicalConnectionPortNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalConnectionRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to physicalConnectionRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to physicalConnectionRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_datalinkEntityProviderEntityNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to datalinkEntityProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to datalinkEntityProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_datalinkEntityRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to datalinkEntityRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to datalinkEntityRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dLSAPRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dLSAPRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmW(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmW not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmW: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXSend(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmXSend not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmXSend: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXReceive(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmXReceive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmXReceive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMadministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPPMadministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPPMadministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPPMRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPPMRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionInterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionK(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionSequenceModulus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT4Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOinterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOinterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOinterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOk(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOk not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOk: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOn1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOn1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOn2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOn2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOsequenceModulus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOsequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOsequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt4Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMORowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMORowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMORowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACDLERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to mACDLERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to mACDLERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to mACRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to mACRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCDLERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCDLERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCDLERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCLPMRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCCLPMRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCCLPMRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCOPMRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCCOPMRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCCOPMRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationLLCName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCStationLLCName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCStationLLCName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSupportedServicesTypes(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to lLCStationSupportedServicesTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCStationSupportedServicesTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1AcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationType1AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationType1AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1MaximumRetryCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationType1MaximumRetryCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationType1MaximumRetryCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumPDUN3(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationMaximumPDUN3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationMaximumPDUN3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumRetransmissions4(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationMaximumRetransmissions4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationMaximumRetransmissions4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationReceiveVariableLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationReceiveVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationReceiveVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationTransmitVariableLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationTransmitVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationTransmitVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType3AcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationType3AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationType3AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationBufferSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationBufferSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationBufferSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSTRIndicator(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to lLCStationSTRIndicator not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCStationSTRIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationVersionNumber(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationVersionNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationVersionNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingEnabled(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupAgingEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupAgingEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupAgingValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupAgingValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupEnableType2Reset(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupEnableType2Reset not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupEnableType2Reset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumRouteDescriptors(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupMaximumRouteDescriptors not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupMaximumRouteDescriptors: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumResponseTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupMaximumResponseTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupMaximumResponseTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMinimumPDUSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupMinimumPDUSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupMinimumPDUSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEHold(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupRDEHold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupRDEHold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEReplace(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupRDEReplace not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupRDEReplace: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupResetOnTestEnabled(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupResetOnTestEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupResetOnTestEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnectionlessName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnectionlessName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Name(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnection2Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2MaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2MaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2ReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2SendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2BusyStateTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2BusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2BusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PBitTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2PBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2PBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2RejectTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2RejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2RejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Route(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnection2Route not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2Route: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2KStep(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2KStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2KStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaxSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2MaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2MaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2OptionalTolerationIPDUs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2OptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2OptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AlarmStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to lLCConnection2AlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2AlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOMaximumRetransmissions not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOReceivedWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOReceivedWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOAcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBusyStateTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBitTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORejectTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMORejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMORejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORoute(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMORoute not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMORoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOKStep(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOKStep not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaxSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOMaxSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOOptionalTolerationIPDUs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckReceiveResources(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckReceiveResources not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckReceiveResources: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMORowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMORowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMORowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkEntityTitles(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to networkEntityTitles not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to networkEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkEntitySystemTypes(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to networkEntitySystemTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to networkEntitySystemTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkEntityRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to networkEntityRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to networkEntityRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_nSAPRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to nSAPRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to nSAPRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cLNSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cLNSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSSupportedProtocols(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to cLNSSupportedProtocols not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to cLNSSupportedProtocols: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSOperationalSystemType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to cLNSOperationalSystemType not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to cLNSOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSMaximumLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cLNSMaximumLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cLNSMaximumLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSEnableChecksum(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cLNSEnableChecksum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cLNSEnableChecksum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cLNSRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cLNSRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cONSAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cONSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cONSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cONSOperationalSystemType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to cONSOperationalSystemType not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to cONSOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cONSRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cONSRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cONSRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMO_DCERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMO_DCERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMO_DCERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_permanentVirtualCircuitRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to permanentVirtualCircuitRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to permanentVirtualCircuitRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_switchedVirtualCallRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to switchedVirtualCallRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to switchedVirtualCallRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_virtualCall_DTERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to virtualCall_DTERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to virtualCall_DTERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dSeriesRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dSeriesRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dSeriesRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_neighbourSNPAAddress(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to neighbourSNPAAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to neighbourSNPAAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_neighbourSystemIds(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to neighbourSystemIds not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to neighbourSystemIds: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_adjacencyRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to adjacencyRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to adjacencyRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDefaultMetricPathCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to destinationDefaultMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to destinationDefaultMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDefaultMetricOutputAdjacencies(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to destinationDefaultMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to destinationDefaultMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDelayMetricPathCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to destinationDelayMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to destinationDelayMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDelayMetricOutputAdjacencies(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to destinationDelayMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to destinationDelayMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationExpenseMetricPathCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to destinationExpenseMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to destinationExpenseMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationExpenseMetricOutputAdjacencies(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to destinationExpenseMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to destinationExpenseMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationErrorMetricPathCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to destinationErrorMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to destinationErrorMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationErrorMetricOutputAdjacencies(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to destinationErrorMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to destinationErrorMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressPrefix(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to reachableAddressPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to reachableAddressPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressMappingType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressMappingType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressMappingType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDefaultMetric(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressDefaultMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressDefaultMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDelayMetric(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressDelayMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressDelayMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressExpenseMetric(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressExpenseMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressExpenseMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressErrorMetric(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressErrorMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressErrorMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDefaultMetricType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressDefaultMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressDefaultMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDelayMetricType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressDelayMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressDelayMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressExpenseMetricType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressExpenseMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressExpenseMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressErrorMetricType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressErrorMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressErrorMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressSNPAAddresses(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to reachableAddressSNPAAddresses not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to reachableAddressSNPAAddresses: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressSNPAMask(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to reachableAddressSNPAMask not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to reachableAddressSNPAMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressSNPAPrefix(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to reachableAddressSNPAPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to reachableAddressSNPAPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultInterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultK(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultSequenceModulus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT4Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultReceivedWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultAcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultBusyStateTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultPBitTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultPBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultPBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRejectTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultRejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultRejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRoute(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnection2DefaultRoute not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2DefaultRoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultKStep(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultKStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaxSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultMaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultOptionalTolerationIPDUs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
