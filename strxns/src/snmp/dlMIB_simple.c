/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "dlMIB_simple.h"

/* 
 * dlMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dlMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212 };

/* 
 * variable7 dlMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the dlMIB_simple mib section 
 */

struct variable7 dlMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   COMMUNICATIONSENTITYLOCALSAPNAMES  1
	{COMMUNICATIONSENTITYLOCALSAPNAMES, ASN_OBJECT_ID, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 2}},
#define   COMMUNICATIONSENTITYOPERATIONALSTATE  2
	{COMMUNICATIONSENTITYOPERATIONALSTATE, ASN_INTEGER, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 3}},
#define   SAP1ADDRESS           3
	{SAP1ADDRESS, ASN_UNSIGNED, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 2}},
#define   SAP1USERENTITYNAMES   4
	{SAP1USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 3}},
#define   SAP2ADDRESS           5
	{SAP2ADDRESS, ASN_OCTET_STR, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 1}},
#define   SAP2USERENTITYNAMES   6
	{SAP2USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 2}},
#define   SAP2PROVIDERENTITYNAMES  7
	{SAP2PROVIDERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 3}},
#define   CLPROTOCOLMACHINEOPERATIONALSTATE  8
	{CLPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 2}},
#define   CLPROTOCOLMACHINETOTALREMOTESAPS  9
	{CLPROTOCOLMACHINETOTALREMOTESAPS, ASN_COUNTER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 3}},
#define   COPROTOCOLMACHINEOPERATIONALSTATE  10
	{COPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_coProtocolMachineTable, 6, {1, 1, 5, 1, 1, 2}},
#define   UNDERLYINGCONNECTIONNAMES  11
	{UNDERLYINGCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 2}},
#define   SUPPPORTEDCONNECTIONNAMES  12
	{SUPPPORTEDCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 3}},
#define   PHYSICALENTITYPHYSICALENTITYTITLES  13
	{PHYSICALENTITYPHYSICALENTITYTITLES, ASN_OBJECT_ID, RWRITE, var_physicalEntityTable, 6, {1, 1, 7, 1, 1, 1}},
#define   DATACIRCUITBITERRORSRECEIVED  14
	{DATACIRCUITBITERRORSRECEIVED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 1}},
#define   DATACIRCUITBITERRORSTRANSMITTED  15
	{DATACIRCUITBITERRORSTRANSMITTED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 2}},
#define   DATACIRCUITBITERRORSTHRESHOLD  16
	{DATACIRCUITBITERRORSTHRESHOLD, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 3}},
#define   DATACIRCUITTYPE       17
	{DATACIRCUITTYPE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 4}},
#define   DATACIRCUITPHYSICALMEDIANAMES  18
	{DATACIRCUITPHYSICALMEDIANAMES, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 5}},
#define   DATACIRCUITPHYSICALINTERFACETYPE  19
	{DATACIRCUITPHYSICALINTERFACETYPE, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 6}},
#define   DATACIRCUITPHYSICALINTERFACESTANDARD  20
	{DATACIRCUITPHYSICALINTERFACESTANDARD, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 7}},
#define   DATACIRCUITSYNCHRONIZATIONMODE  21
	{DATACIRCUITSYNCHRONIZATIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 8}},
#define   DATACIRCUITTRANSMISSIONCODING  22
	{DATACIRCUITTRANSMISSIONCODING, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 9}},
#define   DATACIRCUITTRANSMISSIONMODE  23
	{DATACIRCUITTRANSMISSIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 10}},
#define   DATACIRCUITTRANSMISSIONRATE  24
	{DATACIRCUITTRANSMISSIONRATE, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 11}},
#define   DATACIRCUITROWSTATUS  25
	{DATACIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 12}},
#define   PHYSICALCONNECTIONENDPOINTIDENTIFIER  26
	{PHYSICALCONNECTIONENDPOINTIDENTIFIER, ASN_OCTET_STR, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 1}},
#define   PHYSICALCONNECTIONPORTNUMBER  27
	{PHYSICALCONNECTIONPORTNUMBER, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 2}},
#define   PHYSICALCONNECTIONROWSTATUS  28
	{PHYSICALCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 3}},
#define   DATALINKENTITYPROVIDERENTITYNAMES  29
	{DATALINKENTITYPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 1}},
#define   DATALINKENTITYROWSTATUS  30
	{DATALINKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 2}},
#define   DLSAPROWSTATUS        31
	{DLSAPROWSTATUS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 12, 1, 1, 1}},
#define   LAPBDLEMT1TIMER       32
	{LAPBDLEMT1TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 1}},
#define   LAPBDLEMT3TIMER       33
	{LAPBDLEMT3TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 2}},
#define   LAPBDLEMW             34
	{LAPBDLEMW, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 3}},
#define   LAPBDLEMXSEND         35
	{LAPBDLEMXSEND, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 4}},
#define   LAPBDLEMXRECEIVE      36
	{LAPBDLEMXRECEIVE, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 5}},
#define   LAPBDLEMT2TIMER       37
	{LAPBDLEMT2TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 6}},
#define   LAPBDLERECEIVEDMLPRESETS  38
	{LAPBDLERECEIVEDMLPRESETS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 7}},
#define   LAPBDLETIMESMT1EXPIRED  39
	{LAPBDLETIMESMT1EXPIRED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 8}},
#define   LAPBDLEIFRAMESREASSIGNMENTS  40
	{LAPBDLEIFRAMESREASSIGNMENTS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 9}},
#define   LAPBDLEMLPFRAMESRECEIVED  41
	{LAPBDLEMLPFRAMESRECEIVED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 10}},
#define   LAPBDLEMLPFRAMESSENT  42
	{LAPBDLEMLPFRAMESSENT, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 11}},
#define   LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD  43
	{LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 12}},
#define   LAPBDLERECEIVEDMLPFRAMESINGUARDREGION  44
	{LAPBDLERECEIVEDMLPFRAMESINGUARDREGION, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 13}},
#define   LAPBDLEROWSTATUS      45
	{LAPBDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 14}},
#define   SLPPMADMINISTRATIVESTATE  46
	{SLPPMADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 3}},
#define   SLPPMROWSTATUS        47
	{SLPPMROWSTATUS, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 4}},
#define   SLPCONNECTIONINTERFACETYPE  48
	{SLPCONNECTIONINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 1}},
#define   SLPCONNECTIONK        49
	{SLPCONNECTIONK, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 2}},
#define   SLPCONNECTIONN1       50
	{SLPCONNECTIONN1, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 3}},
#define   SLPCONNECTIONN2       51
	{SLPCONNECTIONN2, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 4}},
#define   SLPCONNECTIONSEQUENCEMODULUS  52
	{SLPCONNECTIONSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 5}},
#define   SLPCONNECTIONT1TIMER  53
	{SLPCONNECTIONT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 6}},
#define   SLPCONNECTIONT2TIMER  54
	{SLPCONNECTIONT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 7}},
#define   SLPCONNECTIONFCSERRORSRECEIVED  55
	{SLPCONNECTIONFCSERRORSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 8}},
#define   SLPCONNECTIONFRMRSRECEIVED  56
	{SLPCONNECTIONFRMRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 9}},
#define   SLPCONNECTIONFRMRSSENT  57
	{SLPCONNECTIONFRMRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 10}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED  58
	{SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 11}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSSENT  59
	{SLPCONNECTIONIFRAMEDATAOCTETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 12}},
#define   SLPCONNECTIONIFRAMESRECEIVED  60
	{SLPCONNECTIONIFRAMESRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 13}},
#define   SLPCONNECTIONIFRAMESSENT  61
	{SLPCONNECTIONIFRAMESSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 14}},
#define   SLPCONNECTIONPOLLSRECEIVED  62
	{SLPCONNECTIONPOLLSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 15}},
#define   SLPCONNECTIONREJSRECEIVED  63
	{SLPCONNECTIONREJSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 16}},
#define   SLPCONNECTIONREJSSENT  64
	{SLPCONNECTIONREJSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 17}},
#define   SLPCONNECTIONRNRSRECEIVED  65
	{SLPCONNECTIONRNRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 18}},
#define   SLPCONNECTIONRNRSSENT  66
	{SLPCONNECTIONRNRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 19}},
#define   SLPCONNECTIONSABMSRECEIVED  67
	{SLPCONNECTIONSABMSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 20}},
#define   SLPCONNECTIONSABMSSENT  68
	{SLPCONNECTIONSABMSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 21}},
#define   SLPCONNECTIONPROTOCOLSTATE  69
	{SLPCONNECTIONPROTOCOLSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 22}},
#define   SLPCONNECTIONTIMEST1EXPIRED  70
	{SLPCONNECTIONTIMEST1EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 23}},
#define   SLPCONNECTIONT3TIMER  71
	{SLPCONNECTIONT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 24}},
#define   SLPCONNECTIONTIMEST3EXPIRED  72
	{SLPCONNECTIONTIMEST3EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 25}},
#define   SLPCONNECTIONT4TIMER  73
	{SLPCONNECTIONT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 26}},
#define   SLPCONNECTIONTIMEST4EXPIRED  74
	{SLPCONNECTIONTIMEST4EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 27}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED  75
	{SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 28}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSSENT  76
	{SLPCONNECTIONABNORMALLINKDISCONNECTSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 29}},
#define   SLPCONNECTIONLINKRESETSRECEIVED  77
	{SLPCONNECTIONLINKRESETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 30}},
#define   SLPCONNECTIONLINKRESETSSENT  78
	{SLPCONNECTIONLINKRESETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 31}},
#define   SLPCONNECTIONTIMESN2REACHED  79
	{SLPCONNECTIONTIMESN2REACHED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 32}},
#define   SLPCONNECTIONADMINISTRATIVESTATE  80
	{SLPCONNECTIONADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 33}},
#define   SLPCONNECTIONOPERATIONALSTATE  81
	{SLPCONNECTIONOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 34}},
#define   SLPCONNECTIONUSAGESTATE  82
	{SLPCONNECTIONUSAGESTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 35}},
#define   SLPCONNECTIONPROCEDURALSTATUS  83
	{SLPCONNECTIONPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 36}},
#define   SLPCONNECTIONALARMSTATUS  84
	{SLPCONNECTIONALARMSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 37}},
#define   SLPCONNECTIONROWSTATUS  85
	{SLPCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 38}},
#define   SLPCONNECTIONIVMOID   86
	{SLPCONNECTIONIVMOID, ASN_OCTET_STR, RONLY, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 1}},
#define   SLPCONNECTIONIVMOINTERFACETYPE  87
	{SLPCONNECTIONIVMOINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   SLPCONNECTIONIVMOK    88
	{SLPCONNECTIONIVMOK, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 3}},
#define   SLPCONNECTIONIVMON1   89
	{SLPCONNECTIONIVMON1, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 4}},
#define   SLPCONNECTIONIVMON2   90
	{SLPCONNECTIONIVMON2, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 5}},
#define   SLPCONNECTIONIVMOSEQUENCEMODULUS  91
	{SLPCONNECTIONIVMOSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 6}},
#define   SLPCONNECTIONIVMOT1TIMER  92
	{SLPCONNECTIONIVMOT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 7}},
#define   SLPCONNECTIONIVMOT2TIMER  93
	{SLPCONNECTIONIVMOT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 8}},
#define   SLPCONNECTIONIVMOT3TIMER  94
	{SLPCONNECTIONIVMOT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 9}},
#define   SLPCONNECTIONIVMOT4TIMER  95
	{SLPCONNECTIONIVMOT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 10}},
#define   SLPCONNECTIONIVMOROWSTATUS  96
	{SLPCONNECTIONIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 11}},
#define   MACDLEROWSTATUS       97
	{MACDLEROWSTATUS, ASN_INTEGER, RWRITE, var_mACDLETable, 6, {1, 1, 17, 1, 1, 1}},
#define   MACOPERATIONALSTATE   98
	{MACOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mACTable, 6, {1, 1, 18, 1, 1, 1}},
#define   MACROWSTATUS          99
	{MACROWSTATUS, ASN_INTEGER, RWRITE, var_mACTable, 6, {1, 1, 18, 1, 1, 3}},
#define   LLCDLEROWSTATUS       100
	{LLCDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lLCDLETable, 6, {1, 1, 19, 1, 1, 1}},
#define   LLCCLPMROWSTATUS      101
	{LLCCLPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCLPMTable, 6, {1, 1, 20, 1, 1, 1}},
#define   LLCCOPMROWSTATUS      102
	{LLCCOPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCOPMTable, 6, {1, 1, 21, 1, 1, 1}},
#define   RESOURCETYPEIDNAME    103
	{RESOURCETYPEIDNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 1}},
#define   RESOURCEINFOMANUFACTUREROUI  104
	{RESOURCEINFOMANUFACTUREROUI, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 2}},
#define   RESOURCEINFOMANUFACTURERNAME  105
	{RESOURCEINFOMANUFACTURERNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 3}},
#define   RESOURCEINFOMANUFACTURERPRODUCTNAME  106
	{RESOURCEINFOMANUFACTURERPRODUCTNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 4}},
#define   RESOURCEINFOMANUFACTURERPRODUCTVERSION  107
	{RESOURCEINFOMANUFACTURERPRODUCTVERSION, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 5}},
#define   LLCSTATIONLLCNAME     108
	{LLCSTATIONLLCNAME, ASN_OCTET_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 1}},
#define   LLCSTATIONMAXIMUMLSAPSCONFIGURED  109
	{LLCSTATIONMAXIMUMLSAPSCONFIGURED, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 2}},
#define   LLCSTATIONNUMBEROFACTIVELSAPS  110
	{LLCSTATIONNUMBEROFACTIVELSAPS, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 3}},
#define   LLCSTATIONSUPPORTEDSERVICESTYPES  111
	{LLCSTATIONSUPPORTEDSERVICESTYPES, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 4}},
#define   LLCSTATIONSTATUS      112
	{LLCSTATIONSTATUS, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 5}},
#define   LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE  113
	{LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 6}},
#define   LLCSTATIONTYPE1MAXIMUMRETRYCOUNT  114
	{LLCSTATIONTYPE1MAXIMUMRETRYCOUNT, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 7}},
#define   LLCSTATIONMAXIMUMPDUN3  115
	{LLCSTATIONMAXIMUMPDUN3, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 8}},
#define   LLCSTATIONMAXIMUMRETRANSMISSIONS4  116
	{LLCSTATIONMAXIMUMRETRANSMISSIONS4, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 9}},
#define   LLCSTATIONRECEIVEVARIABLELIFETIME  117
	{LLCSTATIONRECEIVEVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 10}},
#define   LLCSTATIONTRANSMITVARIABLELIFETIME  118
	{LLCSTATIONTRANSMITVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 11}},
#define   LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE  119
	{LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 12}},
#define   LLCSTATIONTYPE3RETRANSMISSIONS  120
	{LLCSTATIONTYPE3RETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 13}},
#define   LLCSTATIONAVGBUFFERUSESIZE  121
	{LLCSTATIONAVGBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 14}},
#define   LLCSTATIONBUFFERPROBLEMS  122
	{LLCSTATIONBUFFERPROBLEMS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 15}},
#define   LLCSTATIONBUFFERSIZE  123
	{LLCSTATIONBUFFERSIZE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 16}},
#define   LLCSTATIONMAXBUFFERUSESIZE  124
	{LLCSTATIONMAXBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 17}},
#define   LLCSTATIONINACTIVELSAP  125
	{LLCSTATIONINACTIVELSAP, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 18}},
#define   LLCSTATIONPDUSDISCARD  126
	{LLCSTATIONPDUSDISCARD, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 19}},
#define   LLCSTATIONSTRINDICATOR  127
	{LLCSTATIONSTRINDICATOR, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 20}},
#define   LLCSTATIONVERSIONNUMBER  128
	{LLCSTATIONVERSIONNUMBER, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 21}},
#define   LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS  129
	{LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 22}},
#define   LLCSAPADDRESS         130
	{LLCSAPADDRESS, ASN_OCTET_STR, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 2}},
#define   LLCSAPRDE             131
	{LLCSAPRDE, ASN_INTEGER, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 3}},
#define   RDESETUPAGINGENABLED  132
	{RDESETUPAGINGENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 1}},
#define   RDESETUPAGINGVALUE    133
	{RDESETUPAGINGVALUE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 2}},
#define   RDESETUPENABLETYPE2RESET  134
	{RDESETUPENABLETYPE2RESET, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 3}},
#define   RDESETUPMAXIMUMROUTEDESCRIPTORS  135
	{RDESETUPMAXIMUMROUTEDESCRIPTORS, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 4}},
#define   RDESETUPMAXIMUMRESPONSETIME  136
	{RDESETUPMAXIMUMRESPONSETIME, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 5}},
#define   RDESETUPMINIMUMPDUSIZE  137
	{RDESETUPMINIMUMPDUSIZE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 6}},
#define   RDESETUPRDEHOLD       138
	{RDESETUPRDEHOLD, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 7}},
#define   RDESETUPRDEREPLACE    139
	{RDESETUPRDEREPLACE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 8}},
#define   RDESETUPNAME          140
	{RDESETUPNAME, ASN_INTEGER, RONLY, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 9}},
#define   RDESETUPRESETONTESTENABLED  141
	{RDESETUPRESETONTESTENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 10}},
#define   RDEPAIRDISCARDCOUNTER  142
	{RDEPAIRDISCARDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 2}},
#define   RDEPAIRNSRPDUCOUNTER  143
	{RDEPAIRNSRPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 3}},
#define   RDEPAIRNSRSELECTEDCOUNTER  144
	{RDEPAIRNSRSELECTEDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 4}},
#define   RDEPAIRRIF            145
	{RDEPAIRRIF, ASN_OCTET_STR, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 5}},
#define   RDEPAIRSRFPDUCOUNTER  146
	{RDEPAIRSRFPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 6}},
#define   RDEPAIRQUERYCOUNTER   147
	{RDEPAIRQUERYCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 7}},
#define   LLCCONNECTIONLESSNAME  148
	{LLCCONNECTIONLESSNAME, ASN_OCTET_STR, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 1}},
#define   LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE  149
	{LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 2}},
#define   LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE  150
	{LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 3}},
#define   LLCCONNECTIONLESSTESTRECEIVEDCOMMAND  151
	{LLCCONNECTIONLESSTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 4}},
#define   LLCCONNECTIONLESSTESTRECEIVEDRESPONSE  152
	{LLCCONNECTIONLESSTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 5}},
#define   LLCCONNECTIONLESSTESTSENTABBRESPONSE  153
	{LLCCONNECTIONLESSTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 6}},
#define   LLCCONNECTIONLESSTESTSENTCOMMAND  154
	{LLCCONNECTIONLESSTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 7}},
#define   LLCCONNECTIONLESSTESTSENTRESPONSE  155
	{LLCCONNECTIONLESSTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 8}},
#define   LLCCONNECTIONLESSUIRECEIVED  156
	{LLCCONNECTIONLESSUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 9}},
#define   LLCCONNECTIONLESSUISENT  157
	{LLCCONNECTIONLESSUISENT, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 10}},
#define   LLCCONNECTIONLESSXIDRECEIVEDCOMMAND  158
	{LLCCONNECTIONLESSXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 11}},
#define   LLCCONNECTIONLESSXIDRECEIVEDRESPONSE  159
	{LLCCONNECTIONLESSXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 12}},
#define   LLCCONNECTIONLESSXIDSENTCOMMAND  160
	{LLCCONNECTIONLESSXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 13}},
#define   LLCCONNECTIONLESSXIDSENTRESPONSE  161
	{LLCCONNECTIONLESSXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 14}},
#define   LLCCONNECTION2NAME    162
	{LLCCONNECTION2NAME, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 1}},
#define   LLCCONNECTION2MAXIMUMRETRANSMISSIONS  163
	{LLCCONNECTION2MAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 2}},
#define   LLCCONNECTION2RECEIVEDWINDOWSIZE  164
	{LLCCONNECTION2RECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 3}},
#define   LLCCONNECTION2SENDWINDOWSIZE  165
	{LLCCONNECTION2SENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 4}},
#define   LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE  166
	{LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 5}},
#define   LLCCONNECTION2BUSYSTATETIMEOUTVALUE  167
	{LLCCONNECTION2BUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 6}},
#define   LLCCONNECTION2PBITTIMEOUTVALUE  168
	{LLCCONNECTION2PBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 7}},
#define   LLCCONNECTION2REJECTTIMEOUTVALUE  169
	{LLCCONNECTION2REJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 8}},
#define   LLCCONNECTION2LOCALBUSY  170
	{LLCCONNECTION2LOCALBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 9}},
#define   LLCCONNECTION2REMOTEBUSY  171
	{LLCCONNECTION2REMOTEBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 10}},
#define   LLCCONNECTION2REMOTERESET  172
	{LLCCONNECTION2REMOTERESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 11}},
#define   LLCCONNECTION2LOCALRESET  173
	{LLCCONNECTION2LOCALRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 12}},
#define   LLCCONNECTION2PROVIDERRESET  174
	{LLCCONNECTION2PROVIDERRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 13}},
#define   LLCCONNECTION2ROUTE   175
	{LLCCONNECTION2ROUTE, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 14}},
#define   LLCCONNECTION2KSTEP   176
	{LLCCONNECTION2KSTEP, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 15}},
#define   LLCCONNECTION2MAXSENDWINDOWSIZE  177
	{LLCCONNECTION2MAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 16}},
#define   LLCCONNECTION2RECEIVEDI  178
	{LLCCONNECTION2RECEIVEDI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 17}},
#define   LLCCONNECTION2SENTI   179
	{LLCCONNECTION2SENTI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 18}},
#define   LLCCONNECTION2SENTACKS  180
	{LLCCONNECTION2SENTACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 19}},
#define   LLCCONNECTION2RECEIVEDACKS  181
	{LLCCONNECTION2RECEIVEDACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 20}},
#define   LLCCONNECTION2RECEIVEDFRMR  182
	{LLCCONNECTION2RECEIVEDFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 21}},
#define   LLCCONNECTION2SENTFRMR  183
	{LLCCONNECTION2SENTFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 22}},
#define   LLCCONNECTION2RECEIVEDRR  184
	{LLCCONNECTION2RECEIVEDRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 23}},
#define   LLCCONNECTION2SENTRR  185
	{LLCCONNECTION2SENTRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 24}},
#define   LLCCONNECTION2RECEIVEDRNR  186
	{LLCCONNECTION2RECEIVEDRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 25}},
#define   LLCCONNECTION2SENTRNR  187
	{LLCCONNECTION2SENTRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 26}},
#define   LLCCONNECTION2RECEIVEDREJ  188
	{LLCCONNECTION2RECEIVEDREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 27}},
#define   LLCCONNECTION2SENTREJ  189
	{LLCCONNECTION2SENTREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 28}},
#define   LLCCONNECTION2RECEIVEDSABME  190
	{LLCCONNECTION2RECEIVEDSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 29}},
#define   LLCCONNECTION2SENTSABME  191
	{LLCCONNECTION2SENTSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 30}},
#define   LLCCONNECTION2RECEIVEDUA  192
	{LLCCONNECTION2RECEIVEDUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 31}},
#define   LLCCONNECTION2SENTUA  193
	{LLCCONNECTION2SENTUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 32}},
#define   LLCCONNECTION2RECEIVEDDISC  194
	{LLCCONNECTION2RECEIVEDDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 33}},
#define   LLCCONNECTION2SENTDISC  195
	{LLCCONNECTION2SENTDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 34}},
#define   LLCCONNECTION2RECEIVEDDM  196
	{LLCCONNECTION2RECEIVEDDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 35}},
#define   LLCCONNECTION2SENTDM  197
	{LLCCONNECTION2SENTDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 36}},
#define   LLCCONNECTION2PDUSDISCARDED1  198
	{LLCCONNECTION2PDUSDISCARDED1, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 37}},
#define   LLCCONNECTION2PDUSDISCARDED2  199
	{LLCCONNECTION2PDUSDISCARDED2, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 38}},
#define   LLCCONNECTION2PDURETRANSMISSIONS  200
	{LLCCONNECTION2PDURETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 39}},
#define   LLCCONNECTION2OPTIONALTOLERATIONIPDUS  201
	{LLCCONNECTION2OPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 40}},
#define   LLCCONNECTION2DUPLICATEIPDUSRECEIVED  202
	{LLCCONNECTION2DUPLICATEIPDUSRECEIVED, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 41}},
#define   LLCCONNECTION2VIOLATION  203
	{LLCCONNECTION2VIOLATION, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 42}},
#define   LLCCONNECTION2PROTOCOLSTATE  204
	{LLCCONNECTION2PROTOCOLSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 43}},
#define   LLCCONNECTION2ADMINISTRATIVESTATE  205
	{LLCCONNECTION2ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 44}},
#define   LLCCONNECTION2OPERATIONALSTATE  206
	{LLCCONNECTION2OPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 45}},
#define   LLCCONNECTION2USAGESTATE  207
	{LLCCONNECTION2USAGESTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 46}},
#define   LLCCONNECTION2PROCEDURALSTATUS  208
	{LLCCONNECTION2PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 47}},
#define   LLCCONNECTION2ALARMSTATUS  209
	{LLCCONNECTION2ALARMSTATUS, ASN_BIT_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 48}},
#define   LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS  210
	{LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 2}},
#define   LLCCONNECTION2IVMORECEIVEDWINDOWSIZE  211
	{LLCCONNECTION2IVMORECEIVEDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 3}},
#define   LLCCONNECTION2IVMOSENDWINDOWSIZE  212
	{LLCCONNECTION2IVMOSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 4}},
#define   LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE  213
	{LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 5}},
#define   LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE  214
	{LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 6}},
#define   LLCCONNECTION2IVMOBITTIMEOUTVALUE  215
	{LLCCONNECTION2IVMOBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 7}},
#define   LLCCONNECTION2IVMOREJECTTIMEOUTVALUE  216
	{LLCCONNECTION2IVMOREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 8}},
#define   LLCCONNECTION2IVMOROUTE  217
	{LLCCONNECTION2IVMOROUTE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 9}},
#define   LLCCONNECTION2IVMOKSTEP  218
	{LLCCONNECTION2IVMOKSTEP, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 10}},
#define   LLCCONNECTION2IVMOMAXSENDWINDOWSIZE  219
	{LLCCONNECTION2IVMOMAXSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 11}},
#define   LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS  220
	{LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE  221
	{LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS  222
	{LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE  223
	{LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 4}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND  224
	{LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 5}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE  225
	{LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 6}},
#define   LLCCONNECTIONLESSACKTESTSENTABBRESPONSE  226
	{LLCCONNECTIONLESSACKTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 7}},
#define   LLCCONNECTIONLESSACKTESTSENTCOMMAND  227
	{LLCCONNECTIONLESSACKTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 8}},
#define   LLCCONNECTIONLESSACKTESTSENTRESPONSE  228
	{LLCCONNECTIONLESSACKTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 9}},
#define   LLCCONNECTIONLESSACKRECEIVERESOURCES  229
	{LLCCONNECTIONLESSACKRECEIVERESOURCES, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 10}},
#define   LLCCONNECTIONLESSACKUIRECEIVED  230
	{LLCCONNECTIONLESSACKUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 11}},
#define   LLCCONNECTIONLESSACKUISENT  231
	{LLCCONNECTIONLESSACKUISENT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND  232
	{LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 13}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE  233
	{LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 14}},
#define   LLCCONNECTIONLESSACKXIDSENTCOMMAND  234
	{LLCCONNECTIONLESSACKXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 15}},
#define   LLCCONNECTIONLESSACKXIDSENTRESPONSE  235
	{LLCCONNECTIONLESSACKXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 16}},
#define   LLCCONNECTIONLESSACKRETRANSMISSIONS  236
	{LLCCONNECTIONLESSACKRETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 17}},
#define   LLCCONNECTIONLESSACKNORESPONSE  237
	{LLCCONNECTIONLESSACKNORESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 18}},
#define   LLCCONNECTIONLESSACKCOMMANDIP  238
	{LLCCONNECTIONLESSACKCOMMANDIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 19}},
#define   LLCCONNECTIONLESSACKCOMMANDIT  239
	{LLCCONNECTIONLESSACKCOMMANDIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 20}},
#define   LLCCONNECTIONLESSACKCOMMANDOK  240
	{LLCCONNECTIONLESSACKCOMMANDOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 21}},
#define   LLCCONNECTIONLESSACKCOMMANDPE  241
	{LLCCONNECTIONLESSACKCOMMANDPE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 22}},
#define   LLCCONNECTIONLESSACKCOMMANDRS  242
	{LLCCONNECTIONLESSACKCOMMANDRS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 23}},
#define   LLCCONNECTIONLESSACKCOMMANDUE  243
	{LLCCONNECTIONLESSACKCOMMANDUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 24}},
#define   LLCCONNECTIONLESSACKCOMMANDUN  244
	{LLCCONNECTIONLESSACKCOMMANDUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 25}},
#define   LLCCONNECTIONLESSACKRECEIVEDACCOMMAND  245
	{LLCCONNECTIONLESSACKRECEIVEDACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 26}},
#define   LLCCONNECTIONLESSACKSENTACCOMMAND  246
	{LLCCONNECTIONLESSACKSENTACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 27}},
#define   LLCCONNECTIONLESSACKRESPONSEIP  247
	{LLCCONNECTIONLESSACKRESPONSEIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 28}},
#define   LLCCONNECTIONLESSACKRESPONSEIT  248
	{LLCCONNECTIONLESSACKRESPONSEIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 29}},
#define   LLCCONNECTIONLESSACKRESPONSENE  249
	{LLCCONNECTIONLESSACKRESPONSENE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 30}},
#define   LLCCONNECTIONLESSACKRESPONSENR  250
	{LLCCONNECTIONLESSACKRESPONSENR, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 31}},
#define   LLCCONNECTIONLESSACKRESPONSEOK  251
	{LLCCONNECTIONLESSACKRESPONSEOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 32}},
#define   LLCCONNECTIONLESSACKRESPONSERS  252
	{LLCCONNECTIONLESSACKRESPONSERS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 33}},
#define   LLCCONNECTIONLESSACKRESPONSEUE  253
	{LLCCONNECTIONLESSACKRESPONSEUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 34}},
#define   LLCCONNECTIONLESSACKRESPONSEUN  254
	{LLCCONNECTIONLESSACKRESPONSEUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 35}},
#define   LLCCONNECTIONLESSACKVIOLATION  255
	{LLCCONNECTIONLESSACKVIOLATION, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 36}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE  256
	{LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS  257
	{LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKIVMOROWSTATUS  258
	{LLCCONNECTIONLESSACKIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 4}},
#define   NETWORKENTITYTITLES   259
	{NETWORKENTITYTITLES, ASN_OCTET_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 1}},
#define   NETWORKENTITYSYSTEMTYPES  260
	{NETWORKENTITYSYSTEMTYPES, ASN_BIT_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 2}},
#define   NETWORKENTITYROWSTATUS  261
	{NETWORKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 3}},
#define   NSAPROWSTATUS         262
	{NSAPROWSTATUS, ASN_INTEGER, RWRITE, var_nSAPTable, 6, {1, 1, 33, 1, 1, 1}},
#define   CLNSADMINISTRATIVESTATE  263
	{CLNSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 1}},
#define   CLNSSUPPORTEDPROTOCOLS  264
	{CLNSSUPPORTEDPROTOCOLS, ASN_OCTET_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 2}},
#define   CLNSOPERATIONALSYSTEMTYPE  265
	{CLNSOPERATIONALSYSTEMTYPE, ASN_BIT_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 3}},
#define   CLNSOCTETSSENTCOUNTER  266
	{CLNSOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 4}},
#define   CLNSOCTETSRECEIVEDCOUNTER  267
	{CLNSOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 5}},
#define   CLNSSEGMENTSRECEIVED  268
	{CLNSSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 6}},
#define   CLNSSEGMENTSDISCARDED  269
	{CLNSSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 7}},
#define   CLNSASSEMBLINGSEGMENTSDISCARDED  270
	{CLNSASSEMBLINGSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 8}},
#define   CLNSERRORREPORTSRECEIVED  271
	{CLNSERRORREPORTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 9}},
#define   CLNSPDUDISCARDS       272
	{CLNSPDUDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 10}},
#define   CLNSCONGESTIONDISCARDS  273
	{CLNSCONGESTIONDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 11}},
#define   CLNSMAXIMUMLIFETIME   274
	{CLNSMAXIMUMLIFETIME, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 12}},
#define   CLNSENABLECHECKSUM    275
	{CLNSENABLECHECKSUM, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 13}},
#define   CLNSROWSTATUS         276
	{CLNSROWSTATUS, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 14}},
#define   CLNSISISVERSION       277
	{CLNSISISVERSION, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 1}},
#define   CLNSISISISTYPE        278
	{CLNSISISISTYPE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 2}},
#define   CLNSISISSYSTEMID      279
	{CLNSISISSYSTEMID, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 3}},
#define   CLNSISISMAXIMUMPATHSPLITS  280
	{CLNSISISMAXIMUMPATHSPLITS, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 4}},
#define   CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL  281
	{CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 5}},
#define   CLNSISISMAXIMUMLSPGENERATIONINTERVAL  282
	{CLNSISISMAXIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 6}},
#define   CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL  283
	{CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 7}},
#define   CLNSISISCOMPLETESNPINTERVAL  284
	{CLNSISISCOMPLETESNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 8}},
#define   CLNSISISORIGINATINGL1LSPBUFFERSIZE  285
	{CLNSISISORIGINATINGL1LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 9}},
#define   CLNSISISMANUALAREAADDRESSES  286
	{CLNSISISMANUALAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 10}},
#define   CLNSISISMAXIMUMAREAADDRESSES  287
	{CLNSISISMAXIMUMAREAADDRESSES, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 11}},
#define   CLNSISISMINIMUMLSPGENERATIONINTERVAL  288
	{CLNSISISMINIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 12}},
#define   CLNSISISPOLLESHELLORATE  289
	{CLNSISISPOLLESHELLORATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 13}},
#define   CLNSISISPARTIALSNPINTERVAL  290
	{CLNSISISPARTIALSNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 14}},
#define   CLNSISISWAITINGTIME   291
	{CLNSISISWAITINGTIME, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 15}},
#define   CLNSISISDRISISHELLOTIMER  292
	{CLNSISISDRISISHELLOTIMER, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 16}},
#define   CLNSISISL1STATE       293
	{CLNSISISL1STATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 17}},
#define   CLNSISISAREAADDRESSES  294
	{CLNSISISAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 18}},
#define   CLNSISISCORRUPTEDLSPSDETECTED  295
	{CLNSISISCORRUPTEDLSPSDETECTED, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 19}},
#define   CLNSISISLSPL1DATABASEOVERLOADS  296
	{CLNSISISLSPL1DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 20}},
#define   CLNSISISMANUALADDRESSESDROPPEDFROMAREAS  297
	{CLNSISISMANUALADDRESSESDROPPEDFROMAREAS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 21}},
#define   CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER  298
	{CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 22}},
#define   CLNSISISSEQUENCENUMBERSKIPS  299
	{CLNSISISSEQUENCENUMBERSKIPS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 23}},
#define   CLNSISISOWNLSPPURGES  300
	{CLNSISISOWNLSPPURGES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 24}},
#define   CLNSISISIDFIELDLENGTHMISMATCHES  301
	{CLNSISISIDFIELDLENGTHMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 25}},
#define   CLNSISISMAXIMUMAREAADDRESSESMISMATCHES  302
	{CLNSISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 26}},
#define   CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES  303
	{CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 27}},
#define   CLNSISISLSPTOOLARGETOPROPAGATE  304
	{CLNSISISLSPTOOLARGETOPROPAGATE, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 28}},
#define   CLNSISISAREATRANSMITPASSWORD  305
	{CLNSISISAREATRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 29}},
#define   CLNSISISAREARECEIVEPASSWORDS  306
	{CLNSISISAREARECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 30}},
#define   CLNSISISAUTHENTICATIONFAILURES  307
	{CLNSISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 31}},
#define   CLNSISISROWSTATUS     308
	{CLNSISISROWSTATUS, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 32}},
#define   CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES  309
	{CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 1}},
#define   CLNSISISLEVEL2PARTITIONAREAADDRESSES  310
	{CLNSISISLEVEL2PARTITIONAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 2}},
#define   CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM  311
	{CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 3}},
#define   CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES  312
	{CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 4}},
#define   CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE  313
	{CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 5}},
#define   CLNSISISLEVEL2L2STATE  314
	{CLNSISISLEVEL2L2STATE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 6}},
#define   CLNSISISLEVEL2LSPL2DATABASEOVERLOADS  315
	{CLNSISISLEVEL2LSPL2DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 7}},
#define   CLNSISISLEVEL2DOMAINTRANSMITPASSWORD  316
	{CLNSISISLEVEL2DOMAINTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 8}},
#define   CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS  317
	{CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 9}},
#define   CLNSISISLEVEL2ROWSTATUS  318
	{CLNSISISLEVEL2ROWSTATUS, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 10}},
#define   LINKAGEOPERATIONALSTATE  319
	{LINKAGEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 3}},
#define   LINKAGEADMINISTRATIVESTATE  320
	{LINKAGEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 4}},
#define   LINKAGESNSERVICEPROVIDER  321
	{LINKAGESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 5}},
#define   LINKAGESNSAP          322
	{LINKAGESNSAP, ASN_OBJECT_ID, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 6}},
#define   LINKAGEOPERATIONALPROTOCOLS  323
	{LINKAGEOPERATIONALPROTOCOLS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 7}},
#define   LINKAGEISISO9542OPERATIONALSUBSETS  324
	{LINKAGEISISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 8}},
#define   LINKAGEISHOLDINGTIMERMULTIPLIER  325
	{LINKAGEISHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 9}},
#define   LINKAGEISISCONFIGURATIONTIMER  326
	{LINKAGEISISCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 10}},
#define   LINKAGEISSUGGESTEDESCONFIGURATIONTIMER  327
	{LINKAGEISSUGGESTEDESCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 11}},
#define   LINKAGEISREDIRECTHOLDINGTIME  328
	{LINKAGEISREDIRECTHOLDINGTIME, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 12}},
#define   LINKAGEISESREACHABILITYCHANGES  329
	{LINKAGEISESREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 13}},
#define   LINKAGEISINVALID9542PDUS  330
	{LINKAGEISINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 14}},
#define   LINKAGEESISO9542OPERATIONALSUBSETS  331
	{LINKAGEESISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 15}},
#define   LINKAGEESHOLDINGTIMERMULTIPLIER  332
	{LINKAGEESHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 16}},
#define   LINKAGEESMANUALISSNPAADDRESS  333
	{LINKAGEESMANUALISSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 17}},
#define   LINKAGEESDEFAULTESCONFIGTIMER  334
	{LINKAGEESDEFAULTESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 18}},
#define   LINKAGEESACTIVEESCONFIGTIMER  335
	{LINKAGEESACTIVEESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 19}},
#define   LINKAGEESISREACHABILITYCHANGES  336
	{LINKAGEESISREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 20}},
#define   LINKAGEESINVALID9542PDUS  337
	{LINKAGEESINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 21}},
#define   LINKAGEENABLECHECKSUM  338
	{LINKAGEENABLECHECKSUM, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 22}},
#define   LINKAGEINITIALMINIMUMTIMER  339
	{LINKAGEINITIALMINIMUMTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 23}},
#define   LINKAGERESERVETIMER   340
	{LINKAGERESERVETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 24}},
#define   LINKAGEIDLETIMER      341
	{LINKAGEIDLETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 25}},
#define   LINKAGESNDCFCALLSPLACED  342
	{LINKAGESNDCFCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 26}},
#define   LINKAGESNDCFCALLSFAILED  343
	{LINKAGESNDCFCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 27}},
#define   LINKAGECODLCALLSPLACED  344
	{LINKAGECODLCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 28}},
#define   LINKAGECODLCALLSFAILED  345
	{LINKAGECODLCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 29}},
#define   LINKAGEISISTYPE       346
	{LINKAGEISISTYPE, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 30}},
#define   LINKAGEISISISISHELLOTIMER  347
	{LINKAGEISISISISHELLOTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 31}},
#define   LINKAGEISISL1DEFAULTMETRIC  348
	{LINKAGEISISL1DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 32}},
#define   LINKAGEISISL1DELAYMETRIC  349
	{LINKAGEISISL1DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 33}},
#define   LINKAGEISISL1EXPENSEMETRIC  350
	{LINKAGEISISL1EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 34}},
#define   LINKAGEISISL1ERRORMETRIC  351
	{LINKAGEISISL1ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 35}},
#define   LINKAGEISISEXTERNALDOMAIN  352
	{LINKAGEISISEXTERNALDOMAIN, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 36}},
#define   LINKAGEISISCHANGEDINADJACENCYSTATE  353
	{LINKAGEISISCHANGEDINADJACENCYSTATE, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 37}},
#define   LINKAGEISISINITIALISATIONFAILURES  354
	{LINKAGEISISINITIALISATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 38}},
#define   LINKAGEISISREJECTEDADJACENCIES  355
	{LINKAGEISISREJECTEDADJACENCIES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 39}},
#define   LINKAGEISISISISCONTROLPDUSSENT  356
	{LINKAGEISISISISCONTROLPDUSSENT, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 40}},
#define   LINKAGEISISISISCONTROLPDUSRECEIVED  357
	{LINKAGEISISISISCONTROLPDUSRECEIVED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 41}},
#define   LINKAGEISISIDFIELDLENTHMISMATCHES  358
	{LINKAGEISISIDFIELDLENTHMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 42}},
#define   LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES  359
	{LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 43}},
#define   LINKAGEISISCIRCUITTRANSMITPASSWORD  360
	{LINKAGEISISCIRCUITTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 44}},
#define   LINKAGEISISCIRCUITRECEIVEDPASSWORDS  361
	{LINKAGEISISCIRCUITRECEIVEDPASSWORDS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 45}},
#define   LINKAGEISISAUTHENTICATIONFAILURES  362
	{LINKAGEISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 46}},
#define   LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY  363
	{LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 47}},
#define   LINKAGEISISL1CIRCUITID  364
	{LINKAGEISISL1CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 48}},
#define   LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM  365
	{LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 49}},
#define   LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES  366
	{LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 50}},
#define   LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT  367
	{LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 51}},
#define   LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT  368
	{LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 52}},
#define   LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT  369
	{LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 53}},
#define   LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT  370
	{LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 54}},
#define   LINKAGEISISPTPTCIRCUITID  371
	{LINKAGEISISPTPTCIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 55}},
#define   LINKAGEISISOUTGOINGCALLIVMO  372
	{LINKAGEISISOUTGOINGCALLIVMO, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 56}},
#define   LINKAGEISISNEIGHBORSNPAADDRESS  373
	{LINKAGEISISNEIGHBORSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 57}},
#define   LINKAGEISISL2DEFAULTMETRIC  374
	{LINKAGEISISL2DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 58}},
#define   LINKAGEISISL2DELAYMETRIC  375
	{LINKAGEISISL2DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 59}},
#define   LINKAGEISISL2EXPENSEMETRIC  376
	{LINKAGEISISL2EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 60}},
#define   LINKAGEISISL2ERRORMETRIC  377
	{LINKAGEISISL2ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 61}},
#define   LINKAGEISISMANUALL2ONLYMODE  378
	{LINKAGEISISMANUALL2ONLYMODE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 62}},
#define   LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY  379
	{LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 63}},
#define   LINKAGEISISL2CIRCUITID  380
	{LINKAGEISISL2CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 64}},
#define   LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM  381
	{LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 65}},
#define   LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES  382
	{LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 66}},
#define   LINKAGEROWSTATUS      383
	{LINKAGEROWSTATUS, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 67}},
#define   CONSADMINISTRATIVESTATE  384
	{CONSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 1}},
#define   CONSOPERATIONALSYSTEMTYPE  385
	{CONSOPERATIONALSYSTEMTYPE, ASN_BIT_STR, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 2}},
#define   CONSROWSTATUS         386
	{CONSROWSTATUS, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 3}},
#define   NETWORKCONNECTIONLOCALNSAPMO  387
	{NETWORKCONNECTIONLOCALNSAPMO, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 1}},
#define   NETWORKCONNECTIONREMOTENSAPADDRESS  388
	{NETWORKCONNECTIONREMOTENSAPADDRESS, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 2}},
#define   NETWORKCONNECTIONROWSTATUS  389
	{NETWORKCONNECTIONROWSTATUS, ASN_INTEGER, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 3}},
#define   X25PLEOPERATIONALSTATE  390
	{X25PLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 2}},
#define   X25PLEADMINISTRATIVESTATE  391
	{X25PLEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 3}},
#define   X25PLEPROTOCOLVERSIONSUPPORTED  392
	{X25PLEPROTOCOLVERSIONSUPPORTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 4}},
#define   X25PLELOCALDTEADDRESS  393
	{X25PLELOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 5}},
#define   X25PLEMODE            394
	{X25PLEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 6}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSES  395
	{X25PLEDEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 7}},
#define   X25PLEFLOWCONTROLPARAMETERNEGOTIATION  396
	{X25PLEFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 8}},
#define   X25PLEDEFAULTPACKAGESIZES  397
	{X25PLEDEFAULTPACKAGESIZES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 9}},
#define   X25PLETHROUGHPUTCLASSNEGOTIATION  398
	{X25PLETHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 10}},
#define   X25PLESNSERVICEPROVIDER  399
	{X25PLESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 11}},
#define   X25PLESNSAP           400
	{X25PLESNSAP, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 12}},
#define   X25PELOGICALCHANNELASSIGNMENTS  401
	{X25PELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 13}},
#define   X25PLEINTERFACEMODE   402
	{X25PLEINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 14}},
#define   X25PLEDEFAULTTHROUGHPUTCLASS  403
	{X25PLEDEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 15}},
#define   X25PLEFLOWCONTROLNEGOTIATIONPERMITTED  404
	{X25PLEFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 16}},
#define   X25PLECALLDEFLECTIONSUBSCRIPTION  405
	{X25PLECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 17}},
#define   X25PLEMAXACTIVECIRCUITS  406
	{X25PLEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 18}},
#define   X25PLERESTARTTIME     407
	{X25PLERESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 19}},
#define   X25PLEDEFAULTPACKETSIZE  408
	{X25PLEDEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 20}},
#define   X25PLEDEFAULTWINDOWSIZE  409
	{X25PLEDEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 21}},
#define   X25PLEMINIMUMRECALLTIMER  410
	{X25PLEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 22}},
#define   X25PLERESTARTCOUNT    411
	{X25PLERESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 23}},
#define   X25PLESN_SERVICEPROVIDER  412
	{X25PLESN_SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 24}},
#define   X25PLESN_SA_P         413
	{X25PLESN_SA_P, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 25}},
#define   X25PLELOGICALCHANNELASSIGNMENTS  414
	{X25PLELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 26}},
#define   X25PLEPACKETSEQUENCING  415
	{X25PLEPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 27}},
#define   X25PLEOCTETSSENTCOUNTER  416
	{X25PLEOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 28}},
#define   X25PLEOCTETSRECEIVEDCOUNTER  417
	{X25PLEOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 29}},
#define   X25PLEDATAPACKETSSENT  418
	{X25PLEDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 30}},
#define   X25PLEDATAPACKETSRECEIVED  419
	{X25PLEDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 31}},
#define   X25PLECALLATTEMPTS    420
	{X25PLECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 32}},
#define   X25PLECALLSCONNECTED  421
	{X25PLECALLSCONNECTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 33}},
#define   X25PLEPROVIDERINITIATEDDISCONNECTS  422
	{X25PLEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 34}},
#define   X25PLECALLTIMEOUTS    423
	{X25PLECALLTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 35}},
#define   X25PLECLEARTIMEOUTS   424
	{X25PLECLEARTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 36}},
#define   X25PLEREMOTELYINITIATEDRESETS  425
	{X25PLEREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 37}},
#define   X25PLEDATARETRANSMISSIONTIMEREXPIRIES  426
	{X25PLEDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 38}},
#define   X25PLEPROVIDERINITIATEDRESETS  427
	{X25PLEPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 39}},
#define   X25PLERESETTIMEOUTS   428
	{X25PLERESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 40}},
#define   X25PLEREMOTELYINITIATEDRESTARTS  429
	{X25PLEREMOTELYINITIATEDRESTARTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 41}},
#define   X25PLERESTARTCOUNTSEXCEEDED  430
	{X25PLERESTARTCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 42}},
#define   X25PLEPROTOCOLERRORSDETECTEDLOCALLY  431
	{X25PLEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 43}},
#define   X25PLEPROTOCOLERRORSACCUSEDOF  432
	{X25PLEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 44}},
#define   X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  433
	{X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 45}},
#define   X25PLECLEARCOUNTSEXCEEDED  434
	{X25PLECLEARCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 46}},
#define   X25PLEPLECLIENTMONAME  435
	{X25PLEPLECLIENTMONAME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 47}},
#define   X25PLEREGISTRATIONREQUESTTIME  436
	{X25PLEREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 48}},
#define   X25PLEREGISTRATIONREQUESTCOUNT  437
	{X25PLEREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 49}},
#define   X25PLEREGISTRATIONPERMITTED  438
	{X25PLEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 50}},
#define   X25PLEROWSTATUS       439
	{X25PLEROWSTATUS, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 51}},
#define   X25PLE_DTECALLDEFLECTIONSUBSCRIPTION  440
	{X25PLE_DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 1}},
#define   X25PLE_DTECALLREQUESTRESPONSETIMER  441
	{X25PLE_DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 2}},
#define   X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING  442
	{X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 3}},
#define   X25PLE_DTEMAXACTIVECIRCUITS  443
	{X25PLE_DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 4}},
#define   X25PLE_DTEMINIMUMRECALLTIMER  444
	{X25PLE_DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 5}},
#define   X25PLE_DTERESETREQUESTRESPONSETIMER  445
	{X25PLE_DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 6}},
#define   X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT  446
	{X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 7}},
#define   X25PLE_DTERESTARTREQUESTRESPONSETIMER  447
	{X25PLE_DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 8}},
#define   X25PLE_DTECLEARREQUESTRESPONSETIMER  448
	{X25PLE_DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 9}},
#define   X25PLE_DTEINTERRUPTRESPONSETIMER  449
	{X25PLE_DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 10}},
#define   X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT  450
	{X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 11}},
#define   X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT  451
	{X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 12}},
#define   X25PLE_DTECALLATTEMPTS  452
	{X25PLE_DTECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 13}},
#define   X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY  453
	{X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 14}},
#define   X25PLE_DTEPROTOCOLERRORSACCUSEDOF  454
	{X25PLE_DTEPROTOCOLERRORSACCUSEDOF, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 15}},
#define   X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  455
	{X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 16}},
#define   X25PLE_DTEOCTETSRECEIVEDCOUNTER  456
	{X25PLE_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 17}},
#define   X25PLE_DTEOCTETSSENTCOUNTER  457
	{X25PLE_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 18}},
#define   X25PLE_DTECALLTIMEOUTS  458
	{X25PLE_DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 19}},
#define   X25PLE_DTECALLSCONNECTED  459
	{X25PLE_DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 20}},
#define   X25PLE_DTECLEARCOUNTSEXCEEDED  460
	{X25PLE_DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 21}},
#define   X25PLE_DTECLEARTIMEOUTS  461
	{X25PLE_DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 22}},
#define   X25PLE_DTEDATAPACKETSRECEIVED  462
	{X25PLE_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 23}},
#define   X25PLE_DTEDATAPACKETSSENT  463
	{X25PLE_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 24}},
#define   X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES  464
	{X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 25}},
#define   X25PLE_DTEPROVIDERINITIATEDRESETS  465
	{X25PLE_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 26}},
#define   X25PLE_DTEPROVIDERINITIATEDDISCONNECTS  466
	{X25PLE_DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 27}},
#define   X25PLE_DTEREMOTELYINITIATEDRESETS  467
	{X25PLE_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 28}},
#define   X25PLE_DTEREMOTELYINITIATEDRESTARTS  468
	{X25PLE_DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 29}},
#define   X25PLE_DTERESETTIMEOUTS  469
	{X25PLE_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 30}},
#define   X25PLE_DTERESTARTCOUNTSEXCEEDED  470
	{X25PLE_DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 31}},
#define   X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER  471
	{X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 32}},
#define   X25PLE_DTEWINDOWROTATIONTIMER  472
	{X25PLE_DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 33}},
#define   X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT  473
	{X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 34}},
#define   X25PLE_DTEREJECTRESPONSETIMER  474
	{X25PLE_DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 35}},
#define   X25PLE_DTEREJECTRETRANSMISSIONCOUNT  475
	{X25PLE_DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 36}},
#define   X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER  476
	{X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 37}},
#define   X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  477
	{X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 38}},
#define   X25PLE_DTEREGISTRATIONPERMITTED  478
	{X25PLE_DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 39}},
#define   X25PLE_DCECALLATTEMPTS  479
	{X25PLE_DCECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 1}},
#define   X25PLE_DCECALLSCONNECTED  480
	{X25PLE_DCECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 2}},
#define   X25PLE_DCECUG         481
	{X25PLE_DCECUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 3}},
#define   X25PLE_DCEFASTSELECTACCEPTANCE  482
	{X25PLE_DCEFASTSELECTACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 4}},
#define   X25PLE_DCEINCOMINGCALLSBARRED  483
	{X25PLE_DCEINCOMINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 5}},
#define   X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING  484
	{X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 6}},
#define   X25PLE_DCEOUTGOINGCALLSBARRED  485
	{X25PLE_DCEOUTGOINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 7}},
#define   X25PLE_DCEDATAPACKETSRECEIVED  486
	{X25PLE_DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 8}},
#define   X25PLE_DCEDATAPACKETSSENT  487
	{X25PLE_DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 9}},
#define   X25PLE_DCEINTERRUPTPACKETSRECEIVED  488
	{X25PLE_DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 10}},
#define   X25PLE_DCEINTERRUPTPACKETSSENT  489
	{X25PLE_DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 11}},
#define   X25PLE_DCEINTERRUPTTIMEREXPIRIES  490
	{X25PLE_DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 12}},
#define   X25PLE_DCEOCTETSRECEIVEDCOUNTER  491
	{X25PLE_DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 13}},
#define   X25PLE_DCEOCTETSSENTCOUNTER  492
	{X25PLE_DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 14}},
#define   X25PLE_DCEPROVIDERINITIATEDDISCONNECTS  493
	{X25PLE_DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 15}},
#define   X25PLE_DCEPROVIDERINITIATEDRESETS  494
	{X25PLE_DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 16}},
#define   X25PLE_DCEREMOTELYINITIATEDRESTARTS  495
	{X25PLE_DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 17}},
#define   X25PLE_DCEREMOTELYINITIATEDRESETS  496
	{X25PLE_DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 18}},
#define   X25PLE_DCERESETTIMEOUTS  497
	{X25PLE_DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 19}},
#define   X25PLE_DCEX25SEGMENTSRECEIVED  498
	{X25PLE_DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 20}},
#define   X25PLE_DCEX25SEGMENTSSENT  499
	{X25PLE_DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 21}},
#define   X25PLE_DCEBILATERALCUG  500
	{X25PLE_DCEBILATERALCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 22}},
#define   X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS  501
	{X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 23}},
#define   X25PLE_DCECALLDEFLECTIONSUBSCRIPTION  502
	{X25PLE_DCECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 24}},
#define   X25PLE_DCECALLREDIRECTION  503
	{X25PLE_DCECALLREDIRECTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 25}},
#define   X25PLE_DCECHARGINGINFORMATION  504
	{X25PLE_DCECHARGINGINFORMATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 26}},
#define   X25PLE_DCECUGWITHINCOMINGACCESS  505
	{X25PLE_DCECUGWITHINCOMINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 27}},
#define   X25PLE_DCECUGWITHOUTGOINGACCESS  506
	{X25PLE_DCECUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 28}},
#define   X25PLE_DCEDBITMODIFICATION  507
	{X25PLE_DCEDBITMODIFICATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 29}},
#define   X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT  508
	{X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 30}},
#define   X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING  509
	{X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 31}},
#define   X25PLE_DCEHUNTGROUP   510
	{X25PLE_DCEHUNTGROUP, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 32}},
#define   X25PLE_DCEINCOMINGCALLBARREDWITHINCUG  511
	{X25PLE_DCEINCOMINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 33}},
#define   X25PLE_DCELOCALCHARGINGPREVENTION  512
	{X25PLE_DCELOCALCHARGINGPREVENTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 34}},
#define   X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES  513
	{X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 35}},
#define   X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES  514
	{X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 36}},
#define   X25PLE_DCENUIOVERRIDE  515
	{X25PLE_DCENUIOVERRIDE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 37}},
#define   X25PLE_DCENUISUBSCRIPTION  516
	{X25PLE_DCENUISUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 38}},
#define   X25PLE_DCEONEWAYLOGICALCHANNELINCOMING  517
	{X25PLE_DCEONEWAYLOGICALCHANNELINCOMING, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 39}},
#define   X25PLE_DCEONLINEFACILITYREGISTRATION  518
	{X25PLE_DCEONLINEFACILITYREGISTRATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 40}},
#define   X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG  519
	{X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 41}},
#define   X25PLE_DCEPACKETRETRANSMISSION  520
	{X25PLE_DCEPACKETRETRANSMISSION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 42}},
#define   X25PLE_DCEREVERSECHARGINGACCEPTANCE  521
	{X25PLE_DCEREVERSECHARGINGACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 43}},
#define   X25PLE_DCEROASUBSCRIPTION  522
	{X25PLE_DCEROASUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 44}},
#define   X25PLE_DCECLEARINDICATION  523
	{X25PLE_DCECLEARINDICATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 45}},
#define   X25PLE_DCEINCOMINGCALL  524
	{X25PLE_DCEINCOMINGCALL, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 46}},
#define   X25PLE_DCERESETINDICATION  525
	{X25PLE_DCERESETINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 47}},
#define   X25PLE_DCERESTARTINDICATION  526
	{X25PLE_DCERESTARTINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 48}},
#define   X25PLEIVMOLOCALDTEADDRESS  527
	{X25PLEIVMOLOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 2}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTS  528
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 3}},
#define   X25PLEIVMOSN_SERVICEPROVIDER  529
	{X25PLEIVMOSN_SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 4}},
#define   X25PLEIVMODEFAULTPACKETSIZES  530
	{X25PLEIVMODEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 5}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSES  531
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 6}},
#define   X25PLEIVMODEFAULTWINDOWSIZES  532
	{X25PLEIVMODEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 7}},
#define   X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION  533
	{X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 8}},
#define   X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION  534
	{X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 9}},
#define   X25PLEIVMOX25PLEMODE  535
	{X25PLEIVMOX25PLEMODE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 10}},
#define   X25PLEIVMOINTERFACEMODE  536
	{X25PLEIVMOINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 11}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASS  537
	{X25PLEIVMODEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 12}},
#define   X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED  538
	{X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 13}},
#define   X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION  539
	{X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 14}},
#define   X25PLEIVMOMAXACTIVECIRCUITS  540
	{X25PLEIVMOMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 15}},
#define   X25PLEIVMORESTARTTIME  541
	{X25PLEIVMORESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 16}},
#define   X25PLEIVMODEFAULTPACKETSIZE  542
	{X25PLEIVMODEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 17}},
#define   X25PLEIVMODEFAULTWINDOWSIZE  543
	{X25PLEIVMODEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 18}},
#define   X25PLEIVMOMINIMUMRECALLTIMER  544
	{X25PLEIVMOMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 19}},
#define   X25PLEIVMORESTARTCOUNT  545
	{X25PLEIVMORESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 20}},
#define   X25PLEIVMOPACKETSEQUENCING  546
	{X25PLEIVMOPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 21}},
#define   X25PLEIVMOREGISTRATIONREQUESTTIME  547
	{X25PLEIVMOREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 22}},
#define   X25PLEIVMOREGISTRATIONREQUESTCOUNT  548
	{X25PLEIVMOREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 23}},
#define   X25PLEIVMOREGISTRATIONPERMITTED  549
	{X25PLEIVMOREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 24}},
#define   X25PLEIVMOROWSTATUS   550
	{X25PLEIVMOROWSTATUS, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 25}},
#define   X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION  551
	{X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 1}},
#define   X25PLEIVMO_DTECALLREQUESTRESPONSETIMER  552
	{X25PLEIVMO_DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 2}},
#define   X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING  553
	{X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 3}},
#define   X25PLEIVMO_DTEMAXACTIVECIRCUITS  554
	{X25PLEIVMO_DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 4}},
#define   X25PLEIVMO_DTEMINIMUMRECALLTIMER  555
	{X25PLEIVMO_DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 5}},
#define   X25PLEIVMO_DTERESETREQUESTRESPONSETIMER  556
	{X25PLEIVMO_DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 6}},
#define   X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT  557
	{X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 7}},
#define   X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER  558
	{X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 8}},
#define   X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER  559
	{X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 9}},
#define   X25PLEIVMO_DTEINTERRUPTRESPONSETIMER  560
	{X25PLEIVMO_DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 10}},
#define   X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT  561
	{X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 11}},
#define   X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT  562
	{X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 12}},
#define   X25PLEIVMO_DTECALLATTEMPTS  563
	{X25PLEIVMO_DTECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 13}},
#define   X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY  564
	{X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 14}},
#define   X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF  565
	{X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 15}},
#define   X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  566
	{X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 16}},
#define   X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER  567
	{X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 17}},
#define   X25PLEIVMO_DTEOCTETSSENTCOUNTER  568
	{X25PLEIVMO_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 18}},
#define   X25PLEIVMO_DTECALLTIMEOUTS  569
	{X25PLEIVMO_DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 19}},
#define   X25PLEIVMO_DTECALLSCONNECTED  570
	{X25PLEIVMO_DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 20}},
#define   X25PLEIVMO_DTECLEARCOUNTSEXCEEDED  571
	{X25PLEIVMO_DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 21}},
#define   X25PLEIVMO_DTECLEARTIMEOUTS  572
	{X25PLEIVMO_DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 22}},
#define   X25PLEIVMO_DTEDATAPACKETSRECEIVED  573
	{X25PLEIVMO_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 23}},
#define   X25PLEIVMO_DTEDATAPACKETSSENT  574
	{X25PLEIVMO_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 24}},
#define   X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES  575
	{X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 25}},
#define   X25PLEIVMO_DTEPROVIDERINITIATEDRESETS  576
	{X25PLEIVMO_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 26}},
#define   X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS  577
	{X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 27}},
#define   X25PLEIVMO_DTEREMOTELYINITIATEDRESETS  578
	{X25PLEIVMO_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 28}},
#define   X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS  579
	{X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 29}},
#define   X25PLEIVMO_DTERESETTIMEOUTS  580
	{X25PLEIVMO_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 30}},
#define   X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED  581
	{X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 31}},
#define   X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER  582
	{X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 32}},
#define   X25PLEIVMO_DTEWINDOWROTATIONTIMER  583
	{X25PLEIVMO_DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 33}},
#define   X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT  584
	{X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 34}},
#define   X25PLEIVMO_DTEREJECTRESPONSETIMER  585
	{X25PLEIVMO_DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 35}},
#define   X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT  586
	{X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 36}},
#define   X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER  587
	{X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 37}},
#define   X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  588
	{X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 38}},
#define   X25PLEIVMO_DTEREGISTRATIONPERMITTED  589
	{X25PLEIVMO_DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 39}},
#define   X25PLEIVMO_DTEROWSTATUS  590
	{X25PLEIVMO_DTEROWSTATUS, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 40}},
#define   X25PLEIVMO_DCEROWSTATUS  591
	{X25PLEIVMO_DCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMO_DCETable, 6, {1, 1, 45, 1, 1, 1}},
#define   VIRTUALCALLCHANNEL    592
	{VIRTUALCALLCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 2}},
#define   VIRTUALCALLPACKETSIZE  593
	{VIRTUALCALLPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 3}},
#define   VIRTUALCALLWINDOWSIZE  594
	{VIRTUALCALLWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 4}},
#define   VIRTUALCALLOCTETSSENTCOUNTER  595
	{VIRTUALCALLOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 5}},
#define   VIRTUALCALLOCTETSRECEIVEDCOUNTER  596
	{VIRTUALCALLOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 6}},
#define   VIRTUALCALLDATAPACKETSSENT  597
	{VIRTUALCALLDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 7}},
#define   VIRTUALCALLDATAPACKETSRECEIVED  598
	{VIRTUALCALLDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 8}},
#define   VIRTUALCALLREMOTELYINITIATEDRESETS  599
	{VIRTUALCALLREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 9}},
#define   VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES  600
	{VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 10}},
#define   VIRTUALCALLPROVIDERINITIATEDRESETS  601
	{VIRTUALCALLPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 11}},
#define   VIRTUALCALLRESETTIMEOUTS  602
	{VIRTUALCALLRESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 12}},
#define   VIRTUALCALLINTERRUPTPACKETSSENT  603
	{VIRTUALCALLINTERRUPTPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 13}},
#define   VIRTUALCALLINTERRUPTPACKETSRECEIVED  604
	{VIRTUALCALLINTERRUPTPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 14}},
#define   VIRTUALCALLINTERRUPTTIMEREXPIRIES  605
	{VIRTUALCALLINTERRUPTTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 15}},
#define   VIRTUALCIRCUITLOGICALCHANNEL  606
	{VIRTUALCIRCUITLOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 2}},
#define   VIRTUALCIRCUITPACKETSIZES  607
	{VIRTUALCIRCUITPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 3}},
#define   VIRTUALCIRCUITTHROUGHPUTCLASSES  608
	{VIRTUALCIRCUITTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 4}},
#define   VIRTUALCIRCUITWINDOWSIZES  609
	{VIRTUALCIRCUITWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER  610
	{VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 1}},
#define   VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER  611
	{VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 2}},
#define   VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED  612
	{VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 3}},
#define   VIRTUALCIRCUIT_DTEDATAPACKETSSENT  613
	{VIRTUALCIRCUIT_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 4}},
#define   VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES  614
	{VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED  615
	{VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 6}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT  616
	{VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 7}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES  617
	{VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 8}},
#define   VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS  618
	{VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 9}},
#define   VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS  619
	{VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 10}},
#define   VIRTUALCIRCUIT_DTERESETTIMEOUTS  620
	{VIRTUALCIRCUIT_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 11}},
#define   VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED  621
	{VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 1}},
#define   VIRTUALCIRCUIT_DCEDATAPACKETSSENT  622
	{VIRTUALCIRCUIT_DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 2}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED  623
	{VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 3}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT  624
	{VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 4}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES  625
	{VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER  626
	{VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 6}},
#define   VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER  627
	{VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 7}},
#define   VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS  628
	{VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 8}},
#define   VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS  629
	{VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 9}},
#define   VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS  630
	{VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 10}},
#define   VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS  631
	{VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 11}},
#define   VIRTUALCIRCUIT_DCERESETTIMEOUTS  632
	{VIRTUALCIRCUIT_DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 12}},
#define   VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED  633
	{VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 13}},
#define   VIRTUALCIRCUIT_DCEX25SEGMENTSSENT  634
	{VIRTUALCIRCUIT_DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 14}},
#define   PERMANENTVIRTUALCIRCUITCHANNEL  635
	{PERMANENTVIRTUALCIRCUITCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUITROWSTATUS  636
	{PERMANENTVIRTUALCIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL  637
	{PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES  638
	{PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES  639
	{PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES  640
	{PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS  641
	{PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION  642
	{PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL  643
	{PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES  644
	{PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES  645
	{PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES  646
	{PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE  647
	{PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 6}},
#define   PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS  648
	{PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 7}},
#define   PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL  649
	{PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 8}},
#define   PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS  650
	{PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 9}},
#define   VIRTUALCALLIVMOFASTSELECT  651
	{VIRTUALCALLIVMOFASTSELECT, ASN_INTEGER, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 2}},
#define   VIRTUALCALLIVMOPACKETSIZES  652
	{VIRTUALCALLIVMOPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 3}},
#define   VIRTUALCALLIVMOREVERSECHARGING  653
	{VIRTUALCALLIVMOREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 4}},
#define   VIRTUALCALLIVMOTHROUGHPUTCLASSES  654
	{VIRTUALCALLIVMOTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 5}},
#define   VIRTUALCALLIVMOWINDOWSIZES  655
	{VIRTUALCALLIVMOWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 6}},
#define   VIRTUALCALLIVMOPROPOSEDPACKETSIZE  656
	{VIRTUALCALLIVMOPROPOSEDPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 7}},
#define   VIRTUALCALLIVMOPROPOSEDWINDOWSIZE  657
	{VIRTUALCALLIVMOPROPOSEDWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 8}},
#define   VIRTUALCALLIVMOACCEPTREVERSECHARGING  658
	{VIRTUALCALLIVMOACCEPTREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 9}},
#define   VIRTUALCALLIVMOPROPOSEREVERSECHARGING  659
	{VIRTUALCALLIVMOPROPOSEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 10}},
#define   VIRTUALCALLIVMOCALLTIME  660
	{VIRTUALCALLIVMOCALLTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 11}},
#define   VIRTUALCALLIVMORESETTIME  661
	{VIRTUALCALLIVMORESETTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 12}},
#define   VIRTUALCALLIVMOCLEARTIME  662
	{VIRTUALCALLIVMOCLEARTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 13}},
#define   VIRTUALCALLIVMOINTERRUPTTIME  663
	{VIRTUALCALLIVMOINTERRUPTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 14}},
#define   VIRTUALCALLIVMORESETCOUNT  664
	{VIRTUALCALLIVMORESETCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 15}},
#define   VIRTUALCALLIVMOCLEARCOUNT  665
	{VIRTUALCALLIVMOCLEARCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 16}},
#define   VIRTUALCALLIVMOWINDOWTIME  666
	{VIRTUALCALLIVMOWINDOWTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 17}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONTIME  667
	{VIRTUALCALLIVMODATARETRANSMISSIONTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 18}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONCOUNT  668
	{VIRTUALCALLIVMODATARETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 19}},
#define   VIRTUALCALLIVMOREJECTTIME  669
	{VIRTUALCALLIVMOREJECTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 20}},
#define   VIRTUALCALLIVMOREJECTCOUNT  670
	{VIRTUALCALLIVMOREJECTCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 21}},
#define   VIRTUALCALLIVMOROWSTATUS  671
	{VIRTUALCALLIVMOROWSTATUS, ASN_INTEGER, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 22}},
#define   SWITCHEDVIRTUALCALLDIRECTION  672
	{SWITCHEDVIRTUALCALLDIRECTION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 1}},
#define   SWITCHEDVIRTUALCALLREMOTEDTEADDRESS  673
	{SWITCHEDVIRTUALCALLREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 2}},
#define   SWITCHEDVIRTUALCALLTHROUGHPUTCLASS  674
	{SWITCHEDVIRTUALCALLTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 3}},
#define   SWITCHEDVIRTUALCALLREDIRECTREASON  675
	{SWITCHEDVIRTUALCALLREDIRECTREASON, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 4}},
#define   SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS  676
	{SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 5}},
#define   SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION  677
	{SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 6}},
#define   SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION  678
	{SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 7}},
#define   SWITCHEDVIRTUALCALLROWSTATUS  679
	{SWITCHEDVIRTUALCALLROWSTATUS, ASN_INTEGER, RWRITE, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 8}},
#define   VIRTUALCALL_DTECALLINGADDRESSEXTENSION  680
	{VIRTUALCALL_DTECALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 1}},
#define   VIRTUALCALL_DTECALLEDADDRESSEXTENSION  681
	{VIRTUALCALL_DTECALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 2}},
#define   VIRTUALCALL_DTEDIRECTION  682
	{VIRTUALCALL_DTEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 3}},
#define   VIRTUALCALL_DTEFASTSELECT  683
	{VIRTUALCALL_DTEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 4}},
#define   VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS  684
	{VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 5}},
#define   VIRTUALCALL_DTEREDIRECTREASON  685
	{VIRTUALCALL_DTEREDIRECTREASON, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 6}},
#define   VIRTUALCALL_DTEREMOTEDTEADDRESS  686
	{VIRTUALCALL_DTEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 7}},
#define   VIRTUALCALL_DTEREVERSECHARGING  687
	{VIRTUALCALL_DTEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 8}},
#define   VIRTUALCALL_DTEROWSTATUS  688
	{VIRTUALCALL_DTEROWSTATUS, ASN_INTEGER, RWRITE, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 9}},
#define   VIRTUALCALL_DCECHARGINGDIRECTION  689
	{VIRTUALCALL_DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 1}},
#define   VIRTUALCALL_DCECUGSELECTION  690
	{VIRTUALCALL_DCECUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 2}},
#define   VIRTUALCALL_DCEDIRECTION  691
	{VIRTUALCALL_DCEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 3}},
#define   VIRTUALCALL_DCEFASTSELECT  692
	{VIRTUALCALL_DCEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 4}},
#define   VIRTUALCALL_DCEREMOTEDTEADDRESS  693
	{VIRTUALCALL_DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 5}},
#define   VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION  694
	{VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 6}},
#define   VIRTUALCALL_DCEBILATERALCUGSELECTION  695
	{VIRTUALCALL_DCEBILATERALCUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 7}},
#define   VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION  696
	{VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 8}},
#define   VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION  697
	{VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 9}},
#define   VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION  698
	{VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 10}},
#define   VIRTUALCALL_DCENUISELECTION  699
	{VIRTUALCALL_DCENUISELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 11}},
#define   VIRTUALCALL_DCEREVERSECHARGING  700
	{VIRTUALCALL_DCEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 12}},
#define   VIRTUALCALL_DCEROASELECTION  701
	{VIRTUALCALL_DCEROASELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 13}},
#define   VIRTUALCALL_DCEROWSTATUS  702
	{VIRTUALCALL_DCEROWSTATUS, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 14}},
#define   DSERIESRESETREQUESTINDICATIONPACKETS  703
	{DSERIESRESETREQUESTINDICATIONPACKETS, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 2}},
#define   DSERIESSEGMENTSSENT   704
	{DSERIESSEGMENTSSENT, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 3}},
#define   DSERIESSEGMENTSRECEIVED  705
	{DSERIESSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 4}},
#define   DSERIESROWSTATUS      706
	{DSERIESROWSTATUS, ASN_INTEGER, RWRITE, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 5}},
#define   ADJACENCYSTATE        707
	{ADJACENCYSTATE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 2}},
#define   NEIGHBOURSNPAADDRESS  708
	{NEIGHBOURSNPAADDRESS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 3}},
#define   NEIGHBOURSYSTEMTYPE   709
	{NEIGHBOURSYSTEMTYPE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 4}},
#define   NEIGHBOURSYSTEMIDS    710
	{NEIGHBOURSYSTEMIDS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 5}},
#define   ADJACENCYUSAGE        711
	{ADJACENCYUSAGE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 6}},
#define   AREAADDRESSESOFNEIGHBOUR  712
	{AREAADDRESSESOFNEIGHBOUR, ASN_OCTET_STR, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 7}},
#define   HOLDINGTIMER          713
	{HOLDINGTIMER, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 8}},
#define   PRIORITYOFNEIGHBOUR   714
	{PRIORITYOFNEIGHBOUR, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 9}},
#define   ADJACENCYROWSTATUS    715
	{ADJACENCYROWSTATUS, ASN_INTEGER, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 10}},
#define   VIRTUALADJACENCYMETRIC  716
	{VIRTUALADJACENCYMETRIC, ASN_INTEGER, RONLY, var_virtualAdjacencyTable, 6, {1, 1, 59, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICPATHCOST  717
	{DESTINATIONDEFAULTMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES  718
	{DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 3}},
#define   DESTINATIONDELAYMETRICPATHCOST  719
	{DESTINATIONDELAYMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 4}},
#define   DESTINATIONDELAYMETRICOUTPUTADJACENCIES  720
	{DESTINATIONDELAYMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 5}},
#define   DESTINATIONEXPENSEMETRICPATHCOST  721
	{DESTINATIONEXPENSEMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 6}},
#define   DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES  722
	{DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 7}},
#define   DESTINATIONERRORMETRICPATHCOST  723
	{DESTINATIONERRORMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 8}},
#define   DESTINATIONERRORMETRICOUTPUTADJACENCIES  724
	{DESTINATIONERRORMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 9}},
#define   DESINTATIONSYSTEMMETRIC  725
	{DESINTATIONSYSTEMMETRIC, ASN_INTEGER, RONLY, var_destinationSystemTable, 6, {1, 1, 61, 1, 1, 3}},
#define   DESTINATIONAREAID     726
	{DESTINATIONAREAID, ASN_OCTET_STR, RONLY, var_destinationAreaTable, 6, {1, 1, 62, 1, 1, 1}},
#define   REACHABLEADDRESSPREFIX  727
	{REACHABLEADDRESSPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 2}},
#define   REACHABLEADDRESSMAPPINGTYPE  728
	{REACHABLEADDRESSMAPPINGTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 3}},
#define   REACHABLEADDRESSDEFAULTMETRIC  729
	{REACHABLEADDRESSDEFAULTMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 4}},
#define   REACHABLEADDRESSDELAYMETRIC  730
	{REACHABLEADDRESSDELAYMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 5}},
#define   REACHABLEADDRESSEXPENSEMETRIC  731
	{REACHABLEADDRESSEXPENSEMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 6}},
#define   REACHABLEADDRESSERRORMETRIC  732
	{REACHABLEADDRESSERRORMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 7}},
#define   REACHABLEADDRESSDEFAULTMETRICTYPE  733
	{REACHABLEADDRESSDEFAULTMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 8}},
#define   REACHABLEADDRESSDELAYMETRICTYPE  734
	{REACHABLEADDRESSDELAYMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 9}},
#define   REACHABLEADDRESSEXPENSEMETRICTYPE  735
	{REACHABLEADDRESSEXPENSEMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 10}},
#define   REACHABLEADDRESSERRORMETRICTYPE  736
	{REACHABLEADDRESSERRORMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 11}},
#define   REACHABLEADDRESSOPERATIONALSTATE  737
	{REACHABLEADDRESSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 12}},
#define   REACHABLEADDRESSADMINISTRATIVESTATE  738
	{REACHABLEADDRESSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 13}},
#define   REACHABLEADDRESSSNPAADDRESSES  739
	{REACHABLEADDRESSSNPAADDRESSES, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 14}},
#define   REACHABLEADDRESSSNPAMASK  740
	{REACHABLEADDRESSSNPAMASK, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 15}},
#define   REACHABLEADDRESSSNPAPREFIX  741
	{REACHABLEADDRESSSNPAPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 16}},
#define   REACHABLEADDRESSROWSTATUS  742
	{REACHABLEADDRESSROWSTATUS, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 17}},
#define   LLCDISCONTINUITYTIME  743
	{LLCDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_dlMIB, 4, {1, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTINTERFACETYPE  744
	{SLPCONNECTIONDEFAULTINTERFACETYPE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTK  745
	{SLPCONNECTIONDEFAULTK, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 2}},
#define   SLPCONNECTIONDEFAULTN1  746
	{SLPCONNECTIONDEFAULTN1, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 3}},
#define   SLPCONNECTIONDEFAULTN2  747
	{SLPCONNECTIONDEFAULTN2, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 4}},
#define   SLPCONNECTIONDEFAULTSEQUENCEMODULUS  748
	{SLPCONNECTIONDEFAULTSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 5}},
#define   SLPCONNECTIONDEFAULTT1TIMER  749
	{SLPCONNECTIONDEFAULTT1TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 6}},
#define   SLPCONNECTIONDEFAULTT2TIMER  750
	{SLPCONNECTIONDEFAULTT2TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 7}},
#define   SLPCONNECTIONDEFAULTT3TIMER  751
	{SLPCONNECTIONDEFAULTT3TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 8}},
#define   SLPCONNECTIONDEFAULTT4TIMER  752
	{SLPCONNECTIONDEFAULTT4TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 9}},
#define   LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS  753
	{LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 1}},
#define   LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE  754
	{LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 2}},
#define   LLCCONNECTION2DEFAULTSENDWINDOWSIZE  755
	{LLCCONNECTION2DEFAULTSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 3}},
#define   LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE  756
	{LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 4}},
#define   LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE  757
	{LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 5}},
#define   LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE  758
	{LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 6}},
#define   LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE  759
	{LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 7}},
#define   LLCCONNECTION2DEFAULTROUTE  760
	{LLCCONNECTION2DEFAULTROUTE, ASN_OCTET_STR, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 8}},
#define   LLCCONNECTION2DEFAULTKSTEP  761
	{LLCCONNECTION2DEFAULTKSTEP, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 9}},
#define   LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE  762
	{LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 10}},
#define   LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS  763
	{LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 11}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE  764
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 1}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS  765
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 2}},
#define   PHYSICALBITERRORTHRESHOLDREACHED  765
	{PHYSICALBITERRORTHRESHOLDREACHED, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 1}},
#define   PHYSICALCONNECTIONERROR  765
	{PHYSICALCONNECTIONERROR, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 2}},
#define   PHSYICALCONNECTIONESTABLISHED  765
	{PHSYICALCONNECTIONESTABLISHED, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 3}},
#define   PHYSICALLOSSOFSIGNAL  765
	{PHYSICALLOSSOFSIGNAL, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 4}},
#define   PHYSICALLOSSOFSYNCHRONIZATION  765
	{PHYSICALLOSSOFSYNCHRONIZATION, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 5}},
#define   FRMR                  765
	{FRMR, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 6}},
#define   PDUSDISCARDED1        765
	{PDUSDISCARDED1, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 7}},
#define   PDUSDISCARDED2        765
	{PDUSDISCARDED2, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 8}},
#define   PDURETRANSMISSIONS    765
	{PDURETRANSMISSIONS, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 9}},
#define   ACKNOWLEDGETIMEOUT    765
	{ACKNOWLEDGETIMEOUT, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 10}},
#define   BUSYSTATETIMEOUT      765
	{BUSYSTATETIMEOUT, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 11}},
#define   REJECTTIMEOUT         765
	{REJECTTIMEOUT, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 12}},
#define   PBITTIMEOUT           765
	{PBITTIMEOUT, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 13}},
#define   TYPE2VIOLATION        765
	{TYPE2VIOLATION, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 14}},
#define   RETRANMISSIONS        765
	{RETRANMISSIONS, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 15}},
#define   TYPE3VIOLATION        765
	{TYPE3VIOLATION, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 16}},
#define   NORESPONSE            765
	{NORESPONSE, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 17}},
#define   PDUSDISCARDED         765
	{PDUSDISCARDED, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 18}},
#define   BUFFERPROBLEMS        765
	{BUFFERPROBLEMS, ASN_COUNTER,, var_dlMIB, 3, {1, 3, 19}},
#define   NOTIFICATIONPDUHEADER  765
	{NOTIFICATIONPDUHEADER, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 20}},
#define   REACHABILITYCHANGE    765
	{REACHABILITYCHANGE, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 21}},
#define   NOTIFICATIONDATA      765
	{NOTIFICATIONDATA, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 22}},
#define   CONSTRAINTVIOLATION   765
	{CONSTRAINTVIOLATION, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 23}},
#define   NOTIFICATIONRECEIVINGADJACENCY  765
	{NOTIFICATIONRECEIVINGADJACENCY, ASN_OBJECT_ID,, var_dlMIB, 3, {1, 3, 24}},
#define   NOTIFICATIONIDLENGTH  765
	{NOTIFICATIONIDLENGTH, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 25}},
#define   NOTIFICATIONAREAADDRESS  765
	{NOTIFICATIONAREAADDRESS, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 26}},
#define   NOTIFICATIONAREAADDRESSES  765
	{NOTIFICATIONAREAADDRESSES, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 27}},
#define   NOTIFICATIONSOURCEID  765
	{NOTIFICATIONSOURCEID, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 28}},
#define   NOTIFICATIONMAXIMUMAREAADDRESSES  765
	{NOTIFICATIONMAXIMUMAREAADDRESSES, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 29}},
#define   NOTIFICATIONVIRTUALLINKCHANGE  765
	{NOTIFICATIONVIRTUALLINKCHANGE, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 30}},
#define   NOTIFICATIONVIRTUALLINKADDRESS  765
	{NOTIFICATIONVIRTUALLINKADDRESS, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 31}},
#define   NOTIFICATIONSYSTEMID  765
	{NOTIFICATIONSYSTEMID, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 32}},
#define   NOTIFICATIONVERSION   765
	{NOTIFICATIONVERSION, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 33}},
#define   NOTIFICATIONDESIGNATEDINTERMEDIATESYSTEMCHANGE  765
	{NOTIFICATIONDESIGNATEDINTERMEDIATESYSTEMCHANGE, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 34}},
#define   NOTIFICATIONOVERLOADSTATECHANGE  765
	{NOTIFICATIONOVERLOADSTATECHANGE, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 35}},
#define   RESERVEDNAME          765
	{RESERVEDNAME, ASN_INTEGER,, var_dlMIB, 3, {1, 3, 36}},
#define   NOTIFICATIONLSPHEADER  765
	{NOTIFICATIONLSPHEADER, ASN_OCTET_STR,, var_dlMIB, 3, {1, 3, 37}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_dlMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_dlMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("dlMIB_simple", dlMIB_simple_variables, variable7, dlMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_dlMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_dlMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_communicationsEntityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_communicationsEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case COMMUNICATIONSENTITYLOCALSAPNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case COMMUNICATIONSENTITYOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sap1Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sap1Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SAP1ADDRESS:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SAP1USERENTITYNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sap2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sap2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SAP2ADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SAP2USERENTITYNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case SAP2PROVIDERENTITYNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_clProtocolMachineTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_clProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CLPROTOCOLMACHINEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLPROTOCOLMACHINETOTALREMOTESAPS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_coProtocolMachineTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_coProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case COPROTOCOLMACHINEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_singlePeerConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_singlePeerConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case UNDERLYINGCONNECTIONNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case SUPPPORTEDCONNECTIONNAMES:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_physicalEntityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_physicalEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PHYSICALENTITYPHYSICALENTITYTITLES:
		*write_method = write_physicalEntityPhysicalEntityTitles;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_physicalSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_physicalSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_dataCircuitTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_dataCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DATACIRCUITBITERRORSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITBITERRORSTRANSMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITBITERRORSTHRESHOLD:
		*write_method = write_dataCircuitBitErrorsThreshold;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITTYPE:
		*write_method = write_dataCircuitType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITPHYSICALMEDIANAMES:
		*write_method = write_dataCircuitPhysicalMediaNames;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITPHYSICALINTERFACETYPE:
		*write_method = write_dataCircuitPhysicalInterfaceType;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITPHYSICALINTERFACESTANDARD:
		*write_method = write_dataCircuitPhysicalInterfaceStandard;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITSYNCHRONIZATIONMODE:
		*write_method = write_dataCircuitSynchronizationMode;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITTRANSMISSIONCODING:
		*write_method = write_dataCircuitTransmissionCoding;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITTRANSMISSIONMODE:
		*write_method = write_dataCircuitTransmissionMode;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DATACIRCUITTRANSMISSIONRATE:
		*write_method = write_dataCircuitTransmissionRate;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DATACIRCUITROWSTATUS:
		*write_method = write_dataCircuitRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_physicalConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_physicalConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PHYSICALCONNECTIONENDPOINTIDENTIFIER:
		*write_method = write_physicalConnectionEndpointIdentifier;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PHYSICALCONNECTIONPORTNUMBER:
		*write_method = write_physicalConnectionPortNumber;
		long_ret = 0;
		return (u_char *) &long_ret;
	case PHYSICALCONNECTIONROWSTATUS:
		*write_method = write_physicalConnectionRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_datalinkEntityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_datalinkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DATALINKENTITYPROVIDERENTITYNAMES:
		*write_method = write_datalinkEntityProviderEntityNames;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case DATALINKENTITYROWSTATUS:
		*write_method = write_datalinkEntityRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_dLSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_dLSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DLSAPROWSTATUS:
		*write_method = write_dLSAPRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lAPBDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lAPBDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LAPBDLEMT1TIMER:
		*write_method = write_lAPBDLEmT1Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMT3TIMER:
		*write_method = write_lAPBDLEmT3Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMW:
		*write_method = write_lAPBDLEmW;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMXSEND:
		*write_method = write_lAPBDLEmXSend;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMXRECEIVE:
		*write_method = write_lAPBDLEmXReceive;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMT2TIMER:
		*write_method = write_lAPBDLEmT2Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLERECEIVEDMLPRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLETIMESMT1EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEIFRAMESREASSIGNMENTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMLPFRAMESRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMLPFRAMESSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLERECEIVEDMLPFRAMESINGUARDREGION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LAPBDLEROWSTATUS:
		*write_method = write_lAPBDLERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sLPPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sLPPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SLPPMADMINISTRATIVESTATE:
		*write_method = write_sLPPMadministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPPMROWSTATUS:
		*write_method = write_sLPPMRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sLPConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sLPConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SLPCONNECTIONINTERFACETYPE:
		*write_method = write_sLPConnectionInterfaceType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONK:
		*write_method = write_sLPConnectionK;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONN1:
		*write_method = write_sLPConnectionN1;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONN2:
		*write_method = write_sLPConnectionN2;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONSEQUENCEMODULUS:
		*write_method = write_sLPConnectionSequenceModulus;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT1TIMER:
		*write_method = write_sLPConnectionT1Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT2TIMER:
		*write_method = write_sLPConnectionT2Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONFCSERRORSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONFRMRSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONFRMRSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMEDATAOCTETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMESRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIFRAMESSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONPOLLSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONREJSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONREJSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONRNRSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONRNRSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONSABMSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONSABMSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONPROTOCOLSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMEST1EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT3TIMER:
		*write_method = write_sLPConnectionT3Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMEST3EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONT4TIMER:
		*write_method = write_sLPConnectionT4Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMEST4EXPIRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONLINKRESETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONLINKRESETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONTIMESN2REACHED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONADMINISTRATIVESTATE:
		*write_method = write_sLPConnectionAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SLPCONNECTIONALARMSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SLPCONNECTIONROWSTATUS:
		*write_method = write_sLPConnectionRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sLPConnectionIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_sLPConnectionIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SLPCONNECTIONIVMOID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SLPCONNECTIONIVMOINTERFACETYPE:
		*write_method = write_sLPConnectionIVMOinterfaceType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOK:
		*write_method = write_sLPConnectionIVMOk;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMON1:
		*write_method = write_sLPConnectionIVMOn1;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMON2:
		*write_method = write_sLPConnectionIVMOn2;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOSEQUENCEMODULUS:
		*write_method = write_sLPConnectionIVMOsequenceModulus;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT1TIMER:
		*write_method = write_sLPConnectionIVMOt1Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT2TIMER:
		*write_method = write_sLPConnectionIVMOt2Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT3TIMER:
		*write_method = write_sLPConnectionIVMOt3Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOT4TIMER:
		*write_method = write_sLPConnectionIVMOt4Timer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SLPCONNECTIONIVMOROWSTATUS:
		*write_method = write_sLPConnectionIVMORowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_mACDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_mACDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case MACDLEROWSTATUS:
		*write_method = write_mACDLERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_mACTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_mACTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case MACOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case MACROWSTATUS:
		*write_method = write_mACRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCDLEROWSTATUS:
		*write_method = write_lLCDLERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCCLPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCCLPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCLPMROWSTATUS:
		*write_method = write_lLCCLPMRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCCOPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCCOPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCOPMROWSTATUS:
		*write_method = write_lLCCOPMRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_resourceTypeIdTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_resourceTypeIdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case RESOURCETYPEIDNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTUREROUI:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTURERNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTURERPRODUCTNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RESOURCEINFOMANUFACTURERPRODUCTVERSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCStationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCStationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCSTATIONLLCNAME:
		*write_method = write_lLCStationLLCName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSTATIONMAXIMUMLSAPSCONFIGURED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONNUMBEROFACTIVELSAPS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONSUPPORTEDSERVICESTYPES:
		*write_method = write_lLCStationSupportedServicesTypes;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSTATIONSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType1AcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE1MAXIMUMRETRYCOUNT:
		*write_method = write_lLCStationType1MaximumRetryCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONMAXIMUMPDUN3:
		*write_method = write_lLCStationMaximumPDUN3;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONMAXIMUMRETRANSMISSIONS4:
		*write_method = write_lLCStationMaximumRetransmissions4;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONRECEIVEVARIABLELIFETIME:
		*write_method = write_lLCStationReceiveVariableLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTRANSMITVARIABLELIFETIME:
		*write_method = write_lLCStationTransmitVariableLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType3AcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE3RETRANSMISSIONS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONAVGBUFFERUSESIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONBUFFERPROBLEMS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONBUFFERSIZE:
		*write_method = write_lLCStationBufferSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONMAXBUFFERUSESIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONINACTIVELSAP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONPDUSDISCARD:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONSTRINDICATOR:
		*write_method = write_lLCStationSTRIndicator;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSTATIONVERSIONNUMBER:
		*write_method = write_lLCStationVersionNumber;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCSAPADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCSAPRDE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_rDESetupTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_rDESetupTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case RDESETUPAGINGENABLED:
		*write_method = write_rDESetupAgingEnabled;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPAGINGVALUE:
		*write_method = write_rDESetupAgingValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPENABLETYPE2RESET:
		*write_method = write_rDESetupEnableType2Reset;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPMAXIMUMROUTEDESCRIPTORS:
		*write_method = write_rDESetupMaximumRouteDescriptors;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPMAXIMUMRESPONSETIME:
		*write_method = write_rDESetupMaximumResponseTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPMINIMUMPDUSIZE:
		*write_method = write_rDESetupMinimumPDUSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPRDEHOLD:
		*write_method = write_rDESetupRDEHold;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPRDEREPLACE:
		*write_method = write_rDESetupRDEReplace;
		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPNAME:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDESETUPRESETONTESTENABLED:
		*write_method = write_rDESetupResetOnTestEnabled;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_rDEPairTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_rDEPairTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case RDEPAIRDISCARDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRNSRPDUCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRNSRSELECTEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRRIF:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case RDEPAIRSRFPDUCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case RDEPAIRQUERYCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnectionLessTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnectionLessTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTIONLESSNAME:
		*write_method = write_lLCConnectionlessName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessMaximumLLCInformationFieldSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTSENTABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSTESTSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSUIRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSUISENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSXIDSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnection2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnection2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTION2NAME:
		*write_method = write_lLCConnection2Name;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTION2MAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2MaximumRetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2ReceivedWindowSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENDWINDOWSIZE:
		*write_method = write_lLCConnection2SendWindowSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2AcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2BUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2BusyStateTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2PBitTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2REJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2RejectTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2LOCALBUSY:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2REMOTEBUSY:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2REMOTERESET:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2LOCALRESET:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PROVIDERRESET:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2ROUTE:
		*write_method = write_lLCConnection2Route;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTION2KSTEP:
		*write_method = write_lLCConnection2KStep;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2MAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2MaxSendWindowSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDI:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTI:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTACKS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDACKS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDFRMR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTFRMR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDRR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTRR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDRNR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTRNR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDREJ:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTREJ:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDSABME:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTSABME:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDUA:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTUA:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDDISC:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTDISC:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2RECEIVEDDM:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2SENTDM:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PDUSDISCARDED1:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PDUSDISCARDED2:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PDURETRANSMISSIONS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2OPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2OptionalTolerationIPDUs;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2DUPLICATEIPDUSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2VIOLATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PROTOCOLSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2ADMINISTRATIVESTATE:
		*write_method = write_lLCConnection2AdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2OPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2USAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2PROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LLCCONNECTION2ALARMSTATUS:
		*write_method = write_lLCConnection2AlarmStatus;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnection2IVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnection2IVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2IVMOMaximumRetransmissions;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMORECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOReceivedWindowSize;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOSendWindowSize;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOAcknowledgeTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBusyStateTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBitTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOREJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMORejectTimeoutValue;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTION2IVMOROUTE:
		*write_method = write_lLCConnection2IVMORoute;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOKSTEP:
		*write_method = write_lLCConnection2IVMOKStep;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOMAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOMaxSendWindowSize;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2IVMOOptionalTolerationIPDUs;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnectionlessAckTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnectionlessAckTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckMaximumLLCInformationFieldSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckMaximumRetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTSENTABBRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKTESTSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRECEIVERESOURCES:
		*write_method = write_lLCConnectionlessAckReceiveResources;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKUIRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKUISENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDSENTCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKXIDSENTRESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRETRANSMISSIONS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKNORESPONSE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDIP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDIT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDOK:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDPE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDRS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDUE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKCOMMANDUN:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRECEIVEDACCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKSENTACCOMMAND:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEIP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEIT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSENE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSENR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEOK:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSERS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEUE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKRESPONSEUN:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKVIOLATION:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_lLCConnectionlessAckIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_lLCConnectionlessAckIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckIVMOMaximumRetransmissions;
		long_ret = 0;
		return (u_char *) &long_ret;
	case LLCCONNECTIONLESSACKIVMOROWSTATUS:
		*write_method = write_lLCConnectionlessAckIVMORowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_networkEntityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_networkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case NETWORKENTITYTITLES:
		*write_method = write_networkEntityTitles;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NETWORKENTITYSYSTEMTYPES:
		*write_method = write_networkEntitySystemTypes;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NETWORKENTITYROWSTATUS:
		*write_method = write_networkEntityRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_nSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_nSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case NSAPROWSTATUS:
		*write_method = write_nSAPRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_cLNSTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_cLNSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CLNSADMINISTRATIVESTATE:
		*write_method = write_cLNSAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSSUPPORTEDPROTOCOLS:
		*write_method = write_cLNSSupportedProtocols;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSOPERATIONALSYSTEMTYPE:
		*write_method = write_cLNSOperationalSystemType;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSSEGMENTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSSEGMENTSDISCARDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSASSEMBLINGSEGMENTSDISCARDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSERRORREPORTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSPDUDISCARDS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSCONGESTIONDISCARDS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSMAXIMUMLIFETIME:
		*write_method = write_cLNSMaximumLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSENABLECHECKSUM:
		*write_method = write_cLNSEnableChecksum;
		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSROWSTATUS:
		*write_method = write_cLNSRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_cLNSISISTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_cLNSISISTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CLNSISISVERSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISISTYPE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISSYSTEMID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISMAXIMUMPATHSPLITS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMAXIMUMLSPGENERATIONINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISCOMPLETESNPINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISORIGINATINGL1LSPBUFFERSIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMANUALAREAADDRESSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISMAXIMUMAREAADDRESSES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMINIMUMLSPGENERATIONINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISPOLLESHELLORATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISPARTIALSNPINTERVAL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISWAITINGTIME:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISDRISISHELLOTIMER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISL1STATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISAREAADDRESSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISCORRUPTEDLSPSDETECTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLSPL1DATABASEOVERLOADS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMANUALADDRESSESDROPPEDFROMAREAS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISSEQUENCENUMBERSKIPS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISOWNLSPPURGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISIDFIELDLENGTHMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISMAXIMUMAREAADDRESSESMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLSPTOOLARGETOPROPAGATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISAREATRANSMITPASSWORD:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISAREARECEIVEPASSWORDS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISAUTHENTICATIONFAILURES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_cLNSISISLevel2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_cLNSISISLevel2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2PARTITIONAREAADDRESSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2L2STATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2LSPL2DATABASEOVERLOADS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case CLNSISISLEVEL2DOMAINTRANSMITPASSWORD:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CLNSISISLEVEL2ROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_linkageTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_linkageTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case LINKAGEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEADMINISTRATIVESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGESNSERVICEPROVIDER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGESNSAP:

		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case LINKAGEOPERATIONALPROTOCOLS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISO9542OPERATIONALSUBSETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISHOLDINGTIMERMULTIPLIER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCONFIGURATIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISSUGGESTEDESCONFIGURATIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISREDIRECTHOLDINGTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISESREACHABILITYCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISINVALID9542PDUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEESISO9542OPERATIONALSUBSETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESHOLDINGTIMERMULTIPLIER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESMANUALISSNPAADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESDEFAULTESCONFIGTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESACTIVEESCONFIGTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEESISREACHABILITYCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEESINVALID9542PDUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEENABLECHECKSUM:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEINITIALMINIMUMTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGERESERVETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEIDLETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGESNDCFCALLSPLACED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGESNDCFCALLSFAILED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGECODLCALLSPLACED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGECODLCALLSFAILED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISTYPE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISISISHELLOTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1DEFAULTMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1DELAYMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1EXPENSEMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1ERRORMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISEXTERNALDOMAIN:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCHANGEDINADJACENCYSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISINITIALISATIONFAILURES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISREJECTEDADJACENCIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISISISCONTROLPDUSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISISISCONTROLPDUSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISIDFIELDLENTHMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISCIRCUITTRANSMITPASSWORD:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCIRCUITRECEIVEDPASSWORDS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISAUTHENTICATIONFAILURES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1CIRCUITID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISPTPTCIRCUITID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISOUTGOINGCALLIVMO:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISNEIGHBORSNPAADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2DEFAULTMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2DELAYMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2EXPENSEMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2ERRORMETRIC:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISMANUALL2ONLYMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2CIRCUITID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case LINKAGEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_cONSTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_cONSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case CONSADMINISTRATIVESTATE:
		*write_method = write_cONSAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case CONSOPERATIONALSYSTEMTYPE:
		*write_method = write_cONSOperationalSystemType;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case CONSROWSTATUS:
		*write_method = write_cONSRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_networkConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_networkConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case NETWORKCONNECTIONLOCALNSAPMO:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NETWORKCONNECTIONREMOTENSAPADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NETWORKCONNECTIONROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEADMINISTRATIVESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEPROTOCOLVERSIONSUPPORTED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLELOCALDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTTHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEFLOWCONTROLPARAMETERNEGOTIATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDEFAULTPACKAGESIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLETHROUGHPUTCLASSNEGOTIATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLESNSERVICEPROVIDER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLESNSAP:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PELOGICALCHANNELASSIGNMENTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEINTERFACEMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTTHROUGHPUTCLASS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEFLOWCONTROLNEGOTIATIONPERMITTED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEMAXACTIVECIRCUITS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLERESTARTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDEFAULTPACKETSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDEFAULTWINDOWSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEMINIMUMRECALLTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLERESTARTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLESN_SERVICEPROVIDER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLESN_SA_P:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLELOGICALCHANNELASSIGNMENTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPACKETSEQUENCING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEOCTETSSENTCOUNTER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEOCTETSRECEIVEDCOUNTER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDATAPACKETSSENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDATAPACKETSRECEIVED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECALLATTEMPTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECALLSCONNECTED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLECALLTIMEOUTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECLEARTIMEOUTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREMOTELYINITIATEDRESETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDATARETRANSMISSIONTIMEREXPIRIES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPROVIDERINITIATEDRESETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLERESETTIMEOUTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREMOTELYINITIATEDRESTARTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLERESTARTCOUNTSEXCEEDED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPROTOCOLERRORSDETECTEDLOCALLY:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPROTOCOLERRORSACCUSEDOF:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLECLEARCOUNTSEXCEEDED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPLECLIENTMONAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREGISTRATIONREQUESTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREGISTRATIONREQUESTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEREGISTRATIONPERMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLE_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLE_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLE_DTECALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECALLREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEMAXACTIVECIRCUITS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEMINIMUMRECALLTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTERESETREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTERESTARTREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTECLEARREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEINTERRUPTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTECALLATTEMPTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEPROTOCOLERRORSACCUSEDOF:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECALLTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECALLSCONNECTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECLEARCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTECLEARTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEREMOTELYINITIATEDRESTARTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTERESTARTCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEWINDOWROTATIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREJECTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREJECTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DTEREGISTRATIONPERMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLE_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLE_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLE_DCECALLATTEMPTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECALLSCONNECTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECUG:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEFASTSELECTACCEPTANCE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINCOMINGCALLSBARRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEOUTGOINGCALLSBARRED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINTERRUPTPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINTERRUPTPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINTERRUPTTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEREMOTELYINITIATEDRESTARTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEX25SEGMENTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEX25SEGMENTSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEBILATERALCUG:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECALLREDIRECTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECHARGINGINFORMATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECUGWITHINCOMINGACCESS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECUGWITHOUTGOINGACCESS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEDBITMODIFICATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCEHUNTGROUP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINCOMINGCALLBARREDWITHINCUG:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCELOCALCHARGINGPREVENTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCENUIOVERRIDE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCENUISUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEONEWAYLOGICALCHANNELINCOMING:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEONLINEFACILITYREGISTRATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEPACKETRETRANSMISSION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEREVERSECHARGINGACCEPTANCE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEROASUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCECLEARINDICATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLE_DCEINCOMINGCALL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCERESETINDICATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLE_DCERESTARTINDICATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLEIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMOLOCALDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOSN_SERVICEPROVIDER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOX25PLEMODE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOINTERFACEMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOMAXACTIVECIRCUITS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMORESTARTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTPACKETSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMODEFAULTWINDOWSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOMINIMUMRECALLTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMORESTARTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOPACKETSEQUENCING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOREGISTRATIONREQUESTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOREGISTRATIONREQUESTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOREGISTRATIONPERMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMO_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLEIVMO_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECALLREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEMAXACTIVECIRCUITS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEMINIMUMRECALLTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTERESETREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEINTERRUPTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTECALLATTEMPTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECALLTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECALLSCONNECTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECLEARCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTECLEARTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEWINDOWROTATIONTIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREJECTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMO_DTEREGISTRATIONPERMITTED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMO_DTEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMO_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_x25PLEIVMO_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMO_DCEROWSTATUS:
		*write_method = write_x25PLEIVMO - DCERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCallTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCALLCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLPACKETSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLWINDOWSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLOCTETSSENTCOUNTER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLOCTETSRECEIVEDCOUNTER:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLDATAPACKETSSENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLDATAPACKETSRECEIVED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLREMOTELYINITIATEDRESETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLPROVIDERINITIATEDRESETS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLRESETTIMEOUTS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLINTERRUPTPACKETSSENT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLINTERRUPTPACKETSRECEIVED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLINTERRUPTTIMEREXPIRIES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCircuitTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCIRCUITLOGICALCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCIRCUITPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCIRCUITTHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCIRCUITWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCircuit_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCircuit_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DTERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCircuit_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCircuit_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEDATAPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCERESETTIMEOUTS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCIRCUIT_DCEX25SEGMENTSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_permanentVirtualCircuitTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_permanentVirtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PERMANENTVIRTUALCIRCUITCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUITROWSTATUS:
		*write_method = write_permanentVirtualCircuitRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_permanentVirtualCircuit_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_permanentVirtualCircuit_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_permanentVirtualCircuit_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_permanentVirtualCircuit_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCallIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCallIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCALLIVMOFASTSELECT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALLIVMOPACKETSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOTHROUGHPUTCLASSES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOWINDOWSIZES:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOPROPOSEDPACKETSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOPROPOSEDWINDOWSIZE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOACCEPTREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOPROPOSEREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOCALLTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMORESETTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOCLEARTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOINTERRUPTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMORESETCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOCLEARCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOWINDOWTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMODATARETRANSMISSIONTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMODATARETRANSMISSIONCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOREJECTTIME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOREJECTCOUNT:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALLIVMOROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_switchedVirtualCallTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_switchedVirtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SWITCHEDVIRTUALCALLDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLTHROUGHPUTCLASS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLREDIRECTREASON:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SWITCHEDVIRTUALCALLROWSTATUS:
		*write_method = write_switchedVirtualCallRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCall_DTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCall_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCALL_DTECALLINGADDRESSEXTENSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTECALLEDADDRESSEXTENSION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEFASTSELECT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEREDIRECTREASON:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DTEROWSTATUS:
		*write_method = write_virtualCall - DTERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualCall_DCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualCall_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALCALL_DCECHARGINGDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCECUGSELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEDIRECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEFASTSELECT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALL_DCEREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEBILATERALCUGSELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCENUISELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEREVERSECHARGING:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEROASELECTION:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case VIRTUALCALL_DCEROWSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_dSeriesCountsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_dSeriesCountsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DSERIESRESETREQUESTINDICATIONPACKETS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DSERIESSEGMENTSSENT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DSERIESSEGMENTSRECEIVED:

		long_ret = 0;
		return (u_char *) &long_ret;
	case DSERIESROWSTATUS:
		*write_method = write_dSeriesRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_adjacencyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_adjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case ADJACENCYSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case NEIGHBOURSNPAADDRESS:
		*write_method = write_neighbourSNPAAddress;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case NEIGHBOURSYSTEMTYPE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case NEIGHBOURSYSTEMIDS:
		*write_method = write_neighbourSystemIds;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case ADJACENCYUSAGE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case AREAADDRESSESOFNEIGHBOUR:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case HOLDINGTIMER:

		long_ret = 0;
		return (u_char *) &long_ret;
	case PRIORITYOFNEIGHBOUR:

		long_ret = 0;
		return (u_char *) &long_ret;
	case ADJACENCYROWSTATUS:
		*write_method = write_adjacencyRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_virtualAdjacencyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_virtualAdjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case VIRTUALADJACENCYMETRIC:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_destinationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_destinationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DESTINATIONDEFAULTMETRICPATHCOST:
		*write_method = write_destinationDefaultMetricPathCost;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationDefaultMetricOutputAdjacencies;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DESTINATIONDELAYMETRICPATHCOST:
		*write_method = write_destinationDelayMetricPathCost;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DESTINATIONDELAYMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationDelayMetricOutputAdjacencies;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DESTINATIONEXPENSEMETRICPATHCOST:
		*write_method = write_destinationExpenseMetricPathCost;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationExpenseMetricOutputAdjacencies;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case DESTINATIONERRORMETRICPATHCOST:
		*write_method = write_destinationErrorMetricPathCost;
		long_ret = 0;
		return (u_char *) &long_ret;
	case DESTINATIONERRORMETRICOUTPUTADJACENCIES:
		*write_method = write_destinationErrorMetricOutputAdjacencies;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_destinationSystemTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_destinationSystemTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DESINTATIONSYSTEMMETRIC:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_destinationAreaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_destinationAreaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case DESTINATIONAREAID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_reachableAddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dlMIB_simple above.
 */
unsigned char *
var_reachableAddressTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case REACHABLEADDRESSPREFIX:
		*write_method = write_reachableAddressPrefix;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case REACHABLEADDRESSMAPPINGTYPE:
		*write_method = write_reachableAddressMappingType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSDEFAULTMETRIC:
		*write_method = write_reachableAddressDefaultMetric;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSDELAYMETRIC:
		*write_method = write_reachableAddressDelayMetric;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSEXPENSEMETRIC:
		*write_method = write_reachableAddressExpenseMetric;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSERRORMETRIC:
		*write_method = write_reachableAddressErrorMetric;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSDEFAULTMETRICTYPE:
		*write_method = write_reachableAddressDefaultMetricType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSDELAYMETRICTYPE:
		*write_method = write_reachableAddressDelayMetricType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSEXPENSEMETRICTYPE:
		*write_method = write_reachableAddressExpenseMetricType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSERRORMETRICTYPE:
		*write_method = write_reachableAddressErrorMetricType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSADMINISTRATIVESTATE:
		*write_method = write_reachableAddressAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case REACHABLEADDRESSSNPAADDRESSES:
		*write_method = write_reachableAddressSNPAAddresses;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case REACHABLEADDRESSSNPAMASK:
		*write_method = write_reachableAddressSNPAMask;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case REACHABLEADDRESSSNPAPREFIX:
		*write_method = write_reachableAddressSNPAPrefix;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case REACHABLEADDRESSROWSTATUS:
		*write_method = write_reachableAddressRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_physicalEntityPhysicalEntityTitles(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to physicalEntityPhysicalEntityTitles not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to physicalEntityPhysicalEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitBitErrorsThreshold(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OPAQUE) {
			fprintf(stderr, "write to dataCircuitBitErrorsThreshold not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitBitErrorsThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dataCircuitType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dataCircuitType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitPhysicalMediaNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to dataCircuitPhysicalMediaNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitPhysicalMediaNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitPhysicalInterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to dataCircuitPhysicalInterfaceType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitPhysicalInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitPhysicalInterfaceStandard(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to dataCircuitPhysicalInterfaceStandard not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitPhysicalInterfaceStandard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitSynchronizationMode(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dataCircuitSynchronizationMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dataCircuitSynchronizationMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitTransmissionCoding(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to dataCircuitTransmissionCoding not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitTransmissionCoding: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitTransmissionMode(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dataCircuitTransmissionMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dataCircuitTransmissionMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitTransmissionRate(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OPAQUE) {
			fprintf(stderr, "write to dataCircuitTransmissionRate not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to dataCircuitTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dataCircuitRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dataCircuitRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dataCircuitRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalConnectionEndpointIdentifier(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to physicalConnectionEndpointIdentifier not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to physicalConnectionEndpointIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalConnectionPortNumber(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to physicalConnectionPortNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to physicalConnectionPortNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_physicalConnectionRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to physicalConnectionRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to physicalConnectionRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_datalinkEntityProviderEntityNames(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to datalinkEntityProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to datalinkEntityProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_datalinkEntityRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to datalinkEntityRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to datalinkEntityRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dLSAPRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dLSAPRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmW(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmW not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmW: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXSend(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmXSend not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmXSend: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXReceive(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmXReceive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmXReceive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLEmT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLEmT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lAPBDLERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lAPBDLERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMadministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPPMadministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPPMadministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPPMRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPPMRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionInterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionK(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionSequenceModulus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT4Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOinterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOinterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOinterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOk(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOk not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOk: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOn1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOn1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOn2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOn2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOsequenceModulus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOsequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOsequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt4Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMOt4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMOt4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMORowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionIVMORowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionIVMORowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACDLERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to mACDLERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to mACDLERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to mACRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to mACRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCDLERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCDLERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCDLERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCLPMRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCCLPMRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCCLPMRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCOPMRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCCOPMRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCCOPMRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationLLCName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCStationLLCName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCStationLLCName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSupportedServicesTypes(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to lLCStationSupportedServicesTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCStationSupportedServicesTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1AcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationType1AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationType1AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1MaximumRetryCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationType1MaximumRetryCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationType1MaximumRetryCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumPDUN3(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationMaximumPDUN3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationMaximumPDUN3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumRetransmissions4(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationMaximumRetransmissions4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationMaximumRetransmissions4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationReceiveVariableLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationReceiveVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationReceiveVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationTransmitVariableLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationTransmitVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationTransmitVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType3AcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationType3AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationType3AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationBufferSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationBufferSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationBufferSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSTRIndicator(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to lLCStationSTRIndicator not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCStationSTRIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationVersionNumber(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCStationVersionNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCStationVersionNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingEnabled(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupAgingEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupAgingEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupAgingValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupAgingValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupEnableType2Reset(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupEnableType2Reset not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupEnableType2Reset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumRouteDescriptors(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupMaximumRouteDescriptors not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupMaximumRouteDescriptors: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumResponseTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupMaximumResponseTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupMaximumResponseTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMinimumPDUSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupMinimumPDUSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupMinimumPDUSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEHold(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupRDEHold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupRDEHold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEReplace(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupRDEReplace not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupRDEReplace: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupResetOnTestEnabled(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to rDESetupResetOnTestEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to rDESetupResetOnTestEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnectionlessName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnectionlessName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Name(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnection2Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2MaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2MaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2ReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2ReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2SendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2SendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2BusyStateTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2BusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2BusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PBitTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2PBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2PBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2RejectTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2RejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2RejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Route(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnection2Route not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2Route: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2KStep(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2KStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2KStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaxSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2MaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2MaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2OptionalTolerationIPDUs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2OptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2OptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AlarmStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to lLCConnection2AlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2AlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOMaximumRetransmissions not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOReceivedWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOReceivedWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOAcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBusyStateTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBitTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORejectTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMORejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMORejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORoute(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMORoute not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMORoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOKStep(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOKStep not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaxSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to lLCConnection2IVMOMaxSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOOptionalTolerationIPDUs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2IVMOOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckReceiveResources(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckReceiveResources not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckReceiveResources: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMORowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMORowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckIVMORowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkEntityTitles(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to networkEntityTitles not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to networkEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkEntitySystemTypes(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to networkEntitySystemTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to networkEntitySystemTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_networkEntityRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to networkEntityRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to networkEntityRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_nSAPRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to nSAPRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to nSAPRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cLNSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cLNSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSSupportedProtocols(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to cLNSSupportedProtocols not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to cLNSSupportedProtocols: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSOperationalSystemType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to cLNSOperationalSystemType not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to cLNSOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSMaximumLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cLNSMaximumLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cLNSMaximumLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSEnableChecksum(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cLNSEnableChecksum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cLNSEnableChecksum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cLNSRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cLNSRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cLNSRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cONSAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cONSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cONSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cONSOperationalSystemType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to cONSOperationalSystemType not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to cONSOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_cONSRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to cONSRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to cONSRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMO_DCERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMO_DCERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMO_DCERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_permanentVirtualCircuitRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to permanentVirtualCircuitRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to permanentVirtualCircuitRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_switchedVirtualCallRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to switchedVirtualCallRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to switchedVirtualCallRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_virtualCall_DTERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to virtualCall_DTERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to virtualCall_DTERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dSeriesRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to dSeriesRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to dSeriesRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_neighbourSNPAAddress(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to neighbourSNPAAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to neighbourSNPAAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_neighbourSystemIds(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to neighbourSystemIds not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to neighbourSystemIds: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_adjacencyRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to adjacencyRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to adjacencyRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDefaultMetricPathCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to destinationDefaultMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to destinationDefaultMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDefaultMetricOutputAdjacencies(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to destinationDefaultMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to destinationDefaultMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDelayMetricPathCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to destinationDelayMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to destinationDelayMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationDelayMetricOutputAdjacencies(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to destinationDelayMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to destinationDelayMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationExpenseMetricPathCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to destinationExpenseMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to destinationExpenseMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationExpenseMetricOutputAdjacencies(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to destinationExpenseMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to destinationExpenseMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationErrorMetricPathCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to destinationErrorMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to destinationErrorMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_destinationErrorMetricOutputAdjacencies(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to destinationErrorMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to destinationErrorMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressPrefix(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to reachableAddressPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to reachableAddressPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressMappingType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressMappingType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressMappingType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDefaultMetric(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressDefaultMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressDefaultMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDelayMetric(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressDelayMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressDelayMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressExpenseMetric(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressExpenseMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressExpenseMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressErrorMetric(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressErrorMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressErrorMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDefaultMetricType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressDefaultMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressDefaultMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressDelayMetricType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressDelayMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressDelayMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressExpenseMetricType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressExpenseMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressExpenseMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressErrorMetricType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressErrorMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressErrorMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressSNPAAddresses(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to reachableAddressSNPAAddresses not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to reachableAddressSNPAAddresses: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressSNPAMask(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to reachableAddressSNPAMask not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to reachableAddressSNPAMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressSNPAPrefix(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to reachableAddressSNPAPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to reachableAddressSNPAPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_reachableAddressRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to reachableAddressRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to reachableAddressRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultInterfaceType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultK(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultSequenceModulus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT1Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT2Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT3Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT4Timer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sLPConnectionDefaultT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sLPConnectionDefaultT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultReceivedWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultAcknowledgeTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultBusyStateTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultPBitTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultPBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultPBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRejectTimeoutValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultRejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultRejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRoute(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to lLCConnection2DefaultRoute not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to lLCConnection2DefaultRoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultKStep(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultKStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaxSendWindowSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultMaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultOptionalTolerationIPDUs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnection2DefaultOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumRetransmissions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to lLCConnectionlessAckDefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
