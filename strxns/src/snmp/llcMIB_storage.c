/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "llcMIB_storage.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int llcMIB_refresh = 1;
volatile int mACDLETable_refresh = 1;
volatile int mACTable_refresh = 1;
volatile int resourceTypeIdTable_refresh = 1;
volatile int dLSAPTable_refresh = 1;
volatile int lLCDLETable_refresh = 1;
volatile int lLCStationTable_refresh = 1;
volatile int lLCSAPTable_refresh = 1;
volatile int rDESetupTable_refresh = 1;
volatile int rDEPairTable_refresh = 1;
volatile int lLCCLPMTable_refresh = 1;
volatile int lLCConnectionLessTable_refresh = 1;
volatile int lLCCOPMTable_refresh = 1;
volatile int lLCConnection2Table_refresh = 1;
volatile int lLCConnection2IVMOTable_refresh = 1;
volatile int lLCConnectionlessAckTable_refresh = 1;
volatile int lLCConnectionlessAckIVMOTable_refresh = 1;

/*
 * llcMIB_variables_oid: object identifier for llcMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid llcMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 23 };
oid mACDLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 23, 1, 1, 1, 1, 1 };
oid mACTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 23, 1, 1, 2, 1, 1 };
oid dLSAPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 23, 1, 1, 4, 1, 1 };
oid lLCDLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 23, 1, 1, 5, 1, 1 };
oid lLCCLPMTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 23, 1, 1, 10, 1, 1 };
oid lLCCOPMTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 23, 1, 1, 12, 1, 1 };
oid lLCConnectionlessAckIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 23, 1, 1, 16, 1, 1 };

/*
 * variable7 llcMIB_variables: tree for llcMIB
 * This variable defines function callbacks and type return information for the llcMIB mib section
 */
struct variable7 llcMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   MACDLELOCALSAPNAMES   (4 % 256)
	{MACDLELOCALSAPNAMES, ASN_OBJECT_ID, RWRITE, var_mACDLETable, 6, {1, 1, 1, 1, 1, 2}},
#define   MACDLEOPERATIONALSTATE  (5 % 256)
	{MACDLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mACDLETable, 6, {1, 1, 1, 1, 1, 3}},
#define   MACDLEPROVIDERENTITYNAMES  (6 % 256)
	{MACDLEPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_mACDLETable, 6, {1, 1, 1, 1, 1, 4}},
#define   MACDLEROWSTATUS       (7 % 256)
	{MACDLEROWSTATUS, ASN_INTEGER, RWRITE, var_mACDLETable, 6, {1, 1, 1, 1, 1, 5}},
#define   MACOPERATIONALSTATE   (11 % 256)
	{MACOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mACTable, 6, {1, 1, 2, 1, 1, 1}},
#define   MACROWSTATUS          (13 % 256)
	{MACROWSTATUS, ASN_INTEGER, RWRITE, var_mACTable, 6, {1, 1, 2, 1, 1, 3}},
#define   RESOURCETYPEIDNAME    (17 % 256)
	{RESOURCETYPEIDNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 1}},
#define   RESOURCEINFOMANUFACTUREROUI  (18 % 256)
	{RESOURCEINFOMANUFACTUREROUI, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 2}},
#define   RESOURCEINFOMANUFACTURERNAME  (19 % 256)
	{RESOURCEINFOMANUFACTURERNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 3}},
#define   RESOURCEINFOMANUFACTURERPRODUCTNAME  (20 % 256)
	{RESOURCEINFOMANUFACTURERPRODUCTNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 4}},
#define   RESOURCEINFOMANUFACTURERPRODUCTVERSION  (21 % 256)
	{RESOURCEINFOMANUFACTURERPRODUCTVERSION, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 3, 1, 1, 5}},
#define   DLSAPSAP1ADDRESS      (26 % 256)
	{DLSAPSAP1ADDRESS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 4, 1, 1, 2}},
#define   DLSAPUSERENTITYNAMES  (27 % 256)
	{DLSAPUSERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_dLSAPTable, 6, {1, 1, 4, 1, 1, 3}},
#define   DLSAPROWSTATUS        (28 % 256)
	{DLSAPROWSTATUS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 4, 1, 1, 4}},
#define   LLCDLELOCALSAPNAMES   (32 % 256)
	{LLCDLELOCALSAPNAMES, ASN_OBJECT_ID, RWRITE, var_lLCDLETable, 6, {1, 1, 5, 1, 1, 2}},
#define   LLCDLEOPERATIONALSTATE  (33 % 256)
	{LLCDLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCDLETable, 6, {1, 1, 5, 1, 1, 3}},
#define   LLCDLEPROVIDERENTITYNAMES  (34 % 256)
	{LLCDLEPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_lLCDLETable, 6, {1, 1, 5, 1, 1, 4}},
#define   LLCDLEROWSTATUS       (35 % 256)
	{LLCDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lLCDLETable, 6, {1, 1, 5, 1, 1, 5}},
#define   LLCSTATIONLLCNAME     (40 % 256)
	{LLCSTATIONLLCNAME, ASN_OCTET_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 1}},
#define   LLCSTATIONMAXIMUMLSAPSCONFIGURED  (41 % 256)
	{LLCSTATIONMAXIMUMLSAPSCONFIGURED, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 2}},
#define   LLCSTATIONNUMBEROFACTIVELSAPS  (42 % 256)
	{LLCSTATIONNUMBEROFACTIVELSAPS, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 3}},
#define   LLCSTATIONSUPPORTEDSERVICESTYPES  (43 % 256)
	{LLCSTATIONSUPPORTEDSERVICESTYPES, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 4}},
#define   LLCSTATIONSTATUS      (44 % 256)
	{LLCSTATIONSTATUS, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 5}},
#define   LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE  (45 % 256)
	{LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 6}},
#define   LLCSTATIONTYPE1MAXIMUMRETRYCOUNT  (46 % 256)
	{LLCSTATIONTYPE1MAXIMUMRETRYCOUNT, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 7}},
#define   LLCSTATIONMAXIMUMPDUN3  (47 % 256)
	{LLCSTATIONMAXIMUMPDUN3, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 8}},
#define   LLCSTATIONMAXIMUMRETRANSMISSIONS4  (48 % 256)
	{LLCSTATIONMAXIMUMRETRANSMISSIONS4, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 9}},
#define   LLCSTATIONRECEIVEVARIABLELIFETIME  (49 % 256)
	{LLCSTATIONRECEIVEVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 10}},
#define   LLCSTATIONTRANSMITVARIABLELIFETIME  (50 % 256)
	{LLCSTATIONTRANSMITVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 11}},
#define   LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE  (51 % 256)
	{LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 12}},
#define   LLCSTATIONTYPE3RETRANSMISSIONS  (52 % 256)
	{LLCSTATIONTYPE3RETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 13}},
#define   LLCSTATIONAVGBUFFERUSESIZE  (53 % 256)
	{LLCSTATIONAVGBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 14}},
#define   LLCSTATIONBUFFERPROBLEMS  (54 % 256)
	{LLCSTATIONBUFFERPROBLEMS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 15}},
#define   LLCSTATIONBUFFERSIZE  (55 % 256)
	{LLCSTATIONBUFFERSIZE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 16}},
#define   LLCSTATIONMAXBUFFERUSESIZE  (56 % 256)
	{LLCSTATIONMAXBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 17}},
#define   LLCSTATIONINACTIVELSAP  (57 % 256)
	{LLCSTATIONINACTIVELSAP, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 18}},
#define   LLCSTATIONPDUSDISCARD  (58 % 256)
	{LLCSTATIONPDUSDISCARD, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 19}},
#define   LLCSTATIONSTRINDICATOR  (59 % 256)
	{LLCSTATIONSTRINDICATOR, ASN_BIT_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 20}},
#define   LLCSTATIONVERSIONNUMBER  (60 % 256)
	{LLCSTATIONVERSIONNUMBER, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 21}},
#define   LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS  (61 % 256)
	{LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 6, 1, 1, 22}},
#define   LLCSAPADDRESS         (67 % 256)
	{LLCSAPADDRESS, ASN_OCTET_STR, RONLY, var_lLCSAPTable, 6, {1, 1, 7, 1, 1, 2}},
#define   LLCSAPRDE             (68 % 256)
	{LLCSAPRDE, ASN_INTEGER, RONLY, var_lLCSAPTable, 6, {1, 1, 7, 1, 1, 3}},
#define   RDESETUPAGINGENABLED  (73 % 256)
	{RDESETUPAGINGENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 1}},
#define   RDESETUPAGINGVALUE    (74 % 256)
	{RDESETUPAGINGVALUE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 2}},
#define   RDESETUPENABLETYPE2RESET  (75 % 256)
	{RDESETUPENABLETYPE2RESET, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 3}},
#define   RDESETUPMAXIMUMROUTEDESCRIPTORS  (76 % 256)
	{RDESETUPMAXIMUMROUTEDESCRIPTORS, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 4}},
#define   RDESETUPMAXIMUMRESPONSETIME  (77 % 256)
	{RDESETUPMAXIMUMRESPONSETIME, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 5}},
#define   RDESETUPMINIMUMPDUSIZE  (78 % 256)
	{RDESETUPMINIMUMPDUSIZE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 6}},
#define   RDESETUPRDEHOLD       (79 % 256)
	{RDESETUPRDEHOLD, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 7}},
#define   RDESETUPRDEREPLACE    (80 % 256)
	{RDESETUPRDEREPLACE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 8}},
#define   RDESETUPNAME          (81 % 256)
	{RDESETUPNAME, ASN_INTEGER, RONLY, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 9}},
#define   RDESETUPRESETONTESTENABLED  (82 % 256)
	{RDESETUPRESETONTESTENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 8, 1, 1, 10}},
#define   RDEPAIRDISCARDCOUNTER  (88 % 256)
	{RDEPAIRDISCARDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 2}},
#define   RDEPAIRNSRPDUCOUNTER  (89 % 256)
	{RDEPAIRNSRPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 3}},
#define   RDEPAIRNSRSELECTEDCOUNTER  (90 % 256)
	{RDEPAIRNSRSELECTEDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 4}},
#define   RDEPAIRRIF            (91 % 256)
	{RDEPAIRRIF, ASN_OCTET_STR, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 5}},
#define   RDEPAIRSRFPDUCOUNTER  (92 % 256)
	{RDEPAIRSRFPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 6}},
#define   RDEPAIRQUERYCOUNTER   (93 % 256)
	{RDEPAIRQUERYCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 9, 1, 1, 7}},
#define   LLCCLPMOPERATIONALSTATE  (97 % 256)
	{LLCCLPMOPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCCLPMTable, 6, {1, 1, 10, 1, 1, 2}},
#define   LLCCLPMTOTALREMOTESAPS  (98 % 256)
	{LLCCLPMTOTALREMOTESAPS, ASN_COUNTER, RONLY, var_lLCCLPMTable, 6, {1, 1, 10, 1, 1, 3}},
#define   LLCCLPMROWSTATUS      (99 % 256)
	{LLCCLPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCLPMTable, 6, {1, 1, 10, 1, 1, 4}},
#define   LLCCONNECTIONLESSNAME  (102 % 256)
	{LLCCONNECTIONLESSNAME, ASN_OCTET_STR, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 1}},
#define   LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE  (103 % 256)
	{LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 2}},
#define   LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE  (104 % 256)
	{LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 3}},
#define   LLCCONNECTIONLESSTESTRECEIVEDCOMMAND  (105 % 256)
	{LLCCONNECTIONLESSTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 4}},
#define   LLCCONNECTIONLESSTESTRECEIVEDRESPONSE  (106 % 256)
	{LLCCONNECTIONLESSTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 5}},
#define   LLCCONNECTIONLESSTESTSENTABBRESPONSE  (107 % 256)
	{LLCCONNECTIONLESSTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 6}},
#define   LLCCONNECTIONLESSTESTSENTCOMMAND  (108 % 256)
	{LLCCONNECTIONLESSTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 7}},
#define   LLCCONNECTIONLESSTESTSENTRESPONSE  (109 % 256)
	{LLCCONNECTIONLESSTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 8}},
#define   LLCCONNECTIONLESSUIRECEIVED  (110 % 256)
	{LLCCONNECTIONLESSUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 9}},
#define   LLCCONNECTIONLESSUISENT  (111 % 256)
	{LLCCONNECTIONLESSUISENT, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 10}},
#define   LLCCONNECTIONLESSXIDRECEIVEDCOMMAND  (112 % 256)
	{LLCCONNECTIONLESSXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 11}},
#define   LLCCONNECTIONLESSXIDRECEIVEDRESPONSE  (113 % 256)
	{LLCCONNECTIONLESSXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 12}},
#define   LLCCONNECTIONLESSXIDSENTCOMMAND  (114 % 256)
	{LLCCONNECTIONLESSXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 13}},
#define   LLCCONNECTIONLESSXIDSENTRESPONSE  (115 % 256)
	{LLCCONNECTIONLESSXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 11, 1, 1, 14}},
#define   LLCCOPMOPERATIONALSTATE  (119 % 256)
	{LLCCOPMOPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCCOPMTable, 6, {1, 1, 12, 1, 1, 2}},
#define   LLCCOPMROWSTATUS      (120 % 256)
	{LLCCOPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCOPMTable, 6, {1, 1, 12, 1, 1, 3}},
#define   LLCCONNECTION2NAME    (123 % 256)
	{LLCCONNECTION2NAME, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 1}},
#define   LLCCONNECTION2MAXIMUMRETRANSMISSIONS  (124 % 256)
	{LLCCONNECTION2MAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 2}},
#define   LLCCONNECTION2RECEIVEDWINDOWSIZE  (125 % 256)
	{LLCCONNECTION2RECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 3}},
#define   LLCCONNECTION2SENDWINDOWSIZE  (126 % 256)
	{LLCCONNECTION2SENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 4}},
#define   LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE  (127 % 256)
	{LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 5}},
#define   LLCCONNECTION2BUSYSTATETIMEOUTVALUE  (128 % 256)
	{LLCCONNECTION2BUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 6}},
#define   LLCCONNECTION2PBITTIMEOUTVALUE  (129 % 256)
	{LLCCONNECTION2PBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 7}},
#define   LLCCONNECTION2REJECTTIMEOUTVALUE  (130 % 256)
	{LLCCONNECTION2REJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 8}},
#define   LLCCONNECTION2LOCALBUSY  (131 % 256)
	{LLCCONNECTION2LOCALBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 9}},
#define   LLCCONNECTION2REMOTEBUSY  (132 % 256)
	{LLCCONNECTION2REMOTEBUSY, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 10}},
#define   LLCCONNECTION2REMOTERESET  (133 % 256)
	{LLCCONNECTION2REMOTERESET, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 11}},
#define   LLCCONNECTION2LOCALRESET  (134 % 256)
	{LLCCONNECTION2LOCALRESET, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 12}},
#define   LLCCONNECTION2PROVIDERRESET  (135 % 256)
	{LLCCONNECTION2PROVIDERRESET, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 13}},
#define   LLCCONNECTION2ROUTE   (136 % 256)
	{LLCCONNECTION2ROUTE, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 14}},
#define   LLCCONNECTION2KSTEP   (137 % 256)
	{LLCCONNECTION2KSTEP, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 15}},
#define   LLCCONNECTION2MAXSENDWINDOWSIZE  (138 % 256)
	{LLCCONNECTION2MAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 16}},
#define   LLCCONNECTION2RECEIVEDI  (139 % 256)
	{LLCCONNECTION2RECEIVEDI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 17}},
#define   LLCCONNECTION2SENTI   (140 % 256)
	{LLCCONNECTION2SENTI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 18}},
#define   LLCCONNECTION2SENTACKS  (141 % 256)
	{LLCCONNECTION2SENTACKS, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 19}},
#define   LLCCONNECTION2RECEIVEDACKS  (142 % 256)
	{LLCCONNECTION2RECEIVEDACKS, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 20}},
#define   LLCCONNECTION2RECEIVEDFRMR  (143 % 256)
	{LLCCONNECTION2RECEIVEDFRMR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 21}},
#define   LLCCONNECTION2SENTFRMR  (144 % 256)
	{LLCCONNECTION2SENTFRMR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 22}},
#define   LLCCONNECTION2RECEIVEDRR  (145 % 256)
	{LLCCONNECTION2RECEIVEDRR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 23}},
#define   LLCCONNECTION2SENTRR  (146 % 256)
	{LLCCONNECTION2SENTRR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 24}},
#define   LLCCONNECTION2RECEIVEDRNR  (147 % 256)
	{LLCCONNECTION2RECEIVEDRNR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 25}},
#define   LLCCONNECTION2SENTRNR  (148 % 256)
	{LLCCONNECTION2SENTRNR, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 26}},
#define   LLCCONNECTION2RECEIVEDREJ  (149 % 256)
	{LLCCONNECTION2RECEIVEDREJ, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 27}},
#define   LLCCONNECTION2SENTREJ  (150 % 256)
	{LLCCONNECTION2SENTREJ, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 28}},
#define   LLCCONNECTION2RECEIVEDSABME  (151 % 256)
	{LLCCONNECTION2RECEIVEDSABME, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 29}},
#define   LLCCONNECTION2SENTSABME  (152 % 256)
	{LLCCONNECTION2SENTSABME, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 30}},
#define   LLCCONNECTION2RECEIVEDUA  (153 % 256)
	{LLCCONNECTION2RECEIVEDUA, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 31}},
#define   LLCCONNECTION2SENTUA  (154 % 256)
	{LLCCONNECTION2SENTUA, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 32}},
#define   LLCCONNECTION2RECEIVEDDISC  (155 % 256)
	{LLCCONNECTION2RECEIVEDDISC, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 33}},
#define   LLCCONNECTION2SENTDISC  (156 % 256)
	{LLCCONNECTION2SENTDISC, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 34}},
#define   LLCCONNECTION2RECEIVEDDM  (157 % 256)
	{LLCCONNECTION2RECEIVEDDM, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 35}},
#define   LLCCONNECTION2SENTDM  (158 % 256)
	{LLCCONNECTION2SENTDM, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 36}},
#define   LLCCONNECTION2PDUSDISCARDED1  (159 % 256)
	{LLCCONNECTION2PDUSDISCARDED1, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 37}},
#define   LLCCONNECTION2PDUSDISCARDED2  (160 % 256)
	{LLCCONNECTION2PDUSDISCARDED2, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 38}},
#define   LLCCONNECTION2PDURETRANSMISSIONS  (161 % 256)
	{LLCCONNECTION2PDURETRANSMISSIONS, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 39}},
#define   LLCCONNECTION2OPTIONALTOLERATIONIPDUS  (162 % 256)
	{LLCCONNECTION2OPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 40}},
#define   LLCCONNECTION2DUPLICATEIPDUSRECEIVED  (163 % 256)
	{LLCCONNECTION2DUPLICATEIPDUSRECEIVED, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 41}},
#define   LLCCONNECTION2VIOLATION  (164 % 256)
	{LLCCONNECTION2VIOLATION, ASN_COUNTER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 42}},
#define   LLCCONNECTION2PROTOCOLSTATE  (165 % 256)
	{LLCCONNECTION2PROTOCOLSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 43}},
#define   LLCCONNECTION2ADMINISTRATIVESTATE  (166 % 256)
	{LLCCONNECTION2ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 44}},
#define   LLCCONNECTION2OPERATIONALSTATE  (167 % 256)
	{LLCCONNECTION2OPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 45}},
#define   LLCCONNECTION2USAGESTATE  (168 % 256)
	{LLCCONNECTION2USAGESTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 46}},
#define   LLCCONNECTION2PROCEDURALSTATUS  (169 % 256)
	{LLCCONNECTION2PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 47}},
#define   LLCCONNECTION2ALARMSTATUS  (170 % 256)
	{LLCCONNECTION2ALARMSTATUS, ASN_BIT_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 13, 1, 1, 48}},
#define   LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS  (174 % 256)
	{LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 2}},
#define   LLCCONNECTION2IVMORECEIVEDWINDOWSIZE  (175 % 256)
	{LLCCONNECTION2IVMORECEIVEDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 3}},
#define   LLCCONNECTION2IVMOSENDWINDOWSIZE  (176 % 256)
	{LLCCONNECTION2IVMOSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 4}},
#define   LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE  (177 % 256)
	{LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 5}},
#define   LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE  (178 % 256)
	{LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 6}},
#define   LLCCONNECTION2IVMOBITTIMEOUTVALUE  (179 % 256)
	{LLCCONNECTION2IVMOBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 7}},
#define   LLCCONNECTION2IVMOREJECTTIMEOUTVALUE  (180 % 256)
	{LLCCONNECTION2IVMOREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 8}},
#define   LLCCONNECTION2IVMOROUTE  (181 % 256)
	{LLCCONNECTION2IVMOROUTE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 9}},
#define   LLCCONNECTION2IVMOKSTEP  (182 % 256)
	{LLCCONNECTION2IVMOKSTEP, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 10}},
#define   LLCCONNECTION2IVMOMAXSENDWINDOWSIZE  (183 % 256)
	{LLCCONNECTION2IVMOMAXSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 11}},
#define   LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS  (184 % 256)
	{LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 14, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKNAME  (187 % 256)
	{LLCCONNECTIONLESSACKNAME, ASN_OCTET_STR, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 1}},
#define   LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE  (188 % 256)
	{LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS  (189 % 256)
	{LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE  (190 % 256)
	{LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 4}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND  (191 % 256)
	{LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 5}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE  (192 % 256)
	{LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 6}},
#define   LLCCONNECTIONLESSACKTESTSENTABBRESPONSE  (193 % 256)
	{LLCCONNECTIONLESSACKTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 7}},
#define   LLCCONNECTIONLESSACKTESTSENTCOMMAND  (194 % 256)
	{LLCCONNECTIONLESSACKTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 8}},
#define   LLCCONNECTIONLESSACKTESTSENTRESPONSE  (195 % 256)
	{LLCCONNECTIONLESSACKTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 9}},
#define   LLCCONNECTIONLESSACKRECEIVERESOURCES  (196 % 256)
	{LLCCONNECTIONLESSACKRECEIVERESOURCES, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 10}},
#define   LLCCONNECTIONLESSACKUIRECEIVED  (197 % 256)
	{LLCCONNECTIONLESSACKUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 11}},
#define   LLCCONNECTIONLESSACKUISENT  (198 % 256)
	{LLCCONNECTIONLESSACKUISENT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND  (199 % 256)
	{LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 13}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE  (200 % 256)
	{LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 14}},
#define   LLCCONNECTIONLESSACKXIDSENTCOMMAND  (201 % 256)
	{LLCCONNECTIONLESSACKXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 15}},
#define   LLCCONNECTIONLESSACKXIDSENTRESPONSE  (202 % 256)
	{LLCCONNECTIONLESSACKXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 16}},
#define   LLCCONNECTIONLESSACKRETRANSMISSIONS  (203 % 256)
	{LLCCONNECTIONLESSACKRETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 17}},
#define   LLCCONNECTIONLESSACKNORESPONSE  (204 % 256)
	{LLCCONNECTIONLESSACKNORESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 18}},
#define   LLCCONNECTIONLESSACKCOMMANDIP  (205 % 256)
	{LLCCONNECTIONLESSACKCOMMANDIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 19}},
#define   LLCCONNECTIONLESSACKCOMMANDIT  (206 % 256)
	{LLCCONNECTIONLESSACKCOMMANDIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 20}},
#define   LLCCONNECTIONLESSACKCOMMANDOK  (207 % 256)
	{LLCCONNECTIONLESSACKCOMMANDOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 21}},
#define   LLCCONNECTIONLESSACKCOMMANDPE  (208 % 256)
	{LLCCONNECTIONLESSACKCOMMANDPE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 22}},
#define   LLCCONNECTIONLESSACKCOMMANDRS  (209 % 256)
	{LLCCONNECTIONLESSACKCOMMANDRS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 23}},
#define   LLCCONNECTIONLESSACKCOMMANDUE  (210 % 256)
	{LLCCONNECTIONLESSACKCOMMANDUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 24}},
#define   LLCCONNECTIONLESSACKCOMMANDUN  (211 % 256)
	{LLCCONNECTIONLESSACKCOMMANDUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 25}},
#define   LLCCONNECTIONLESSACKRECEIVEDACCOMMAND  (212 % 256)
	{LLCCONNECTIONLESSACKRECEIVEDACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 26}},
#define   LLCCONNECTIONLESSACKSENTACCOMMAND  (213 % 256)
	{LLCCONNECTIONLESSACKSENTACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 27}},
#define   LLCCONNECTIONLESSACKRESPONSEIP  (214 % 256)
	{LLCCONNECTIONLESSACKRESPONSEIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 28}},
#define   LLCCONNECTIONLESSACKRESPONSEIT  (215 % 256)
	{LLCCONNECTIONLESSACKRESPONSEIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 29}},
#define   LLCCONNECTIONLESSACKRESPONSENE  (216 % 256)
	{LLCCONNECTIONLESSACKRESPONSENE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 30}},
#define   LLCCONNECTIONLESSACKRESPONSENR  (217 % 256)
	{LLCCONNECTIONLESSACKRESPONSENR, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 31}},
#define   LLCCONNECTIONLESSACKRESPONSEOK  (218 % 256)
	{LLCCONNECTIONLESSACKRESPONSEOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 32}},
#define   LLCCONNECTIONLESSACKRESPONSERS  (219 % 256)
	{LLCCONNECTIONLESSACKRESPONSERS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 33}},
#define   LLCCONNECTIONLESSACKRESPONSEUE  (220 % 256)
	{LLCCONNECTIONLESSACKRESPONSEUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 34}},
#define   LLCCONNECTIONLESSACKRESPONSEUN  (221 % 256)
	{LLCCONNECTIONLESSACKRESPONSEUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 35}},
#define   LLCCONNECTIONLESSACKVIOLATION  (222 % 256)
	{LLCCONNECTIONLESSACKVIOLATION, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 15, 1, 1, 36}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE  (226 % 256)
	{LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS  (227 % 256)
	{LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 16, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKIVMOROWSTATUS  (228 % 256)
	{LLCCONNECTIONLESSACKIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 16, 1, 1, 4}},
#define   LLCDISCONTINUITYTIME  (229 % 256)
	{LLCDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_llcMIB, 4, {1, 2, 1, 1}},
#define   LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS  (230 % 256)
	{LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 1}},
#define   LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE  (231 % 256)
	{LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 2}},
#define   LLCCONNECTION2DEFAULTSENDWINDOWSIZE  (232 % 256)
	{LLCCONNECTION2DEFAULTSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 3}},
#define   LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE  (233 % 256)
	{LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 4}},
#define   LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE  (234 % 256)
	{LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 5}},
#define   LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE  (235 % 256)
	{LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 6}},
#define   LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE  (236 % 256)
	{LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 7}},
#define   LLCCONNECTION2DEFAULTROUTE  (237 % 256)
	{LLCCONNECTION2DEFAULTROUTE, ASN_OCTET_STR, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 8}},
#define   LLCCONNECTION2DEFAULTKSTEP  (238 % 256)
	{LLCCONNECTION2DEFAULTKSTEP, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 9}},
#define   LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE  (239 % 256)
	{LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 10}},
#define   LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS  (240 % 256)
	{LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 1, 11}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE  (241 % 256)
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 2, 1}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS  (242 % 256)
	{LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_llcMIB, 5, {1, 2, 2, 2, 2}},
};

/* (L = length of the oidsuffix) */
struct llcMIB_data *llcMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mACDLETableStorage = NULL;
struct header_complex_index *mACTableStorage = NULL;
struct header_complex_index *resourceTypeIdTableStorage = NULL;
struct header_complex_index *dLSAPTableStorage = NULL;
struct header_complex_index *lLCDLETableStorage = NULL;
struct header_complex_index *lLCStationTableStorage = NULL;
struct header_complex_index *lLCSAPTableStorage = NULL;
struct header_complex_index *rDESetupTableStorage = NULL;
struct header_complex_index *rDEPairTableStorage = NULL;
struct header_complex_index *lLCCLPMTableStorage = NULL;
struct header_complex_index *lLCConnectionLessTableStorage = NULL;
struct header_complex_index *lLCCOPMTableStorage = NULL;
struct header_complex_index *lLCConnection2TableStorage = NULL;
struct header_complex_index *lLCConnection2IVMOTableStorage = NULL;
struct header_complex_index *lLCConnectionlessAckTableStorage = NULL;
struct header_complex_index *lLCConnectionlessAckIVMOTableStorage = NULL;

/*
 * init_llcMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_llcMIB(void)
{
	DEBUGMSGTL(("llcMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("llcMIB", llcMIB_variables, variable7, llcMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_llcMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("llcMIB", parse_llcMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mACDLETable", parse_mACDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("mACTable", parse_mACTable, NULL, "HELP STRING");
	snmpd_register_config_handler("resourceTypeIdTable", parse_resourceTypeIdTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dLSAPTable", parse_dLSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCDLETable", parse_lLCDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCStationTable", parse_lLCStationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCSAPTable", parse_lLCSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("rDESetupTable", parse_rDESetupTable, NULL, "HELP STRING");
	snmpd_register_config_handler("rDEPairTable", parse_rDEPairTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCCLPMTable", parse_lLCCLPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionLessTable", parse_lLCConnectionLessTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCCOPMTable", parse_lLCCOPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnection2Table", parse_lLCConnection2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnection2IVMOTable", parse_lLCConnection2IVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionlessAckTable", parse_lLCConnectionlessAckTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionlessAckIVMOTable", parse_lLCConnectionlessAckIVMOTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_llcMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mACDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mACTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_resourceTypeIdTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dLSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCStationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_rDESetupTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_rDEPairTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCCLPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionLessTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCCOPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnection2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnection2IVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionlessAckTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionlessAckIVMOTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("llcMIB", "done.\n"));
}

/*
 * deinit_llcMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_llcMIB(void)
{
	DEBUGMSGTL(("llcMIB", "deinitializating...  "));
	unregister_mib(llcMIB_variables_oid, sizeof(llcMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("llcMIB");
	snmpd_unregister_config_handler("mACDLETable");
	snmpd_unregister_config_handler("mACTable");
	snmpd_unregister_config_handler("resourceTypeIdTable");
	snmpd_unregister_config_handler("dLSAPTable");
	snmpd_unregister_config_handler("lLCDLETable");
	snmpd_unregister_config_handler("lLCStationTable");
	snmpd_unregister_config_handler("lLCSAPTable");
	snmpd_unregister_config_handler("rDESetupTable");
	snmpd_unregister_config_handler("rDEPairTable");
	snmpd_unregister_config_handler("lLCCLPMTable");
	snmpd_unregister_config_handler("lLCConnectionLessTable");
	snmpd_unregister_config_handler("lLCCOPMTable");
	snmpd_unregister_config_handler("lLCConnection2Table");
	snmpd_unregister_config_handler("lLCConnection2IVMOTable");
	snmpd_unregister_config_handler("lLCConnectionlessAckTable");
	snmpd_unregister_config_handler("lLCConnectionlessAckIVMOTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("llcMIB", "done.\n"));
}

int
term_llcMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_llcMIB();
	return 0;
}

/*
 * llcMIB_add(): adds a structure node for scalars
 */
int
llcMIB_add(struct llcMIB_data *thedata)
{
	DEBUGMSGTL(("llcMIB", "adding data...  "));
	llcMIBStorage = thedata;
	DEBUGMSGTL(("llcMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_llcMIB(): parses .conf file entries needed to configure the mib.
 */
void
parse_llcMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct llcMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(llcMIB_data);

	DEBUGMSGTL(("llcMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->llcDiscontinuityTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultPBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultRejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2DefaultRoute, &tmpsize);
	StorageTmp->lLCConnection2DefaultRouteLen = tmpsize;
	if (StorageTmp->lLCConnection2DefaultRoute == NULL) {
		config_perror("invalid specification for lLCConnection2DefaultRoute");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultKStep, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultMaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions, &tmpsize);
	llcMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("llcMIB", "done.\n"));
}

/*
 * store_llcMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_llcMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct llcMIB_data *StorageTmp;

	DEBUGMSGTL(("llcMIB", "storing data...  "));
	refresh_llcMIB();
	if ((StorageTmp = llcMIBStorage) == NULL) {
		DEBUGMSGTL(("llcMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->llcMIBStorageType == ST_NONVOLATILE) */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "llcMIB ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->llcDiscontinuityTime, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultMaximumRetransmissions, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultReceivedWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultSendWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultPBitTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultRejectTimeoutValue, &tmpsize);
		tmpsize = StorageTmp->lLCConnection2DefaultRouteLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2DefaultRoute, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultKStep, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultMaxSendWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("llcMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_llcMIB: refresh llcMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS susbystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_llcMIB(void)
{
	if (llcMIBStorage == NULL) {
		struct llcMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(llcMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		llcMIBStorage = StorageNew;
		llcMIB_refresh = 1;
	}
	if (llcMIB_refresh == 0)
		return;
	llcMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_llcMIB(): locate variables in llcMIB
 *
 * This function is called every time the agent gets a request for a scalar variable that might be
 * found within your mib section registered above.  It is up to you to do the right thing and return
 * the correct value.  You should also correct the value of "var_len" if necessary.
 *
 * Please see the documentation for more information about writing module extensions, and check out
 * the examples in the examples and mibII directories.
 */
u_char *
var_llcMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct llcMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_llcMIB();
	if ((StorageTmp = llcMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCDISCONTINUITYTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->llcDiscontinuityTime);
		return (u_char *) &StorageTmp->llcDiscontinuityTime;
	case LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2DefaultMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2DefaultMaximumRetransmissions;
	case LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2DefaultReceivedWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultReceivedWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2DefaultReceivedWindowSize;
	case LLCCONNECTION2DEFAULTSENDWINDOWSIZE:
		*write_method = write_lLCConnection2DefaultSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2DefaultSendWindowSize;
	case LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultAcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue;
	case LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultBusyStateTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue;
	case LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultPBitTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultPBitTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultPBitTimeoutValue;
	case LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2DefaultRejectTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultRejectTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2DefaultRejectTimeoutValue;
	case LLCCONNECTION2DEFAULTROUTE:
		*write_method = write_lLCConnection2DefaultRoute;
		*var_len = StorageTmp->lLCConnection2DefaultRouteLen;
		return (u_char *) StorageTmp->lLCConnection2DefaultRoute;
	case LLCCONNECTION2DEFAULTKSTEP:
		*write_method = write_lLCConnection2DefaultKStep;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultKStep);
		return (u_char *) &StorageTmp->lLCConnection2DefaultKStep;
	case LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2DefaultMaxSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultMaxSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2DefaultMaxSendWindowSize;
	case LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2DefaultOptionalTolerationIPDUs;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs);
		return (u_char *) &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs;
	case LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckDefaultMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * mACDLETable_add(): adds a structure node to our data set
 */
int
mACDLETable_add(struct mACDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mACDLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mACDLECommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mACDLECommunicationsEntityId, thedata->mACDLECommunicationsEntityIdLen);
	header_complex_add_data(&mACDLETableStorage, vars, thedata);
	DEBUGMSGTL(("mACDLETable", "registered an entry\n"));
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mACDLETable_del(): delete a structure
 */
int
mACDLETable_del(struct mACDLETable_data **thedata)
{
	struct mACDLETable_data *StorageDel;

	DEBUGMSGTL(("mACDLETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mACDLECommunicationsEntityId);
		StorageDel->mACDLECommunicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->mACDLELocalSapNames);
		StorageDel->mACDLELocalSapNamesLen = 0;
		SNMP_FREE(StorageDel->mACDLEProviderEntityNames);
		StorageDel->mACDLEProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mACDLETable(): parse configuration file for mACDLETable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mACDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct mACDLETable_data *StorageTmp = SNMP_MALLOC_STRUCT(mACDLETable_data);

	DEBUGMSGTL(("mACDLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mACDLECommunicationsEntityId, &tmpsize);
	StorageTmp->mACDLECommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->mACDLECommunicationsEntityId == NULL) {
		config_perror("invalid specification for mACDLECommunicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mACDLELocalSapNames, &tmpsize);
	StorageTmp->mACDLELocalSapNamesLen = tmpsize;
	if (StorageTmp->mACDLELocalSapNames == NULL) {
		config_perror("invalid specification for mACDLELocalSapNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACDLEOperationalState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mACDLEProviderEntityNames, &tmpsize);
	StorageTmp->mACDLEProviderEntityNamesLen = tmpsize;
	if (StorageTmp->mACDLEProviderEntityNames == NULL) {
		config_perror("invalid specification for mACDLEProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACDLERowStatus, &tmpsize);
	mACDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mACDLETable", "done.\n"));
}

/*
 * store_mACDLETable(): store configuraiton file for mACDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mACDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mACDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mACDLETable", "storing data...  "));
	refresh_mACDLETable();
	(void) tmpsize;
	for (hcindex = mACDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mACDLETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mACDLETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mACDLETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mACDLECommunicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mACDLECommunicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->mACDLELocalSapNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mACDLELocalSapNames, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACDLEOperationalState, &tmpsize);
			tmpsize = StorageTmp->mACDLEProviderEntityNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mACDLEProviderEntityNames, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mACDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mACTable_add(): adds a structure node to our data set
 */
int
mACTable_add(struct mACTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mACTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mACDLECommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mACDLECommunicationsEntityId, thedata->mACDLECommunicationsEntityIdLen);
	/* mACId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mACId, thedata->mACIdLen);
	header_complex_add_data(&mACTableStorage, vars, thedata);
	DEBUGMSGTL(("mACTable", "registered an entry\n"));
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mACTable_del(): delete a structure
 */
int
mACTable_del(struct mACTable_data **thedata)
{
	struct mACTable_data *StorageDel;

	DEBUGMSGTL(("mACTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mACDLECommunicationsEntityId);
		StorageDel->mACDLECommunicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->mACId);
		StorageDel->mACIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mACTable(): parse configuration file for mACTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mACTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mACTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mACTable_data);

	DEBUGMSGTL(("mACTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mACDLECommunicationsEntityId, &tmpsize);
	StorageTmp->mACDLECommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->mACDLECommunicationsEntityId == NULL) {
		config_perror("invalid specification for mACDLECommunicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACOperationalState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mACId, &tmpsize);
	StorageTmp->mACIdLen = tmpsize;
	if (StorageTmp->mACId == NULL) {
		config_perror("invalid specification for mACId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACRowStatus, &tmpsize);
	mACTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mACTable", "done.\n"));
}

/*
 * store_mACTable(): store configuraiton file for mACTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mACTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mACTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mACTable", "storing data...  "));
	refresh_mACTable();
	(void) tmpsize;
	for (hcindex = mACTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mACTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mACTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mACTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mACDLECommunicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mACDLECommunicationsEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACOperationalState, &tmpsize);
			tmpsize = StorageTmp->mACIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mACId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mACTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * resourceTypeIdTable_add(): adds a structure node to our data set
 */
int
resourceTypeIdTable_add(struct resourceTypeIdTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("resourceTypeIdTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mACDLECommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mACDLECommunicationsEntityId, thedata->mACDLECommunicationsEntityIdLen);
	header_complex_add_data(&resourceTypeIdTableStorage, vars, thedata);
	DEBUGMSGTL(("resourceTypeIdTable", "registered an entry\n"));
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * resourceTypeIdTable_del(): delete a structure
 */
int
resourceTypeIdTable_del(struct resourceTypeIdTable_data **thedata)
{
	struct resourceTypeIdTable_data *StorageDel;

	DEBUGMSGTL(("resourceTypeIdTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mACDLECommunicationsEntityId);
		StorageDel->mACDLECommunicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->resourceTypeIdName);
		StorageDel->resourceTypeIdNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerOUI);
		StorageDel->resourceInfoManufacturerOUILen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerName);
		StorageDel->resourceInfoManufacturerNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerProductName);
		StorageDel->resourceInfoManufacturerProductNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerProductVersion);
		StorageDel->resourceInfoManufacturerProductVersionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_resourceTypeIdTable(): parse configuration file for resourceTypeIdTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_resourceTypeIdTable(const char *token, char *line)
{
	size_t tmpsize;
	struct resourceTypeIdTable_data *StorageTmp = SNMP_MALLOC_STRUCT(resourceTypeIdTable_data);

	DEBUGMSGTL(("resourceTypeIdTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mACDLECommunicationsEntityId, &tmpsize);
	StorageTmp->mACDLECommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->mACDLECommunicationsEntityId == NULL) {
		config_perror("invalid specification for mACDLECommunicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceTypeIdName, &tmpsize);
	StorageTmp->resourceTypeIdNameLen = tmpsize;
	if (StorageTmp->resourceTypeIdName == NULL) {
		config_perror("invalid specification for resourceTypeIdName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerOUI, &tmpsize);
	StorageTmp->resourceInfoManufacturerOUILen = tmpsize;
	if (StorageTmp->resourceInfoManufacturerOUI == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerOUI");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerName, &tmpsize);
	StorageTmp->resourceInfoManufacturerNameLen = tmpsize;
	if (StorageTmp->resourceInfoManufacturerName == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerProductName, &tmpsize);
	StorageTmp->resourceInfoManufacturerProductNameLen = tmpsize;
	if (StorageTmp->resourceInfoManufacturerProductName == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerProductName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerProductVersion, &tmpsize);
	StorageTmp->resourceInfoManufacturerProductVersionLen = tmpsize;
	if (StorageTmp->resourceInfoManufacturerProductVersion == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerProductVersion");
		return;
	}

	resourceTypeIdTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
}

/*
 * store_resourceTypeIdTable(): store configuraiton file for resourceTypeIdTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_resourceTypeIdTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct resourceTypeIdTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("resourceTypeIdTable", "storing data...  "));
	refresh_resourceTypeIdTable();
	(void) tmpsize;
	for (hcindex = resourceTypeIdTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct resourceTypeIdTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->resourceTypeIdTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "resourceTypeIdTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mACDLECommunicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mACDLECommunicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->resourceTypeIdNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceTypeIdName, &tmpsize);
			tmpsize = StorageTmp->resourceInfoManufacturerOUILen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerOUI, &tmpsize);
			tmpsize = StorageTmp->resourceInfoManufacturerNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerName, &tmpsize);
			tmpsize = StorageTmp->resourceInfoManufacturerProductNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerProductName, &tmpsize);
			tmpsize = StorageTmp->resourceInfoManufacturerProductVersionLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerProductVersion, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("resourceTypeIdTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * dLSAPTable_add(): adds a structure node to our data set
 */
int
dLSAPTable_add(struct dLSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dLSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mACDLECommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mACDLECommunicationsEntityId, thedata->mACDLECommunicationsEntityIdLen);
	/* dLSAPSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->dLSAPSapId, thedata->dLSAPSapIdLen);
	header_complex_add_data(&dLSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("dLSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * dLSAPTable_del(): delete a structure
 */
int
dLSAPTable_del(struct dLSAPTable_data **thedata)
{
	struct dLSAPTable_data *StorageDel;

	DEBUGMSGTL(("dLSAPTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mACDLECommunicationsEntityId);
		StorageDel->mACDLECommunicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->dLSAPSapId);
		StorageDel->dLSAPSapIdLen = 0;
		SNMP_FREE(StorageDel->dLSAPUserEntityNames);
		StorageDel->dLSAPUserEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_dLSAPTable(): parse configuration file for dLSAPTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_dLSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp = SNMP_MALLOC_STRUCT(dLSAPTable_data);

	DEBUGMSGTL(("dLSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mACDLECommunicationsEntityId, &tmpsize);
	StorageTmp->mACDLECommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->mACDLECommunicationsEntityId == NULL) {
		config_perror("invalid specification for mACDLECommunicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dLSAPSapId, &tmpsize);
	StorageTmp->dLSAPSapIdLen = tmpsize;
	if (StorageTmp->dLSAPSapId == NULL) {
		config_perror("invalid specification for dLSAPSapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dLSAPSap1Address, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->dLSAPUserEntityNames, &tmpsize);
	StorageTmp->dLSAPUserEntityNamesLen = tmpsize;
	if (StorageTmp->dLSAPUserEntityNames == NULL) {
		config_perror("invalid specification for dLSAPUserEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dLSAPRowStatus, &tmpsize);
	dLSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
}

/*
 * store_dLSAPTable(): store configuraiton file for dLSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dLSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dLSAPTable", "storing data...  "));
	refresh_dLSAPTable();
	(void) tmpsize;
	for (hcindex = dLSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dLSAPTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->dLSAPTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dLSAPTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->mACDLECommunicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mACDLECommunicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->dLSAPSapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dLSAPSapId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dLSAPSap1Address, &tmpsize);
			tmpsize = StorageTmp->dLSAPUserEntityNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->dLSAPUserEntityNames, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dLSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCDLETable_add(): adds a structure node to our data set
 */
int
lLCDLETable_add(struct lLCDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCDLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* lLCDLECommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCDLECommunicationsEntityId, thedata->lLCDLECommunicationsEntityIdLen);
	header_complex_add_data(&lLCDLETableStorage, vars, thedata);
	DEBUGMSGTL(("lLCDLETable", "registered an entry\n"));
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCDLETable_del(): delete a structure
 */
int
lLCDLETable_del(struct lLCDLETable_data **thedata)
{
	struct lLCDLETable_data *StorageDel;

	DEBUGMSGTL(("lLCDLETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCDLECommunicationsEntityId);
		StorageDel->lLCDLECommunicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->lLCDLELocalSapNames);
		StorageDel->lLCDLELocalSapNamesLen = 0;
		SNMP_FREE(StorageDel->lLCDLEProviderEntityNames);
		StorageDel->lLCDLEProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCDLETable(): parse configuration file for lLCDLETable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCDLETable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCDLETable_data);

	DEBUGMSGTL(("lLCDLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
	StorageTmp->lLCDLECommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->lLCDLECommunicationsEntityId == NULL) {
		config_perror("invalid specification for lLCDLECommunicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->lLCDLELocalSapNames, &tmpsize);
	StorageTmp->lLCDLELocalSapNamesLen = tmpsize;
	if (StorageTmp->lLCDLELocalSapNames == NULL) {
		config_perror("invalid specification for lLCDLELocalSapNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCDLEOperationalState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->lLCDLEProviderEntityNames, &tmpsize);
	StorageTmp->lLCDLEProviderEntityNamesLen = tmpsize;
	if (StorageTmp->lLCDLEProviderEntityNames == NULL) {
		config_perror("invalid specification for lLCDLEProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCDLERowStatus, &tmpsize);
	lLCDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
}

/*
 * store_lLCDLETable(): store configuraiton file for lLCDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCDLETable", "storing data...  "));
	refresh_lLCDLETable();
	(void) tmpsize;
	for (hcindex = lLCDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCDLETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCDLETableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCDLETable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCDLECommunicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->lLCDLELocalSapNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->lLCDLELocalSapNames, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCDLEOperationalState, &tmpsize);
			tmpsize = StorageTmp->lLCDLEProviderEntityNamesLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->lLCDLEProviderEntityNames, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCStationTable_add(): adds a structure node to our data set
 */
int
lLCStationTable_add(struct lLCStationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCStationTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* lLCDLECommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCDLECommunicationsEntityId, thedata->lLCDLECommunicationsEntityIdLen);
	/* dLSAPSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->dLSAPSapId, thedata->dLSAPSapIdLen);
	header_complex_add_data(&lLCStationTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCStationTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCStationTable_del(): delete a structure
 */
int
lLCStationTable_del(struct lLCStationTable_data **thedata)
{
	struct lLCStationTable_data *StorageDel;

	DEBUGMSGTL(("lLCStationTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCDLECommunicationsEntityId);
		StorageDel->lLCDLECommunicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->dLSAPSapId);
		StorageDel->dLSAPSapIdLen = 0;
		SNMP_FREE(StorageDel->lLCStationLLCName);
		StorageDel->lLCStationLLCNameLen = 0;
		SNMP_FREE(StorageDel->lLCStationSupportedServicesTypes);
		StorageDel->lLCStationSupportedServicesTypesLen = 0;
		SNMP_FREE(StorageDel->lLCStationSTRIndicator);
		StorageDel->lLCStationSTRIndicatorLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCStationTable(): parse configuration file for lLCStationTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCStationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCStationTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCStationTable_data);

	DEBUGMSGTL(("lLCStationTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
	StorageTmp->lLCDLECommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->lLCDLECommunicationsEntityId == NULL) {
		config_perror("invalid specification for lLCDLECommunicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dLSAPSapId, &tmpsize);
	StorageTmp->dLSAPSapIdLen = tmpsize;
	if (StorageTmp->dLSAPSapId == NULL) {
		config_perror("invalid specification for dLSAPSapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCStationLLCName, &tmpsize);
	StorageTmp->lLCStationLLCNameLen = tmpsize;
	if (StorageTmp->lLCStationLLCName == NULL) {
		config_perror("invalid specification for lLCStationLLCName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumLSAPsConfigured, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationNumberOfActiveLSAPs, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCStationSupportedServicesTypes, &tmpsize);
	StorageTmp->lLCStationSupportedServicesTypesLen = tmpsize;
	if (StorageTmp->lLCStationSupportedServicesTypes == NULL) {
		config_perror("invalid specification for lLCStationSupportedServicesTypes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType1AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType1MaximumRetryCount, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumPDUN3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumRetransmissions4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationReceiveVariableLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationTransmitVariableLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType3AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationType3Retransmissions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationAvgBufferUseSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationBufferProblems, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationBufferSize, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationMaxBufferUseSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationInactiveLSAP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationPDUsDiscard, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCStationSTRIndicator, &tmpsize);
	StorageTmp->lLCStationSTRIndicatorLen = tmpsize;
	if (StorageTmp->lLCStationSTRIndicator == NULL) {
		config_perror("invalid specification for lLCStationSTRIndicator");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationVersionNumber, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts, &tmpsize);
	lLCStationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
}

/*
 * store_lLCStationTable(): store configuraiton file for lLCStationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCStationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCStationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCStationTable", "storing data...  "));
	refresh_lLCStationTable();
	(void) tmpsize;
	for (hcindex = lLCStationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCStationTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCStationTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCStationTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCDLECommunicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->dLSAPSapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dLSAPSapId, &tmpsize);
			tmpsize = StorageTmp->lLCStationLLCNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCStationLLCName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumLSAPsConfigured, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationNumberOfActiveLSAPs, &tmpsize);
			tmpsize = StorageTmp->lLCStationSupportedServicesTypesLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCStationSupportedServicesTypes, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType1AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType1MaximumRetryCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumPDUN3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumRetransmissions4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationReceiveVariableLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationTransmitVariableLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType3AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationType3Retransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationAvgBufferUseSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationBufferProblems, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationBufferSize, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationMaxBufferUseSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationInactiveLSAP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationPDUsDiscard, &tmpsize);
			tmpsize = StorageTmp->lLCStationSTRIndicatorLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCStationSTRIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationVersionNumber, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCStationTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCSAPTable_add(): adds a structure node to our data set
 */
int
lLCSAPTable_add(struct lLCSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* lLCDLECommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCDLECommunicationsEntityId, thedata->lLCDLECommunicationsEntityIdLen);
	/* dLSAPSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->dLSAPSapId, thedata->dLSAPSapIdLen);
	header_complex_add_data(&lLCSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCSAPTable_del(): delete a structure
 */
int
lLCSAPTable_del(struct lLCSAPTable_data **thedata)
{
	struct lLCSAPTable_data *StorageDel;

	DEBUGMSGTL(("lLCSAPTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCDLECommunicationsEntityId);
		StorageDel->lLCDLECommunicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->dLSAPSapId);
		StorageDel->dLSAPSapIdLen = 0;
		SNMP_FREE(StorageDel->lLCSAPName);
		StorageDel->lLCSAPNameLen = 0;
		SNMP_FREE(StorageDel->lLCSAPAddress);
		StorageDel->lLCSAPAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCSAPTable(): parse configuration file for lLCSAPTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCSAPTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCSAPTable_data);

	DEBUGMSGTL(("lLCSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
	StorageTmp->lLCDLECommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->lLCDLECommunicationsEntityId == NULL) {
		config_perror("invalid specification for lLCDLECommunicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dLSAPSapId, &tmpsize);
	StorageTmp->dLSAPSapIdLen = tmpsize;
	if (StorageTmp->dLSAPSapId == NULL) {
		config_perror("invalid specification for dLSAPSapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCSAPName, &tmpsize);
	StorageTmp->lLCSAPNameLen = tmpsize;
	if (StorageTmp->lLCSAPName == NULL) {
		config_perror("invalid specification for lLCSAPName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCSAPAddress, &tmpsize);
	StorageTmp->lLCSAPAddressLen = tmpsize;
	if (StorageTmp->lLCSAPAddress == NULL) {
		config_perror("invalid specification for lLCSAPAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCSAPRDE, &tmpsize);
	lLCSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
}

/*
 * store_lLCSAPTable(): store configuraiton file for lLCSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCSAPTable", "storing data...  "));
	refresh_lLCSAPTable();
	(void) tmpsize;
	for (hcindex = lLCSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCSAPTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCSAPTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCSAPTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCDLECommunicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->dLSAPSapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dLSAPSapId, &tmpsize);
			tmpsize = StorageTmp->lLCSAPNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCSAPName, &tmpsize);
			tmpsize = StorageTmp->lLCSAPAddressLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCSAPAddress, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCSAPRDE, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * rDESetupTable_add(): adds a structure node to our data set
 */
int
rDESetupTable_add(struct rDESetupTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("rDESetupTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* lLCDLECommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCDLECommunicationsEntityId, thedata->lLCDLECommunicationsEntityIdLen);
	/* dLSAPSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->dLSAPSapId, thedata->dLSAPSapIdLen);
	header_complex_add_data(&rDESetupTableStorage, vars, thedata);
	DEBUGMSGTL(("rDESetupTable", "registered an entry\n"));
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * rDESetupTable_del(): delete a structure
 */
int
rDESetupTable_del(struct rDESetupTable_data **thedata)
{
	struct rDESetupTable_data *StorageDel;

	DEBUGMSGTL(("rDESetupTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCDLECommunicationsEntityId);
		StorageDel->lLCDLECommunicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->dLSAPSapId);
		StorageDel->dLSAPSapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_rDESetupTable(): parse configuration file for rDESetupTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_rDESetupTable(const char *token, char *line)
{
	size_t tmpsize;
	struct rDESetupTable_data *StorageTmp = SNMP_MALLOC_STRUCT(rDESetupTable_data);

	DEBUGMSGTL(("rDESetupTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
	StorageTmp->lLCDLECommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->lLCDLECommunicationsEntityId == NULL) {
		config_perror("invalid specification for lLCDLECommunicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dLSAPSapId, &tmpsize);
	StorageTmp->dLSAPSapIdLen = tmpsize;
	if (StorageTmp->dLSAPSapId == NULL) {
		config_perror("invalid specification for dLSAPSapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupAgingEnabled, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupAgingValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupEnableType2Reset, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMaximumRouteDescriptors, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMaximumResponseTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMinimumPDUSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupRDEHold, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupRDEReplace, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupName, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupResetOnTestEnabled, &tmpsize);
	rDESetupTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
}

/*
 * store_rDESetupTable(): store configuraiton file for rDESetupTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_rDESetupTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct rDESetupTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("rDESetupTable", "storing data...  "));
	refresh_rDESetupTable();
	(void) tmpsize;
	for (hcindex = rDESetupTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct rDESetupTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->rDESetupTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "rDESetupTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCDLECommunicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->dLSAPSapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dLSAPSapId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupAgingEnabled, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupAgingValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupEnableType2Reset, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMaximumRouteDescriptors, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMaximumResponseTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMinimumPDUSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupRDEHold, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupRDEReplace, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupResetOnTestEnabled, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("rDESetupTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * rDEPairTable_add(): adds a structure node to our data set
 */
int
rDEPairTable_add(struct rDEPairTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("rDEPairTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* lLCDLECommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCDLECommunicationsEntityId, thedata->lLCDLECommunicationsEntityIdLen);
	/* dLSAPSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->dLSAPSapId, thedata->dLSAPSapIdLen);
	/* rDEPairName */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->rDEPairName, thedata->rDEPairNameLen);
	header_complex_add_data(&rDEPairTableStorage, vars, thedata);
	DEBUGMSGTL(("rDEPairTable", "registered an entry\n"));
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * rDEPairTable_del(): delete a structure
 */
int
rDEPairTable_del(struct rDEPairTable_data **thedata)
{
	struct rDEPairTable_data *StorageDel;

	DEBUGMSGTL(("rDEPairTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCDLECommunicationsEntityId);
		StorageDel->lLCDLECommunicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->dLSAPSapId);
		StorageDel->dLSAPSapIdLen = 0;
		SNMP_FREE(StorageDel->rDEPairName);
		StorageDel->rDEPairNameLen = 0;
		SNMP_FREE(StorageDel->rDEPairRIF);
		StorageDel->rDEPairRIFLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_rDEPairTable(): parse configuration file for rDEPairTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_rDEPairTable(const char *token, char *line)
{
	size_t tmpsize;
	struct rDEPairTable_data *StorageTmp = SNMP_MALLOC_STRUCT(rDEPairTable_data);

	DEBUGMSGTL(("rDEPairTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
	StorageTmp->lLCDLECommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->lLCDLECommunicationsEntityId == NULL) {
		config_perror("invalid specification for lLCDLECommunicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dLSAPSapId, &tmpsize);
	StorageTmp->dLSAPSapIdLen = tmpsize;
	if (StorageTmp->dLSAPSapId == NULL) {
		config_perror("invalid specification for dLSAPSapId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->rDEPairName, &tmpsize);
	StorageTmp->rDEPairNameLen = tmpsize;
	if (StorageTmp->rDEPairName == NULL) {
		config_perror("invalid specification for rDEPairName");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairDiscardCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairNSRPDUCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairNSRSelectedCounter, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->rDEPairRIF, &tmpsize);
	StorageTmp->rDEPairRIFLen = tmpsize;
	if (StorageTmp->rDEPairRIF == NULL) {
		config_perror("invalid specification for rDEPairRIF");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairSRFPDUCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairQueryCounter, &tmpsize);
	rDEPairTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
}

/*
 * store_rDEPairTable(): store configuraiton file for rDEPairTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_rDEPairTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct rDEPairTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("rDEPairTable", "storing data...  "));
	refresh_rDEPairTable();
	(void) tmpsize;
	for (hcindex = rDEPairTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct rDEPairTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->rDEPairTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "rDEPairTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCDLECommunicationsEntityIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCDLECommunicationsEntityId, &tmpsize);
			tmpsize = StorageTmp->dLSAPSapIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dLSAPSapId, &tmpsize);
			tmpsize = StorageTmp->rDEPairNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->rDEPairName, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairDiscardCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairNSRPDUCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairNSRSelectedCounter, &tmpsize);
			tmpsize = StorageTmp->rDEPairRIFLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->rDEPairRIF, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairSRFPDUCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairQueryCounter, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("rDEPairTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCCLPMTable_add(): adds a structure node to our data set
 */
int
lLCCLPMTable_add(struct lLCCLPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCCLPMTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	header_complex_add_data(&lLCCLPMTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCCLPMTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCCLPMTable_del(): delete a structure
 */
int
lLCCLPMTable_del(struct lLCCLPMTable_data **thedata)
{
	struct lLCCLPMTable_data *StorageDel;

	DEBUGMSGTL(("lLCCLPMTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCCLPMClProtocolMachineId);
		StorageDel->lLCCLPMClProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCCLPMTable(): parse configuration file for lLCCLPMTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCCLPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCCLPMTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCCLPMTable_data);

	DEBUGMSGTL(("lLCCLPMTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCCLPMClProtocolMachineId, &tmpsize);
	StorageTmp->lLCCLPMClProtocolMachineIdLen = tmpsize;
	if (StorageTmp->lLCCLPMClProtocolMachineId == NULL) {
		config_perror("invalid specification for lLCCLPMClProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCLPMOperationalState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCCLPMTotalRemoteSAPs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCLPMRowStatus, &tmpsize);
	lLCCLPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
}

/*
 * store_lLCCLPMTable(): store configuraiton file for lLCCLPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCCLPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCCLPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCCLPMTable", "storing data...  "));
	refresh_lLCCLPMTable();
	(void) tmpsize;
	for (hcindex = lLCCLPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCCLPMTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCCLPMTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCCLPMTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCCLPMClProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCCLPMClProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCLPMOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCCLPMTotalRemoteSAPs, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCLPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCCLPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionLessTable_add(): adds a structure node to our data set
 */
int
lLCConnectionLessTable_add(struct lLCConnectionLessTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnectionLessTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	header_complex_add_data(&lLCConnectionLessTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnectionLessTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionLessTable_del(): delete a structure
 */
int
lLCConnectionLessTable_del(struct lLCConnectionLessTable_data **thedata)
{
	struct lLCConnectionLessTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionLessTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCConnectionlessName);
		StorageDel->lLCConnectionlessNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnectionLessTable(): parse configuration file for lLCConnectionLessTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnectionLessTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionLessTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnectionLessTable_data);

	DEBUGMSGTL(("lLCConnectionLessTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessName, &tmpsize);
	StorageTmp->lLCConnectionlessNameLen = tmpsize;
	if (StorageTmp->lLCConnectionlessName == NULL) {
		config_perror("invalid specification for lLCConnectionlessName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessUIReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessUISent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDSentResponse, &tmpsize);
	lLCConnectionLessTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
}

/*
 * store_lLCConnectionLessTable(): store configuraiton file for lLCConnectionLessTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionLessTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionLessTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnectionLessTable", "storing data...  "));
	refresh_lLCConnectionLessTable();
	(void) tmpsize;
	for (hcindex = lLCConnectionLessTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionLessTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnectionLessTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionLessTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCConnectionlessNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessUIReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessUISent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDSentResponse, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnectionLessTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCCOPMTable_add(): adds a structure node to our data set
 */
int
lLCCOPMTable_add(struct lLCCOPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCCOPMTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	header_complex_add_data(&lLCCOPMTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCCOPMTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCCOPMTable_del(): delete a structure
 */
int
lLCCOPMTable_del(struct lLCCOPMTable_data **thedata)
{
	struct lLCCOPMTable_data *StorageDel;

	DEBUGMSGTL(("lLCCOPMTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCCOPMCoProtocolMachineId);
		StorageDel->lLCCOPMCoProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCCOPMTable(): parse configuration file for lLCCOPMTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCCOPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCCOPMTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCCOPMTable_data);

	DEBUGMSGTL(("lLCCOPMTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCCOPMCoProtocolMachineId, &tmpsize);
	StorageTmp->lLCCOPMCoProtocolMachineIdLen = tmpsize;
	if (StorageTmp->lLCCOPMCoProtocolMachineId == NULL) {
		config_perror("invalid specification for lLCCOPMCoProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCOPMOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCOPMRowStatus, &tmpsize);
	lLCCOPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
}

/*
 * store_lLCCOPMTable(): store configuraiton file for lLCCOPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCCOPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCCOPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCCOPMTable", "storing data...  "));
	refresh_lLCCOPMTable();
	(void) tmpsize;
	for (hcindex = lLCCOPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCCOPMTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCCOPMTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCCOPMTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCCOPMCoProtocolMachineIdLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCCOPMCoProtocolMachineId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCOPMOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCOPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCCOPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnection2Table_add(): adds a structure node to our data set
 */
int
lLCConnection2Table_add(struct lLCConnection2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnection2Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	header_complex_add_data(&lLCConnection2TableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnection2Table", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnection2Table_del(): delete a structure
 */
int
lLCConnection2Table_del(struct lLCConnection2Table_data **thedata)
{
	struct lLCConnection2Table_data *StorageDel;

	DEBUGMSGTL(("lLCConnection2Table", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCConnection2Name);
		StorageDel->lLCConnection2NameLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2Route);
		StorageDel->lLCConnection2RouteLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2ProceduralStatus);
		StorageDel->lLCConnection2ProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2AlarmStatus);
		StorageDel->lLCConnection2AlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnection2Table(): parse configuration file for lLCConnection2Table
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnection2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnection2Table_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnection2Table_data);

	DEBUGMSGTL(("lLCConnection2Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2Name, &tmpsize);
	StorageTmp->lLCConnection2NameLen = tmpsize;
	if (StorageTmp->lLCConnection2Name == NULL) {
		config_perror("invalid specification for lLCConnection2Name");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2MaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2ReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2SendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2BusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2PBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2RejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2LocalBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2RemoteBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2RemoteReset, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2LocalReset, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ProviderReset, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2Route, &tmpsize);
	StorageTmp->lLCConnection2RouteLen = tmpsize;
	if (StorageTmp->lLCConnection2Route == NULL) {
		config_perror("invalid specification for lLCConnection2Route");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2KStep, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2MaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedI, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentI, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentAcks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedAcks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedFRMR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentFRMR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedRR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentRR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedRNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentRNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedREJ, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentREJ, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedSABME, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentSABME, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedUA, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentUA, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedDISC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentDISC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedDM, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentDM, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDUsDiscarded1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDUsDiscarded2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDURetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2OptionalTolerationIPDUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2DuplicateIPDUsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2Violation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2ProtocolState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2AdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2OperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2UsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCConnection2ProceduralStatus, &tmpsize);
	StorageTmp->lLCConnection2ProceduralStatusLen = tmpsize;
	if (StorageTmp->lLCConnection2ProceduralStatus == NULL) {
		config_perror("invalid specification for lLCConnection2ProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->lLCConnection2AlarmStatus, &tmpsize);
	StorageTmp->lLCConnection2AlarmStatusLen = tmpsize;
	if (StorageTmp->lLCConnection2AlarmStatus == NULL) {
		config_perror("invalid specification for lLCConnection2AlarmStatus");
		return;
	}

	lLCConnection2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
}

/*
 * store_lLCConnection2Table(): store configuraiton file for lLCConnection2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnection2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnection2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnection2Table", "storing data...  "));
	refresh_lLCConnection2Table();
	(void) tmpsize;
	for (hcindex = lLCConnection2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnection2Table_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnection2TableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnection2Table ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCConnection2NameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2Name, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2MaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2ReceivedWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2SendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2BusyStateTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2PBitTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2RejectTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2LocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2RemoteBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2RemoteReset, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2LocalReset, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ProviderReset, &tmpsize);
			tmpsize = StorageTmp->lLCConnection2RouteLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2Route, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2KStep, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2MaxSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedI, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentI, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentAcks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedAcks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedFRMR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentFRMR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedRR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentRR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedRNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentRNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedREJ, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentREJ, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedSABME, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentSABME, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedUA, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentUA, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedDISC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentDISC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedDM, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentDM, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDUsDiscarded1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDUsDiscarded2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDURetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2OptionalTolerationIPDUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2DuplicateIPDUsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2Violation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2ProtocolState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2AdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2OperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2UsageState, &tmpsize);
			tmpsize = StorageTmp->lLCConnection2ProceduralStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCConnection2ProceduralStatus, &tmpsize);
			tmpsize = StorageTmp->lLCConnection2AlarmStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->lLCConnection2AlarmStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnection2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnection2IVMOTable_add(): adds a structure node to our data set
 */
int
lLCConnection2IVMOTable_add(struct lLCConnection2IVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	header_complex_add_data(&lLCConnection2IVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnection2IVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnection2IVMOTable_del(): delete a structure
 */
int
lLCConnection2IVMOTable_del(struct lLCConnection2IVMOTable_data **thedata)
{
	struct lLCConnection2IVMOTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCConnection2IVMOName);
		StorageDel->lLCConnection2IVMONameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnection2IVMOTable(): parse configuration file for lLCConnection2IVMOTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnection2IVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnection2IVMOTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnection2IVMOTable_data);

	DEBUGMSGTL(("lLCConnection2IVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2IVMOName, &tmpsize);
	StorageTmp->lLCConnection2IVMONameLen = tmpsize;
	if (StorageTmp->lLCConnection2IVMOName == NULL) {
		config_perror("invalid specification for lLCConnection2IVMOName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMORejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMORoute, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOKStep, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOMaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs, &tmpsize);
	lLCConnection2IVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
}

/*
 * store_lLCConnection2IVMOTable(): store configuraiton file for lLCConnection2IVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnection2IVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnection2IVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnection2IVMOTable", "storing data...  "));
	refresh_lLCConnection2IVMOTable();
	(void) tmpsize;
	for (hcindex = lLCConnection2IVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnection2IVMOTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnection2IVMOTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnection2IVMOTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCConnection2IVMONameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2IVMOName, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOReceivedWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOBitTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMORejectTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMORoute, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOKStep, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOMaxSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnection2IVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionlessAckTable_add(): adds a structure node to our data set
 */
int
lLCConnectionlessAckTable_add(struct lLCConnectionlessAckTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	header_complex_add_data(&lLCConnectionlessAckTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnectionlessAckTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionlessAckTable_del(): delete a structure
 */
int
lLCConnectionlessAckTable_del(struct lLCConnectionlessAckTable_data **thedata)
{
	struct lLCConnectionlessAckTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCConnectionlessAckName);
		StorageDel->lLCConnectionlessAckNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnectionlessAckTable(): parse configuration file for lLCConnectionlessAckTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnectionlessAckTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionlessAckTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnectionlessAckTable_data);

	DEBUGMSGTL(("lLCConnectionlessAckTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessAckName, &tmpsize);
	StorageTmp->lLCConnectionlessAckNameLen = tmpsize;
	if (StorageTmp->lLCConnectionlessAckName == NULL) {
		config_perror("invalid specification for lLCConnectionlessAckName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentResponse, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckReceiveResources, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckUIReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckUISent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDSentResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckNoResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandIP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandIT, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandOK, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandPE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandRS, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandUE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandUN, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckReceivedACCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckSentACCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseIP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseIT, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseNE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseOK, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseRS, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseUE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseUN, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckViolation, &tmpsize);
	lLCConnectionlessAckTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
}

/*
 * store_lLCConnectionlessAckTable(): store configuraiton file for lLCConnectionlessAckTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionlessAckTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionlessAckTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnectionlessAckTable", "storing data...  "));
	refresh_lLCConnectionlessAckTable();
	(void) tmpsize;
	for (hcindex = lLCConnectionlessAckTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionlessAckTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnectionlessAckTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionlessAckTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCConnectionlessAckNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessAckName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckReceiveResources, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckUIReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckUISent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckNoResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandIP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandIT, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandOK, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandPE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandRS, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandUE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandUN, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckReceivedACCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckSentACCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseIP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseIT, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseNE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseOK, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseRS, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseUE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseUN, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckViolation, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnectionlessAckTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionlessAckIVMOTable_add(): adds a structure node to our data set
 */
int
lLCConnectionlessAckIVMOTable_add(struct lLCConnectionlessAckIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* lLCConnectionlessAckIVMOName */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCConnectionlessAckIVMOName, thedata->lLCConnectionlessAckIVMONameLen);
	header_complex_add_data(&lLCConnectionlessAckIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * lLCConnectionlessAckIVMOTable_del(): delete a structure
 */
int
lLCConnectionlessAckIVMOTable_del(struct lLCConnectionlessAckIVMOTable_data **thedata)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageDel;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCConnectionlessAckIVMOName);
		StorageDel->lLCConnectionlessAckIVMONameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lLCConnectionlessAckIVMOTable(): parse configuration file for lLCConnectionlessAckIVMOTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_lLCConnectionlessAckIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = SNMP_MALLOC_STRUCT(lLCConnectionlessAckIVMOTable_data);

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessAckIVMOName, &tmpsize);
	StorageTmp->lLCConnectionlessAckIVMONameLen = tmpsize;
	if (StorageTmp->lLCConnectionlessAckIVMOName == NULL) {
		config_perror("invalid specification for lLCConnectionlessAckIVMOName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMORowStatus, &tmpsize);
	lLCConnectionlessAckIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
}

/*
 * store_lLCConnectionlessAckIVMOTable(): store configuraiton file for lLCConnectionlessAckIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionlessAckIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "storing data...  "));
	refresh_lLCConnectionlessAckIVMOTable();
	(void) tmpsize;
	for (hcindex = lLCConnectionlessAckIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionlessAckIVMOTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->lLCConnectionlessAckIVMOTableStorageType == ST_NONVOLATILE) 
		 */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionlessAckIVMOTable ");
			cptr = line + strlen(line);
			tmpsize = StorageTmp->lLCConnectionlessAckIVMONameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessAckIVMOName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lLCConnectionlessAckIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mACDLETable(): refresh mACDLETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mACDLETable(void)
{
	if (mACDLETable_refresh == 0)
		return;
	mACDLETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mACDLETable_row(): refresh mACDLETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mACDLETable_row(struct mACDLETable_data *StorageTmp)
{
	if (StorageTmp->mACDLETable_request == sa_request)
		return;
	StorageTmp->mACDLETable_request = sa_request;
}

/*
 * var_mACDLETable(): locate variables in mACDLETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_mACDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mACDLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_mACDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mACDLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mACDLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mACDLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MACDLELOCALSAPNAMES:
		*write_method = write_mACDLELocalSapNames;
		*var_len = StorageTmp->mACDLELocalSapNamesLen;
		return (u_char *) StorageTmp->mACDLELocalSapNames;
	case MACDLEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mACDLEOperationalState);
		return (u_char *) &StorageTmp->mACDLEOperationalState;
	case MACDLEPROVIDERENTITYNAMES:
		*write_method = write_mACDLEProviderEntityNames;
		*var_len = StorageTmp->mACDLEProviderEntityNamesLen;
		return (u_char *) StorageTmp->mACDLEProviderEntityNames;
	case MACDLEROWSTATUS:
		*write_method = write_mACDLERowStatus;
		*var_len = sizeof(StorageTmp->mACDLERowStatus);
		return (u_char *) &StorageTmp->mACDLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mACTable(): refresh mACTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mACTable(void)
{
	if (mACTable_refresh == 0)
		return;
	mACTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mACTable_row(): refresh mACTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mACTable_row(struct mACTable_data *StorageTmp)
{
	if (StorageTmp->mACTable_request == sa_request)
		return;
	StorageTmp->mACTable_request = sa_request;
}

/*
 * var_mACTable(): locate variables in mACTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_mACTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mACTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_mACTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mACTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mACTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mACTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case MACOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mACOperationalState);
		return (u_char *) &StorageTmp->mACOperationalState;
	case MACROWSTATUS:
		*write_method = write_mACRowStatus;
		*var_len = sizeof(StorageTmp->mACRowStatus);
		return (u_char *) &StorageTmp->mACRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_resourceTypeIdTable(): refresh resourceTypeIdTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_resourceTypeIdTable(void)
{
	if (resourceTypeIdTable_refresh == 0)
		return;
	resourceTypeIdTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_resourceTypeIdTable_row(): refresh resourceTypeIdTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_resourceTypeIdTable_row(struct resourceTypeIdTable_data *StorageTmp)
{
	if (StorageTmp->resourceTypeIdTable_request == sa_request)
		return;
	StorageTmp->resourceTypeIdTable_request = sa_request;
}

/*
 * var_resourceTypeIdTable(): locate variables in resourceTypeIdTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_resourceTypeIdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct resourceTypeIdTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_resourceTypeIdTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_resourceTypeIdTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(resourceTypeIdTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_resourceTypeIdTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case RESOURCETYPEIDNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceTypeIdNameLen;
		return (u_char *) StorageTmp->resourceTypeIdName;
	case RESOURCEINFOMANUFACTUREROUI:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerOUILen;
		return (u_char *) StorageTmp->resourceInfoManufacturerOUI;
	case RESOURCEINFOMANUFACTURERNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerNameLen;
		return (u_char *) StorageTmp->resourceInfoManufacturerName;
	case RESOURCEINFOMANUFACTURERPRODUCTNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerProductNameLen;
		return (u_char *) StorageTmp->resourceInfoManufacturerProductName;
	case RESOURCEINFOMANUFACTURERPRODUCTVERSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->resourceInfoManufacturerProductVersionLen;
		return (u_char *) StorageTmp->resourceInfoManufacturerProductVersion;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_dLSAPTable(): refresh dLSAPTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dLSAPTable(void)
{
	if (dLSAPTable_refresh == 0)
		return;
	dLSAPTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_dLSAPTable_row(): refresh dLSAPTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_dLSAPTable_row(struct dLSAPTable_data *StorageTmp)
{
	if (StorageTmp->dLSAPTable_request == sa_request)
		return;
	StorageTmp->dLSAPTable_request = sa_request;
}

/*
 * var_dLSAPTable(): locate variables in dLSAPTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_dLSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dLSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_dLSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_dLSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(dLSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_dLSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case DLSAPSAP1ADDRESS:
		*write_method = write_dLSAPSap1Address;
		*var_len = sizeof(StorageTmp->dLSAPSap1Address);
		return (u_char *) &StorageTmp->dLSAPSap1Address;
	case DLSAPUSERENTITYNAMES:
		*write_method = write_dLSAPUserEntityNames;
		*var_len = StorageTmp->dLSAPUserEntityNamesLen;
		return (u_char *) StorageTmp->dLSAPUserEntityNames;
	case DLSAPROWSTATUS:
		*write_method = write_dLSAPRowStatus;
		*var_len = sizeof(StorageTmp->dLSAPRowStatus);
		return (u_char *) &StorageTmp->dLSAPRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCDLETable(): refresh lLCDLETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCDLETable(void)
{
	if (lLCDLETable_refresh == 0)
		return;
	lLCDLETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCDLETable_row(): refresh lLCDLETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCDLETable_row(struct lLCDLETable_data *StorageTmp)
{
	if (StorageTmp->lLCDLETable_request == sa_request)
		return;
	StorageTmp->lLCDLETable_request = sa_request;
}

/*
 * var_lLCDLETable(): locate variables in lLCDLETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCDLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCDLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCDLETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCDLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCDLELOCALSAPNAMES:
		*write_method = write_lLCDLELocalSapNames;
		*var_len = StorageTmp->lLCDLELocalSapNamesLen;
		return (u_char *) StorageTmp->lLCDLELocalSapNames;
	case LLCDLEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCDLEOperationalState);
		return (u_char *) &StorageTmp->lLCDLEOperationalState;
	case LLCDLEPROVIDERENTITYNAMES:
		*write_method = write_lLCDLEProviderEntityNames;
		*var_len = StorageTmp->lLCDLEProviderEntityNamesLen;
		return (u_char *) StorageTmp->lLCDLEProviderEntityNames;
	case LLCDLEROWSTATUS:
		*write_method = write_lLCDLERowStatus;
		*var_len = sizeof(StorageTmp->lLCDLERowStatus);
		return (u_char *) &StorageTmp->lLCDLERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCStationTable(): refresh lLCStationTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCStationTable(void)
{
	if (lLCStationTable_refresh == 0)
		return;
	lLCStationTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCStationTable_row(): refresh lLCStationTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCStationTable_row(struct lLCStationTable_data *StorageTmp)
{
	if (StorageTmp->lLCStationTable_request == sa_request)
		return;
	StorageTmp->lLCStationTable_request = sa_request;
}

/*
 * var_lLCStationTable(): locate variables in lLCStationTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCStationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCStationTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCStationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCStationTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCStationTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCStationTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCSTATIONLLCNAME:
		*write_method = write_lLCStationLLCName;
		*var_len = StorageTmp->lLCStationLLCNameLen;
		return (u_char *) StorageTmp->lLCStationLLCName;
	case LLCSTATIONMAXIMUMLSAPSCONFIGURED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationMaximumLSAPsConfigured);
		return (u_char *) &StorageTmp->lLCStationMaximumLSAPsConfigured;
	case LLCSTATIONNUMBEROFACTIVELSAPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationNumberOfActiveLSAPs);
		return (u_char *) &StorageTmp->lLCStationNumberOfActiveLSAPs;
	case LLCSTATIONSUPPORTEDSERVICESTYPES:
		*write_method = write_lLCStationSupportedServicesTypes;
		*var_len = StorageTmp->lLCStationSupportedServicesTypesLen;
		return (u_char *) StorageTmp->lLCStationSupportedServicesTypes;
	case LLCSTATIONSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationStatus);
		return (u_char *) &StorageTmp->lLCStationStatus;
	case LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType1AcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCStationType1AcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCStationType1AcknowledgeTimeoutValue;
	case LLCSTATIONTYPE1MAXIMUMRETRYCOUNT:
		*write_method = write_lLCStationType1MaximumRetryCount;
		*var_len = sizeof(StorageTmp->lLCStationType1MaximumRetryCount);
		return (u_char *) &StorageTmp->lLCStationType1MaximumRetryCount;
	case LLCSTATIONMAXIMUMPDUN3:
		*write_method = write_lLCStationMaximumPDUN3;
		*var_len = sizeof(StorageTmp->lLCStationMaximumPDUN3);
		return (u_char *) &StorageTmp->lLCStationMaximumPDUN3;
	case LLCSTATIONMAXIMUMRETRANSMISSIONS4:
		*write_method = write_lLCStationMaximumRetransmissions4;
		*var_len = sizeof(StorageTmp->lLCStationMaximumRetransmissions4);
		return (u_char *) &StorageTmp->lLCStationMaximumRetransmissions4;
	case LLCSTATIONRECEIVEVARIABLELIFETIME:
		*write_method = write_lLCStationReceiveVariableLifetime;
		*var_len = sizeof(StorageTmp->lLCStationReceiveVariableLifetime);
		return (u_char *) &StorageTmp->lLCStationReceiveVariableLifetime;
	case LLCSTATIONTRANSMITVARIABLELIFETIME:
		*write_method = write_lLCStationTransmitVariableLifetime;
		*var_len = sizeof(StorageTmp->lLCStationTransmitVariableLifetime);
		return (u_char *) &StorageTmp->lLCStationTransmitVariableLifetime;
	case LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCStationType3AcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCStationType3AcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCStationType3AcknowledgeTimeoutValue;
	case LLCSTATIONTYPE3RETRANSMISSIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationType3Retransmissions);
		return (u_char *) &StorageTmp->lLCStationType3Retransmissions;
	case LLCSTATIONAVGBUFFERUSESIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationAvgBufferUseSize);
		return (u_char *) &StorageTmp->lLCStationAvgBufferUseSize;
	case LLCSTATIONBUFFERPROBLEMS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationBufferProblems);
		return (u_char *) &StorageTmp->lLCStationBufferProblems;
	case LLCSTATIONBUFFERSIZE:
		*write_method = write_lLCStationBufferSize;
		*var_len = sizeof(StorageTmp->lLCStationBufferSize);
		return (u_char *) &StorageTmp->lLCStationBufferSize;
	case LLCSTATIONMAXBUFFERUSESIZE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationMaxBufferUseSize);
		return (u_char *) &StorageTmp->lLCStationMaxBufferUseSize;
	case LLCSTATIONINACTIVELSAP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationInactiveLSAP);
		return (u_char *) &StorageTmp->lLCStationInactiveLSAP;
	case LLCSTATIONPDUSDISCARD:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationPDUsDiscard);
		return (u_char *) &StorageTmp->lLCStationPDUsDiscard;
	case LLCSTATIONSTRINDICATOR:
		*write_method = write_lLCStationSTRIndicator;
		*var_len = StorageTmp->lLCStationSTRIndicatorLen;
		return (u_char *) StorageTmp->lLCStationSTRIndicator;
	case LLCSTATIONVERSIONNUMBER:
		*write_method = write_lLCStationVersionNumber;
		*var_len = sizeof(StorageTmp->lLCStationVersionNumber);
		return (u_char *) &StorageTmp->lLCStationVersionNumber;
	case LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts);
		return (u_char *) &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCSAPTable(): refresh lLCSAPTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCSAPTable(void)
{
	if (lLCSAPTable_refresh == 0)
		return;
	lLCSAPTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCSAPTable_row(): refresh lLCSAPTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCSAPTable_row(struct lLCSAPTable_data *StorageTmp)
{
	if (StorageTmp->lLCSAPTable_request == sa_request)
		return;
	StorageTmp->lLCSAPTable_request = sa_request;
}

/*
 * var_lLCSAPTable(): locate variables in lLCSAPTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCSAPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCSAPADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->lLCSAPAddressLen;
		return (u_char *) StorageTmp->lLCSAPAddress;
	case LLCSAPRDE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCSAPRDE);
		return (u_char *) &StorageTmp->lLCSAPRDE;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_rDESetupTable(): refresh rDESetupTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_rDESetupTable(void)
{
	if (rDESetupTable_refresh == 0)
		return;
	rDESetupTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_rDESetupTable_row(): refresh rDESetupTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_rDESetupTable_row(struct rDESetupTable_data *StorageTmp)
{
	if (StorageTmp->rDESetupTable_request == sa_request)
		return;
	StorageTmp->rDESetupTable_request = sa_request;
}

/*
 * var_rDESetupTable(): locate variables in rDESetupTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_rDESetupTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct rDESetupTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_rDESetupTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_rDESetupTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(rDESetupTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_rDESetupTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case RDESETUPAGINGENABLED:
		*write_method = write_rDESetupAgingEnabled;
		*var_len = sizeof(StorageTmp->rDESetupAgingEnabled);
		return (u_char *) &StorageTmp->rDESetupAgingEnabled;
	case RDESETUPAGINGVALUE:
		*write_method = write_rDESetupAgingValue;
		*var_len = sizeof(StorageTmp->rDESetupAgingValue);
		return (u_char *) &StorageTmp->rDESetupAgingValue;
	case RDESETUPENABLETYPE2RESET:
		*write_method = write_rDESetupEnableType2Reset;
		*var_len = sizeof(StorageTmp->rDESetupEnableType2Reset);
		return (u_char *) &StorageTmp->rDESetupEnableType2Reset;
	case RDESETUPMAXIMUMROUTEDESCRIPTORS:
		*write_method = write_rDESetupMaximumRouteDescriptors;
		*var_len = sizeof(StorageTmp->rDESetupMaximumRouteDescriptors);
		return (u_char *) &StorageTmp->rDESetupMaximumRouteDescriptors;
	case RDESETUPMAXIMUMRESPONSETIME:
		*write_method = write_rDESetupMaximumResponseTime;
		*var_len = sizeof(StorageTmp->rDESetupMaximumResponseTime);
		return (u_char *) &StorageTmp->rDESetupMaximumResponseTime;
	case RDESETUPMINIMUMPDUSIZE:
		*write_method = write_rDESetupMinimumPDUSize;
		*var_len = sizeof(StorageTmp->rDESetupMinimumPDUSize);
		return (u_char *) &StorageTmp->rDESetupMinimumPDUSize;
	case RDESETUPRDEHOLD:
		*write_method = write_rDESetupRDEHold;
		*var_len = sizeof(StorageTmp->rDESetupRDEHold);
		return (u_char *) &StorageTmp->rDESetupRDEHold;
	case RDESETUPRDEREPLACE:
		*write_method = write_rDESetupRDEReplace;
		*var_len = sizeof(StorageTmp->rDESetupRDEReplace);
		return (u_char *) &StorageTmp->rDESetupRDEReplace;
	case RDESETUPNAME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDESetupName);
		return (u_char *) &StorageTmp->rDESetupName;
	case RDESETUPRESETONTESTENABLED:
		*write_method = write_rDESetupResetOnTestEnabled;
		*var_len = sizeof(StorageTmp->rDESetupResetOnTestEnabled);
		return (u_char *) &StorageTmp->rDESetupResetOnTestEnabled;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_rDEPairTable(): refresh rDEPairTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_rDEPairTable(void)
{
	if (rDEPairTable_refresh == 0)
		return;
	rDEPairTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_rDEPairTable_row(): refresh rDEPairTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_rDEPairTable_row(struct rDEPairTable_data *StorageTmp)
{
	if (StorageTmp->rDEPairTable_request == sa_request)
		return;
	StorageTmp->rDEPairTable_request = sa_request;
}

/*
 * var_rDEPairTable(): locate variables in rDEPairTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_rDEPairTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct rDEPairTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_rDEPairTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_rDEPairTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(rDEPairTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_rDEPairTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case RDEPAIRDISCARDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairDiscardCounter);
		return (u_char *) &StorageTmp->rDEPairDiscardCounter;
	case RDEPAIRNSRPDUCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairNSRPDUCounter);
		return (u_char *) &StorageTmp->rDEPairNSRPDUCounter;
	case RDEPAIRNSRSELECTEDCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairNSRSelectedCounter);
		return (u_char *) &StorageTmp->rDEPairNSRSelectedCounter;
	case RDEPAIRRIF:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->rDEPairRIFLen;
		return (u_char *) StorageTmp->rDEPairRIF;
	case RDEPAIRSRFPDUCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairSRFPDUCounter);
		return (u_char *) &StorageTmp->rDEPairSRFPDUCounter;
	case RDEPAIRQUERYCOUNTER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->rDEPairQueryCounter);
		return (u_char *) &StorageTmp->rDEPairQueryCounter;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCCLPMTable(): refresh lLCCLPMTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCCLPMTable(void)
{
	if (lLCCLPMTable_refresh == 0)
		return;
	lLCCLPMTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCCLPMTable_row(): refresh lLCCLPMTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCCLPMTable_row(struct lLCCLPMTable_data *StorageTmp)
{
	if (StorageTmp->lLCCLPMTable_request == sa_request)
		return;
	StorageTmp->lLCCLPMTable_request = sa_request;
}

/*
 * var_lLCCLPMTable(): locate variables in lLCCLPMTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCCLPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCCLPMTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCCLPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCCLPMTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCCLPMTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCCLPMTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCLPMOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCCLPMOperationalState);
		return (u_char *) &StorageTmp->lLCCLPMOperationalState;
	case LLCCLPMTOTALREMOTESAPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCCLPMTotalRemoteSAPs);
		return (u_char *) &StorageTmp->lLCCLPMTotalRemoteSAPs;
	case LLCCLPMROWSTATUS:
		*write_method = write_lLCCLPMRowStatus;
		*var_len = sizeof(StorageTmp->lLCCLPMRowStatus);
		return (u_char *) &StorageTmp->lLCCLPMRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnectionLessTable(): refresh lLCConnectionLessTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionLessTable(void)
{
	if (lLCConnectionLessTable_refresh == 0)
		return;
	lLCConnectionLessTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnectionLessTable_row(): refresh lLCConnectionLessTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnectionLessTable_row(struct lLCConnectionLessTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnectionLessTable_request == sa_request)
		return;
	StorageTmp->lLCConnectionLessTable_request = sa_request;
}

/*
 * var_lLCConnectionLessTable(): locate variables in lLCConnectionLessTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCConnectionLessTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionLessTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCConnectionLessTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnectionLessTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnectionLessTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnectionLessTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTIONLESSNAME:
		*write_method = write_lLCConnectionlessName;
		*var_len = StorageTmp->lLCConnectionlessNameLen;
		return (u_char *) StorageTmp->lLCConnectionlessName;
	case LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedABBResponse;
	case LLCCONNECTIONLESSTESTRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedCommand;
	case LLCCONNECTIONLESSTESTRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedResponse;
	case LLCCONNECTIONLESSTESTSENTABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTSentABBResponse;
	case LLCCONNECTIONLESSTESTSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTSentCommand;
	case LLCCONNECTIONLESSTESTSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessTESTSentResponse;
	case LLCCONNECTIONLESSUIRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessUIReceived);
		return (u_char *) &StorageTmp->lLCConnectionlessUIReceived;
	case LLCCONNECTIONLESSUISENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessUISent);
		return (u_char *) &StorageTmp->lLCConnectionlessUISent;
	case LLCCONNECTIONLESSXIDRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDReceivedCommand;
	case LLCCONNECTIONLESSXIDRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDReceivedResponse;
	case LLCCONNECTIONLESSXIDSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDSentCommand;
	case LLCCONNECTIONLESSXIDSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessXIDSentResponse;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCCOPMTable(): refresh lLCCOPMTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCCOPMTable(void)
{
	if (lLCCOPMTable_refresh == 0)
		return;
	lLCCOPMTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCCOPMTable_row(): refresh lLCCOPMTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCCOPMTable_row(struct lLCCOPMTable_data *StorageTmp)
{
	if (StorageTmp->lLCCOPMTable_request == sa_request)
		return;
	StorageTmp->lLCCOPMTable_request = sa_request;
}

/*
 * var_lLCCOPMTable(): locate variables in lLCCOPMTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCCOPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCCOPMTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCCOPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCCOPMTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCCOPMTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCCOPMTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCOPMOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCCOPMOperationalState);
		return (u_char *) &StorageTmp->lLCCOPMOperationalState;
	case LLCCOPMROWSTATUS:
		*write_method = write_lLCCOPMRowStatus;
		*var_len = sizeof(StorageTmp->lLCCOPMRowStatus);
		return (u_char *) &StorageTmp->lLCCOPMRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnection2Table(): refresh lLCConnection2Table
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnection2Table(void)
{
	if (lLCConnection2Table_refresh == 0)
		return;
	lLCConnection2Table_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnection2Table_row(): refresh lLCConnection2Table row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnection2Table_row(struct lLCConnection2Table_data *StorageTmp)
{
	if (StorageTmp->lLCConnection2Table_request == sa_request)
		return;
	StorageTmp->lLCConnection2Table_request = sa_request;
}

/*
 * var_lLCConnection2Table(): locate variables in lLCConnection2Table
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCConnection2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnection2Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCConnection2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnection2Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnection2Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTION2NAME:
		*write_method = write_lLCConnection2Name;
		*var_len = StorageTmp->lLCConnection2NameLen;
		return (u_char *) StorageTmp->lLCConnection2Name;
	case LLCCONNECTION2MAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2MaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2MaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2MaximumRetransmissions;
	case LLCCONNECTION2RECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2ReceivedWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedWindowSize;
	case LLCCONNECTION2SENDWINDOWSIZE:
		*write_method = write_lLCConnection2SendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2SendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2SendWindowSize;
	case LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2AcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2AcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2AcknowledgeTimeoutValue;
	case LLCCONNECTION2BUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2BusyStateTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2BusyStateTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2BusyStateTimeoutValue;
	case LLCCONNECTION2PBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2PBitTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2PBitTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2PBitTimeoutValue;
	case LLCCONNECTION2REJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2RejectTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2RejectTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2RejectTimeoutValue;
	case LLCCONNECTION2LOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2LocalBusy);
		return (u_char *) &StorageTmp->lLCConnection2LocalBusy;
	case LLCCONNECTION2REMOTEBUSY:
		*write_method = write_lLCConnection2RemoteBusy;
		*var_len = sizeof(StorageTmp->lLCConnection2RemoteBusy);
		return (u_char *) &StorageTmp->lLCConnection2RemoteBusy;
	case LLCCONNECTION2REMOTERESET:
		*write_method = write_lLCConnection2RemoteReset;
		*var_len = sizeof(StorageTmp->lLCConnection2RemoteReset);
		return (u_char *) &StorageTmp->lLCConnection2RemoteReset;
	case LLCCONNECTION2LOCALRESET:
		*write_method = write_lLCConnection2LocalReset;
		*var_len = sizeof(StorageTmp->lLCConnection2LocalReset);
		return (u_char *) &StorageTmp->lLCConnection2LocalReset;
	case LLCCONNECTION2PROVIDERRESET:
		*write_method = write_lLCConnection2ProviderReset;
		*var_len = sizeof(StorageTmp->lLCConnection2ProviderReset);
		return (u_char *) &StorageTmp->lLCConnection2ProviderReset;
	case LLCCONNECTION2ROUTE:
		*write_method = write_lLCConnection2Route;
		*var_len = StorageTmp->lLCConnection2RouteLen;
		return (u_char *) StorageTmp->lLCConnection2Route;
	case LLCCONNECTION2KSTEP:
		*write_method = write_lLCConnection2KStep;
		*var_len = sizeof(StorageTmp->lLCConnection2KStep);
		return (u_char *) &StorageTmp->lLCConnection2KStep;
	case LLCCONNECTION2MAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2MaxSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2MaxSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2MaxSendWindowSize;
	case LLCCONNECTION2RECEIVEDI:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedI);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedI;
	case LLCCONNECTION2SENTI:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2SentI);
		return (u_char *) &StorageTmp->lLCConnection2SentI;
	case LLCCONNECTION2SENTACKS:
		*write_method = write_lLCConnection2SentAcks;
		*var_len = sizeof(StorageTmp->lLCConnection2SentAcks);
		return (u_char *) &StorageTmp->lLCConnection2SentAcks;
	case LLCCONNECTION2RECEIVEDACKS:
		*write_method = write_lLCConnection2ReceivedAcks;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedAcks);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedAcks;
	case LLCCONNECTION2RECEIVEDFRMR:
		*write_method = write_lLCConnection2ReceivedFRMR;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedFRMR);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedFRMR;
	case LLCCONNECTION2SENTFRMR:
		*write_method = write_lLCConnection2SentFRMR;
		*var_len = sizeof(StorageTmp->lLCConnection2SentFRMR);
		return (u_char *) &StorageTmp->lLCConnection2SentFRMR;
	case LLCCONNECTION2RECEIVEDRR:
		*write_method = write_lLCConnection2ReceivedRR;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedRR);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedRR;
	case LLCCONNECTION2SENTRR:
		*write_method = write_lLCConnection2SentRR;
		*var_len = sizeof(StorageTmp->lLCConnection2SentRR);
		return (u_char *) &StorageTmp->lLCConnection2SentRR;
	case LLCCONNECTION2RECEIVEDRNR:
		*write_method = write_lLCConnection2ReceivedRNR;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedRNR);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedRNR;
	case LLCCONNECTION2SENTRNR:
		*write_method = write_lLCConnection2SentRNR;
		*var_len = sizeof(StorageTmp->lLCConnection2SentRNR);
		return (u_char *) &StorageTmp->lLCConnection2SentRNR;
	case LLCCONNECTION2RECEIVEDREJ:
		*write_method = write_lLCConnection2ReceivedREJ;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedREJ);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedREJ;
	case LLCCONNECTION2SENTREJ:
		*write_method = write_lLCConnection2SentREJ;
		*var_len = sizeof(StorageTmp->lLCConnection2SentREJ);
		return (u_char *) &StorageTmp->lLCConnection2SentREJ;
	case LLCCONNECTION2RECEIVEDSABME:
		*write_method = write_lLCConnection2ReceivedSABME;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedSABME);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedSABME;
	case LLCCONNECTION2SENTSABME:
		*write_method = write_lLCConnection2SentSABME;
		*var_len = sizeof(StorageTmp->lLCConnection2SentSABME);
		return (u_char *) &StorageTmp->lLCConnection2SentSABME;
	case LLCCONNECTION2RECEIVEDUA:
		*write_method = write_lLCConnection2ReceivedUA;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedUA);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedUA;
	case LLCCONNECTION2SENTUA:
		*write_method = write_lLCConnection2SentUA;
		*var_len = sizeof(StorageTmp->lLCConnection2SentUA);
		return (u_char *) &StorageTmp->lLCConnection2SentUA;
	case LLCCONNECTION2RECEIVEDDISC:
		*write_method = write_lLCConnection2ReceivedDISC;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedDISC);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedDISC;
	case LLCCONNECTION2SENTDISC:
		*write_method = write_lLCConnection2SentDISC;
		*var_len = sizeof(StorageTmp->lLCConnection2SentDISC);
		return (u_char *) &StorageTmp->lLCConnection2SentDISC;
	case LLCCONNECTION2RECEIVEDDM:
		*write_method = write_lLCConnection2ReceivedDM;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedDM);
		return (u_char *) &StorageTmp->lLCConnection2ReceivedDM;
	case LLCCONNECTION2SENTDM:
		*write_method = write_lLCConnection2SentDM;
		*var_len = sizeof(StorageTmp->lLCConnection2SentDM);
		return (u_char *) &StorageTmp->lLCConnection2SentDM;
	case LLCCONNECTION2PDUSDISCARDED1:
		*write_method = write_lLCConnection2PDUsDiscarded1;
		*var_len = sizeof(StorageTmp->lLCConnection2PDUsDiscarded1);
		return (u_char *) &StorageTmp->lLCConnection2PDUsDiscarded1;
	case LLCCONNECTION2PDUSDISCARDED2:
		*write_method = write_lLCConnection2PDUsDiscarded2;
		*var_len = sizeof(StorageTmp->lLCConnection2PDUsDiscarded2);
		return (u_char *) &StorageTmp->lLCConnection2PDUsDiscarded2;
	case LLCCONNECTION2PDURETRANSMISSIONS:
		*write_method = write_lLCConnection2PDURetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2PDURetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2PDURetransmissions;
	case LLCCONNECTION2OPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2OptionalTolerationIPDUs;
		*var_len = sizeof(StorageTmp->lLCConnection2OptionalTolerationIPDUs);
		return (u_char *) &StorageTmp->lLCConnection2OptionalTolerationIPDUs;
	case LLCCONNECTION2DUPLICATEIPDUSRECEIVED:
		*write_method = write_lLCConnection2DuplicateIPDUsReceived;
		*var_len = sizeof(StorageTmp->lLCConnection2DuplicateIPDUsReceived);
		return (u_char *) &StorageTmp->lLCConnection2DuplicateIPDUsReceived;
	case LLCCONNECTION2VIOLATION:
		*write_method = write_lLCConnection2Violation;
		*var_len = sizeof(StorageTmp->lLCConnection2Violation);
		return (u_char *) &StorageTmp->lLCConnection2Violation;
	case LLCCONNECTION2PROTOCOLSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2ProtocolState);
		return (u_char *) &StorageTmp->lLCConnection2ProtocolState;
	case LLCCONNECTION2ADMINISTRATIVESTATE:
		*write_method = write_lLCConnection2AdministrativeState;
		*var_len = sizeof(StorageTmp->lLCConnection2AdministrativeState);
		return (u_char *) &StorageTmp->lLCConnection2AdministrativeState;
	case LLCCONNECTION2OPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2OperationalState);
		return (u_char *) &StorageTmp->lLCConnection2OperationalState;
	case LLCCONNECTION2USAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnection2UsageState);
		return (u_char *) &StorageTmp->lLCConnection2UsageState;
	case LLCCONNECTION2PROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->lLCConnection2ProceduralStatusLen;
		return (u_char *) StorageTmp->lLCConnection2ProceduralStatus;
	case LLCCONNECTION2ALARMSTATUS:
		*write_method = write_lLCConnection2AlarmStatus;
		*var_len = StorageTmp->lLCConnection2AlarmStatusLen;
		return (u_char *) StorageTmp->lLCConnection2AlarmStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnection2IVMOTable(): refresh lLCConnection2IVMOTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnection2IVMOTable(void)
{
	if (lLCConnection2IVMOTable_refresh == 0)
		return;
	lLCConnection2IVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnection2IVMOTable_row(): refresh lLCConnection2IVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnection2IVMOTable_row(struct lLCConnection2IVMOTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnection2IVMOTable_request == sa_request)
		return;
	StorageTmp->lLCConnection2IVMOTable_request = sa_request;
}

/*
 * var_lLCConnection2IVMOTable(): locate variables in lLCConnection2IVMOTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCConnection2IVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCConnection2IVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnection2IVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnection2IVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnection2IVMOMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnection2IVMOMaximumRetransmissions;
	case LLCCONNECTION2IVMORECEIVEDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOReceivedWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOReceivedWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2IVMOReceivedWindowSize;
	case LLCCONNECTION2IVMOSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2IVMOSendWindowSize;
	case LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOAcknowledgeTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue;
	case LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBusyStateTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue;
	case LLCCONNECTION2IVMOBITTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMOBitTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOBitTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMOBitTimeoutValue;
	case LLCCONNECTION2IVMOREJECTTIMEOUTVALUE:
		*write_method = write_lLCConnection2IVMORejectTimeoutValue;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMORejectTimeoutValue);
		return (u_char *) &StorageTmp->lLCConnection2IVMORejectTimeoutValue;
	case LLCCONNECTION2IVMOROUTE:
		*write_method = write_lLCConnection2IVMORoute;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMORoute);
		return (u_char *) &StorageTmp->lLCConnection2IVMORoute;
	case LLCCONNECTION2IVMOKSTEP:
		*write_method = write_lLCConnection2IVMOKStep;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOKStep);
		return (u_char *) &StorageTmp->lLCConnection2IVMOKStep;
	case LLCCONNECTION2IVMOMAXSENDWINDOWSIZE:
		*write_method = write_lLCConnection2IVMOMaxSendWindowSize;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOMaxSendWindowSize);
		return (u_char *) &StorageTmp->lLCConnection2IVMOMaxSendWindowSize;
	case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS:
		*write_method = write_lLCConnection2IVMOOptionalTolerationIPDUs;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs);
		return (u_char *) &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnectionlessAckTable(): refresh lLCConnectionlessAckTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionlessAckTable(void)
{
	if (lLCConnectionlessAckTable_refresh == 0)
		return;
	lLCConnectionlessAckTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnectionlessAckTable_row(): refresh lLCConnectionlessAckTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnectionlessAckTable_row(struct lLCConnectionlessAckTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnectionlessAckTable_request == sa_request)
		return;
	StorageTmp->lLCConnectionlessAckTable_request = sa_request;
}

/*
 * var_lLCConnectionlessAckTable(): locate variables in lLCConnectionlessAckTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCConnectionlessAckTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCConnectionlessAckTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnectionlessAckTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnectionlessAckTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTIONLESSACKNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->lLCConnectionlessAckNameLen;
		return (u_char *) StorageTmp->lLCConnectionlessAckName;
	case LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckMaximumRetransmissions;
	case LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse;
	case LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedCommand;
	case LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedResponse;
	case LLCCONNECTIONLESSACKTESTSENTABBRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentABBResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentABBResponse;
	case LLCCONNECTIONLESSACKTESTSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentCommand;
	case LLCCONNECTIONLESSACKTESTSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentResponse;
	case LLCCONNECTIONLESSACKRECEIVERESOURCES:
		*write_method = write_lLCConnectionlessAckReceiveResources;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckReceiveResources);
		return (u_char *) &StorageTmp->lLCConnectionlessAckReceiveResources;
	case LLCCONNECTIONLESSACKUIRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckUIReceived);
		return (u_char *) &StorageTmp->lLCConnectionlessAckUIReceived;
	case LLCCONNECTIONLESSACKUISENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckUISent);
		return (u_char *) &StorageTmp->lLCConnectionlessAckUISent;
	case LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDReceivedCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDReceivedCommand;
	case LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDReceivedResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDReceivedResponse;
	case LLCCONNECTIONLESSACKXIDSENTCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDSentCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDSentCommand;
	case LLCCONNECTIONLESSACKXIDSENTRESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDSentResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckXIDSentResponse;
	case LLCCONNECTIONLESSACKRETRANSMISSIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckRetransmissions;
	case LLCCONNECTIONLESSACKNORESPONSE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckNoResponse);
		return (u_char *) &StorageTmp->lLCConnectionlessAckNoResponse;
	case LLCCONNECTIONLESSACKCOMMANDIP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandIP);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandIP;
	case LLCCONNECTIONLESSACKCOMMANDIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandIT);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandIT;
	case LLCCONNECTIONLESSACKCOMMANDOK:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandOK);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandOK;
	case LLCCONNECTIONLESSACKCOMMANDPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandPE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandPE;
	case LLCCONNECTIONLESSACKCOMMANDRS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandRS);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandRS;
	case LLCCONNECTIONLESSACKCOMMANDUE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandUE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandUE;
	case LLCCONNECTIONLESSACKCOMMANDUN:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandUN);
		return (u_char *) &StorageTmp->lLCConnectionlessAckCommandUN;
	case LLCCONNECTIONLESSACKRECEIVEDACCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckReceivedACCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckReceivedACCommand;
	case LLCCONNECTIONLESSACKSENTACCOMMAND:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckSentACCommand);
		return (u_char *) &StorageTmp->lLCConnectionlessAckSentACCommand;
	case LLCCONNECTIONLESSACKRESPONSEIP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseIP);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseIP;
	case LLCCONNECTIONLESSACKRESPONSEIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseIT);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseIT;
	case LLCCONNECTIONLESSACKRESPONSENE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseNE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseNE;
	case LLCCONNECTIONLESSACKRESPONSENR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseNR);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseNR;
	case LLCCONNECTIONLESSACKRESPONSEOK:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseOK);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseOK;
	case LLCCONNECTIONLESSACKRESPONSERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseRS);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseRS;
	case LLCCONNECTIONLESSACKRESPONSEUE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseUE);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseUE;
	case LLCCONNECTIONLESSACKRESPONSEUN:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseUN);
		return (u_char *) &StorageTmp->lLCConnectionlessAckResponseUN;
	case LLCCONNECTIONLESSACKVIOLATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckViolation);
		return (u_char *) &StorageTmp->lLCConnectionlessAckViolation;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_lLCConnectionlessAckIVMOTable(): refresh lLCConnectionlessAckIVMOTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionlessAckIVMOTable(void)
{
	if (lLCConnectionlessAckIVMOTable_refresh == 0)
		return;
	lLCConnectionlessAckIVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lLCConnectionlessAckIVMOTable_row(): refresh lLCConnectionlessAckIVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_lLCConnectionlessAckIVMOTable_row(struct lLCConnectionlessAckIVMOTable_data *StorageTmp)
{
	if (StorageTmp->lLCConnectionlessAckIVMOTable_request == sa_request)
		return;
	StorageTmp->lLCConnectionlessAckIVMOTable_request = sa_request;
}

/*
 * var_lLCConnectionlessAckIVMOTable(): locate variables in lLCConnectionlessAckIVMOTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_llcMIB above.
 */
u_char *
var_lLCConnectionlessAckIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("llcMIB", "var_lLCConnectionlessAckIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lLCConnectionlessAckIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_lLCConnectionlessAckIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE:
		*write_method = write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize);
		return (u_char *) &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
	case LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS:
		*write_method = write_lLCConnectionlessAckIVMOMaximumRetransmissions;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions);
		return (u_char *) &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions;
	case LLCCONNECTIONLESSACKIVMOROWSTATUS:
		*write_method = write_lLCConnectionlessAckIVMORowStatus;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMORowStatus);
		return (u_char *) &StorageTmp->lLCConnectionlessAckIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_mACDLELocalSapNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mACDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("llcMIB", "write_mACDLELocalSapNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mACDLETableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLELocalSapNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLELocalSapNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mACDLELocalSapNames;
		old_length = StorageTmp->mACDLELocalSapNamesLen;
		StorageTmp->mACDLELocalSapNames = objid;
		StorageTmp->mACDLELocalSapNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mACDLELocalSapNames = old_value;
		StorageTmp->mACDLELocalSapNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACDLEProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mACDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("llcMIB", "write_mACDLEProviderEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mACDLETableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLEProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLEProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mACDLEProviderEntityNames;
		old_length = StorageTmp->mACDLEProviderEntityNamesLen;
		StorageTmp->mACDLEProviderEntityNames = objid;
		StorageTmp->mACDLEProviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mACDLEProviderEntityNames = old_value;
		StorageTmp->mACDLEProviderEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPSap1Address(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct dLSAPTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_dLSAPSap1Address entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dLSAPTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPSap1Address not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPSap1Address: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dLSAPSap1Address;
		StorageTmp->dLSAPSap1Address = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dLSAPSap1Address = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPUserEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct dLSAPTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("llcMIB", "write_dLSAPUserEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(dLSAPTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPUserEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPUserEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->dLSAPUserEntityNames;
		old_length = StorageTmp->dLSAPUserEntityNamesLen;
		StorageTmp->dLSAPUserEntityNames = objid;
		StorageTmp->dLSAPUserEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dLSAPUserEntityNames = old_value;
		StorageTmp->dLSAPUserEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCDLELocalSapNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct lLCDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCDLELocalSapNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCDLETableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLELocalSapNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLELocalSapNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCDLELocalSapNames;
		old_length = StorageTmp->lLCDLELocalSapNamesLen;
		StorageTmp->lLCDLELocalSapNames = objid;
		StorageTmp->lLCDLELocalSapNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCDLELocalSapNames = old_value;
		StorageTmp->lLCDLELocalSapNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCDLEProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct lLCDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCDLEProviderEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCDLETableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLEProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLEProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCDLEProviderEntityNames;
		old_length = StorageTmp->lLCDLEProviderEntityNamesLen;
		StorageTmp->lLCDLEProviderEntityNames = objid;
		StorageTmp->lLCDLEProviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCDLEProviderEntityNames = old_value;
		StorageTmp->lLCDLEProviderEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationLLCName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCStationLLCName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationLLCName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationLLCName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationLLCName;
		old_length = StorageTmp->lLCStationLLCNameLen;
		StorageTmp->lLCStationLLCName = string;
		StorageTmp->lLCStationLLCNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationLLCName = old_value;
		StorageTmp->lLCStationLLCNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSupportedServicesTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCStationSupportedServicesTypes entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationSupportedServicesTypes;
		old_length = StorageTmp->lLCStationSupportedServicesTypesLen;
		StorageTmp->lLCStationSupportedServicesTypes = string;
		StorageTmp->lLCStationSupportedServicesTypesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationSupportedServicesTypes = old_value;
		StorageTmp->lLCStationSupportedServicesTypesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCStationType1AcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType1AcknowledgeTimeoutValue;
		StorageTmp->lLCStationType1AcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType1AcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType1MaximumRetryCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCStationType1MaximumRetryCount entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1MaximumRetryCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1MaximumRetryCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType1MaximumRetryCount;
		StorageTmp->lLCStationType1MaximumRetryCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType1MaximumRetryCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumPDUN3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCStationMaximumPDUN3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumPDUN3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumPDUN3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationMaximumPDUN3;
		StorageTmp->lLCStationMaximumPDUN3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationMaximumPDUN3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationMaximumRetransmissions4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCStationMaximumRetransmissions4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumRetransmissions4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumRetransmissions4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationMaximumRetransmissions4;
		StorageTmp->lLCStationMaximumRetransmissions4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationMaximumRetransmissions4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationReceiveVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCStationReceiveVariableLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationReceiveVariableLifetime;
		StorageTmp->lLCStationReceiveVariableLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationReceiveVariableLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationTransmitVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCStationTransmitVariableLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationTransmitVariableLifetime;
		StorageTmp->lLCStationTransmitVariableLifetime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationTransmitVariableLifetime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationType3AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCStationType3AcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType3AcknowledgeTimeoutValue;
		StorageTmp->lLCStationType3AcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType3AcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationBufferSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCStationBufferSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationBufferSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationBufferSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationBufferSize;
		StorageTmp->lLCStationBufferSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationBufferSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationSTRIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCStationSTRIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationSTRIndicator;
		old_length = StorageTmp->lLCStationSTRIndicatorLen;
		StorageTmp->lLCStationSTRIndicator = string;
		StorageTmp->lLCStationSTRIndicatorLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationSTRIndicator = old_value;
		StorageTmp->lLCStationSTRIndicatorLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCStationVersionNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCStationVersionNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationVersionNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationVersionNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationVersionNumber;
		StorageTmp->lLCStationVersionNumber = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationVersionNumber = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_rDESetupAgingEnabled entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case RDESETUPAGINGENABLED_TRUE:
		case RDESETUPAGINGENABLED_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupAgingEnabled;
		StorageTmp->rDESetupAgingEnabled = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupAgingEnabled = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupAgingValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_rDESetupAgingValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupAgingValue;
		StorageTmp->rDESetupAgingValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupAgingValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupEnableType2Reset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_rDESetupEnableType2Reset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupEnableType2Reset not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupEnableType2Reset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupEnableType2Reset;
		StorageTmp->rDESetupEnableType2Reset = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupEnableType2Reset = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumRouteDescriptors(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_rDESetupMaximumRouteDescriptors entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumRouteDescriptors not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumRouteDescriptors: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMaximumRouteDescriptors;
		StorageTmp->rDESetupMaximumRouteDescriptors = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMaximumRouteDescriptors = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMaximumResponseTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_rDESetupMaximumResponseTime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMaximumResponseTime;
		StorageTmp->rDESetupMaximumResponseTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMaximumResponseTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupMinimumPDUSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_rDESetupMinimumPDUSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMinimumPDUSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMinimumPDUSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMinimumPDUSize;
		StorageTmp->rDESetupMinimumPDUSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMinimumPDUSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEHold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_rDESetupRDEHold entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case RDESETUPRDEHOLD_TRUE:
		case RDESETUPRDEHOLD_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupRDEHold;
		StorageTmp->rDESetupRDEHold = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupRDEHold = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupRDEReplace(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_rDESetupRDEReplace entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case RDESETUPRDEREPLACE_TRUE:
		case RDESETUPRDEREPLACE_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupRDEReplace;
		StorageTmp->rDESetupRDEReplace = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupRDEReplace = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_rDESetupResetOnTestEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_rDESetupResetOnTestEnabled entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case RDESETUPRESETONTESTENABLED_TRUE:
		case RDESETUPRESETONTESTENABLED_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupResetOnTestEnabled;
		StorageTmp->rDESetupResetOnTestEnabled = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupResetOnTestEnabled = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnectionLessTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCConnectionlessName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionLessTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessName;
		old_length = StorageTmp->lLCConnectionlessNameLen;
		StorageTmp->lLCConnectionlessName = string;
		StorageTmp->lLCConnectionlessNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessName = old_value;
		StorageTmp->lLCConnectionlessNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionLessTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnectionlessMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionLessTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2Name entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2Name;
		old_length = StorageTmp->lLCConnection2NameLen;
		StorageTmp->lLCConnection2Name = string;
		StorageTmp->lLCConnection2NameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2Name = old_value;
		StorageTmp->lLCConnection2NameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2MaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2MaximumRetransmissions;
		StorageTmp->lLCConnection2MaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2MaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedWindowSize;
		StorageTmp->lLCConnection2ReceivedWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SendWindowSize;
		StorageTmp->lLCConnection2SendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2AcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2AcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2BusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2BusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2BusyStateTimeoutValue;
		StorageTmp->lLCConnection2BusyStateTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2BusyStateTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2PBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2PBitTimeoutValue;
		StorageTmp->lLCConnection2PBitTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2PBitTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2RejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2RejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2RejectTimeoutValue;
		StorageTmp->lLCConnection2RejectTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2RejectTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2RemoteBusy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2RemoteBusy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RemoteBusy not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RemoteBusy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2RemoteBusy;
		StorageTmp->lLCConnection2RemoteBusy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2RemoteBusy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2RemoteReset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2RemoteReset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RemoteReset not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RemoteReset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2RemoteReset;
		StorageTmp->lLCConnection2RemoteReset = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2RemoteReset = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2LocalReset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2LocalReset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2LocalReset not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2LocalReset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2LocalReset;
		StorageTmp->lLCConnection2LocalReset = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2LocalReset = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ProviderReset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ProviderReset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ProviderReset not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ProviderReset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ProviderReset;
		StorageTmp->lLCConnection2ProviderReset = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ProviderReset = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Route(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2Route entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Route not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Route: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2Route;
		old_length = StorageTmp->lLCConnection2RouteLen;
		StorageTmp->lLCConnection2Route = string;
		StorageTmp->lLCConnection2RouteLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2Route = old_value;
		StorageTmp->lLCConnection2RouteLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2KStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2KStep entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2KStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2KStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2KStep;
		StorageTmp->lLCConnection2KStep = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2KStep = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2MaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2MaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2MaxSendWindowSize;
		StorageTmp->lLCConnection2MaxSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2MaxSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentAcks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SentAcks entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentAcks not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentAcks: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SentAcks;
		StorageTmp->lLCConnection2SentAcks = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SentAcks = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedAcks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedAcks entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedAcks not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedAcks: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedAcks;
		StorageTmp->lLCConnection2ReceivedAcks = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedAcks = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedFRMR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedFRMR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedFRMR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedFRMR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedFRMR;
		StorageTmp->lLCConnection2ReceivedFRMR = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedFRMR = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentFRMR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SentFRMR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentFRMR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentFRMR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SentFRMR;
		StorageTmp->lLCConnection2SentFRMR = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SentFRMR = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedRR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedRR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedRR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedRR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedRR;
		StorageTmp->lLCConnection2ReceivedRR = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedRR = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentRR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SentRR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentRR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentRR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SentRR;
		StorageTmp->lLCConnection2SentRR = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SentRR = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedRNR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedRNR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedRNR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedRNR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedRNR;
		StorageTmp->lLCConnection2ReceivedRNR = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedRNR = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentRNR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SentRNR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentRNR not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentRNR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SentRNR;
		StorageTmp->lLCConnection2SentRNR = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SentRNR = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedREJ(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedREJ entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedREJ not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedREJ: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedREJ;
		StorageTmp->lLCConnection2ReceivedREJ = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedREJ = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentREJ(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SentREJ entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentREJ not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentREJ: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SentREJ;
		StorageTmp->lLCConnection2SentREJ = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SentREJ = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedSABME(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedSABME entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedSABME not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedSABME: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedSABME;
		StorageTmp->lLCConnection2ReceivedSABME = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedSABME = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentSABME(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SentSABME entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentSABME not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentSABME: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SentSABME;
		StorageTmp->lLCConnection2SentSABME = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SentSABME = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedUA(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedUA entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedUA not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedUA: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedUA;
		StorageTmp->lLCConnection2ReceivedUA = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedUA = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentUA(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SentUA entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentUA not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentUA: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SentUA;
		StorageTmp->lLCConnection2SentUA = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SentUA = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedDISC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedDISC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedDISC not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedDISC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedDISC;
		StorageTmp->lLCConnection2ReceivedDISC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedDISC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentDISC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SentDISC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentDISC not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentDISC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SentDISC;
		StorageTmp->lLCConnection2SentDISC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SentDISC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2ReceivedDM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2ReceivedDM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedDM not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedDM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedDM;
		StorageTmp->lLCConnection2ReceivedDM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedDM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2SentDM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2SentDM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentDM not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SentDM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SentDM;
		StorageTmp->lLCConnection2SentDM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SentDM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PDUsDiscarded1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2PDUsDiscarded1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PDUsDiscarded1 not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PDUsDiscarded1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2PDUsDiscarded1;
		StorageTmp->lLCConnection2PDUsDiscarded1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2PDUsDiscarded1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PDUsDiscarded2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2PDUsDiscarded2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PDUsDiscarded2 not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PDUsDiscarded2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2PDUsDiscarded2;
		StorageTmp->lLCConnection2PDUsDiscarded2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2PDUsDiscarded2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2PDURetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2PDURetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PDURetransmissions not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PDURetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2PDURetransmissions;
		StorageTmp->lLCConnection2PDURetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2PDURetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2OptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2OptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2OPTIONALTOLERATIONIPDUS_TRUE:
		case LLCCONNECTION2OPTIONALTOLERATIONIPDUS_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2OptionalTolerationIPDUs;
		StorageTmp->lLCConnection2OptionalTolerationIPDUs = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2OptionalTolerationIPDUs = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DuplicateIPDUsReceived(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DuplicateIPDUsReceived entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DuplicateIPDUsReceived not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DuplicateIPDUsReceived: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DuplicateIPDUsReceived;
		StorageTmp->lLCConnection2DuplicateIPDUsReceived = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DuplicateIPDUsReceived = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2Violation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2Violation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_COUNTER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Violation not ASN_COUNTER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Violation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2Violation;
		StorageTmp->lLCConnection2Violation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2Violation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2AdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2ADMINISTRATIVESTATE_LOCKED:
		case LLCCONNECTION2ADMINISTRATIVESTATE_UNLOCKED:
		case LLCCONNECTION2ADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AdministrativeState;
		StorageTmp->lLCConnection2AdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2AlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2AlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AlarmStatus;
		old_length = StorageTmp->lLCConnection2AlarmStatusLen;
		StorageTmp->lLCConnection2AlarmStatus = string;
		StorageTmp->lLCConnection2AlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AlarmStatus = old_value;
		StorageTmp->lLCConnection2AlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMOMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaximumRetransmissions not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOMaximumRetransmissions;
		StorageTmp->lLCConnection2IVMOMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMOReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOReceivedWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOReceivedWindowSize;
		StorageTmp->lLCConnection2IVMOReceivedWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOReceivedWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMOSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOSendWindowSize;
		StorageTmp->lLCConnection2IVMOSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMOAcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMOBusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue;
		StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMOBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOBitTimeoutValue;
		StorageTmp->lLCConnection2IVMOBitTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOBitTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMORejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMORejectTimeoutValue;
		StorageTmp->lLCConnection2IVMORejectTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMORejectTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMORoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMORoute entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORoute not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMORoute;
		StorageTmp->lLCConnection2IVMORoute = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMORoute = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMOKStep entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOKStep not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOKStep;
		StorageTmp->lLCConnection2IVMOKStep = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOKStep = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMOMaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaxSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOMaxSendWindowSize;
		StorageTmp->lLCConnection2IVMOMaxSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOMaxSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2IVMOOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2IVMOOptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS_TRUE:
		case LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs;
		StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnectionlessAckMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnectionlessAckMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckReceiveResources(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnectionlessAckReceiveResources entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTIONLESSACKRECEIVERESOURCES_TRUE:
		case LLCCONNECTIONLESSACKRECEIVERESOURCES_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckReceiveResources;
		StorageTmp->lLCConnectionlessAckReceiveResources = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckReceiveResources = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnectionlessAckIVMOMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[sizeof(llcMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultMaximumRetransmissions;
		StorageTmp->lLCConnection2DefaultMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultReceivedWindowSize;
		StorageTmp->lLCConnection2DefaultReceivedWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultReceivedWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultSendWindowSize;
		StorageTmp->lLCConnection2DefaultSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultAcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultBusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue;
		StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultPBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultPBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultPBitTimeoutValue;
		StorageTmp->lLCConnection2DefaultPBitTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultPBitTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultRejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultRejectTimeoutValue;
		StorageTmp->lLCConnection2DefaultRejectTimeoutValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultRejectTimeoutValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultRoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct llcMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultRoute entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRoute not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultRoute;
		old_length = StorageTmp->lLCConnection2DefaultRouteLen;
		StorageTmp->lLCConnection2DefaultRoute = string;
		StorageTmp->lLCConnection2DefaultRouteLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultRoute = old_value;
		StorageTmp->lLCConnection2DefaultRouteLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultKStep entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultKStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultKStep;
		StorageTmp->lLCConnection2DefaultKStep = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultKStep = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultMaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultMaxSendWindowSize;
		StorageTmp->lLCConnection2DefaultMaxSendWindowSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultMaxSendWindowSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnection2DefaultOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnection2DefaultOptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS_TRUE:
		case LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs;
		StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckDefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct llcMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("llcMIB", "write_lLCConnectionlessAckDefaultMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = llcMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mACDLETable_data *StorageTmp = NULL;
	static struct mACDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mACDLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mACDLETableStorage, NULL, &name[sizeof(mACDLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mACDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mACDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mACDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mACDLECommunicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mACDLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mACDLETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mACDLECommunicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->mACDLECommunicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mACDLERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mACDLETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mACDLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mACDLERowStatus;
			StorageTmp->mACDLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mACDLETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mACDLETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mACDLETableStorage, StorageNew);
			header_complex_extract_entry(&mACDLETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mACDLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mACDLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mACDLETable_del(&StorageDel);
			/* mACDLETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mACRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mACTable_data *StorageTmp = NULL;
	static struct mACTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mACTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mACTableStorage, NULL, &name[sizeof(mACTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mACRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mACTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mACTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mACDLECommunicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* mACId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(mACTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mACTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mACDLECommunicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->mACDLECommunicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mACId, vp->val.string, vp->val_len);
			StorageNew->mACIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mACRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mACTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mACTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mACRowStatus;
			StorageTmp->mACRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mACTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mACTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mACTableStorage, StorageNew);
			header_complex_extract_entry(&mACTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mACRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mACTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mACRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mACTable_del(&StorageDel);
			/* mACTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dLSAPTable_data *StorageTmp = NULL;
	static struct dLSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(dLSAPTableStorage, NULL, &name[sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dLSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dLSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dLSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mACDLECommunicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* dLSAPSapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(dLSAPTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->mACDLECommunicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->mACDLECommunicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->dLSAPSapId, vp->val.string, vp->val_len);
			StorageNew->dLSAPSapIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->dLSAPUserEntityNames = zeroDotZero; */
			StorageNew->dLSAPRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			dLSAPTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			dLSAPTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dLSAPRowStatus;
			StorageTmp->dLSAPRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(dLSAPTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&dLSAPTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(dLSAPTableStorage, StorageNew);
			header_complex_extract_entry(&dLSAPTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dLSAPRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			dLSAPTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dLSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->dLSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dLSAPTable_del(&StorageDel);
			/* dLSAPTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCDLETable_data *StorageTmp = NULL;
	static struct lLCDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCDLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(lLCDLETableStorage, NULL, &name[sizeof(lLCDLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* lLCDLECommunicationsEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCDLETable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(lLCDLETable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->lLCDLECommunicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->lLCDLECommunicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->lLCDLERowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCDLETable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCDLETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCDLERowStatus;
			StorageTmp->lLCDLERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(lLCDLETableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&lLCDLETableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lLCDLETableStorage, StorageNew);
			header_complex_extract_entry(&lLCDLETableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCDLERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCDLETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCDLETable_del(&StorageDel);
			/* lLCDLETable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCLPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCCLPMTable_data *StorageTmp = NULL;
	static struct lLCCLPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCCLPMTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(lLCCLPMTableStorage, NULL, &name[sizeof(lLCCLPMTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCLPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCCLPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCCLPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCCLPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			if (header_complex_parse_oid(&(name[sizeof(lLCCLPMTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(lLCCLPMTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->lLCCLPMRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCCLPMTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCCLPMTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCCLPMRowStatus;
			StorageTmp->lLCCLPMRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(lLCCLPMTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&lLCCLPMTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lLCCLPMTableStorage, StorageNew);
			header_complex_extract_entry(&lLCCLPMTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCCLPMRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCCLPMTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCLPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCLPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCCLPMTable_del(&StorageDel);
			/* lLCCLPMTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCCOPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCCOPMTable_data *StorageTmp = NULL;
	static struct lLCCOPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCCOPMTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(lLCCOPMTableStorage, NULL, &name[sizeof(lLCCOPMTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCOPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCCOPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCCOPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCCOPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			if (header_complex_parse_oid(&(name[sizeof(lLCCOPMTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(lLCCOPMTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->lLCCOPMRowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCCOPMTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCCOPMTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCCOPMRowStatus;
			StorageTmp->lLCCOPMRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(lLCCOPMTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&lLCCOPMTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lLCCOPMTableStorage, StorageNew);
			header_complex_extract_entry(&lLCCOPMTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCCOPMRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCCOPMTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCOPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCCOPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCCOPMTable_del(&StorageDel);
			/* lLCCOPMTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lLCConnectionlessAckIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	static struct lLCConnectionlessAckIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lLCConnectionlessAckIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[sizeof(lLCConnectionlessAckIVMOTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCConnectionlessAckIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCConnectionlessAckIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCConnectionlessAckIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* lLCConnectionlessAckIVMOName */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(lLCConnectionlessAckIVMOTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionlessAckIVMOTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->lLCConnectionlessAckIVMOName, vp->val.string, vp->val_len);
			StorageNew->lLCConnectionlessAckIVMONameLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->lLCConnectionlessAckIVMORowStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			lLCConnectionlessAckIVMOTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			lLCConnectionlessAckIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCConnectionlessAckIVMORowStatus;
			StorageTmp->lLCConnectionlessAckIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(lLCConnectionlessAckIVMOTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&lLCConnectionlessAckIVMOTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lLCConnectionlessAckIVMOTableStorage, StorageNew);
			header_complex_extract_entry(&lLCConnectionlessAckIVMOTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			lLCConnectionlessAckIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCConnectionlessAckIVMOTable_del(&StorageDel);
			/* lLCConnectionlessAckIVMOTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
