/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "lapbMIB_storage.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int lapbMIB_refresh = 1;
volatile int lAPBDLETable_refresh = 1;
volatile int dLSAPTable_refresh = 1;
volatile int sLPPMTable_refresh = 1;
volatile int sLPConnectionTable_refresh = 1;
volatile int sLPConnectionIVMOTable_refresh = 1;

/*
 * lapbMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid lapbMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 22 };
oid lAPBDLETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 22, 1, 1, 1, 1, 1 };
oid dLSAPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 22, 1, 1, 2, 1, 1 };
oid sLPPMTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 22, 1, 1, 3, 1, 1 };
oid sLPConnectionTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 22, 1, 1, 4, 1, 1 };
oid sLPConnectionIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 22, 1, 1, 5, 1, 1 };

/*
 * variable7 lapbMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the lapbMIB mib section
 */
struct variable7 lapbMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   LAPBDLELOCALSAPNAMES  (4 % 256)
	{LAPBDLELOCALSAPNAMES, ASN_OBJECT_ID, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 2}},
#define   LAPBDLEOPERATIONALSTATE  (5 % 256)
	{LAPBDLEOPERATIONALSTATE, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 3}},
#define   LAPBDLEPROVIDERENTITYNAMES  (6 % 256)
	{LAPBDLEPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_lAPBDLETable, 6,
	 {1, 1, 1, 1, 1, 4}},
#define   LAPBDLEMT1TIMER       (7 % 256)
	{LAPBDLEMT1TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 5}},
#define   LAPBDLEMT3TIMER       (8 % 256)
	{LAPBDLEMT3TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 6}},
#define   LAPBDLEMW             (9 % 256)
	{LAPBDLEMW, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 7}},
#define   LAPBDLEMXSEND         (10 % 256)
	{LAPBDLEMXSEND, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 8}},
#define   LAPBDLEMXRECEIVE      (11 % 256)
	{LAPBDLEMXRECEIVE, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 9}},
#define   LAPBDLEMT2TIMER       (12 % 256)
	{LAPBDLEMT2TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 10}},
#define   LAPBDLERECEIVEDMLPRESETS  (13 % 256)
	{LAPBDLERECEIVEDMLPRESETS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 11}},
#define   LAPBDLETIMESMT1EXPIRED  (14 % 256)
	{LAPBDLETIMESMT1EXPIRED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 12}},
#define   LAPBDLEIFRAMESREASSIGNMENTS  (15 % 256)
	{LAPBDLEIFRAMESREASSIGNMENTS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 13}},
#define   LAPBDLEMLPFRAMESRECEIVED  (16 % 256)
	{LAPBDLEMLPFRAMESRECEIVED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 14}},
#define   LAPBDLEMLPFRAMESSENT  (17 % 256)
	{LAPBDLEMLPFRAMESSENT, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 15}},
#define   LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD  (18 % 256)
	{LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD, ASN_COUNTER, RONLY, var_lAPBDLETable, 6,
	 {1, 1, 1, 1, 1, 16}},
#define   LAPBDLERECEIVEDMLPFRAMESINGUARDREGION  (19 % 256)
	{LAPBDLERECEIVEDMLPFRAMESINGUARDREGION, ASN_COUNTER, RONLY, var_lAPBDLETable, 6,
	 {1, 1, 1, 1, 1, 17}},
#define   LAPBDLEROWSTATUS      (20 % 256)
	{LAPBDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 1, 1, 1, 18}},
#define   DLSAPSAP1ADDRESS      (25 % 256)
	{DLSAPSAP1ADDRESS, ASN_UNSIGNED, RONLY, var_dLSAPTable, 6, {1, 1, 2, 1, 1, 2}},
#define   DLSAPUSERENTITYNAMES  (26 % 256)
	{DLSAPUSERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_dLSAPTable, 6, {1, 1, 2, 1, 1, 3}},
#define   DLSAPROWSTATUS        (27 % 256)
	{DLSAPROWSTATUS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 2, 1, 1, 4}},
#define   SLPPMOPERATIONALSTATE  (32 % 256)
	{SLPPMOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sLPPMTable, 6, {1, 1, 3, 1, 1, 2}},
#define   SLPPMADMINISTRATIVESTATE  (33 % 256)
	{SLPPMADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 3, 1, 1, 3}},
#define   SLPPMROWSTATUS        (34 % 256)
	{SLPPMROWSTATUS, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 3, 1, 1, 4}},
#define   SLPCONNECTIONUNDERLYINGCONNECTIONNAMES  (38 % 256)
	{SLPCONNECTIONUNDERLYINGCONNECTIONNAMES, ASN_OBJECT_ID, RWRITE, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 2}},
#define   SLPCONNECTIONSUPPORTEDCONNECTIONNAMES  (39 % 256)
	{SLPCONNECTIONSUPPORTEDCONNECTIONNAMES, ASN_OBJECT_ID, RWRITE, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 3}},
#define   SLPCONNECTIONINTERFACETYPE  (40 % 256)
	{SLPCONNECTIONINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 4}},
#define   SLPCONNECTIONK        (41 % 256)
	{SLPCONNECTIONK, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 5}},
#define   SLPCONNECTIONN1       (42 % 256)
	{SLPCONNECTIONN1, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 6}},
#define   SLPCONNECTIONN2       (43 % 256)
	{SLPCONNECTIONN2, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 7}},
#define   SLPCONNECTIONSEQUENCEMODULUS  (44 % 256)
	{SLPCONNECTIONSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 8}},
#define   SLPCONNECTIONT1TIMER  (45 % 256)
	{SLPCONNECTIONT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 9}},
#define   SLPCONNECTIONT2TIMER  (46 % 256)
	{SLPCONNECTIONT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 10}},
#define   SLPCONNECTIONFCSERRORSRECEIVED  (47 % 256)
	{SLPCONNECTIONFCSERRORSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 11}},
#define   SLPCONNECTIONFRMRSRECEIVED  (48 % 256)
	{SLPCONNECTIONFRMRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 12}},
#define   SLPCONNECTIONFRMRSSENT  (49 % 256)
	{SLPCONNECTIONFRMRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 13}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED  (50 % 256)
	{SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 14}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSSENT  (51 % 256)
	{SLPCONNECTIONIFRAMEDATAOCTETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 15}},
#define   SLPCONNECTIONIFRAMESRECEIVED  (52 % 256)
	{SLPCONNECTIONIFRAMESRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 16}},
#define   SLPCONNECTIONIFRAMESSENT  (53 % 256)
	{SLPCONNECTIONIFRAMESSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 17}},
#define   SLPCONNECTIONPOLLSRECEIVED  (54 % 256)
	{SLPCONNECTIONPOLLSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 18}},
#define   SLPCONNECTIONREJSRECEIVED  (55 % 256)
	{SLPCONNECTIONREJSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 19}},
#define   SLPCONNECTIONREJSSENT  (56 % 256)
	{SLPCONNECTIONREJSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 20}},
#define   SLPCONNECTIONRNRSRECEIVED  (57 % 256)
	{SLPCONNECTIONRNRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 21}},
#define   SLPCONNECTIONRNRSSENT  (58 % 256)
	{SLPCONNECTIONRNRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 22}},
#define   SLPCONNECTIONSABMSRECEIVED  (59 % 256)
	{SLPCONNECTIONSABMSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 23}},
#define   SLPCONNECTIONSABMSSENT  (60 % 256)
	{SLPCONNECTIONSABMSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 24}},
#define   SLPCONNECTIONPROTOCOLSTATE  (61 % 256)
	{SLPCONNECTIONPROTOCOLSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 25}},
#define   SLPCONNECTIONTIMEST1EXPIRED  (62 % 256)
	{SLPCONNECTIONTIMEST1EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 26}},
#define   SLPCONNECTIONT3TIMER  (63 % 256)
	{SLPCONNECTIONT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 27}},
#define   SLPCONNECTIONTIMEST3EXPIRED  (64 % 256)
	{SLPCONNECTIONTIMEST3EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 28}},
#define   SLPCONNECTIONT4TIMER  (65 % 256)
	{SLPCONNECTIONT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 4, 1, 1, 29}},
#define   SLPCONNECTIONTIMEST4EXPIRED  (66 % 256)
	{SLPCONNECTIONTIMEST4EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 30}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED  (67 % 256)
	{SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable,
	 6, {1, 1, 4, 1, 1, 31}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSSENT  (68 % 256)
	{SLPCONNECTIONABNORMALLINKDISCONNECTSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 32}},
#define   SLPCONNECTIONLINKRESETSRECEIVED  (69 % 256)
	{SLPCONNECTIONLINKRESETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 33}},
#define   SLPCONNECTIONLINKRESETSSENT  (70 % 256)
	{SLPCONNECTIONLINKRESETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 34}},
#define   SLPCONNECTIONTIMESN2REACHED  (71 % 256)
	{SLPCONNECTIONTIMESN2REACHED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 35}},
#define   SLPCONNECTIONADMINISTRATIVESTATE  (72 % 256)
	{SLPCONNECTIONADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 36}},
#define   SLPCONNECTIONOPERATIONALSTATE  (73 % 256)
	{SLPCONNECTIONOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 37}},
#define   SLPCONNECTIONUSAGESTATE  (74 % 256)
	{SLPCONNECTIONUSAGESTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 38}},
#define   SLPCONNECTIONPROCEDURALSTATUS  (75 % 256)
	{SLPCONNECTIONPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 39}},
#define   SLPCONNECTIONALARMSTATUS  (76 % 256)
	{SLPCONNECTIONALARMSTATUS, ASN_BIT_STR, RONLY, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 40}},
#define   SLPCONNECTIONROWSTATUS  (77 % 256)
	{SLPCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6,
	 {1, 1, 4, 1, 1, 41}},
#define   SLPCONNECTIONIVMOID   (81 % 256)
	{SLPCONNECTIONIVMOID, ASN_OCTET_STR, RONLY, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 1}},
#define   SLPCONNECTIONIVMOINTERFACETYPE  (82 % 256)
	{SLPCONNECTIONIVMOINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 2}},
#define   SLPCONNECTIONIVMOK    (83 % 256)
	{SLPCONNECTIONIVMOK, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 3}},
#define   SLPCONNECTIONIVMON1   (84 % 256)
	{SLPCONNECTIONIVMON1, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 4}},
#define   SLPCONNECTIONIVMON2   (85 % 256)
	{SLPCONNECTIONIVMON2, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 5}},
#define   SLPCONNECTIONIVMOSEQUENCEMODULUS  (86 % 256)
	{SLPCONNECTIONIVMOSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 6}},
#define   SLPCONNECTIONIVMOT1TIMER  (87 % 256)
	{SLPCONNECTIONIVMOT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 7}},
#define   SLPCONNECTIONIVMOT2TIMER  (88 % 256)
	{SLPCONNECTIONIVMOT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 8}},
#define   SLPCONNECTIONIVMOT3TIMER  (89 % 256)
	{SLPCONNECTIONIVMOT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 9}},
#define   SLPCONNECTIONIVMOT4TIMER  (90 % 256)
	{SLPCONNECTIONIVMOT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 10}},
#define   SLPCONNECTIONIVMOROWSTATUS  (91 % 256)
	{SLPCONNECTIONIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6,
	 {1, 1, 5, 1, 1, 11}},
#define   LAPBDISCONTINUITYTIME  (92 % 256)
	{LAPBDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_lapbMIB, 4, {1, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTINTERFACETYPE  (93 % 256)
	{SLPCONNECTIONDEFAULTINTERFACETYPE, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTK  (94 % 256)
	{SLPCONNECTIONDEFAULTK, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 2}},
#define   SLPCONNECTIONDEFAULTN1  (95 % 256)
	{SLPCONNECTIONDEFAULTN1, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 3}},
#define   SLPCONNECTIONDEFAULTN2  (96 % 256)
	{SLPCONNECTIONDEFAULTN2, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 4}},
#define   SLPCONNECTIONDEFAULTSEQUENCEMODULUS  (97 % 256)
	{SLPCONNECTIONDEFAULTSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 5}},
#define   SLPCONNECTIONDEFAULTT1TIMER  (98 % 256)
	{SLPCONNECTIONDEFAULTT1TIMER, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 6}},
#define   SLPCONNECTIONDEFAULTT2TIMER  (99 % 256)
	{SLPCONNECTIONDEFAULTT2TIMER, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 7}},
#define   SLPCONNECTIONDEFAULTT3TIMER  (100 % 256)
	{SLPCONNECTIONDEFAULTT3TIMER, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 8}},
#define   SLPCONNECTIONDEFAULTT4TIMER  (101 % 256)
	{SLPCONNECTIONDEFAULTT4TIMER, ASN_INTEGER, RWRITE, var_lapbMIB, 5, {1, 2, 2, 1, 9}},

};

/*    (L = length of the oidsuffix) */
struct lapbMIB_data *lapbMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *lAPBDLETableStorage = NULL;
struct header_complex_index *dLSAPTableStorage = NULL;
struct header_complex_index *sLPPMTableStorage = NULL;
struct header_complex_index *sLPConnectionTableStorage = NULL;
struct header_complex_index *sLPConnectionIVMOTableStorage = NULL;

/*
 * init_lapbMIB():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_lapbMIB(void)
{
	DEBUGMSGTL(("lapbMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("lapbMIB", lapbMIB_variables, variable7, lapbMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_lapbMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("lapbMIB", parse_lapbMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("lAPBDLETable", parse_lAPBDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("dLSAPTable", parse_dLSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPPMTable", parse_sLPPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPConnectionTable", parse_sLPConnectionTable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("sLPConnectionIVMOTable", parse_sLPConnectionIVMOTable, NULL,
				      "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lapbMIB,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lAPBDLETable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dLSAPTable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPPMTable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_sLPConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_sLPConnectionIVMOTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("lapbMIB", "done.\n"));
}

/*
 * deinit_lapbMIB():
 *   Deinitialization routine.  This is called before the agent is unloaded.
 *   At a minimum, deregistration of your variables should take place here.
 */
void
deinit_lapbMIB(void)
{
	DEBUGMSGTL(("lapbMIB", "deinitializating...  "));
	unregister_mib(lapbMIB_variables_oid, sizeof(lapbMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("lapbMIB");
	snmpd_unregister_config_handler("lAPBDLETable");
	snmpd_unregister_config_handler("dLSAPTable");
	snmpd_unregister_config_handler("sLPPMTable");
	snmpd_unregister_config_handler("sLPConnectionTable");
	snmpd_unregister_config_handler("sLPConnectionIVMOTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("lapbMIB", "done.\n"));
}

int
term_lapbMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_lapbMIB();
	return 0;
}

/*
 * lapbMIB_add(): adds a structure node for scalars
 */
int
lapbMIB_add(struct lapbMIB_data *thedata)
{
	DEBUGMSGTL(("lapbMIB", "adding data...  "));
	lapbMIBStorage = thedata;
	DEBUGMSGTL(("lapbMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lapbMIB():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_lapbMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct lapbMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(lapbMIB_data);

	DEBUGMSGTL(("lapbMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line =
	    read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->lapbDiscontinuityTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultInterfaceType,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultK, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultN1, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultN2, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->sLPConnectionDefaultSequenceModulus, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT1Timer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT2Timer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT3Timer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT4Timer,
				  &tmpsize);

	lapbMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lapbMIB", "done.\n"));
}

/*
 * store_lapbMIB():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_lapbMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lapbMIB_data *StorageTmp;

	DEBUGMSGTL(("lapbMIB", "storing data...  "));
	refresh_lapbMIB();
	if ((StorageTmp = lapbMIBStorage) == NULL) {
		DEBUGMSGTL(("lapbMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->lapbMIBStorageType == ST_NONVOLATILE) { */
	memset(line, 0, sizeof(line));
	strcat(line, "lapbMIB ");
	cptr = line + strlen(line);
	cptr =
	    read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->lapbDiscontinuityTime,
				   &tmpsize);
	cptr =
	    read_config_store_data(ASN_INTEGER, cptr,
				   &StorageTmp->sLPConnectionDefaultInterfaceType, &tmpsize);
	cptr =
	    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultK, &tmpsize);
	cptr =
	    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultN1,
				   &tmpsize);
	cptr =
	    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultN2,
				   &tmpsize);
	cptr =
	    read_config_store_data(ASN_INTEGER, cptr,
				   &StorageTmp->sLPConnectionDefaultSequenceModulus, &tmpsize);
	cptr =
	    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT1Timer,
				   &tmpsize);
	cptr =
	    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT2Timer,
				   &tmpsize);
	cptr =
	    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT3Timer,
				   &tmpsize);
	cptr =
	    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT4Timer,
				   &tmpsize);

	snmpd_store_config(line);
	/* } */
	DEBUGMSGTL(("lapbMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_lapbMIB: refresh lapbMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread scalars and tables from the STREAMS susbystem.  This function
 * is used when the agent starts for the first time, or after a SIGPOLL
 * has been received (and a scalar has been requested).
 */
void
refresh_lapbMIB(void)
{
	if (lapbMIBStorage == NULL) {
		struct lapbMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(lapbMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		StorageNew->sLPConnectionDefaultInterfaceType = dTE(0);

		lapbMIBStorage = StorageNew;
		lapbMIB_refresh = 1;
	}
	if (lapbMIB_refresh == 0)
		return;
	lapbMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_lapbMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
uint8_t *
var_lapbMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
	    WriteMethod ** write_method)
{
	struct lapbMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_lapbMIB();
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case LAPBDISCONTINUITYTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lapbDiscontinuityTime);
		return (uint8_t *) &StorageTmp->lapbDiscontinuityTime;
	case SLPCONNECTIONDEFAULTINTERFACETYPE:
		*write_method = write_sLPConnectionDefaultInterfaceType;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultInterfaceType);
		return (uint8_t *) &StorageTmp->sLPConnectionDefaultInterfaceType;
	case SLPCONNECTIONDEFAULTK:
		*write_method = write_sLPConnectionDefaultK;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultK);
		return (uint8_t *) &StorageTmp->sLPConnectionDefaultK;
	case SLPCONNECTIONDEFAULTN1:
		*write_method = write_sLPConnectionDefaultN1;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultN1);
		return (uint8_t *) &StorageTmp->sLPConnectionDefaultN1;
	case SLPCONNECTIONDEFAULTN2:
		*write_method = write_sLPConnectionDefaultN2;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultN2);
		return (uint8_t *) &StorageTmp->sLPConnectionDefaultN2;
	case SLPCONNECTIONDEFAULTSEQUENCEMODULUS:
		*write_method = write_sLPConnectionDefaultSequenceModulus;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultSequenceModulus);
		return (uint8_t *) &StorageTmp->sLPConnectionDefaultSequenceModulus;
	case SLPCONNECTIONDEFAULTT1TIMER:
		*write_method = write_sLPConnectionDefaultT1Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT1Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionDefaultT1Timer;
	case SLPCONNECTIONDEFAULTT2TIMER:
		*write_method = write_sLPConnectionDefaultT2Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT2Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionDefaultT2Timer;
	case SLPCONNECTIONDEFAULTT3TIMER:
		*write_method = write_sLPConnectionDefaultT3Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT3Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionDefaultT3Timer;
	case SLPCONNECTIONDEFAULTT4TIMER:
		*write_method = write_sLPConnectionDefaultT4Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT4Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionDefaultT4Timer;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * lAPBDLETable_add(): adds a structure node to our data set
 */
int
lAPBDLETable_add(struct lAPBDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lAPBDLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* lAPBDLEcommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR,
				  (uint8_t *) thedata->lAPBDLEcommunicationsEntityId,
				  thedata->lAPBDLEcommunicationsEntityIdLen);

	header_complex_add_data(&lAPBDLETableStorage, vars, thedata);
	DEBUGMSGTL(("lAPBDLETable", "registered an entry\n"));
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_lAPBDLETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_lAPBDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct lAPBDLETable_data *StorageTmp = SNMP_MALLOC_STRUCT(lAPBDLETable_data);

	DEBUGMSGTL(("lAPBDLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lAPBDLEcommunicationsEntityId,
				  &tmpsize);
	StorageTmp->lAPBDLEcommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->lAPBDLEcommunicationsEntityId == NULL) {
		config_perror("invalid specification for lAPBDLEcommunicationsEntityId");
		return;
	}

	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->lAPBDLElocalSapNames, &tmpsize);
	StorageTmp->lAPBDLElocalSapNamesLen = tmpsize;
	if (StorageTmp->lAPBDLElocalSapNames == NULL) {
		config_perror("invalid specification for lAPBDLElocalSapNames");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEoperationalState,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->lAPBDLEproviderEntityNames,
				  &tmpsize);
	StorageTmp->lAPBDLEproviderEntityNamesLen = tmpsize;
	if (StorageTmp->lAPBDLEproviderEntityNames == NULL) {
		config_perror("invalid specification for lAPBDLEproviderEntityNames");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmW, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmXSend, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmXReceive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT2Timer, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEreceivedMlpResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEtimesMT1Expired, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEIframesReassignments,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line,
				  &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line,
				  &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLERowStatus, &tmpsize);

	lAPBDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
}

/*
 * store_lAPBDLETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_lAPBDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lAPBDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lAPBDLETable", "storing data...  "));
	refresh_lAPBDLETable();
	(void) tmpsize;
	for (hcindex = lAPBDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lAPBDLETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->lAPBDLETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "lAPBDLETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->lAPBDLEcommunicationsEntityIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->lAPBDLEcommunicationsEntityId, &tmpsize);
		tmpsize = StorageTmp->lAPBDLElocalSapNamesLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->lAPBDLElocalSapNames,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEoperationalState,
					   &tmpsize);
		tmpsize = StorageTmp->lAPBDLEproviderEntityNamesLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr,
					   &StorageTmp->lAPBDLEproviderEntityNames, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT1Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT3Timer,
					   &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmW, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmXSend, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmXReceive,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT2Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEreceivedMlpResets,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEtimesMT1Expired,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->lAPBDLEIframesReassignments, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("lAPBDLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * dLSAPTable_add(): adds a structure node to our data set
 */
int
dLSAPTable_add(struct dLSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dLSAPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* lAPBDLEcommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR,
				  (uint8_t *) thedata->lAPBDLEcommunicationsEntityId,
				  thedata->lAPBDLEcommunicationsEntityIdLen);
	/* dLSAPsapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->dLSAPsapId,
				  thedata->dLSAPsapIdLen);

	header_complex_add_data(&dLSAPTableStorage, vars, thedata);
	DEBUGMSGTL(("dLSAPTable", "registered an entry\n"));
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_dLSAPTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_dLSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp = SNMP_MALLOC_STRUCT(dLSAPTable_data);

	DEBUGMSGTL(("dLSAPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lAPBDLEcommunicationsEntityId,
				  &tmpsize);
	StorageTmp->lAPBDLEcommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->lAPBDLEcommunicationsEntityId == NULL) {
		config_perror("invalid specification for lAPBDLEcommunicationsEntityId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dLSAPsapId, &tmpsize);
	StorageTmp->dLSAPsapIdLen = tmpsize;
	if (StorageTmp->dLSAPsapId == NULL) {
		config_perror("invalid specification for dLSAPsapId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dLSAPsap1Address, &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->dLSAPuserEntityNames, &tmpsize);
	StorageTmp->dLSAPuserEntityNamesLen = tmpsize;
	if (StorageTmp->dLSAPuserEntityNames == NULL) {
		config_perror("invalid specification for dLSAPuserEntityNames");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dLSAPRowStatus, &tmpsize);

	dLSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
}

/*
 * store_dLSAPTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_dLSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dLSAPTable", "storing data...  "));
	refresh_dLSAPTable();
	(void) tmpsize;
	for (hcindex = dLSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dLSAPTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->dLSAPTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "dLSAPTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->lAPBDLEcommunicationsEntityIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->lAPBDLEcommunicationsEntityId, &tmpsize);
		tmpsize = StorageTmp->dLSAPsapIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dLSAPsapId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dLSAPsap1Address,
					   &tmpsize);
		tmpsize = StorageTmp->dLSAPuserEntityNamesLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->dLSAPuserEntityNames,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dLSAPRowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("dLSAPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sLPPMTable_add(): adds a structure node to our data set
 */
int
sLPPMTable_add(struct sLPPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sLPPMTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* lAPBDLEcommunicationsEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR,
				  (uint8_t *) thedata->lAPBDLEcommunicationsEntityId,
				  thedata->lAPBDLEcommunicationsEntityIdLen);
	/* sLPPMcoProtocolMachineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR,
				  (uint8_t *) thedata->sLPPMcoProtocolMachineId,
				  thedata->sLPPMcoProtocolMachineIdLen);

	header_complex_add_data(&sLPPMTableStorage, vars, thedata);
	DEBUGMSGTL(("sLPPMTable", "registered an entry\n"));
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sLPPMTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sLPPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPPMTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sLPPMTable_data);

	DEBUGMSGTL(("sLPPMTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lAPBDLEcommunicationsEntityId,
				  &tmpsize);
	StorageTmp->lAPBDLEcommunicationsEntityIdLen = tmpsize;
	if (StorageTmp->lAPBDLEcommunicationsEntityId == NULL) {
		config_perror("invalid specification for lAPBDLEcommunicationsEntityId");
		return;
	}

	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sLPPMcoProtocolMachineId,
				  &tmpsize);
	StorageTmp->sLPPMcoProtocolMachineIdLen = tmpsize;
	if (StorageTmp->sLPPMcoProtocolMachineId == NULL) {
		config_perror("invalid specification for sLPPMcoProtocolMachineId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPPMoperationalState, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPPMadministrativeState,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPPMRowStatus, &tmpsize);

	sLPPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
}

/*
 * store_sLPPMTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sLPPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sLPPMTable", "storing data...  "));
	refresh_sLPPMTable();
	(void) tmpsize;
	for (hcindex = sLPPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPPMTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sLPPMTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sLPPMTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->lAPBDLEcommunicationsEntityIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->lAPBDLEcommunicationsEntityId, &tmpsize);
		tmpsize = StorageTmp->sLPPMcoProtocolMachineIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->sLPPMcoProtocolMachineId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPPMoperationalState,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPPMadministrativeState,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPPMRowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sLPPMTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sLPConnectionTable_add(): adds a structure node to our data set
 */
int
sLPConnectionTable_add(struct sLPConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sLPConnectionTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sLPConnectionConnectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR,
				  (uint8_t *) thedata->sLPConnectionConnectionId,
				  thedata->sLPConnectionConnectionIdLen);

	header_complex_add_data(&sLPConnectionTableStorage, vars, thedata);
	DEBUGMSGTL(("sLPConnectionTable", "registered an entry\n"));
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sLPConnectionTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sLPConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPConnectionTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sLPConnectionTable_data);

	DEBUGMSGTL(("sLPConnectionTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sLPConnectionConnectionId,
				  &tmpsize);
	StorageTmp->sLPConnectionConnectionIdLen = tmpsize;
	if (StorageTmp->sLPConnectionConnectionId == NULL) {
		config_perror("invalid specification for sLPConnectionConnectionId");
		return;
	}

	line =
	    read_config_read_data(ASN_OBJECT_ID, line,
				  &StorageTmp->sLPConnectionUnderlyingConnectionNames, &tmpsize);
	StorageTmp->sLPConnectionUnderlyingConnectionNamesLen = tmpsize;
	if (StorageTmp->sLPConnectionUnderlyingConnectionNames == NULL) {
		config_perror("invalid specification for sLPConnectionUnderlyingConnectionNames");
		return;
	}

	line =
	    read_config_read_data(ASN_OBJECT_ID, line,
				  &StorageTmp->sLPConnectionSupportedConnectionNames, &tmpsize);
	StorageTmp->sLPConnectionSupportedConnectionNamesLen = tmpsize;
	if (StorageTmp->sLPConnectionSupportedConnectionNames == NULL) {
		config_perror("invalid specification for sLPConnectionSupportedConnectionNames");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionInterfaceType,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionK, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionN2, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionSequenceModulus,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT1Timer, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT2Timer, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFCSErrorsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFRMRsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFRMRsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line,
				  &StorageTmp->sLPConnectionIFrameDataOctetsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFrameDataOctetsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFramesReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFramesSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionPollsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionREJsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionREJsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionRNRsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionRNRsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionSABMsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionSABMsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionProtocolState,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT1Expired,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT3Timer, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT3Expired,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT4Timer, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT4Expired,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line,
				  &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line,
				  &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionLinkResetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionLinkResetsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesN2Reached,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionAdministrativeState,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionOperationalState,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionUsageState,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sLPConnectionProceduralStatus,
				  &tmpsize);
	StorageTmp->sLPConnectionProceduralStatusLen = tmpsize;
	if (StorageTmp->sLPConnectionProceduralStatus == NULL) {
		config_perror("invalid specification for sLPConnectionProceduralStatus");
		return;
	}

	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sLPConnectionAlarmStatus,
				  &tmpsize);
	StorageTmp->sLPConnectionAlarmStatusLen = tmpsize;
	if (StorageTmp->sLPConnectionAlarmStatus == NULL) {
		config_perror("invalid specification for sLPConnectionAlarmStatus");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionRowStatus, &tmpsize);

	sLPConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
}

/*
 * store_sLPConnectionTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sLPConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sLPConnectionTable", "storing data...  "));
	refresh_sLPConnectionTable();
	(void) tmpsize;
	for (hcindex = sLPConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPConnectionTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sLPConnectionTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sLPConnectionTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->sLPConnectionConnectionIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->sLPConnectionConnectionId, &tmpsize);
		tmpsize = StorageTmp->sLPConnectionUnderlyingConnectionNamesLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr,
					   &StorageTmp->sLPConnectionUnderlyingConnectionNames,
					   &tmpsize);
		tmpsize = StorageTmp->sLPConnectionSupportedConnectionNamesLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr,
					   &StorageTmp->sLPConnectionSupportedConnectionNames,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->sLPConnectionInterfaceType, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionK,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionN1,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionN2,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->sLPConnectionSequenceModulus, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT1Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT2Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionFCSErrorsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionFRMRsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFRMRsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionIFrameDataOctetsReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionIFrameDataOctetsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionIFramesReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFramesSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionPollsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionREJsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionREJsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionRNRsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionRNRsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionSABMsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionSABMsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->sLPConnectionProtocolState, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionTimesT1Expired, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT3Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionTimesT3Expired, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT4Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionTimesT4Expired, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->
					   sLPConnectionAbnormalLinkDisconnectsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionLinkResetsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionLinkResetsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER, cptr,
					   &StorageTmp->sLPConnectionTimesN2Reached, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->sLPConnectionAdministrativeState, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->sLPConnectionOperationalState, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionUsageState,
					   &tmpsize);
		tmpsize = StorageTmp->sLPConnectionProceduralStatusLen;
		cptr =
		    read_config_store_data(ASN_BIT_STR, cptr,
					   &StorageTmp->sLPConnectionProceduralStatus, &tmpsize);
		tmpsize = StorageTmp->sLPConnectionAlarmStatusLen;
		cptr =
		    read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sLPConnectionAlarmStatus,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionRowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sLPConnectionTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sLPConnectionIVMOTable_add(): adds a structure node to our data set
 */
int
sLPConnectionIVMOTable_add(struct sLPConnectionIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sLPConnectionIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sLPConnectionConnectionId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR,
				  (uint8_t *) thedata->sLPConnectionConnectionId,
				  thedata->sLPConnectionConnectionIdLen);

	header_complex_add_data(&sLPConnectionIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("sLPConnectionIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sLPConnectionIVMOTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sLPConnectionIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPConnectionIVMOTable_data *StorageTmp =
	    SNMP_MALLOC_STRUCT(sLPConnectionIVMOTable_data);
	DEBUGMSGTL(("sLPConnectionIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sLPConnectionConnectionId,
				  &tmpsize);
	StorageTmp->sLPConnectionConnectionIdLen = tmpsize;
	if (StorageTmp->sLPConnectionConnectionId == NULL) {
		config_perror("invalid specification for sLPConnectionConnectionId");
		return;
	}

	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sLPConnectionIVMOid, &tmpsize);
	StorageTmp->sLPConnectionIVMOidLen = tmpsize;
	if (StorageTmp->sLPConnectionIVMOid == NULL) {
		config_perror("invalid specification for sLPConnectionIVMOid");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOinterfaceType,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOk, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOn1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOn2, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOsequenceModulus,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt1Timer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt2Timer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt3Timer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt4Timer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMORowStatus,
				  &tmpsize);

	sLPConnectionIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
}

/*
 * store_sLPConnectionIVMOTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sLPConnectionIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPConnectionIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sLPConnectionIVMOTable", "storing data...  "));
	refresh_sLPConnectionIVMOTable();
	(void) tmpsize;
	for (hcindex = sLPConnectionIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPConnectionIVMOTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sLPConnectionIVMOTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sLPConnectionIVMOTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->sLPConnectionConnectionIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->sLPConnectionConnectionId, &tmpsize);
		tmpsize = StorageTmp->sLPConnectionIVMOidLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sLPConnectionIVMOid,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->sLPConnectionIVMOinterfaceType, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOk,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOn1,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOn2,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->sLPConnectionIVMOsequenceModulus, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt1Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt2Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt3Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt4Timer,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->sLPConnectionIVMORowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sLPConnectionIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_lAPBDLETable(): refresh lAPBDLETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_lAPBDLETable(void)
{
	if (lAPBDLETable_refresh == 0)
		return;
	lAPBDLETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_lAPBDLETable_row(): refresh lAPBDLETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_lAPBDLETable_row(struct lAPBDLETable_data *StorageTmp)
{
	if (StorageTmp->lAPBDLETable_request == sa_request)
		return;
	StorageTmp->lAPBDLETable_request = sa_request;
}

/*
 * var_lAPBDLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB above.
 */
uint8_t *
var_lAPBDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		 WriteMethod ** write_method)
{
	struct lAPBDLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("lapbMIB", "var_lAPBDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_lAPBDLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_lAPBDLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case LAPBDLELOCALSAPNAMES:
		*write_method = write_lAPBDLElocalSapNames;
		*var_len = StorageTmp->lAPBDLElocalSapNamesLen;
		return (uint8_t *) StorageTmp->lAPBDLElocalSapNames;
	case LAPBDLEOPERATIONALSTATE:
		*write_method = write_lAPBDLEoperationalState;
		*var_len = sizeof(StorageTmp->lAPBDLEoperationalState);
		return (uint8_t *) &StorageTmp->lAPBDLEoperationalState;
	case LAPBDLEPROVIDERENTITYNAMES:
		*write_method = write_lAPBDLEproviderEntityNames;
		*var_len = StorageTmp->lAPBDLEproviderEntityNamesLen;
		return (uint8_t *) StorageTmp->lAPBDLEproviderEntityNames;
	case LAPBDLEMT1TIMER:
		*write_method = write_lAPBDLEmT1Timer;
		*var_len = sizeof(StorageTmp->lAPBDLEmT1Timer);
		return (uint8_t *) &StorageTmp->lAPBDLEmT1Timer;
	case LAPBDLEMT3TIMER:
		*write_method = write_lAPBDLEmT3Timer;
		*var_len = sizeof(StorageTmp->lAPBDLEmT3Timer);
		return (uint8_t *) &StorageTmp->lAPBDLEmT3Timer;
	case LAPBDLEMW:
		*write_method = write_lAPBDLEmW;
		*var_len = sizeof(StorageTmp->lAPBDLEmW);
		return (uint8_t *) &StorageTmp->lAPBDLEmW;
	case LAPBDLEMXSEND:
		*write_method = write_lAPBDLEmXSend;
		*var_len = sizeof(StorageTmp->lAPBDLEmXSend);
		return (uint8_t *) &StorageTmp->lAPBDLEmXSend;
	case LAPBDLEMXRECEIVE:
		*write_method = write_lAPBDLEmXReceive;
		*var_len = sizeof(StorageTmp->lAPBDLEmXReceive);
		return (uint8_t *) &StorageTmp->lAPBDLEmXReceive;
	case LAPBDLEMT2TIMER:
		*write_method = write_lAPBDLEmT2Timer;
		*var_len = sizeof(StorageTmp->lAPBDLEmT2Timer);
		return (uint8_t *) &StorageTmp->lAPBDLEmT2Timer;
	case LAPBDLERECEIVEDMLPRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEreceivedMlpResets);
		return (uint8_t *) &StorageTmp->lAPBDLEreceivedMlpResets;
	case LAPBDLETIMESMT1EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEtimesMT1Expired);
		return (uint8_t *) &StorageTmp->lAPBDLEtimesMT1Expired;
	case LAPBDLEIFRAMESREASSIGNMENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEIframesReassignments);
		return (uint8_t *) &StorageTmp->lAPBDLEIframesReassignments;
	case LAPBDLEMLPFRAMESRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesReceived);
		return (uint8_t *) &StorageTmp->lAPBDLEmlpFramesReceived;
	case LAPBDLEMLPFRAMESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesSent);
		return (uint8_t *) &StorageTmp->lAPBDLEmlpFramesSent;
	case LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard);
		return (uint8_t *) &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard;
	case LAPBDLERECEIVEDMLPFRAMESINGUARDREGION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion);
		return (uint8_t *) &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion;
	case LAPBDLEROWSTATUS:
		*write_method = write_lAPBDLERowStatus;
		*var_len = sizeof(StorageTmp->lAPBDLERowStatus);
		return (uint8_t *) &StorageTmp->lAPBDLERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_dLSAPTable(): refresh dLSAPTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_dLSAPTable(void)
{
	if (dLSAPTable_refresh == 0)
		return;
	dLSAPTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_dLSAPTable_row(): refresh dLSAPTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_dLSAPTable_row(struct dLSAPTable_data *StorageTmp)
{
	if (StorageTmp->dLSAPTable_request == sa_request)
		return;
	StorageTmp->dLSAPTable_request = sa_request;
}

/*
 * var_dLSAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB above.
 */
uint8_t *
var_dLSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
	       WriteMethod ** write_method)
{
	struct dLSAPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("lapbMIB", "var_dLSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_dLSAPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(dLSAPTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_dLSAPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case DLSAPSAP1ADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->dLSAPsap1Address);
		return (uint8_t *) &StorageTmp->dLSAPsap1Address;
	case DLSAPUSERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->dLSAPuserEntityNamesLen;
		return (uint8_t *) StorageTmp->dLSAPuserEntityNames;
	case DLSAPROWSTATUS:
		*write_method = write_dLSAPRowStatus;
		*var_len = sizeof(StorageTmp->dLSAPRowStatus);
		return (uint8_t *) &StorageTmp->dLSAPRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sLPPMTable(): refresh sLPPMTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sLPPMTable(void)
{
	if (sLPPMTable_refresh == 0)
		return;
	sLPPMTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sLPPMTable_row(): refresh sLPPMTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sLPPMTable_row(struct sLPPMTable_data *StorageTmp)
{
	if (StorageTmp->sLPPMTable_request == sa_request)
		return;
	StorageTmp->sLPPMTable_request = sa_request;
}

/*
 * var_sLPPMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB above.
 */
uint8_t *
var_sLPPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
	       WriteMethod ** write_method)
{
	struct sLPPMTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("lapbMIB", "var_sLPPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sLPPMTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(sLPPMTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_sLPPMTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SLPPMOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPPMoperationalState);
		return (uint8_t *) &StorageTmp->sLPPMoperationalState;
	case SLPPMADMINISTRATIVESTATE:
		*write_method = write_sLPPMadministrativeState;
		*var_len = sizeof(StorageTmp->sLPPMadministrativeState);
		return (uint8_t *) &StorageTmp->sLPPMadministrativeState;
	case SLPPMROWSTATUS:
		*write_method = write_sLPPMRowStatus;
		*var_len = sizeof(StorageTmp->sLPPMRowStatus);
		return (uint8_t *) &StorageTmp->sLPPMRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sLPConnectionTable(): refresh sLPConnectionTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sLPConnectionTable(void)
{
	if (sLPConnectionTable_refresh == 0)
		return;
	sLPConnectionTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sLPConnectionTable_row(): refresh sLPConnectionTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sLPConnectionTable_row(struct sLPConnectionTable_data *StorageTmp)
{
	if (StorageTmp->sLPConnectionTable_request == sa_request)
		return;
	StorageTmp->sLPConnectionTable_request = sa_request;
}

/*
 * var_sLPConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB above.
 */
uint8_t *
var_sLPConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct sLPConnectionTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("lapbMIB", "var_sLPConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sLPConnectionTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_sLPConnectionTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SLPCONNECTIONUNDERLYINGCONNECTIONNAMES:
		*write_method = write_sLPConnectionUnderlyingConnectionNames;
		*var_len = StorageTmp->sLPConnectionUnderlyingConnectionNamesLen;
		return (uint8_t *) StorageTmp->sLPConnectionUnderlyingConnectionNames;
	case SLPCONNECTIONSUPPORTEDCONNECTIONNAMES:
		*write_method = write_sLPConnectionSupportedConnectionNames;
		*var_len = StorageTmp->sLPConnectionSupportedConnectionNamesLen;
		return (uint8_t *) StorageTmp->sLPConnectionSupportedConnectionNames;
	case SLPCONNECTIONINTERFACETYPE:
		*write_method = write_sLPConnectionInterfaceType;
		*var_len = sizeof(StorageTmp->sLPConnectionInterfaceType);
		return (uint8_t *) &StorageTmp->sLPConnectionInterfaceType;
	case SLPCONNECTIONK:
		*write_method = write_sLPConnectionK;
		*var_len = sizeof(StorageTmp->sLPConnectionK);
		return (uint8_t *) &StorageTmp->sLPConnectionK;
	case SLPCONNECTIONN1:
		*write_method = write_sLPConnectionN1;
		*var_len = sizeof(StorageTmp->sLPConnectionN1);
		return (uint8_t *) &StorageTmp->sLPConnectionN1;
	case SLPCONNECTIONN2:
		*write_method = write_sLPConnectionN2;
		*var_len = sizeof(StorageTmp->sLPConnectionN2);
		return (uint8_t *) &StorageTmp->sLPConnectionN2;
	case SLPCONNECTIONSEQUENCEMODULUS:
		*write_method = write_sLPConnectionSequenceModulus;
		*var_len = sizeof(StorageTmp->sLPConnectionSequenceModulus);
		return (uint8_t *) &StorageTmp->sLPConnectionSequenceModulus;
	case SLPCONNECTIONT1TIMER:
		*write_method = write_sLPConnectionT1Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT1Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionT1Timer;
	case SLPCONNECTIONT2TIMER:
		*write_method = write_sLPConnectionT2Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT2Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionT2Timer;
	case SLPCONNECTIONFCSERRORSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionFCSErrorsReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionFCSErrorsReceived;
	case SLPCONNECTIONFRMRSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionFRMRsReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionFRMRsReceived;
	case SLPCONNECTIONFRMRSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionFRMRsSent);
		return (uint8_t *) &StorageTmp->sLPConnectionFRMRsSent;
	case SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFrameDataOctetsReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionIFrameDataOctetsReceived;
	case SLPCONNECTIONIFRAMEDATAOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFrameDataOctetsSent);
		return (uint8_t *) &StorageTmp->sLPConnectionIFrameDataOctetsSent;
	case SLPCONNECTIONIFRAMESRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFramesReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionIFramesReceived;
	case SLPCONNECTIONIFRAMESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionIFramesSent);
		return (uint8_t *) &StorageTmp->sLPConnectionIFramesSent;
	case SLPCONNECTIONPOLLSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionPollsReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionPollsReceived;
	case SLPCONNECTIONREJSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionREJsReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionREJsReceived;
	case SLPCONNECTIONREJSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionREJsSent);
		return (uint8_t *) &StorageTmp->sLPConnectionREJsSent;
	case SLPCONNECTIONRNRSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionRNRsReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionRNRsReceived;
	case SLPCONNECTIONRNRSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionRNRsSent);
		return (uint8_t *) &StorageTmp->sLPConnectionRNRsSent;
	case SLPCONNECTIONSABMSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionSABMsReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionSABMsReceived;
	case SLPCONNECTIONSABMSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionSABMsSent);
		return (uint8_t *) &StorageTmp->sLPConnectionSABMsSent;
	case SLPCONNECTIONPROTOCOLSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionProtocolState);
		return (uint8_t *) &StorageTmp->sLPConnectionProtocolState;
	case SLPCONNECTIONTIMEST1EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT1Expired);
		return (uint8_t *) &StorageTmp->sLPConnectionTimesT1Expired;
	case SLPCONNECTIONT3TIMER:
		*write_method = write_sLPConnectionT3Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT3Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionT3Timer;
	case SLPCONNECTIONTIMEST3EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT3Expired);
		return (uint8_t *) &StorageTmp->sLPConnectionTimesT3Expired;
	case SLPCONNECTIONT4TIMER:
		*write_method = write_sLPConnectionT4Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionT4Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionT4Timer;
	case SLPCONNECTIONTIMEST4EXPIRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT4Expired);
		return (uint8_t *) &StorageTmp->sLPConnectionTimesT4Expired;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived;
	case SLPCONNECTIONABNORMALLINKDISCONNECTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent);
		return (uint8_t *) &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent;
	case SLPCONNECTIONLINKRESETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionLinkResetsReceived);
		return (uint8_t *) &StorageTmp->sLPConnectionLinkResetsReceived;
	case SLPCONNECTIONLINKRESETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionLinkResetsSent);
		return (uint8_t *) &StorageTmp->sLPConnectionLinkResetsSent;
	case SLPCONNECTIONTIMESN2REACHED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionTimesN2Reached);
		return (uint8_t *) &StorageTmp->sLPConnectionTimesN2Reached;
	case SLPCONNECTIONADMINISTRATIVESTATE:
		*write_method = write_sLPConnectionAdministrativeState;
		*var_len = sizeof(StorageTmp->sLPConnectionAdministrativeState);
		return (uint8_t *) &StorageTmp->sLPConnectionAdministrativeState;
	case SLPCONNECTIONOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionOperationalState);
		return (uint8_t *) &StorageTmp->sLPConnectionOperationalState;
	case SLPCONNECTIONUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sLPConnectionUsageState);
		return (uint8_t *) &StorageTmp->sLPConnectionUsageState;
	case SLPCONNECTIONPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sLPConnectionProceduralStatusLen;
		return (uint8_t *) StorageTmp->sLPConnectionProceduralStatus;
	case SLPCONNECTIONALARMSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sLPConnectionAlarmStatusLen;
		return (uint8_t *) StorageTmp->sLPConnectionAlarmStatus;
	case SLPCONNECTIONROWSTATUS:
		*write_method = write_sLPConnectionRowStatus;
		*var_len = sizeof(StorageTmp->sLPConnectionRowStatus);
		return (uint8_t *) &StorageTmp->sLPConnectionRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sLPConnectionIVMOTable(): refresh sLPConnectionIVMOTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sLPConnectionIVMOTable(void)
{
	if (sLPConnectionIVMOTable_refresh == 0)
		return;
	sLPConnectionIVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sLPConnectionIVMOTable_row(): refresh sLPConnectionIVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sLPConnectionIVMOTable_row(struct sLPConnectionIVMOTable_data *StorageTmp)
{
	if (StorageTmp->sLPConnectionIVMOTable_request == sa_request)
		return;
	StorageTmp->sLPConnectionIVMOTable_request = sa_request;
}

/*
 * var_sLPConnectionIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lapbMIB above.
 */
uint8_t *
var_sLPConnectionIVMOTable(struct variable *vp, oid * name, size_t *length, int exact,
			   size_t *var_len, WriteMethod ** write_method)
{
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("lapbMIB", "var_sLPConnectionIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sLPConnectionIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_sLPConnectionIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SLPCONNECTIONIVMOID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sLPConnectionIVMOidLen;
		return (uint8_t *) StorageTmp->sLPConnectionIVMOid;
	case SLPCONNECTIONIVMOINTERFACETYPE:
		*write_method = write_sLPConnectionIVMOinterfaceType;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOinterfaceType);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMOinterfaceType;
	case SLPCONNECTIONIVMOK:
		*write_method = write_sLPConnectionIVMOk;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOk);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMOk;
	case SLPCONNECTIONIVMON1:
		*write_method = write_sLPConnectionIVMOn1;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOn1);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMOn1;
	case SLPCONNECTIONIVMON2:
		*write_method = write_sLPConnectionIVMOn2;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOn2);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMOn2;
	case SLPCONNECTIONIVMOSEQUENCEMODULUS:
		*write_method = write_sLPConnectionIVMOsequenceModulus;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOsequenceModulus);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMOsequenceModulus;
	case SLPCONNECTIONIVMOT1TIMER:
		*write_method = write_sLPConnectionIVMOt1Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt1Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMOt1Timer;
	case SLPCONNECTIONIVMOT2TIMER:
		*write_method = write_sLPConnectionIVMOt2Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt2Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMOt2Timer;
	case SLPCONNECTIONIVMOT3TIMER:
		*write_method = write_sLPConnectionIVMOt3Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt3Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMOt3Timer;
	case SLPCONNECTIONIVMOT4TIMER:
		*write_method = write_sLPConnectionIVMOt4Timer;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt4Timer);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMOt4Timer;
	case SLPCONNECTIONIVMOROWSTATUS:
		*write_method = write_sLPConnectionIVMORowStatus;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMORowStatus);
		return (uint8_t *) &StorageTmp->sLPConnectionIVMORowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_lAPBDLElocalSapNames(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			   uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct lAPBDLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_lAPBDLElocalSapNames entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to lAPBDLElocalSapNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->lAPBDLElocalSapNames;
		tmplen = StorageTmp->lAPBDLElocalSapNamesLen;
		memdup((void *) &StorageTmp->lAPBDLElocalSapNames, var_val, var_val_len);
		StorageTmp->lAPBDLElocalSapNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->lAPBDLElocalSapNames);
		StorageTmp->lAPBDLElocalSapNames = tmpvar;
		StorageTmp->lAPBDLElocalSapNamesLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEoperationalState(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lAPBDLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_lAPBDLEoperationalState entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to lAPBDLEoperationalState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->lAPBDLEoperationalState;
		StorageTmp->lAPBDLEoperationalState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEoperationalState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEproviderEntityNames(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct lAPBDLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_lAPBDLEproviderEntityNames entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to lAPBDLEproviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->lAPBDLEproviderEntityNames;
		tmplen = StorageTmp->lAPBDLEproviderEntityNamesLen;
		memdup((void *) &StorageTmp->lAPBDLEproviderEntityNames, var_val, var_val_len);
		StorageTmp->lAPBDLEproviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->lAPBDLEproviderEntityNames);
		StorageTmp->lAPBDLEproviderEntityNames = tmpvar;
		StorageTmp->lAPBDLEproviderEntityNamesLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT1Timer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		      uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lAPBDLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_lAPBDLEmT1Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to lAPBDLEmT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->lAPBDLEmT1Timer;
		StorageTmp->lAPBDLEmT1Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT1Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT3Timer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		      uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lAPBDLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_lAPBDLEmT3Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to lAPBDLEmT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->lAPBDLEmT3Timer;
		StorageTmp->lAPBDLEmT3Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT3Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmW(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lAPBDLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_lAPBDLEmW entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmW not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->lAPBDLEmW;
		StorageTmp->lAPBDLEmW = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmW = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXSend(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lAPBDLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_lAPBDLEmXSend entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to lAPBDLEmXSend not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->lAPBDLEmXSend;
		StorageTmp->lAPBDLEmXSend = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmXSend = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmXReceive(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		       uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lAPBDLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_lAPBDLEmXReceive entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to lAPBDLEmXReceive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->lAPBDLEmXReceive;
		StorageTmp->lAPBDLEmXReceive = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmXReceive = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLEmT2Timer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		      uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lAPBDLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_lAPBDLEmT2Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(lAPBDLETableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to lAPBDLEmT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->lAPBDLEmT2Timer;
		StorageTmp->lAPBDLEmT2Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT2Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMadministrativeState(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPPMTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPPMadministrativeState entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPPMTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPPMadministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPPMadministrativeState;
		StorageTmp->sLPPMadministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPPMadministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionUnderlyingConnectionNames(int action, uint8_t *var_val, uint8_t var_val_type,
					     size_t var_val_len, uint8_t *statP, oid * name,
					     size_t name_len)
{
	static oid *tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB",
		    "write_sLPConnectionUnderlyingConnectionNames entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionUnderlyingConnectionNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionUnderlyingConnectionNames;
		tmplen = StorageTmp->sLPConnectionUnderlyingConnectionNamesLen;
		memdup((void *) &StorageTmp->sLPConnectionUnderlyingConnectionNames, var_val,
		       var_val_len);
		StorageTmp->sLPConnectionUnderlyingConnectionNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sLPConnectionUnderlyingConnectionNames);
		StorageTmp->sLPConnectionUnderlyingConnectionNames = tmpvar;
		StorageTmp->sLPConnectionUnderlyingConnectionNamesLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionSupportedConnectionNames(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static oid *tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB",
		    "write_sLPConnectionSupportedConnectionNames entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionSupportedConnectionNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionSupportedConnectionNames;
		tmplen = StorageTmp->sLPConnectionSupportedConnectionNamesLen;
		memdup((void *) &StorageTmp->sLPConnectionSupportedConnectionNames, var_val,
		       var_val_len);
		StorageTmp->sLPConnectionSupportedConnectionNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sLPConnectionSupportedConnectionNames);
		StorageTmp->sLPConnectionSupportedConnectionNames = tmpvar;
		StorageTmp->sLPConnectionSupportedConnectionNamesLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionInterfaceType(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionInterfaceType entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionInterfaceType;
		StorageTmp->sLPConnectionInterfaceType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionInterfaceType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionK(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionK entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionK;
		StorageTmp->sLPConnectionK = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionK = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		      uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionN1 entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionN1;
		StorageTmp->sLPConnectionN1 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionN1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionN2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		      uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionN2 entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionN2;
		StorageTmp->sLPConnectionN2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionN2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionSequenceModulus(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionSequenceModulus entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionSequenceModulus;
		StorageTmp->sLPConnectionSequenceModulus = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionSequenceModulus = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT1Timer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionT1Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionT1Timer;
		StorageTmp->sLPConnectionT1Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT1Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT2Timer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionT2Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionT2Timer;
		StorageTmp->sLPConnectionT2Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT2Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT3Timer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionT3Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionT3Timer;
		StorageTmp->sLPConnectionT3Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT3Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionT4Timer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionT4Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionT4Timer;
		StorageTmp->sLPConnectionT4Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT4Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type,
				       size_t var_val_len, uint8_t *statP, oid * name,
				       size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionAdministrativeState entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(sLPConnectionTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionAdministrativeState;
		StorageTmp->sLPConnectionAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOinterfaceType(int action, uint8_t *var_val, uint8_t var_val_type,
				     size_t var_val_len, uint8_t *statP, oid * name,
				     size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionIVMOinterfaceType entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionIVMOinterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionIVMOinterfaceType;
		StorageTmp->sLPConnectionIVMOinterfaceType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOinterfaceType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOk(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			 uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionIVMOk entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionIVMOk not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionIVMOk;
		StorageTmp->sLPConnectionIVMOk = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOk = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			  uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionIVMOn1 entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionIVMOn1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionIVMOn1;
		StorageTmp->sLPConnectionIVMOn1 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOn1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOn2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			  uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionIVMOn2 entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionIVMOn2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionIVMOn2;
		StorageTmp->sLPConnectionIVMOn2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOn2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOsequenceModulus(int action, uint8_t *var_val, uint8_t var_val_type,
				       size_t var_val_len, uint8_t *statP, oid * name,
				       size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionIVMOsequenceModulus entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionIVMOsequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionIVMOsequenceModulus;
		StorageTmp->sLPConnectionIVMOsequenceModulus = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOsequenceModulus = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt1Timer(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionIVMOt1Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionIVMOt1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionIVMOt1Timer;
		StorageTmp->sLPConnectionIVMOt1Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt1Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt2Timer(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionIVMOt2Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionIVMOt2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionIVMOt2Timer;
		StorageTmp->sLPConnectionIVMOt2Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt2Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt3Timer(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionIVMOt3Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionIVMOt3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionIVMOt3Timer;
		StorageTmp->sLPConnectionIVMOt3Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt3Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMOt4Timer(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionIVMOt4Timer entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(sLPConnectionIVMOTableStorage, NULL,
			    &name[sizeof(lapbMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1,
			    NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionIVMOt4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionIVMOt4Timer;
		StorageTmp->sLPConnectionIVMOt4Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt4Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultInterfaceType(int action, uint8_t *var_val, uint8_t var_val_type,
					size_t var_val_len, uint8_t *statP, oid * name,
					size_t name_len)
{
	static int32_t tmpvar;
	struct lapbMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionDefaultInterfaceType entering action=%d...  \n",
		    action));
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value dTE ( 0 ) */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionDefaultInterfaceType;
		StorageTmp->sLPConnectionDefaultInterfaceType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultInterfaceType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultK(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lapbMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionDefaultK entering action=%d...  \n", action));
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionDefaultK;
		StorageTmp->sLPConnectionDefaultK = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultK = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lapbMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionDefaultN1 entering action=%d...  \n", action));
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionDefaultN1;
		StorageTmp->sLPConnectionDefaultN1 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultN1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultN2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lapbMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionDefaultN2 entering action=%d...  \n", action));
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionDefaultN2;
		StorageTmp->sLPConnectionDefaultN2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultN2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultSequenceModulus(int action, uint8_t *var_val, uint8_t var_val_type,
					  size_t var_val_len, uint8_t *statP, oid * name,
					  size_t name_len)
{
	static int32_t tmpvar;
	struct lapbMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB",
		    "write_sLPConnectionDefaultSequenceModulus entering action=%d...  \n", action));
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges 8..8 128..128 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionDefaultSequenceModulus;
		StorageTmp->sLPConnectionDefaultSequenceModulus = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultSequenceModulus = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT1Timer(int action, uint8_t *var_val, uint8_t var_val_type,
				  size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lapbMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionDefaultT1Timer entering action=%d...  \n",
		    action));
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionDefaultT1Timer;
		StorageTmp->sLPConnectionDefaultT1Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT1Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT2Timer(int action, uint8_t *var_val, uint8_t var_val_type,
				  size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lapbMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionDefaultT2Timer entering action=%d...  \n",
		    action));
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionDefaultT2Timer;
		StorageTmp->sLPConnectionDefaultT2Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT2Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT3Timer(int action, uint8_t *var_val, uint8_t var_val_type,
				  size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lapbMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionDefaultT3Timer entering action=%d...  \n",
		    action));
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionDefaultT3Timer;
		StorageTmp->sLPConnectionDefaultT3Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT3Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionDefaultT4Timer(int action, uint8_t *var_val, uint8_t var_val_type,
				  size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct lapbMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("lapbMIB", "write_sLPConnectionDefaultT4Timer entering action=%d...  \n",
		    action));
	if ((StorageTmp = lapbMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to sLPConnectionDefaultT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sLPConnectionDefaultT4Timer;
		StorageTmp->sLPConnectionDefaultT4Timer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT4Timer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_lAPBDLERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		       uint8_t *statP, oid * name, size_t name_len)
{
	struct lAPBDLETable_data *StorageTmp = NULL;
	static struct lAPBDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(lAPBDLETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(lAPBDLETableStorage, NULL,
			   &name[sizeof(lAPBDLETable_variables_oid) / sizeof(oid) + 3 - 1], &newlen,
			   1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* lAPBDLEcommunicationsEntityId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(lAPBDLETable_variables_oid) / sizeof(oid) + 2]), newlen,
			     vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(lAPBDLETable_data);
			memdup((void *) &StorageNew->lAPBDLEcommunicationsEntityId, vp->val.string,
			       vp->val_len);
			StorageNew->lAPBDLEcommunicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->lAPBDLERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				lAPBDLETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->lAPBDLERowStatus;
			StorageTmp->lAPBDLERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(lAPBDLETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&lAPBDLETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(lAPBDLETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&lAPBDLETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			lAPBDLETable_add(StorageDel);
		} else {
			StorageTmp->lAPBDLERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->lAPBDLERowStatus == RS_CREATEANDGO) {
				StorageTmp->lAPBDLERowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->lAPBDLERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->lAPBDLERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_dLSAPRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		     uint8_t *statP, oid * name, size_t name_len)
{
	struct dLSAPTable_data *StorageTmp = NULL;
	static struct dLSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(dLSAPTableStorage, NULL,
			   &name[sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen,
			   1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* lAPBDLEcommunicationsEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* dLSAPsapId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(dLSAPTable_variables_oid) / sizeof(oid) + 2]), newlen,
			     vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(dLSAPTable_data);
			memdup((void *) &StorageNew->lAPBDLEcommunicationsEntityId, vp->val.string,
			       vp->val_len);
			StorageNew->lAPBDLEcommunicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->dLSAPsapId, vp->val.string, vp->val_len);
			StorageNew->dLSAPsapIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->dLSAPRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				dLSAPTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->dLSAPRowStatus;
			StorageTmp->dLSAPRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(dLSAPTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&dLSAPTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(dLSAPTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&dLSAPTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			dLSAPTable_add(StorageDel);
		} else {
			StorageTmp->dLSAPRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->dLSAPRowStatus == RS_CREATEANDGO) {
				StorageTmp->dLSAPRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->dLSAPRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->dLSAPRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPPMRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		     uint8_t *statP, oid * name, size_t name_len)
{
	struct sLPPMTable_data *StorageTmp = NULL;
	static struct sLPPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sLPPMTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(sLPPMTableStorage, NULL,
			   &name[sizeof(sLPPMTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen,
			   1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* lAPBDLEcommunicationsEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sLPPMcoProtocolMachineId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(sLPPMTable_variables_oid) / sizeof(oid) + 2]), newlen,
			     vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sLPPMTable_data);
			memdup((void *) &StorageNew->lAPBDLEcommunicationsEntityId, vp->val.string,
			       vp->val_len);
			StorageNew->lAPBDLEcommunicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sLPPMcoProtocolMachineId, vp->val.string,
			       vp->val_len);
			StorageNew->sLPPMcoProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sLPPMRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sLPPMTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sLPPMRowStatus;
			StorageTmp->sLPPMRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sLPPMTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sLPPMTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sLPPMTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sLPPMTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sLPPMTable_add(StorageDel);
		} else {
			StorageTmp->sLPPMRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sLPPMRowStatus == RS_CREATEANDGO) {
				StorageTmp->sLPPMRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sLPPMRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sLPPMRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static struct sLPConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sLPConnectionTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(sLPConnectionTableStorage, NULL,
			   &name[sizeof(sLPConnectionTable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to sLPConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sLPConnectionConnectionId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(sLPConnectionTable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionTable_data);
			memdup((void *) &StorageNew->sLPConnectionConnectionId, vp->val.string,
			       vp->val_len);
			StorageNew->sLPConnectionConnectionIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->sLPConnectionUnderlyingConnectionNames = zeroDotZero; */
			/* StorageNew->sLPConnectionSupportedConnectionNames = zeroDotZero; */

			StorageNew->sLPConnectionRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sLPConnectionTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sLPConnectionRowStatus;
			StorageTmp->sLPConnectionRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sLPConnectionTableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&sLPConnectionTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sLPConnectionTableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&sLPConnectionTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sLPConnectionTable_add(StorageDel);
		} else {
			StorageTmp->sLPConnectionRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sLPConnectionRowStatus == RS_CREATEANDGO) {
				StorageTmp->sLPConnectionRowStatus = RS_ACTIVE;
			} else if (StorageTmp
				   && StorageTmp->sLPConnectionRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sLPConnectionRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sLPConnectionIVMORowStatus(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static struct sLPConnectionIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen =
	    name_len - (sizeof(sLPConnectionIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(sLPConnectionIVMOTableStorage, NULL,
			   &name[sizeof(sLPConnectionIVMOTable_variables_oid) / sizeof(oid) + 3 -
				 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to sLPConnectionIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sLPConnectionConnectionId 
												 */

			if (header_complex_parse_oid
			    (&
			     (name[sizeof(sLPConnectionIVMOTable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionIVMOTable_data);
			memdup((void *) &StorageNew->sLPConnectionConnectionId, vp->val.string,
			       vp->val_len);
			StorageNew->sLPConnectionConnectionIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sLPConnectionIVMORowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sLPConnectionIVMOTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sLPConnectionIVMORowStatus;
			StorageTmp->sLPConnectionIVMORowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr =
			    header_complex_find_entry(sLPConnectionIVMOTableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&sLPConnectionIVMOTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr =
			    header_complex_find_entry(sLPConnectionIVMOTableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&sLPConnectionIVMOTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sLPConnectionIVMOTable_add(StorageDel);
		} else {
			StorageTmp->sLPConnectionIVMORowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sLPConnectionIVMORowStatus == RS_CREATEANDGO) {
				StorageTmp->sLPConnectionIVMORowStatus = RS_ACTIVE;
			} else if (StorageTmp
				   && StorageTmp->sLPConnectionIVMORowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sLPConnectionIVMORowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
