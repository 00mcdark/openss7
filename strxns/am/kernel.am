## =============================================================================
## 
# @(#) $RCSfile: kernel.am,v $ $Name:  $($Revision: 0.9.2.41 $) $Date: 2005/04/04 18:50:22 $
##
## -----------------------------------------------------------------------------
##
## Copyright (c) 2001-2005  OpenSS7 Corporation <http://www.openss7.com>
## Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>
##
## All Rights Reserved.
##
## This program is free software; you can redistribute it and/or modify it under
## the terms of the GNU General Public License as published by the Free Software
## Foundation; either version 2 of the License, or (at your option) any later
## version.
##
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
## details.
##
## You should have received a copy of the GNU General Public License along with
## this program; if not, write to the Free Software Foundation, Inc., 675 Mass
## Ave, Cambridge, MA 02139, USA.
##
## -----------------------------------------------------------------------------
##
## U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
## behalf of the U.S. Government ("Government"), the following provisions apply
## to you.  If the Software is supplied by the Department of Defense ("DoD"), it
## is classified as "Commercial Computer Software" under paragraph 252.227-7014
## of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
## successor regulations) and the Government is acquiring only the license rights
## granted herein (the license rights customarily provided to non-Government
## users).  If the Software is supplied to any unit or agency of the Government
## other than DoD, it is classified as "Restricted Computer Software" and the
## Government's rights in the Software are defined in paragraph 52.227-19 of the
## Federal Acquisition Regulations ("FAR") (or any success regulations) or, in
## the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
## (or any successor regulations).
##
## -----------------------------------------------------------------------------
##
## Commercial licensing and support of this software is available from OpenSS7
## Corporation at a fee.  See http://www.openss7.com/
##
## -----------------------------------------------------------------------------
##
## Last Modified $Date: 2005/04/04 18:50:22 $ by $Author: brian $
##
## =============================================================================

if PKG_BUILD_ARCH
## PKG_BUILD_ARCH
if RPM_BUILD_KERNEL
## RPM_BUILD_KERNEL

Modules.map: $(KERNEL_MODULES)
	$(NM) -s $(KERNEL_MODULES) > $@

CLEANFILES 		+= Modules.map

if WITH_KO_MODULES
###################################################################################################
## WITH_KO_MODULES

if AMDEP
## AMDEP
sinclude $(DEPDIR)/modules.Pk

$(DEPDIR)/modules.Pk:
	@$(ECHO) "Creating $@ dependencies..." ; \
	( \
		srcs=`$(ECHO) " $(KERNEL_MODULES) " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|\.o |.mod.c |g'` ; \
		$(ECHO) "stamp-mobjects: $$srcs" ; $(ECHO) "" ; \
		objs=`$(ECHO) " $(KERNEL_MODULES) " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|\.o |.o |g'` ; \
		$(ECHO) "stamp-kobjects: $$objs" ; $(ECHO) "" ; \
		mods=`$(ECHO) " $(KERNEL_MODULES) " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|\.o | |g'` ; \
		for m in $$mods ; do \
			$(ECHO) "sinclude $(DEPDIR)/$$m.mod.Po" ; \
			$(ECHO) "sinclude $(DEPDIR)/$$m.Pko" ; \
		done \
	) >$(DEPDIR)/modules.Tpk || { rm -f $(DEPDIR)/modules.Tpk ; exit 1 ; } ; \
	mv -f $(DEPDIR)/modules.Tpk $@
## AMDEP
endif

stamp-modpost: stamp-verobjs $(KERNEL_MODULES)
	@list=`$(ECHO) " $(KERNEL_MODULES) " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g'` ; \
	$(ECHO) "MODPOST_CACHE=$(MODPOST_CACHE) $(MODPOST) -vv $(MODPOST_OPTIONS) -i '$(MODPOST_INPUTS)' -o $(MODPOST_MODVER) $$list" ; \
	MODPOST_CACHE=$(MODPOST_CACHE) $(MODPOST) -vv $(MODPOST_OPTIONS) -i '$(MODPOST_INPUTS)' -o $(MODPOST_MODVER) $$list ; \
	touch stamp-modpost

CLEANFILES		+= System.symvers Module.symvers

if am__fastdepCC
## am__fastdepCC
stamp-mobjects: stamp-modpost $(KERNEL_MODULES)
	@mods=`$(ECHO) " $? " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|\.o | |g;s|\.mod\.c | |g'` ; \
	for m in $$mods ; do \
		test :$$m != :stamp-modpost || continue ; \
		$(ECHO) "if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(KERNEL_CPPFLAGS) $(KERNEL_CFLAGS) $(KERNEL_MODFLAGS) -MT $$m.mod.o -MMD -MP -MF $(DEPDIR)/$$m.mod.Tpo -c -o $$m.mod.o $$m.mod.c ; \
		then mv -f $(DEPDIR)/$$m.mod.Tpo $(DEPDIR)/$$m.mod.Po ; else rm -f $(DEPDIR)/$$m.mod.Tpo ; exit 1 ; fi" ; \
		if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(KERNEL_CPPFLAGS) $(KERNEL_CFLAGS) $(KERNEL_MODFLAGS) -MT $$m.mod.o -MMD -MP -MF $(DEPDIR)/$$m.mod.Tpo -c -o $$m.mod.o $$m.mod.c ; \
		then mv -f $(DEPDIR)/$$m.mod.Tpo $(DEPDIR)/$$m.mod.Po ; else rm -f $(DEPDIR)/$$m.mod.Tpo ; exit 1 ; fi ; \
	done ; \
	touch stamp-mobjects
## am__fastdepCC
else
## !am__fastdepCC
if AMDEP
## AMDEP
stamp-mobjects: stamp-modpost $(KERNEL_MODULES)
	@mods=`$(ECHO) " $? " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|\.o | |g;s|\.mod\.c | |g'` ; \
	for m in $$mods ; do \
		test :$$m != :stamp-modpost || continue ; \
		$(ECHO) "source=$$m.mod.c object=$$m.mod.o libtool=no DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
		$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(KERNEL_CPPFLAGS) $(KERNEL_CFLAGS) $(KERNEL_MODFLAGS) -c $$m.mod.c" ; \
		source=$$m.mod.c object=$$m.mod.o libtool=no DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
		$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(KERNEL_CPPFLAGS) $(KERNEL_CFLAGS) $(KERNEL_MODFLAGS) -c $$m.mod.c ; \
	done ; \
	touch stamp-mobjects
## AMDEP
else
## !AMDEP
stamp-mobjects: stamp-modpost $(KERNEL_MODULES)
	@mods=`$(ECHO) " $? " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|\.o | |g;s|\.mod\.c | |g'` ; \
	for m in $$mods ; do \
		test :$$m != :stamp-modpost || continue ; \
		$(ECHO) "$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(KERNEL_CPPFLAGS) $(KERNEL_CFLAGS) $(KERNEL_MODFLAGS) -c $$m.mod.c" ; \
		$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(KERNEL_CPPFLAGS) $(KERNEL_CFLAGS) $(KERNEL_MODFLAGS) -c $$m.mod.c ; \
	done ; \
	touch stamp-mobjects
## !AMDEP
endif
## !am__fastdepCC
endif

if AMDEP
## AMDEP
.o.ko:
	@m=`$(ECHO) "$<" | sed -r -e 's|(\.mod)?\.o$$||'` ; \
	$(ECHO) "if $(LD) -r -o $@ $$m.o $$m.mod.o ; then $(ECHO) \"$@: $$m.o $$m.mod.o\" > $(DEPDIR)/$$m.Pko ; fi" ; \
	if $(LD) -r -o $@ $$m.o $$m.mod.o ; then $(ECHO) "$@: $$m.o $$m.mod.o" > $(DEPDIR)/$$m.Pko ; fi
## AMDEP
else
## !AMDEP
.o.ko:
	@m=`$(ECHO) "$<" | sed -r -e 's|(\.mod)?\.o$$||'` ; \
	$(ECHO) "$(LD) -r -o $@ $$m.o $$m.mod.o" ; \
	$(LD) -r -o $@ $$m.o $$m.mod.o
## !AMDEP
endif

MY_SUFFIXES		+= .ko .o

if AMDEP
## AMDEP
stamp-kobjects: stamp-mobjects $(KERNEL_MODULES)
	@mods=`$(ECHO) " $? " | sed -r -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|(\.mod)?\.o | |g'` ; \
	for m in $$mods ; do \
		test :$$m != :stamp-mobjects || continue ; \
		$(ECHO) "if $(LD) -r -o $$m.ko $$m.o $$m.mod.o ; then $(ECHO) \"$$m.ko: $$m.o $$m.mod.o\" > $(DEPDIR)/$$m.Pko ; fi" ; \
		if $(LD) -r -o $$m.ko $$m.o $$m.mod.o ; then $(ECHO) "$$m.ko: $$m.o $$m.mod.o" > $(DEPDIR)/$$m.Pko ; fi ; \
	done ; \
	touch stamp-kobjects
## AMDEP
else
## !AMDEP
stamp-kobjects: stamp-mobjects $(KERNEL_MODULES)
	@mods=`$(ECHO) " $? " | sed -r -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|(\.mod)?\.o | |g'` ; \
	for m in $$mods ; do \
		test :$$m != :stamp-mobjects || continue ; \
		$(ECHO) "$(LD) -r -o $$m.ko $$m.o $$m.mod.o" ; \
		$(LD) -r -o $$m.ko $$m.o $$m.mod.o ; \
	done ; \
	touch stamp-kobjects
## !AMDEP
endif

clean-kernel:
	@srcs=`$(ECHO) " $(KERNEL_MODULES) " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|\.o |.mod.c |g'` ; \
	objs=`$(ECHO) " $(KERNEL_MODULES) " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|\.o |.mod.o |g'` ; \
	mods=`$(ECHO) " $(KERNEL_MODULES) " | sed -e 's| lib[^[:space:]]*_a-| $(kpre)|g;s|\.o |.ko |g'` ; \
	$(ECHO) "rm -f -- stamp-modpost stamp-mobjects stamp-kobjects $$srcs $$objs $$mods" ; \
	rm -f -- stamp-modpost stamp-mobjects stamp-kobjects $$srcs $$objs $$mods

all-kernel: stamp-kobjects Modules.map

ALL_LOCAL 		+= all-kernel
CLEAN_LOCAL 		+= clean-kernel
DISTCLEANFILES		+= modpost.cache

## WITH_KO_MODULES
###################################################################################################
else
###################################################################################################
## !WITH_KO_MODULES

all-kernel: stamp-verobjs Modules.map

ALL_LOCAL 		+= all-kernel

## !WITH_KO_MODULES
###################################################################################################
endif

#STRIP_KERNEL_MODULES	= $(STRIP) --strip-debug -X -x
STRIP_KERNEL_MODULES	= $(STRIP) --strip-debug

##
# This is equivalent to the source rpm %install scriptlet, and is in fact invoked by that scriptlet.
# This is performed both for the install as well as the install-strip targets.  This simply installs
# and strips if required.  We use libtool to install even though these are not .la libraries but
# just objects.  We set kernel module stripping as above.
##
install-modules: $(KERNEL_MODULES)
	@$(NORMAL_INSTALL)
	$(mkinstalldirs) $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)
	@list=` $(ECHO) " $(KERNEL_MODULES) " | sed -r -e 's| [^[:space:]]*/| $(kpre)|g;s| lib[^[:space:]]*_a-| $(kpre)|g;s|\.(k)?o(\.gz)? |$(kext) |g'` ; for p in $$list ; do \
		$(ECHO) "$(LIBTOOL) --mode=install $(INSTALL) -m 644 $$p $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/$$p" ; \
		$(LIBTOOL) --mode=install $(INSTALL) -m 644 $$p $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/$$p ; \
		if test -n "$(INSTALL_STRIP_FLAG)" -a -n "$(STRIP_KERNEL_MODULES)" ; then \
			$(ECHO) "$(STRIP_KERNEL_MODULES) $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/$$p" ; \
			$(STRIP_KERNEL_MODULES) $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/$$p ; \
		fi ; \
		if test -n "$(COMPRESS_KERNEL_MODULES)" ; then \
			$(ECHO) "$(COMPRESS_KERNEL_MODULES) $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/$$p" ; \
			$(COMPRESS_KERNEL_MODULES) $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/$$p ; \
		fi ; \
	done

##
# This target creates symbolic links from the boot subdirectory to the appropriate kernel module.
# This is for the older-style modprobe with classes.  Therefore it is 2.4 specific.
##
install-preloads:
	$(mkinstalldirs) $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/boot
	@list=` $(ECHO) " $(KERNEL_PRELOADS) " | sed -r -e 's| [^[:space:]]*/| $(kpre)|g;s| lib[^[:space:]]*_a-| $(kpre)|g;s|\.(k)?o(\.gz)? |$(kext)$(kzip) |g'` ; for p in $$list ; do \
		test -f $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/$$p || continue ; \
		$(ECHO) "( cd $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/boot ; $(LN_S) -fn ../$$p . )" ; \
		( cd $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/boot ; $(LN_S) -fn ../$$p . ) ; \
	done

##
# This target installs the kernel module directory specific aliases file.  These files are only
# specific to the old modprobe and are therefore 2.4 specific.
##
install-modconf:
	$(mkinstalldirs) $(DESTDIR)$(kmoduledir)
	@test -f "$(KERNEL_MODCONF)" || exit 0 ; \
	$(ECHO) "$(INSTALL) -m 600 $(KERNEL_MODCONF) $(DESTDIR)$(kmoduledir)/modules.$(KMODCONF_EXT)" ; \
	$(INSTALL) -m 600 $(KERNEL_MODCONF) $(DESTDIR)$(kmoduledir)/modules.$(KMODCONF_EXT)

##
# For 2.6 kernels, we don't need modules.conf entries, because we put the character device file
# aliases directly into the kernel modules.  Preloads is another way around init scripts for things
# that should be loaded at boot time and only applies to the old insmod.  We normally install init
# scripts now.
##
# Note that for 2.4 kernels and SySV initscripts we used to put boot-time modprobe loadable modules
# into the /etc/modules file and the initscripts would load them with /etc/rc.d/rc.modules.  Now, at
# least on Mandrakelinux we need to place them in /etc/modprobe.preload for the same effect.
##
if WITH_KO_MODULES
PRE_INSTALL_AM		+= pre-modules
INSTALL			+= install-modules
else
PRE_INSTALL_AM		+= pre-modules pre-modconf
INSTALL_EXEC_LOCAL	+= install-modules install-preloads install-modconf
endif

##
# Unfortunately some recent non-autoconf/rpm releases have been mimicing our locations for placing
# kernel modules, so they could be anywhere.  This pre-installation scriptlet searches for any
# kernel modules by the same name as ours and simply removes them.
##
# A better and more thourough approach if a current modules.dep file exists is to walk through the
# dependency graph from each module and remove all modules that depend on that module as well.
##
pre-modules:
	@list=`$(ECHO) " $(KERNEL_MODULES) " | sed -r -e 's| [^[:space:]]*/| |g;s| lib[^[:space:]]*_a-| $(kpre)|g;s|\.(k)?o(\.gz)? | |g'` ; \
	for dir in $(DESTDIR)$(kmoduledir)/ $(DESTDIR)$(kmoduledir)/../preferred $(DESTDIR)$(kmoduledir)/../default $(DESTDIR)$(kmoduledir)/../boot ; do \
		test -d $$dir || continue ; \
		for m in `find $$dir \( -name 'streams*.o' -o -name 'streams*.ko' -o -name 'streams*.o.gz' -o -name 'streams*.ko.gz' \) 2>/dev/null` ; do \
			b=`echo $$m | sed -r -e 's|^.*/||;s|\.(k)?o(\.gz)? | |'` ; \
			case " $$list " in (*" $$b "*) $(ECHO) "rm -f -- $$m" ; rm -f -- $$m ;; (*) continue ;; esac ; \
		done ; \
		if test -f $$dir/modules.dep ; then \
			dep= ; while read line ; do \
				case $$line in \
					(*\)	line="`echo $$line | sed -e 's|\\$$||'`" ; \
						dep="$${dep:+$$dep }$$line" ; continue ;; \
					(*)	dep="$${dep:+$$dep }$$line" ;; \
				esac ; \
				set dummy $$dep ; \
				if test "$${2+set}" = "set" ; then \
					t=$$1 ; \
					target=target_`echo $$t | sed -r -e 's|^.*/||;s|\.(k)?o(\.gz)?(:)?$$||;s|[^a-zA-Z0-9_]|_|g'` ; \
					shift ; \
					for p in $$* ; do \
						prereq=prereq_`echo $$p | sed -r -e 's|^.*/||;s|\.(k)?o(\.gz)?(:)?$$||;s|[^a-zA-Z0-9_]|_|g'` ; \
						eval "$$prereq=\"\$${$$prereq:+\$$$$prereq }$$t" ; \
						eval "$$target=\"\$${$$target:+\$$$$target }$$p" ; \
					done ; \
				fi ; \
			done < $$dir/modules.dep ; \
		fi ; \
	done ; \
	expanded=0 ; \
	while test $$expanded != 0 ; do \
		for m in $$list ; do \
			for p in eval "\$prereq_`echo $t | sed -r -e 's|^.*/||;s|\.(k)?o(\.gz)?(:)?$||;s|[^a-zA-Z0-9_]|_|g'`" ; do \
				case " $$list " in \
					(*" $$p "*) continue ;; \
					(*) list="$$list $$p" ; expanded=1 ;; \
				esac ; \
			done ; \
		done ; \
	done ; \
	for m in $$list ; do \
		rm -f -- `find $(DESTDIR)$(kmoduledir)/.. \( -name $m.o -o -name $m.ko -o -name $m.o.gz -o -name $m.ko.gz \) 2>/dev/null` ; \
	done

pre-modconf:

##
# The post-modconf target checks for a fully configured install directory by checking for the
# existence of the /etc/modules.conf file in the target install directory $(DESTDIR).
##
# If it exists, then we are doing a non-rpm (autoconf) install and need to configure
# /etc/modules.conf in the target directory.  First we check if modules.conf has already been
# patched by looking for our include statement.  If we have already patched up the modules.conf
# file, we just leave it.
##
# If an adjustment needs to be made, we next check for an older non-rpm LiS distribution by checking
# for the tell-tale 'BEGIN LiS' string in modules.conf.  If there is an older non-rpm LiS, we remove
# any reference to any of our installable modules that may have previously been referenced in the
# modules.conf by LiS before proceeding.  We also need to force remove any kernel modules left by
# LiS in the misc modules subdirectory that have the same name as our installable modules.
##
# If we have a older rpm LiS or LfS distribution as indicated by the telltale lines in modules.conf,
# we must remove any references to our installable modules that may have previously been referenced
# in the modules.lis by LiS or modules.streams by LfS before proceeding.  We also need to force
# remove any kernel modules left by the older rpm LiS or LfS in the misc or streams subdirectory
# that have the same name as our installable modules.
##
# Lastly, we add our prune and include lines to the modules.conf file.  If we have a usable system
# map file and an executable depmod, we perform the depmod.
##
# This autoconf installation process has the side effect that upon uninstall of this package, any
# modules replaced from LiS or LfS will be lost.  A fresh install of the older LiS or LfS may be
# required to restore them.  Use current version of the openss7 autoconf/rpm LiS or LfS instead,
# please.
##
post-modconf:
	@test -f $(DESTDIR)$(sysconfdir)/modules.conf \
	   -a -f $(DESTDIR)$(kmoduledir)/modules.dep \
	   -a -f $(DESTDIR)$(kmoduledir)/modules.$(KMODCONF_EXT) || exit 0 ; \
	grep -q 'include.*modules.$(KMODCONF_EXT)' $(DESTDIR)$(sysconfdir)/modules.conf || exit 0 ; \
	cp -f $(DESTDIR)$(sysconfdir)/modules.conf $(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$ ; \
	if ( grep -q 'BEGIN LiS' $(DESTDIR)$(sysconfdir)/modules.conf ) ; then \
		list=` $(ECHO) " $(KERNEL_MODULES) " | sed -r -e 's| [^[:space:]]*/| |g;s| lib[^[:space:]]*_a-| $(kpre)|g;s|\.(k)?o(\.gz)? | |g'` ; for m in $$list ; do \
			p="$$m$(kext)$(kzip)" ; \
			sed -e "/$$m/d" $(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$ > $(DESTDIR)$(sysconfdir)/modules.conf.tmp.$$$$ ; \
			mv -f $(DESTDIR)$(sysconfdir)/modules.conf.tmp.$$$$ $(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$ ; \
			$(ECHO) "rm -f -- $(DESTDIR)$(kmoduledir)/misc/$$p" ; \
			rm -f -- $(DESTDIR)$(kmoduledir)/misc/$$p ; \
			$(ECHO) "rm -f -- $(DESTDIR)$(kmoduledir)/../preferred/misc/$$p" ; \
			rm -f -- $(DESTDIR)$(kmoduledir)/../preferred/misc/$$p ; \
			$(ECHO) "rm -f -- $(DESTDIR)$(kmoduledir)/../default/misc/$$p" ; \
			rm -f -- $(DESTDIR)$(kmoduledir)/../default/misc/$$p ; \
		done ; \
		$(ECHO) "rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/misc" ; \
		rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/misc ; \
		$(ECHO) "rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/../preferred/misc" ; \
		rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/../preferred/misc ; \
		$(ECHO) "rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/../default/misc" ; \
		rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/../default/misc ; \
	fi ; \
	if test "$(PACKAGE_TARNAME)" != "LiS" -a "$(PACKAGE_TARNAME)" != "streams" ; then \
		for ext in lis streams ; do \
			if ( grep -q "include.*modules.$$ext" $(DESTDIR)$(sysconfdir)/modules.conf ) ; then \
				if test -f $(DESTDIR)$(kmoduledir)/modules.$$ext ; then \
					cp -f $(DESTDIR)$(kmoduledir)/modules.$$ext $(DESTDIR)$(kmoduledir)/modules.$$ext.new.$$$$ ; \
					list=` $(ECHO) " $(KERNEL_MODULES) " | sed -r -e 's| [^[:space:]]*/| |g;s| lib[^[:space:]]*_a-| $(kpre)|g;s|\.(k)?o(\.gz)? | |g'` ; for m in $$list ; do \
						p="$$m$(kext)$(kzip)" ; \
						sed -e "/$$m/d" $(DESTDIR)$(kmoduledir)/modules.$$ext.new.$$$$ > $(DESTDIR)$(kmoduledir)/etc/modules.$$ext.tmp.$$$$ ; \
						mv -f $(DESTDIR)$(kmoduledir)/etc/modules.$$ext.tmp.$$$$ $(DESTDIR)$(kmoduledir)/modules.$$ext.new.$$$$ ; \
						for dir in misc lis streams ; do \
							$(ECHO) "rm -f -- $(DESTDIR)$(kmoduledir)/$$dir/$$p" ; \
							rm -f -- $(DESTDIR)$(kmoduledir)/$$dir/$$p ; \
							$(ECHO) "rm -f -- $(DESTDIR)$(kmoduledir)/../preferred/$$dir/$$p" ; \
							rm -f -- $(DESTDIR)$(kmoduledir)/../preferred/$$dir/$$p ; \
							$(ECHO) "rm -f -- $(DESTDIR)$(kmoduledir)/../default/$$dir/$$p" ; \
							rm -f -- $(DESTDIR)$(kmoduledir)/../default/$$dir/$$p ; \
						done ; \
					done ; \
					for dir in misc lis streams ; do \
						$(ECHO) "rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/$$dir" ; \
						rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/$$dir ; \
						$(ECHO) "rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/../preferred/$$dir" ; \
						rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/../preferred/$$dir ; \
						$(ECHO) "rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/../default/$$dir" ; \
						rmdir --ignore-fail-on-non-empty $(DESTDIR)$(kmoduledir)/../default/$$dir ; \
					done ; \
				fi ; \
				chmod --reference=$(DESTDIR)$(kmoduledir)/modules.$$ext $(DESTDIR)$(kmoduledir)/modules.$$ext.new.$$$$ ; \
				cp -fb --suffix=$$ext.bak $(DESTDIR)$(kmoduledir)/modules.$$ext.new.$$$$ $(DESTDIR)$(kmoduledir)/modules.$$ext ; \
				rm -f -- "$(DESTDIR)$(kmoduledir)/modules.$$ext.new.$$$$" ; \
			fi ; \
		done ; \
	fi ; \
	$(ECHO) 'prune modules.$(KMODCONF_EXT)' >> $(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$ ; \
	$(ECHO) 'if -f /lib/modules/`uname -r`/modules.$(KMODCONF_EXT)' >> $(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$ ; \
	$(ECHO) 'include /lib/modules/`uname -r`/modules.$(KMODCONF_EXT)' >> $(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$ ; \
	$(ECHO) 'endif' >> $(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$ ; \
	chmod --reference=$(DESTDIR)$(sysconfdir)/modules.conf $(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$ ; \
	cp -fb --suffix=.$(KMODCONF_EXT).bak $(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$ $(DESTDIR)$(sysconfdir)/modules.conf ; \
	rm -f -- "$(DESTDIR)$(sysconfdir)/modules.conf.new.$$$$"

##
# If we have preload modules defined, we are the first install, and we have the appropriate preload
# file (not all distros do), then we add our module names to the head of that file.  We do not worry
# about placing markers in the file as we do with modules.conf.
##
post-preload:
	@test -n "$(KERNEL_PRELOADS)" || exit 0 ; \
	list=` $(ECHO) " $(KERNEL_MODULES) " | sed -r -e 's| [^[:space:]]*/| |g;s| lib[^[:space:]]*_a-| $(kpre)|g;s|\.(k)?o(\.gz)? |$(kext)$(kzip) |g'` ; for p in $$list ; do \
		test `grep -l "/$$p:" $(DESTDIR)$(rootdir)/lib/modules/*/modules.dep | wc -l` -eq 0 || exit 0 ; \
	done ; \
	if test "$(kext)" = ".ko" ; \
	then prel_fil=$(DESTDIR)$(sysconfdir)/modprobe.preload ; \
	else prel_fil=$(DESTDIR)$(sysconfdir)/modules ; \
	fi ; \
	test -f $$prel_fil || exit 0 ; \
	cp -f $$prel_fil $$prel_fil.new.$$$$ ; \
	list='$(KERNEL_PRELOADS)' ; for p in $$list ; do \
		f=`$(ECHO) "$$p" | sed -e 's|\.o$$||'` ; \
		sed -e "/^$$f\>/d" $$prel_fil.new.$$$$ > $$prel_fil.tmp.$$$$ ; \
		mv -f $$prel_fil.tmp.$$$$ $$prel_fil.new.$$$$ ; \
		$(ECHO) "$$f" >> $$prel_fil.new.$$$$ ; \
	done ; \
	chmod --reference=$$prel_fil $$prel_fil.new.$$$$ ; \
	cp -fb --suffix=$$ext.bak $$prel_fil.new.$$$$ $$prel_fil ; \
	rm -f -- "$$prel_fil.new.$$$$"

##
# If we have a usable depmod command and the modules.dep file already exists in the modules
# directory, and the system map file is available, then perform the depmod on the modules.  We had
# to change the -ae flag to -Ae for compatibility with 2.5.48+, but that should not cause a problem
# (it should just run quicker).
##
post-depmod:
	@test -n "$(DEPMOD)" -a -x "$(DEPMOD)" -a -f "$(DESTDIR)$(kmoduledir)/modules.dep" -a -f "$(DESTDIR)$(rootdir)$(ksysmap)" || exit 0 ; \
	$(ECHO) "UNAME_MACHINE=$(target_cpu) $(DEPMOD) -Ae -b $(DESTDIR)$(rootdir)/ -C $$conf_fil -F $(DESTDIR)$(rootdir)$(ksysmap) $(kversion)" ; \
	UNAME_MACHINE=$(target_cpu) $(DEPMOD) -Ae -b $(DESTDIR)$(rootdir)/ -C $$conf_fil -F $(DESTDIR)$(rootdir)$(ksysmap) $(kversion)

##
# Pull the trick of linking /usr/src/PACKAGE_TARNAME to the source directory on autoconf installs.
# For rpm and debian installs, $(DESTDIR)$(rootdir)/usr/src does not exist (yet) in the rpm build
# directory, so this symbolic link is not made.
##
post-source:
	@test -d $(DESTDIR)$(rootdir)/usr/src || exit 0 ; \
	$(ECHO) "$(LN_S) -fn `(cd $(srcdir); pwd)` $(DESTDIR)$(rootdir)/usr/src/$(PACKAGE_TARNAME)" ; \
	$(LN_S) -fn `(cd $(srcdir); pwd)` $(DESTDIR)$(rootdir)/usr/src/$(PACKAGE_TARNAME)

##
# The post deprecated target checks for a configured target directory and the existence of the
# deprecated lksctp module and moves it as necessary.
##
post-deprecated:
	@test -f $(DESTDIR)$(kmoduledir)/modules.dep || exit 0 ; \
	test -e $(DESTDIR)$(kmoduledir)/net/sctp/sctp$(kext)$(kzip) || exit 0 ; \
	mv -f $(DESTDIR)$(kmoduledir)/net/sctp/sctp$(kext)$(kzip) $(DESTDIR)$(kmoduledir)/net/sctp/sctp_deprecated$(kext)$(kzip)

##
## These post- targets are equivalent to the kernel modules package rpm %post scriptlet for non-rpm
## (autoconf) installs.  It is only executed when the install directory is fully configured for
## kernel modules.  That is, this does not run when building an rpm because the binaries are
## installed in a temporary, unconfigured directory.  Autoconf has no post-install targets, so we
## hook this into the install target with install-exec-hook that runs after install-exec has
## completed.
##
if WITH_KO_MODULES
POST_INSTALL_AM		+= post-depmod post-source
else
POST_INSTALL_AM		+= post-modconf post-preload post-depmod post-source
endif

#POST_INSTALL_AM	+= post-deprecated

##
# There is no rpm equivalent for this target.  This simply removes kernel modules.  It is not
# invoked by rpm but is only used from the tarball uninstall.  We simply remove our modules and any
# preload links that were built (and possibly the directories that they are in).
##
uninstall-preload:
	@list=` $(ECHO) " $(KERNEL_PRELOADS) " | sed -r -e 's| [^[:space:]]*/| |g;s| lib[^[:space:]]*_a-| $(kpre)|g;s|\.(k)?o(\.gz)? |$(kext)$(kzip) |g'` ; for p in $$list ; do \
		$(ECHO_C)rm -f -- $(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/boot/$$p ; \
	done
	rmdir --ignore-fail-on-non-empty "$(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/boot"

uninstall-modules:
	@$(NORMAL_UNINSTALL)
	@list=` $(ECHO) " $(KERNEL_MODULES) " | sed -r -e 's| [^[:space:]]*/| |g;s| lib[^[:space:]]*_a-| $(kpre)|g;s|\.(k)?o(\.gz)? |$(kext)$(kzip) |g'` ; for p in $$list ; do \
		$(ECHO_C)$(LIBTOOL) --mode=uninstall rm -f -- "$(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)/$$p" ; \
	done
	rmdir --ignore-fail-on-non-empty "$(DESTDIR)$(kmoduledir)/$(KERNEL_SUBDIR)"

uninstall-modconf:
	rm -f -- "$(DESTDIR)$(kmoduledir)/modules.$(KMODCONF_EXT)"

if WITH_KO_MODULES
UNINSTALL_LOCAL		+= uninstall-modules
else
UNINSTALL_LOCAL		+= uninstall-preload uninstall-modules uninstall-modconf
endif

##
# The postun-modconf target checks for a fully configured uninstall directory by checking for the
# existence of the /etc/modules.conf file in the target uninstall directory $(DESTDIR).  It it
# exists, then we are doing a non-rpm (autoconf) uninstall and need to unconfigure modules.conf in
# the target directory.
##
# First which check if there are any remaning modules.ext files that belong to other kernel
# releases.  If there are, we do not remove the patch from modules.conf because it is still needed
# by the other kernels.  If there are not, the include patch is removed from the modules.conf file.
##
# It is not possible to restore any modules or associated modules.conf entries for non-rpm or older
# rpm LiS or LfS releases.  You need to reinstall those packages (if desired) to restore the removed
# modules and entries.  Use current versions of the openss7 autoconf/rpm LiS or LfS instead, please.
##
postun-modconf:
	@conf_fil=$(DESTDIR)$(sysconfdir)/modules.conf ; \
	test -f $$conf_fil || exit 0 ; \
	for f in $(DESTDIR)$(kmoduledir)/../*/modules.$(KMODCONF_EXT) ; do \
		test -f $$f || exit 0 ; break ; \
	done ; \
	conf_tmp="$${TMPDIR-/var/tmp}/modules.conf.tmp.$$$$" ; \
	conf_new="$${TMPDIR-/var/tmp}/modules.conf.new.$$$$" ; \
	cp -f -- $$conf_fil $$conf_new ; \
	sed -e '\|^include[[:space:]].*$(modutildir)/$(KMODCONF_EXT)|d' $$conf_new > $$conf_tmp ; \
	mv -f -- $$conf_tmp $$conf_new ; \
	echo "include $(modutildir)/$(KMODCONF_EXT)" >> $$conf_new ; \
	chmod --reference=$$conf_fil $$conf_new ; \
	cp -f -b --suffix=.$(KMODCONF_EXT).bak -- $$conf_new $$conf_fil ; \
	rm -f -- $$conf_new

##
# If we have preload modules defined, we are the last uninstall, and we have the appropriate preload
# file, then we remove our module names from that file.  Determining the uninstall is a little more
# complicated because .ko modules do not have modconf files, so we need to look in the modules.dep
# file for a dependency including one of our modules.
##
postun-preload:
	@test -n "$(KERNEL_PRELOADS)" || exit 0 ; \
	mods=` $(ECHO) " $(KERNEL_MODULES) " | sed -r -e 's| [^[:space:]]*/| |g;s| lib[^[:space:]]*_a-| $(kpre)|g;s|\.(k)?o(\.gz)? |$(kext)$(kzip) |g'` ; for p in $$mods ; do \
		test `grep -l "/$$p:" $(DESTDIR)$(rootdir)/lib/modules/*/modules.dep | wc -l` -eq 0 || exit 0 ; \
	done ; \
	if test "$(kext)" = ".ko" ; \
	then prel_fil=$(DESTDIR)$(sysconfdir)/modprobe.preload ; \
	else prel_fil=$(DESTDIR)$(sysconfdir)/modules ; \
	fi ; \
	test -f $$prel_fil || exit 0 ; \
	prel_tmp="${TMPDIR-/var/tmp}/modules.tmp.$$$$" ; \
	prel_new="${TMPDIR-/var/tmp}/modules.new.$$$$" ; \
	cp -f -- $$prel_fil $$prel_new ; \
	mods='$(KERNEL_PRELOADS)' ; for p in $$mods ; do \
		m=`$(ECHO) $$p | sed -e 's|\.o$$||'` ; \
		sed -e '\|^[[:space:]]*'"$$m"'[[:space:]]*$$|d' $$prel_new > $$prel_tmp ; \
		mv -f -- $$prel_tmp $$prel_new ; \
	done ; \
	chmod --reference=$$prel_fil -- $$prel_new ; \
	cp -fb --suffix=$(KMODCONF_EXT).bak -- $$prel_new $$prel_fil ; \
	rm -f -- $$prel_new

##
# If we have a usable system map file and an executable depmod, we perform the depmod.
##
# We run depmod -Ae instead of -ae on autoconf install because installed files have current
# timestamps.  For rpm intalls, installed binary files have original timestamps and -Ae will not
# result in updated files.
##
postun-depmod:
	@test -n "$(DEPMOD)" -a -x "$(DEPMOD)" -a -f "$(DESTDIR)$(kmoduledir)/modules.dep" -a -f "$(DESTDIR)$(rootdir)$(ksysmap)" || exit 0 ; \
	$(ECHO) "UNAME_MACHINE=$(target_cpu) $(DEPMOD) -Ae -b $(DESTDIR)$(rootdir)/ -C $$conf_fil -F $(DESTDIR)$(rootdir)$(ksysmap) $(kversion)" ; \
	UNAME_MACHINE=$(target_cpu) $(DEPMOD) -Ae -b $(DESTDIR)$(rootdir)/ -C $$conf_fil -F $(DESTDIR)$(rootdir)$(ksysmap) $(kversion)

postun-source:
	rm -f -- "$(DESTDIR)$(rootdir)/usr/src/$(PACKAGE_TARNAME)"

##
# If we moved the deprecated lksctp module on install, we move it back on uninstall.
##
postun-deprecated:
	@test -f $(DESTDIR)$(kmoduledir)/modules.dep || exit 0 ; \
	test -e $(DESTDIR)$(kmoduledir)/kernel/net/sctp/sctp_deprecated$(kext)$(kzip) || exit 0 ; \
	$(ECHO) "mv -f $(DESTDIR)$(kmoduledir)/kernel/net/sctp/sctp_deprecated$(kext)$(kzip) $(DESTDIR)$(kmoduledir)/kernel/net/sctp/sctp$(kext)$(kzip)" ; \
	mv -f $(DESTDIR)$(kmoduledir)/kernel/net/sctp/sctp_deprecated$(kext)$(kzip) $(DESTDIR)$(kmoduledir)/kernel/net/sctp/sctp$(kext)$(kzip)

##
# This is equivalent to the kernel modules package rpm %postun scriptlet.  It is only executed when
# the uninstall directory is fully configured for kernel modules.  That is, this does not run when
# building an rpm because the binaries are not uninstalled (they are usually just removed
# wholesale).  Autoconf has no post-uninstall targets, so we hook this into the uninstall-hook that
# runs after uninstall has completed.
##
if WITH_KO_MODULES
POST_UNINSTALL_AM	+= postun-depmod postun-source
else
POST_UNINSTALL_AM	+= postun-modconf postun-preload postun-depmod postun-source
endif

#POST_UNINSTALL_AM	+= postun-deprecated

##
# Checking for undefined symbols is rather pointless on .ko objects.  The reason is that these must
# have been checked when we were performing modpost on the .ko objects anyway.  But we let them run
# here in the check target anyway.
##
if PERFORM_CHECKS
## PERFORM_CHECKS
dist_check_SCRIPTS	+= $(top_srcdir)/scripts/check_modules
TESTS_ENVIRONMENT 	+= DESTDIR='$(DESTDIR)' \
			   ksysmap='$(ksysmap)' \
			   KERNEL_MODULES='$(KERNEL_MODULES)' \
			   KERNEL_MODMAPS='$(KERNEL_MODMAPS)'
CLEANFILES		+= check_modules.log
DISTCLEANFILES		+= *.err *.out
## PERFORM_CHECKS
endif

## PKG_BUILD_ARCH
endif
## RPM_BUILD_KERNEL
endif

dist_noinst_SCRIPTS	+= scripts/cflagcheck $(top_srcdir)/scripts/modpost.sh
EXTRA_SCRIPTS		+= scripts/cflagcheck

## vim: ft=automake
