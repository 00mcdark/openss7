/*****************************************************************************

 @(#) src/snmp/megacoMIB.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] = "src/snmp/megacoMIB.c (" PACKAGE_ENVR ") " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NETSNMP_MEMDUP
#include "ucd_memdup.h"
#endif
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "megacoMIB.h"
#define MASTER 1
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "megacoMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int megacoMIB_refresh = 1;
volatile int medGwyLinkIdTable_refresh = 1;
volatile int medGwyGatewayConfigTable_refresh = 1;
volatile int medGwyGatewayControllerTable_refresh = 1;
volatile int medGwyGatewayStatsTable_refresh = 1;
volatile int medGwyTermIdTable_refresh = 1;
volatile int medGwyTerminationsTable_refresh = 1;
volatile int medGwyPropertyProfileTable_refresh = 1;

/*
 * megacoMIB_variables_oid: object identifier for megacoMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid megacoMIB_variables_oid[7] = { 1, 3, 6, 1, 2, 1, 1000 };
oid medGwyGatewayConfigTable_variables_oid[11] = { 1, 3, 6, 1, 2, 1, 1000, 1, 1, 2, 1 };
oid medGwyTerminationsTable_variables_oid[11] = { 1, 3, 6, 1, 2, 1, 1000, 1, 3, 2, 1 };
oid medGwyPropertyProfileTable_variables_oid[11] = { 1, 3, 6, 1, 2, 1, 1000, 1, 3, 3, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid medGwyLinkStatusChange_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 2, 0, 1 };
oid medGwyInvalidControllerAddress_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 2, 0, 2 };
oid medGwyInvalidTerminationId_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 2, 0, 3 };
oid medGwyInvalidPackageElement_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 2, 0, 4 };
oid medGwyTerminationStatusChange_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 2, 0, 5 };
oid medGwyGatewayHandoff_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 2, 0, 6 };
oid medGwyProtocolError_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 2, 0, 7 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid medGwyReceivedElement_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 2, 1, 1 };

/*
 * Other oids defined in this MIB.
 */
oid medGwyCompliance_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 3, 1, 1 };
oid medGwyConfigGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 3, 2, 1 };
oid medGwyStatsGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 3, 2, 2 };
oid medGwyGWControllerGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 3, 2, 3 };
oid medGwyNextIdGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 3, 2, 4 };
oid medGwyNotificationsGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 3, 2, 5 };
oid medGwyTerminationGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 1000, 3, 2, 6 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 megacoMIB_variables: tree for megacoMIB
 * This variable defines function callbacks and type return information for the megacoMIB mib section
 */
struct variable7 megacoMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   MEDGWYNEXTLINKID      1
	{(u_char) MEDGWYNEXTLINKID, ASN_INTEGER, RWRITE, var_medGwyLinkIdTable, 5, {1, 1, 1, 1, 1}},
#define   MEDGWYGATEWAYLINKNAME  2
	{(u_char) MEDGWYGATEWAYLINKNAME, ASN_OCTET_STR, RWRITE, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 3}},
#define   MEDGWYGATEWAYIPADDRESS  3
	{(u_char) MEDGWYGATEWAYIPADDRESS, ASN_IPADDRESS, RWRITE, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 4}},
#define   MEDGWYGATEWAYPORT     4
	{(u_char) MEDGWYGATEWAYPORT, ASN_INTEGER, RWRITE, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 5}},
#define   MEDGWYGATEWAYENCODINGSCHEME  5
	{(u_char) MEDGWYGATEWAYENCODINGSCHEME, ASN_INTEGER, RWRITE, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 6}},
#define   MEDGWYGATEWAYPROTOCOL  6
	{(u_char) MEDGWYGATEWAYPROTOCOL, ASN_INTEGER, RWRITE, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 7}},
#define   MEDGWYGATEWAYSIGNALINGTPTPROTOCOL  7
	{(u_char) MEDGWYGATEWAYSIGNALINGTPTPROTOCOL, ASN_INTEGER, RWRITE, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 8}},
#define   MEDGWYGATEWAYADMINSTATUS  8
	{(u_char) MEDGWYGATEWAYADMINSTATUS, ASN_INTEGER, RWRITE, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 9}},
#define   MEDGWYGATEWAYOPERSTATUS  9
	{(u_char) MEDGWYGATEWAYOPERSTATUS, ASN_INTEGER, RONLY, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 10}},
#define   MEDGWYGATEWAYLASTSTATUSCHANGE  10
	{(u_char) MEDGWYGATEWAYLASTSTATUSCHANGE, ASN_TIMETICKS, RONLY, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 11}},
#define   MEDGWYGATEWAYRESETSTATISTICS  11
	{(u_char) MEDGWYGATEWAYRESETSTATISTICS, ASN_INTEGER, RWRITE, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 12}},
#define   MEDGWYGATEWAYROWSTATUS  12
	{(u_char) MEDGWYGATEWAYROWSTATUS, ASN_INTEGER, RWRITE, var_medGwyGatewayConfigTable, 5, {1, 1, 2, 1, 13}},
#define   MEDGWYGATEWAYCONTROLLERIPADDRESS  13
	{(u_char) MEDGWYGATEWAYCONTROLLERIPADDRESS, ASN_IPADDRESS, RWRITE, var_medGwyGatewayControllerTable, 5, {1, 1, 3, 1, 2}},
#define   MEDGWYGATEWAYCONTROLLERPORT  14
	{(u_char) MEDGWYGATEWAYCONTROLLERPORT, ASN_INTEGER, RWRITE, var_medGwyGatewayControllerTable, 5, {1, 1, 3, 1, 3}},
#define   MEDGWYGATEWAYCONTROLLERADMINSTATUS  15
	{(u_char) MEDGWYGATEWAYCONTROLLERADMINSTATUS, ASN_INTEGER, RWRITE, var_medGwyGatewayControllerTable, 5, {1, 1, 3, 1, 4}},
#define   MEDGWYGATEWAYCONTROLLEROPERSTATUS  16
	{(u_char) MEDGWYGATEWAYCONTROLLEROPERSTATUS, ASN_INTEGER, RONLY, var_medGwyGatewayControllerTable, 5, {1, 1, 3, 1, 5}},
#define   MEDGWYGATEWAYNUMINMESSAGES  17
	{(u_char) MEDGWYGATEWAYNUMINMESSAGES, ASN_UNSIGNED, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 1}},
#define   MEDGWYGATEWAYNUMINOCTETS  18
	{(u_char) MEDGWYGATEWAYNUMINOCTETS, ASN_UNSIGNED, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 2}},
#define   MEDGWYGATEWAYNUMOUTMESSAGES  19
	{(u_char) MEDGWYGATEWAYNUMOUTMESSAGES, ASN_UNSIGNED, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 3}},
#define   MEDGWYGATEWAYNUMOUTOCTETS  20
	{(u_char) MEDGWYGATEWAYNUMOUTOCTETS, ASN_UNSIGNED, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 4}},
#define   MEDGWYGATEWAYNUMERRORS  21
	{(u_char) MEDGWYGATEWAYNUMERRORS, ASN_UNSIGNED, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 5}},
#define   MEDGWYGATEWAYNUMTIMERRECOVERY  22
	{(u_char) MEDGWYGATEWAYNUMTIMERRECOVERY, ASN_UNSIGNED, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 6}},
#define   MEDGWYGATEWAYTRANSPORTNUMLOSSES  23
	{(u_char) MEDGWYGATEWAYTRANSPORTNUMLOSSES, ASN_UNSIGNED, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 7}},
#define   MEDGWYGATEWAYTRANSPORTNUMSWITCHOVER  24
	{(u_char) MEDGWYGATEWAYTRANSPORTNUMSWITCHOVER, ASN_UNSIGNED, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 8}},
#define   MEDGWYGATEWAYTRANSPORTTOTALNUMALARMS  25
	{(u_char) MEDGWYGATEWAYTRANSPORTTOTALNUMALARMS, ASN_UNSIGNED, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 9}},
#define   MEDGWYGATEWAYTRANSPORTLASTEVENT  26
	{(u_char) MEDGWYGATEWAYTRANSPORTLASTEVENT, ASN_INTEGER, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 10}},
#define   MEDGWYGATEWAYTRANSPORTLASTEVENTTIME  27
	{(u_char) MEDGWYGATEWAYTRANSPORTLASTEVENTTIME, ASN_TIMETICKS, RWRITE, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 11}},
#define   MEDGWYGATEWAYLASTSTATISTICSRESET  28
	{(u_char) MEDGWYGATEWAYLASTSTATISTICSRESET, ASN_TIMETICKS, RONLY, var_medGwyGatewayStatsTable, 5, {1, 2, 1, 1, 12}},
#define   MEDGWYNEXTTERMINATIONID  29
	{(u_char) MEDGWYNEXTTERMINATIONID, ASN_INTEGER, RWRITE, var_medGwyTermIdTable, 5, {1, 3, 1, 1, 1}},
#define   MEDGWYTERMINATIONNAME  30
	{(u_char) MEDGWYTERMINATIONNAME, ASN_OCTET_STR, RWRITE, var_medGwyTerminationsTable, 5, {1, 3, 2, 1, 2}},
#define   MEDGWYTERMINATIONADMINSTATUS  31
	{(u_char) MEDGWYTERMINATIONADMINSTATUS, ASN_INTEGER, RWRITE, var_medGwyTerminationsTable, 5, {1, 3, 2, 1, 3}},
#define   MEDGWYTERMINATIONOPERSTATUS  32
	{(u_char) MEDGWYTERMINATIONOPERSTATUS, ASN_INTEGER, RWRITE, var_medGwyTerminationsTable, 5, {1, 3, 2, 1, 4}},
#define   MEDGWYTERMINATIONINTERFACEIDENTIFIER  33
	{(u_char) MEDGWYTERMINATIONINTERFACEIDENTIFIER, ASN_INTEGER, RWRITE, var_medGwyTerminationsTable, 5, {1, 3, 2, 1, 5}},
#define   MEDGWYTERMINATIONPROPERTYPROFILEID  34
	{(u_char) MEDGWYTERMINATIONPROPERTYPROFILEID, ASN_UNSIGNED, RWRITE, var_medGwyTerminationsTable, 5, {1, 3, 2, 1, 6}},
#define   MEDGWYTERMINATIONROWSTATUS  35
	{(u_char) MEDGWYTERMINATIONROWSTATUS, ASN_INTEGER, RWRITE, var_medGwyTerminationsTable, 5, {1, 3, 2, 1, 7}},
#define   MEDGWYPROPERTYPROFILEPROPERTY  36
	{(u_char) MEDGWYPROPERTYPROFILEPROPERTY, ASN_OBJECT_ID, RWRITE, var_medGwyPropertyProfileTable, 5, {1, 3, 3, 1, 3}},
#define   MEDGWYTERMPROPERTYPROFILESTATUS  37
	{(u_char) MEDGWYTERMPROPERTYPROFILESTATUS, ASN_INTEGER, RWRITE, var_medGwyPropertyProfileTable, 5, {1, 3, 3, 1, 4}},
};

/* (L = length of the oidsuffix) */
struct megacoMIB_data *megacoMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *medGwyLinkIdTableStorage = NULL;
struct header_complex_index *medGwyGatewayConfigTableStorage = NULL;
struct header_complex_index *medGwyGatewayControllerTableStorage = NULL;
struct header_complex_index *medGwyGatewayStatsTableStorage = NULL;
struct header_complex_index *medGwyTermIdTableStorage = NULL;
struct header_complex_index *medGwyTerminationsTableStorage = NULL;
struct header_complex_index *medGwyPropertyProfileTableStorage = NULL;

void (*megacoMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void megacoMIB_loop_handler(int);
void megacoMIB_fd_handler(int, void *);

/**
 * @fn void init_megacoMIB(void)
 * @brief megacoMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (megacoMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_megacoMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("megacoMIB", "init_megacoMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("megacoMIB", megacoMIB_variables, variable7, megacoMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_megacoMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("megacoMIB", parse_megacoMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("medGwyLinkIdTable", parse_medGwyLinkIdTable, NULL, "HELP STRING");
	snmpd_register_config_handler("medGwyGatewayConfigTable", parse_medGwyGatewayConfigTable, NULL, "HELP STRING");
	snmpd_register_config_handler("medGwyGatewayControllerTable", parse_medGwyGatewayControllerTable, NULL, "HELP STRING");
	snmpd_register_config_handler("medGwyGatewayStatsTable", parse_medGwyGatewayStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("medGwyTermIdTable", parse_medGwyTermIdTable, NULL, "HELP STRING");
	snmpd_register_config_handler("medGwyTerminationsTable", parse_medGwyTerminationsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("medGwyPropertyProfileTable", parse_medGwyPropertyProfileTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_megacoMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_medGwyLinkIdTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_medGwyGatewayConfigTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_medGwyGatewayControllerTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_medGwyGatewayStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_medGwyTermIdTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_medGwyTerminationsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_medGwyPropertyProfileTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, megacoMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, megacoMIB_fd_handler, (void *) 1);
	}
	megacoMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &megacoMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/**
 * @fn void deinit_megacoMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (megacoMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_megacoMIB(void)
{
	DEBUGMSGTL(("megacoMIB", "deinit_megacoMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = megacoMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(megacoMIB_variables_oid, sizeof(megacoMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("megacoMIB");
	snmpd_unregister_config_handler("medGwyLinkIdTable");
	snmpd_unregister_config_handler("medGwyGatewayConfigTable");
	snmpd_unregister_config_handler("medGwyGatewayControllerTable");
	snmpd_unregister_config_handler("medGwyGatewayStatsTable");
	snmpd_unregister_config_handler("medGwyTermIdTable");
	snmpd_unregister_config_handler("medGwyTerminationsTable");
	snmpd_unregister_config_handler("medGwyPropertyProfileTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

int
term_megacoMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("megacoMIB", "term_megacoMIB: terminating...  "));
	deinit_megacoMIB();
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct megacoMIB_data *megacoMIB_create(void)
 * @brief create a fresh data structure representing scalars in megacoMIB.
 *
 * Creates a new megacoMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in megacoMIB.
 */
struct megacoMIB_data *
megacoMIB_create(void)
{
	struct megacoMIB_data *StorageNew = SNMP_MALLOC_STRUCT(megacoMIB_data);

	DEBUGMSGTL(("megacoMIB", "megacoMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */

	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	megacoMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct megacoMIB_data *megacoMIB_duplicate(struct megacoMIB_data *thedata)
 * @param thedata the mib structure to duplicate
 * @brief duplicate a mib structure for the mib
 *
 * Duplicates the specified mib structure @param thedata and returns a pointer to the newly
 * allocated mib structure on success, or NULL on failure.
 */
struct megacoMIB_data *
megacoMIB_duplicate(struct megacoMIB_data *thedata)
{
	struct megacoMIB_data *StorageNew = SNMP_MALLOC_STRUCT(megacoMIB_data);

	DEBUGMSGTL(("megacoMIB", "megacoMIB_duplicate: duplicating mib... "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	megacoMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int megacoMIB_destroy(struct megacoMIB_data **thedata)
 * @param thedata pointer to the data structure in megacoMIB.
 * @brief delete a scalars structure from megacoMIB.
 *
 * Frees scalars that were previously removed from megacoMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
megacoMIB_destroy(struct megacoMIB_data **thedata)
{
	struct megacoMIB_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "megacoMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int megacoMIB_add(struct megacoMIB_data *thedata)
 * @param thedata the structure representing megacoMIB scalars.
 * @brief adds node to the megacoMIB scalar data set.
 *
 * Adds a scalar structure to the megacoMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
megacoMIB_add(struct megacoMIB_data *thedata)
{
	DEBUGMSGTL(("megacoMIB", "megacoMIB_add: adding data...  "));
	if (thedata)
		megacoMIBStorage = thedata;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_megacoMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for megacoMIB entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case megacoMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_megacoMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct megacoMIB_data *StorageTmp = megacoMIB_create();

	DEBUGMSGTL(("megacoMIB", "parse_megacoMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	megacoMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/*
 * store_megacoMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_megacoMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct megacoMIB_data *StorageTmp;

	DEBUGMSGTL(("megacoMIB", "store_megacoMIB: storing data...  "));
	refresh_megacoMIB(1);
	if ((StorageTmp = megacoMIBStorage) == NULL) {
		DEBUGMSGTL(("megacoMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "megacoMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_megacoMIB(struct megacoMIB_data *StorageTmp, struct megacoMIB_data *StorageOld)
 * @param StorageTmp the data as updated
 * @param StorageOld the data previous to update
 *
 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
 * made for setting values that were not in the varbinds.
 */
int
check_megacoMIB(struct megacoMIB_data *StorageTmp, struct megacoMIB_data *StorageOld)
{
	/* XXX: provide code to check the scalars for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_megacoMIB(struct megacoMIB_data *StorageTmp, struct megacoMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase)
 *
 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
 * consistency already checked (see check_megacoMIB()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the mib were applied: the values in StorageTmp are the new values.
 */
int
update_megacoMIB(struct megacoMIB_data *StorageTmp, struct megacoMIB_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	megacoMIB_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn revert_megacoMIB(struct 
 * @fn void revert_megacoMIB(struct megacoMIB_data *StorageTmp, struct megacoMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase)
 */
void
revert_megacoMIB(struct megacoMIB_data *StorageTmp, struct megacoMIB_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_megacoMIB(StorageOld, NULL);
}

/**
 * @fn void refresh_megacoMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of megacoMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_megacoMIB(int force)
{
	if (megacoMIBStorage == NULL) {
		struct megacoMIB_data *StorageNew;

		if ((StorageNew = megacoMIB_create()) == NULL)
			return;
		megacoMIBStorage = StorageNew;
		megacoMIB_refresh = 1;
	}
	if (!force && megacoMIB_refresh == 0)
		return;
	DEBUGMSGTL(("megacoMIB", "refresh_megacoMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	megacoMIB_refresh = 0;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/**
 * @fn u_char * var_megacoMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in megacoMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_megacoMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct megacoMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("megacoMIB", "var_megacoMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_megacoMIB(0);
	if ((StorageTmp = megacoMIBStorage) == NULL) {
		DEBUGMSGTL(("megacoMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("megacoMIB", "found.\n"));
	else
		DEBUGMSGTL(("megacoMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct medGwyLinkIdTable_data *medGwyLinkIdTable_create(void)
 * @brief create a fresh data structure representing a new row in the medGwyLinkIdTable table.
 *
 * Creates a new medGwyLinkIdTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct medGwyLinkIdTable_data *
medGwyLinkIdTable_create(void)
{
	struct medGwyLinkIdTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyLinkIdTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyLinkIdTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->medGwyGatewayId = 0;
		StorageNew->medGwyNextLinkId = 0;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	medGwyLinkIdTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct medGwyLinkIdTable_data *medGwyLinkIdTable_duplicate(struct medGwyLinkIdTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct medGwyLinkIdTable_data *
medGwyLinkIdTable_duplicate(struct medGwyLinkIdTable_data *thedata)
{
	struct medGwyLinkIdTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyLinkIdTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyLinkIdTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->medGwyLinkIdTable_id = thedata->medGwyLinkIdTable_id;
		StorageNew->medGwyGatewayId = thedata->medGwyGatewayId;
		StorageNew->medGwyNextLinkId = thedata->medGwyNextLinkId;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	medGwyLinkIdTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int medGwyLinkIdTable_destroy(struct medGwyLinkIdTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
medGwyLinkIdTable_destroy(struct medGwyLinkIdTable_data **thedata)
{
	struct medGwyLinkIdTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyLinkIdTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyLinkIdTable_add(struct medGwyLinkIdTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the medGwyLinkIdTable table data set.
 *
 * Adds a table row structure to the medGwyLinkIdTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
medGwyLinkIdTable_add(struct medGwyLinkIdTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("megacoMIB", "medGwyLinkIdTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* medGwyGatewayId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayId, sizeof(thedata->medGwyGatewayId));
		header_complex_add_data(&medGwyLinkIdTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("megacoMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyLinkIdTable_del(struct medGwyLinkIdTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the medGwyLinkIdTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
medGwyLinkIdTable_del(struct medGwyLinkIdTable_data *thedata)
{
	struct medGwyLinkIdTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyLinkIdTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(medGwyLinkIdTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&medGwyLinkIdTableStorage, hciptr);
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_medGwyLinkIdTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for medGwyLinkIdTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case medGwyLinkIdTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_medGwyLinkIdTable(const char *token, char *line)
{
	size_t tmpsize;
	struct medGwyLinkIdTable_data *StorageTmp = medGwyLinkIdTable_create();

	DEBUGMSGTL(("megacoMIB", "parse_medGwyLinkIdTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyNextLinkId, &tmpsize);
	medGwyLinkIdTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/*
 * store_medGwyLinkIdTable(): store configuraiton file for medGwyLinkIdTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_medGwyLinkIdTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct medGwyLinkIdTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("megacoMIB", "store_medGwyLinkIdTable: storing data...  "));
	refresh_medGwyLinkIdTable(1);
	(void) tmpsize;
	for (hcindex = medGwyLinkIdTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct medGwyLinkIdTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "medGwyLinkIdTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyNextLinkId, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct medGwyGatewayConfigTable_data *medGwyGatewayConfigTable_create(void)
 * @brief create a fresh data structure representing a new row in the medGwyGatewayConfigTable table.
 *
 * Creates a new medGwyGatewayConfigTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct medGwyGatewayConfigTable_data *
medGwyGatewayConfigTable_create(void)
{
	struct medGwyGatewayConfigTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyGatewayConfigTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayConfigTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->medGwyGatewayLinkName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->medGwyGatewayLinkNameLen = 0;
		StorageNew->medGwyGatewayLinkName[StorageNew->medGwyGatewayLinkNameLen] = 0;
		StorageNew->medGwyGatewayIPAddress = (u_char *) "\x00\x00\x00\x00";
		StorageNew->medGwyGatewayIPAddressLen = 4;
		StorageNew->medGwyGatewayPort = 2944;
		StorageNew->medGwyGatewayEncodingScheme = MEDGWYGATEWAYENCODINGSCHEME_TEXT;
		StorageNew->medGwyGatewayProtocol = 0;
		StorageNew->medGwyGatewaySignalingTptProtocol = 0;
		StorageNew->medGwyGatewayAdminStatus = 0;
		StorageNew->medGwyGatewayOperStatus = 0;
		StorageNew->medGwyGatewayLastStatusChange = 0;
		StorageNew->medGwyGatewayResetStatistics = 0;
		StorageNew->medGwyGatewayRowStatus = 0;
		StorageNew->medGwyGatewayRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	medGwyGatewayConfigTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct medGwyGatewayConfigTable_data *medGwyGatewayConfigTable_duplicate(struct medGwyGatewayConfigTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct medGwyGatewayConfigTable_data *
medGwyGatewayConfigTable_duplicate(struct medGwyGatewayConfigTable_data *thedata)
{
	struct medGwyGatewayConfigTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyGatewayConfigTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayConfigTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->medGwyGatewayConfigTable_id = thedata->medGwyGatewayConfigTable_id;
		StorageNew->medGwyGatewayId = thedata->medGwyGatewayId;
		StorageNew->medGwyGatewayLinkId = thedata->medGwyGatewayLinkId;
		if (!(StorageNew->medGwyGatewayLinkName = malloc(thedata->medGwyGatewayLinkNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->medGwyGatewayLinkName, thedata->medGwyGatewayLinkName, thedata->medGwyGatewayLinkNameLen);
		StorageNew->medGwyGatewayLinkNameLen = thedata->medGwyGatewayLinkNameLen;
		StorageNew->medGwyGatewayLinkName[StorageNew->medGwyGatewayLinkNameLen] = 0;
		if (!(StorageNew->medGwyGatewayIPAddress = malloc(thedata->medGwyGatewayIPAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->medGwyGatewayIPAddress, thedata->medGwyGatewayIPAddress, thedata->medGwyGatewayIPAddressLen);
		StorageNew->medGwyGatewayIPAddressLen = thedata->medGwyGatewayIPAddressLen;
		StorageNew->medGwyGatewayIPAddress[StorageNew->medGwyGatewayIPAddressLen] = 0;
		StorageNew->medGwyGatewayPort = thedata->medGwyGatewayPort;
		StorageNew->medGwyGatewayEncodingScheme = thedata->medGwyGatewayEncodingScheme;
		StorageNew->medGwyGatewayProtocol = thedata->medGwyGatewayProtocol;
		StorageNew->medGwyGatewaySignalingTptProtocol = thedata->medGwyGatewaySignalingTptProtocol;
		StorageNew->medGwyGatewayAdminStatus = thedata->medGwyGatewayAdminStatus;
		StorageNew->medGwyGatewayOperStatus = thedata->medGwyGatewayOperStatus;
		StorageNew->medGwyGatewayLastStatusChange = thedata->medGwyGatewayLastStatusChange;
		StorageNew->medGwyGatewayResetStatistics = thedata->medGwyGatewayResetStatistics;
		StorageNew->medGwyGatewayRowStatus = thedata->medGwyGatewayRowStatus;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	medGwyGatewayConfigTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int medGwyGatewayConfigTable_destroy(struct medGwyGatewayConfigTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
medGwyGatewayConfigTable_destroy(struct medGwyGatewayConfigTable_data **thedata)
{
	struct medGwyGatewayConfigTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayConfigTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->medGwyGatewayLinkName);
		StorageDel->medGwyGatewayLinkNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyGatewayConfigTable_add(struct medGwyGatewayConfigTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the medGwyGatewayConfigTable table data set.
 *
 * Adds a table row structure to the medGwyGatewayConfigTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
medGwyGatewayConfigTable_add(struct medGwyGatewayConfigTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayConfigTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* medGwyGatewayId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayId, sizeof(thedata->medGwyGatewayId));
		/* medGwyGatewayLinkId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayLinkId, sizeof(thedata->medGwyGatewayLinkId));
		header_complex_add_data(&medGwyGatewayConfigTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("megacoMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyGatewayConfigTable_del(struct medGwyGatewayConfigTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the medGwyGatewayConfigTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
medGwyGatewayConfigTable_del(struct medGwyGatewayConfigTable_data *thedata)
{
	struct medGwyGatewayConfigTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayConfigTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(medGwyGatewayConfigTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&medGwyGatewayConfigTableStorage, hciptr);
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_medGwyGatewayConfigTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for medGwyGatewayConfigTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case medGwyGatewayConfigTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_medGwyGatewayConfigTable(const char *token, char *line)
{
	size_t tmpsize;
	struct medGwyGatewayConfigTable_data *StorageTmp = medGwyGatewayConfigTable_create();

	DEBUGMSGTL(("megacoMIB", "parse_medGwyGatewayConfigTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayLinkId, &tmpsize);
	SNMP_FREE(StorageTmp->medGwyGatewayLinkName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->medGwyGatewayLinkName, &StorageTmp->medGwyGatewayLinkNameLen);
	if (StorageTmp->medGwyGatewayLinkName == NULL) {
		config_perror("invalid specification for medGwyGatewayLinkName");
		return;
	}
	SNMP_FREE(StorageTmp->medGwyGatewayIPAddress);
	line = read_config_read_data(ASN_IPADDRESS, line, &StorageTmp->medGwyGatewayIPAddress, &StorageTmp->medGwyGatewayIPAddressLen);
	if (StorageTmp->medGwyGatewayIPAddress == NULL) {
		config_perror("invalid specification for medGwyGatewayIPAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayPort, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayEncodingScheme, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayProtocol, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewaySignalingTptProtocol, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayAdminStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayOperStatus, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->medGwyGatewayLastStatusChange, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayResetStatistics, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayRowStatus, &tmpsize);
	medGwyGatewayConfigTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/*
 * store_medGwyGatewayConfigTable(): store configuraiton file for medGwyGatewayConfigTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_medGwyGatewayConfigTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct medGwyGatewayConfigTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("megacoMIB", "store_medGwyGatewayConfigTable: storing data...  "));
	refresh_medGwyGatewayConfigTable(1);
	(void) tmpsize;
	for (hcindex = medGwyGatewayConfigTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct medGwyGatewayConfigTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "medGwyGatewayConfigTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->medGwyGatewayLinkName, &StorageTmp->medGwyGatewayLinkNameLen);
			cptr = read_config_store_data(ASN_IPADDRESS, cptr, &StorageTmp->medGwyGatewayIPAddress, &StorageTmp->medGwyGatewayIPAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayPort, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayEncodingScheme, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayProtocol, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewaySignalingTptProtocol, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayAdminStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayOperStatus, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->medGwyGatewayLastStatusChange, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayResetStatistics, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct medGwyGatewayControllerTable_data *medGwyGatewayControllerTable_create(void)
 * @brief create a fresh data structure representing a new row in the medGwyGatewayControllerTable table.
 *
 * Creates a new medGwyGatewayControllerTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct medGwyGatewayControllerTable_data *
medGwyGatewayControllerTable_create(void)
{
	struct medGwyGatewayControllerTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyGatewayControllerTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayControllerTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->medGwyGatewayId = 0;
		StorageNew->medGwyGatewayLinkId = 0;
		StorageNew->medGwyGatewayControllerIPAddress = (u_char *) "\x00\x00\x00\x00";
		StorageNew->medGwyGatewayControllerIPAddressLen = 4;
		StorageNew->medGwyGatewayControllerPort = 0;
		StorageNew->medGwyGatewayControllerAdminStatus = 0;
		StorageNew->medGwyGatewayControllerOperStatus = 0;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	medGwyGatewayControllerTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct medGwyGatewayControllerTable_data *medGwyGatewayControllerTable_duplicate(struct medGwyGatewayControllerTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct medGwyGatewayControllerTable_data *
medGwyGatewayControllerTable_duplicate(struct medGwyGatewayControllerTable_data *thedata)
{
	struct medGwyGatewayControllerTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyGatewayControllerTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayControllerTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->medGwyGatewayControllerTable_id = thedata->medGwyGatewayControllerTable_id;
		StorageNew->medGwyGatewayId = thedata->medGwyGatewayId;
		StorageNew->medGwyGatewayLinkId = thedata->medGwyGatewayLinkId;
		StorageNew->medGwyGatewayControllerId = thedata->medGwyGatewayControllerId;
		if (!(StorageNew->medGwyGatewayControllerIPAddress = malloc(thedata->medGwyGatewayControllerIPAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->medGwyGatewayControllerIPAddress, thedata->medGwyGatewayControllerIPAddress, thedata->medGwyGatewayControllerIPAddressLen);
		StorageNew->medGwyGatewayControllerIPAddressLen = thedata->medGwyGatewayControllerIPAddressLen;
		StorageNew->medGwyGatewayControllerIPAddress[StorageNew->medGwyGatewayControllerIPAddressLen] = 0;
		StorageNew->medGwyGatewayControllerPort = thedata->medGwyGatewayControllerPort;
		StorageNew->medGwyGatewayControllerAdminStatus = thedata->medGwyGatewayControllerAdminStatus;
		StorageNew->medGwyGatewayControllerOperStatus = thedata->medGwyGatewayControllerOperStatus;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	medGwyGatewayControllerTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int medGwyGatewayControllerTable_destroy(struct medGwyGatewayControllerTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
medGwyGatewayControllerTable_destroy(struct medGwyGatewayControllerTable_data **thedata)
{
	struct medGwyGatewayControllerTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayControllerTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyGatewayControllerTable_add(struct medGwyGatewayControllerTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the medGwyGatewayControllerTable table data set.
 *
 * Adds a table row structure to the medGwyGatewayControllerTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
medGwyGatewayControllerTable_add(struct medGwyGatewayControllerTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayControllerTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* medGwyGatewayId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayId, sizeof(thedata->medGwyGatewayId));
		/* medGwyGatewayLinkId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayLinkId, sizeof(thedata->medGwyGatewayLinkId));
		/* medGwyGatewayControllerId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayControllerId, sizeof(thedata->medGwyGatewayControllerId));
		header_complex_add_data(&medGwyGatewayControllerTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("megacoMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyGatewayControllerTable_del(struct medGwyGatewayControllerTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the medGwyGatewayControllerTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
medGwyGatewayControllerTable_del(struct medGwyGatewayControllerTable_data *thedata)
{
	struct medGwyGatewayControllerTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayControllerTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(medGwyGatewayControllerTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&medGwyGatewayControllerTableStorage, hciptr);
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_medGwyGatewayControllerTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for medGwyGatewayControllerTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case medGwyGatewayControllerTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_medGwyGatewayControllerTable(const char *token, char *line)
{
	size_t tmpsize;
	struct medGwyGatewayControllerTable_data *StorageTmp = medGwyGatewayControllerTable_create();

	DEBUGMSGTL(("megacoMIB", "parse_medGwyGatewayControllerTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayLinkId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayControllerId, &tmpsize);
	SNMP_FREE(StorageTmp->medGwyGatewayControllerIPAddress);
	line = read_config_read_data(ASN_IPADDRESS, line, &StorageTmp->medGwyGatewayControllerIPAddress, &StorageTmp->medGwyGatewayControllerIPAddressLen);
	if (StorageTmp->medGwyGatewayControllerIPAddress == NULL) {
		config_perror("invalid specification for medGwyGatewayControllerIPAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayControllerPort, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayControllerAdminStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayControllerOperStatus, &tmpsize);
	medGwyGatewayControllerTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/*
 * store_medGwyGatewayControllerTable(): store configuraiton file for medGwyGatewayControllerTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_medGwyGatewayControllerTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct medGwyGatewayControllerTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("megacoMIB", "store_medGwyGatewayControllerTable: storing data...  "));
	refresh_medGwyGatewayControllerTable(1);
	(void) tmpsize;
	for (hcindex = medGwyGatewayControllerTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct medGwyGatewayControllerTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "medGwyGatewayControllerTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayControllerId, &tmpsize);
			cptr = read_config_store_data(ASN_IPADDRESS, cptr, &StorageTmp->medGwyGatewayControllerIPAddress, &StorageTmp->medGwyGatewayControllerIPAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayControllerPort, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayControllerAdminStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayControllerOperStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct medGwyGatewayStatsTable_data *medGwyGatewayStatsTable_create(void)
 * @brief create a fresh data structure representing a new row in the medGwyGatewayStatsTable table.
 *
 * Creates a new medGwyGatewayStatsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct medGwyGatewayStatsTable_data *
medGwyGatewayStatsTable_create(void)
{
	struct medGwyGatewayStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyGatewayStatsTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayStatsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->medGwyGatewayId = 0;
		StorageNew->medGwyGatewayLinkId = 0;
		StorageNew->medGwyGatewayNumInMessages = 0;
		StorageNew->medGwyGatewayNumInOctets = 0;
		StorageNew->medGwyGatewayNumOutMessages = 0;
		StorageNew->medGwyGatewayNumOutOctets = 0;
		StorageNew->medGwyGatewayNumErrors = 0;
		StorageNew->medGwyGatewayNumTimerRecovery = 0;
		StorageNew->medGwyGatewayTransportNumLosses = 0;
		StorageNew->medGwyGatewayTransportNumSwitchover = 0;
		StorageNew->medGwyGatewayTransportTotalNumAlarms = 0;
		StorageNew->medGwyGatewayTransportLastEvent = 0;
		StorageNew->medGwyGatewayTransportLastEventTime = 0;
		StorageNew->medGwyGatewayLastStatisticsReset = 0;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	medGwyGatewayStatsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct medGwyGatewayStatsTable_data *medGwyGatewayStatsTable_duplicate(struct medGwyGatewayStatsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct medGwyGatewayStatsTable_data *
medGwyGatewayStatsTable_duplicate(struct medGwyGatewayStatsTable_data *thedata)
{
	struct medGwyGatewayStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyGatewayStatsTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayStatsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->medGwyGatewayStatsTable_id = thedata->medGwyGatewayStatsTable_id;
		StorageNew->medGwyGatewayId = thedata->medGwyGatewayId;
		StorageNew->medGwyGatewayLinkId = thedata->medGwyGatewayLinkId;
		StorageNew->medGwyGatewayNumInMessages = thedata->medGwyGatewayNumInMessages;
		StorageNew->medGwyGatewayNumInOctets = thedata->medGwyGatewayNumInOctets;
		StorageNew->medGwyGatewayNumOutMessages = thedata->medGwyGatewayNumOutMessages;
		StorageNew->medGwyGatewayNumOutOctets = thedata->medGwyGatewayNumOutOctets;
		StorageNew->medGwyGatewayNumErrors = thedata->medGwyGatewayNumErrors;
		StorageNew->medGwyGatewayNumTimerRecovery = thedata->medGwyGatewayNumTimerRecovery;
		StorageNew->medGwyGatewayTransportNumLosses = thedata->medGwyGatewayTransportNumLosses;
		StorageNew->medGwyGatewayTransportNumSwitchover = thedata->medGwyGatewayTransportNumSwitchover;
		StorageNew->medGwyGatewayTransportTotalNumAlarms = thedata->medGwyGatewayTransportTotalNumAlarms;
		StorageNew->medGwyGatewayTransportLastEvent = thedata->medGwyGatewayTransportLastEvent;
		StorageNew->medGwyGatewayTransportLastEventTime = thedata->medGwyGatewayTransportLastEventTime;
		StorageNew->medGwyGatewayLastStatisticsReset = thedata->medGwyGatewayLastStatisticsReset;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	medGwyGatewayStatsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int medGwyGatewayStatsTable_destroy(struct medGwyGatewayStatsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
medGwyGatewayStatsTable_destroy(struct medGwyGatewayStatsTable_data **thedata)
{
	struct medGwyGatewayStatsTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayStatsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyGatewayStatsTable_add(struct medGwyGatewayStatsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the medGwyGatewayStatsTable table data set.
 *
 * Adds a table row structure to the medGwyGatewayStatsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
medGwyGatewayStatsTable_add(struct medGwyGatewayStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayStatsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* medGwyGatewayId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayId, sizeof(thedata->medGwyGatewayId));
		/* medGwyGatewayLinkId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayLinkId, sizeof(thedata->medGwyGatewayLinkId));
		header_complex_add_data(&medGwyGatewayStatsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("megacoMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyGatewayStatsTable_del(struct medGwyGatewayStatsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the medGwyGatewayStatsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
medGwyGatewayStatsTable_del(struct medGwyGatewayStatsTable_data *thedata)
{
	struct medGwyGatewayStatsTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyGatewayStatsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(medGwyGatewayStatsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&medGwyGatewayStatsTableStorage, hciptr);
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_medGwyGatewayStatsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for medGwyGatewayStatsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case medGwyGatewayStatsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_medGwyGatewayStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct medGwyGatewayStatsTable_data *StorageTmp = medGwyGatewayStatsTable_create();

	DEBUGMSGTL(("megacoMIB", "parse_medGwyGatewayStatsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayLinkId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayNumInMessages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayNumInOctets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayNumOutMessages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayNumOutOctets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayNumErrors, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayNumTimerRecovery, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayTransportNumLosses, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayTransportNumSwitchover, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayTransportTotalNumAlarms, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyGatewayTransportLastEvent, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->medGwyGatewayTransportLastEventTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->medGwyGatewayLastStatisticsReset, &tmpsize);
	medGwyGatewayStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/*
 * store_medGwyGatewayStatsTable(): store configuraiton file for medGwyGatewayStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_medGwyGatewayStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct medGwyGatewayStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("megacoMIB", "store_medGwyGatewayStatsTable: storing data...  "));
	refresh_medGwyGatewayStatsTable(1);
	(void) tmpsize;
	for (hcindex = medGwyGatewayStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct medGwyGatewayStatsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "medGwyGatewayStatsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayNumInMessages, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayNumInOctets, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayNumOutMessages, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayNumOutOctets, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayNumErrors, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayNumTimerRecovery, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayTransportNumLosses, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayTransportNumSwitchover, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayTransportTotalNumAlarms, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyGatewayTransportLastEvent, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->medGwyGatewayTransportLastEventTime, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->medGwyGatewayLastStatisticsReset, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct medGwyTermIdTable_data *medGwyTermIdTable_create(void)
 * @brief create a fresh data structure representing a new row in the medGwyTermIdTable table.
 *
 * Creates a new medGwyTermIdTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct medGwyTermIdTable_data *
medGwyTermIdTable_create(void)
{
	struct medGwyTermIdTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyTermIdTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyTermIdTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->medGwyGatewayId = 0;
		StorageNew->medGwyNextTerminationId = 0;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	medGwyTermIdTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct medGwyTermIdTable_data *medGwyTermIdTable_duplicate(struct medGwyTermIdTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct medGwyTermIdTable_data *
medGwyTermIdTable_duplicate(struct medGwyTermIdTable_data *thedata)
{
	struct medGwyTermIdTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyTermIdTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyTermIdTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->medGwyTermIdTable_id = thedata->medGwyTermIdTable_id;
		StorageNew->medGwyGatewayId = thedata->medGwyGatewayId;
		StorageNew->medGwyNextTerminationId = thedata->medGwyNextTerminationId;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	medGwyTermIdTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int medGwyTermIdTable_destroy(struct medGwyTermIdTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
medGwyTermIdTable_destroy(struct medGwyTermIdTable_data **thedata)
{
	struct medGwyTermIdTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyTermIdTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyTermIdTable_add(struct medGwyTermIdTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the medGwyTermIdTable table data set.
 *
 * Adds a table row structure to the medGwyTermIdTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
medGwyTermIdTable_add(struct medGwyTermIdTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("megacoMIB", "medGwyTermIdTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* medGwyGatewayId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayId, sizeof(thedata->medGwyGatewayId));
		header_complex_add_data(&medGwyTermIdTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("megacoMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyTermIdTable_del(struct medGwyTermIdTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the medGwyTermIdTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
medGwyTermIdTable_del(struct medGwyTermIdTable_data *thedata)
{
	struct medGwyTermIdTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyTermIdTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(medGwyTermIdTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&medGwyTermIdTableStorage, hciptr);
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_medGwyTermIdTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for medGwyTermIdTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case medGwyTermIdTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_medGwyTermIdTable(const char *token, char *line)
{
	size_t tmpsize;
	struct medGwyTermIdTable_data *StorageTmp = medGwyTermIdTable_create();

	DEBUGMSGTL(("megacoMIB", "parse_medGwyTermIdTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyNextTerminationId, &tmpsize);
	medGwyTermIdTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/*
 * store_medGwyTermIdTable(): store configuraiton file for medGwyTermIdTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_medGwyTermIdTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct medGwyTermIdTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("megacoMIB", "store_medGwyTermIdTable: storing data...  "));
	refresh_medGwyTermIdTable(1);
	(void) tmpsize;
	for (hcindex = medGwyTermIdTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct medGwyTermIdTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "medGwyTermIdTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyNextTerminationId, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct medGwyTerminationsTable_data *medGwyTerminationsTable_create(void)
 * @brief create a fresh data structure representing a new row in the medGwyTerminationsTable table.
 *
 * Creates a new medGwyTerminationsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct medGwyTerminationsTable_data *
medGwyTerminationsTable_create(void)
{
	struct medGwyTerminationsTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyTerminationsTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyTerminationsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->medGwyGatewayId = 0;
		if ((StorageNew->medGwyTerminationName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->medGwyTerminationNameLen = 0;
		StorageNew->medGwyTerminationName[StorageNew->medGwyTerminationNameLen] = 0;
		StorageNew->medGwyTerminationAdminStatus = 0;
		StorageNew->medGwyTerminationOperStatus = 0;
		StorageNew->medGwyTerminationInterfaceIdentifier = 0;
		StorageNew->medGwyTerminationPropertyProfileId = 0;
		StorageNew->medGwyTerminationRowStatus = 0;
		StorageNew->medGwyTerminationRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	medGwyTerminationsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct medGwyTerminationsTable_data *medGwyTerminationsTable_duplicate(struct medGwyTerminationsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct medGwyTerminationsTable_data *
medGwyTerminationsTable_duplicate(struct medGwyTerminationsTable_data *thedata)
{
	struct medGwyTerminationsTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyTerminationsTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyTerminationsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->medGwyTerminationsTable_id = thedata->medGwyTerminationsTable_id;
		StorageNew->medGwyGatewayId = thedata->medGwyGatewayId;
		StorageNew->medGwyTerminationId = thedata->medGwyTerminationId;
		if (!(StorageNew->medGwyTerminationName = malloc(thedata->medGwyTerminationNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->medGwyTerminationName, thedata->medGwyTerminationName, thedata->medGwyTerminationNameLen);
		StorageNew->medGwyTerminationNameLen = thedata->medGwyTerminationNameLen;
		StorageNew->medGwyTerminationName[StorageNew->medGwyTerminationNameLen] = 0;
		StorageNew->medGwyTerminationAdminStatus = thedata->medGwyTerminationAdminStatus;
		StorageNew->medGwyTerminationOperStatus = thedata->medGwyTerminationOperStatus;
		StorageNew->medGwyTerminationInterfaceIdentifier = thedata->medGwyTerminationInterfaceIdentifier;
		StorageNew->medGwyTerminationPropertyProfileId = thedata->medGwyTerminationPropertyProfileId;
		StorageNew->medGwyTerminationRowStatus = thedata->medGwyTerminationRowStatus;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	medGwyTerminationsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int medGwyTerminationsTable_destroy(struct medGwyTerminationsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
medGwyTerminationsTable_destroy(struct medGwyTerminationsTable_data **thedata)
{
	struct medGwyTerminationsTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyTerminationsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->medGwyTerminationName);
		StorageDel->medGwyTerminationNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyTerminationsTable_add(struct medGwyTerminationsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the medGwyTerminationsTable table data set.
 *
 * Adds a table row structure to the medGwyTerminationsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
medGwyTerminationsTable_add(struct medGwyTerminationsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("megacoMIB", "medGwyTerminationsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* medGwyGatewayId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayId, sizeof(thedata->medGwyGatewayId));
		/* medGwyTerminationId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyTerminationId, sizeof(thedata->medGwyTerminationId));
		header_complex_add_data(&medGwyTerminationsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("megacoMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyTerminationsTable_del(struct medGwyTerminationsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the medGwyTerminationsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
medGwyTerminationsTable_del(struct medGwyTerminationsTable_data *thedata)
{
	struct medGwyTerminationsTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyTerminationsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(medGwyTerminationsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&medGwyTerminationsTableStorage, hciptr);
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_medGwyTerminationsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for medGwyTerminationsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case medGwyTerminationsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_medGwyTerminationsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct medGwyTerminationsTable_data *StorageTmp = medGwyTerminationsTable_create();

	DEBUGMSGTL(("megacoMIB", "parse_medGwyTerminationsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyTerminationId, &tmpsize);
	SNMP_FREE(StorageTmp->medGwyTerminationName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->medGwyTerminationName, &StorageTmp->medGwyTerminationNameLen);
	if (StorageTmp->medGwyTerminationName == NULL) {
		config_perror("invalid specification for medGwyTerminationName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyTerminationAdminStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyTerminationOperStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyTerminationInterfaceIdentifier, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyTerminationPropertyProfileId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyTerminationRowStatus, &tmpsize);
	medGwyTerminationsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/*
 * store_medGwyTerminationsTable(): store configuraiton file for medGwyTerminationsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_medGwyTerminationsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct medGwyTerminationsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("megacoMIB", "store_medGwyTerminationsTable: storing data...  "));
	refresh_medGwyTerminationsTable(1);
	(void) tmpsize;
	for (hcindex = medGwyTerminationsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct medGwyTerminationsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "medGwyTerminationsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyTerminationId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->medGwyTerminationName, &StorageTmp->medGwyTerminationNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyTerminationAdminStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyTerminationOperStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyTerminationInterfaceIdentifier, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyTerminationPropertyProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyTerminationRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct medGwyPropertyProfileTable_data *medGwyPropertyProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the medGwyPropertyProfileTable table.
 *
 * Creates a new medGwyPropertyProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct medGwyPropertyProfileTable_data *
medGwyPropertyProfileTable_create(void)
{
	struct medGwyPropertyProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyPropertyProfileTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyPropertyProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->medGwyGatewayId = 0;
		if ((StorageNew->medGwyPropertyProfileProperty = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->medGwyPropertyProfilePropertyLen = 2;
		StorageNew->medGwyTermPropertyProfileStatus = 0;
		StorageNew->medGwyTermPropertyProfileStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	medGwyPropertyProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct medGwyPropertyProfileTable_data *medGwyPropertyProfileTable_duplicate(struct medGwyPropertyProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct medGwyPropertyProfileTable_data *
medGwyPropertyProfileTable_duplicate(struct medGwyPropertyProfileTable_data *thedata)
{
	struct medGwyPropertyProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(medGwyPropertyProfileTable_data);

	DEBUGMSGTL(("megacoMIB", "medGwyPropertyProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->medGwyPropertyProfileTable_id = thedata->medGwyPropertyProfileTable_id;
		StorageNew->medGwyGatewayId = thedata->medGwyGatewayId;
		StorageNew->medGwyPropertyProfileId = thedata->medGwyPropertyProfileId;
		StorageNew->medGwyPropertyProfileIndex = thedata->medGwyPropertyProfileIndex;
		if (!(StorageNew->medGwyPropertyProfileProperty = snmp_duplicate_objid(thedata->medGwyPropertyProfileProperty, thedata->medGwyPropertyProfilePropertyLen / sizeof(oid))))
			goto destroy;
		StorageNew->medGwyPropertyProfilePropertyLen = thedata->medGwyPropertyProfilePropertyLen;
		StorageNew->medGwyTermPropertyProfileStatus = thedata->medGwyTermPropertyProfileStatus;
	}
      done:
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	medGwyPropertyProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int medGwyPropertyProfileTable_destroy(struct medGwyPropertyProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
medGwyPropertyProfileTable_destroy(struct medGwyPropertyProfileTable_data **thedata)
{
	struct medGwyPropertyProfileTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyPropertyProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->medGwyPropertyProfileProperty);
		StorageDel->medGwyPropertyProfilePropertyLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyPropertyProfileTable_add(struct medGwyPropertyProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the medGwyPropertyProfileTable table data set.
 *
 * Adds a table row structure to the medGwyPropertyProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
medGwyPropertyProfileTable_add(struct medGwyPropertyProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("megacoMIB", "medGwyPropertyProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* medGwyGatewayId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyGatewayId, sizeof(thedata->medGwyGatewayId));
		/* medGwyPropertyProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyPropertyProfileId, sizeof(thedata->medGwyPropertyProfileId));
		/* medGwyPropertyProfileIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->medGwyPropertyProfileIndex, sizeof(thedata->medGwyPropertyProfileIndex));
		header_complex_add_data(&medGwyPropertyProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("megacoMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int medGwyPropertyProfileTable_del(struct medGwyPropertyProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the medGwyPropertyProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
medGwyPropertyProfileTable_del(struct medGwyPropertyProfileTable_data *thedata)
{
	struct medGwyPropertyProfileTable_data *StorageDel;

	DEBUGMSGTL(("megacoMIB", "medGwyPropertyProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(medGwyPropertyProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&medGwyPropertyProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_medGwyPropertyProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for medGwyPropertyProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case medGwyPropertyProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_medGwyPropertyProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct medGwyPropertyProfileTable_data *StorageTmp = medGwyPropertyProfileTable_create();

	DEBUGMSGTL(("megacoMIB", "parse_medGwyPropertyProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyGatewayId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyPropertyProfileId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->medGwyPropertyProfileIndex, &tmpsize);
	SNMP_FREE(StorageTmp->medGwyPropertyProfileProperty);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->medGwyPropertyProfileProperty, &StorageTmp->medGwyPropertyProfilePropertyLen);
	if (StorageTmp->medGwyPropertyProfileProperty == NULL) {
		config_perror("invalid specification for medGwyPropertyProfileProperty");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->medGwyTermPropertyProfileStatus, &tmpsize);
	medGwyPropertyProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/*
 * store_medGwyPropertyProfileTable(): store configuraiton file for medGwyPropertyProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_medGwyPropertyProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct medGwyPropertyProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("megacoMIB", "store_medGwyPropertyProfileTable: storing data...  "));
	refresh_medGwyPropertyProfileTable(1);
	(void) tmpsize;
	for (hcindex = medGwyPropertyProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct medGwyPropertyProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "medGwyPropertyProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyGatewayId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyPropertyProfileId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->medGwyPropertyProfileIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->medGwyPropertyProfileProperty, &StorageTmp->medGwyPropertyProfilePropertyLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->medGwyTermPropertyProfileStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int activate_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int check_medGwyLinkIdTable_row(struct medGwyLinkIdTable_data *StorageTmp, struct medGwyLinkIdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_medGwyLinkIdTable_row(struct medGwyLinkIdTable_data *StorageTmp, struct medGwyLinkIdTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_medGwyLinkIdTable_row(struct medGwyLinkIdTable_data *StorageTmp, struct medGwyLinkIdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_medGwyLinkIdTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_medGwyLinkIdTable_row(struct medGwyLinkIdTable_data *StorageTmp, struct medGwyLinkIdTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	medGwyLinkIdTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_medGwyLinkIdTable_row(struct medGwyLinkIdTable_data *StorageTmp, struct medGwyLinkIdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_medGwyLinkIdTable_row(struct medGwyLinkIdTable_data *StorageTmp, struct medGwyLinkIdTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_medGwyLinkIdTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_medGwyLinkIdTable_row(struct medGwyLinkIdTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the medGwyLinkIdTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct medGwyLinkIdTable_data *
refresh_medGwyLinkIdTable_row(struct medGwyLinkIdTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->medGwyLinkIdTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->medGwyLinkIdTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_medGwyLinkIdTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the medGwyLinkIdTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_medGwyLinkIdTable(int force)
{
	if (!force && medGwyLinkIdTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	medGwyLinkIdTable_refresh = 0;
}

/**
 * @fn u_char *var_medGwyLinkIdTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in medGwyLinkIdTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_megacoMIB above.
 */
u_char *
var_medGwyLinkIdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct medGwyLinkIdTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("megacoMIB", "var_medGwyLinkIdTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_medGwyLinkIdTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(medGwyLinkIdTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_medGwyLinkIdTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MEDGWYNEXTLINKID:	/* ReadWrite */
		*write_method = write_medGwyNextLinkId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyNextLinkId);
		rval = (u_char *) &StorageTmp->medGwyNextLinkId;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp, struct medGwyGatewayConfigTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp, struct medGwyGatewayConfigTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp, struct medGwyGatewayConfigTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_medGwyGatewayConfigTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp, struct medGwyGatewayConfigTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	medGwyGatewayConfigTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp, struct medGwyGatewayConfigTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp, struct medGwyGatewayConfigTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_medGwyGatewayConfigTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the medGwyGatewayConfigTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct medGwyGatewayConfigTable_data *
refresh_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->medGwyGatewayConfigTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->medGwyGatewayConfigTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_medGwyGatewayConfigTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the medGwyGatewayConfigTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_medGwyGatewayConfigTable(int force)
{
	if (!force && medGwyGatewayConfigTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	medGwyGatewayConfigTable_refresh = 0;
}

/**
 * @fn u_char *var_medGwyGatewayConfigTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in medGwyGatewayConfigTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_megacoMIB above.
 */
u_char *
var_medGwyGatewayConfigTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("megacoMIB", "var_medGwyGatewayConfigTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_medGwyGatewayConfigTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(medGwyGatewayConfigTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_medGwyGatewayConfigTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MEDGWYGATEWAYLINKNAME:	/* Create */
		*write_method = write_medGwyGatewayLinkName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->medGwyGatewayLinkNameLen;
		rval = (u_char *) StorageTmp->medGwyGatewayLinkName;
		break;
	case (u_char) MEDGWYGATEWAYIPADDRESS:	/* Create */
		*write_method = write_medGwyGatewayIPAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->medGwyGatewayIPAddressLen;
		rval = (u_char *) StorageTmp->medGwyGatewayIPAddress;
		break;
	case (u_char) MEDGWYGATEWAYPORT:	/* Create */
		*write_method = write_medGwyGatewayPort;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayPort);
		rval = (u_char *) &StorageTmp->medGwyGatewayPort;
		break;
	case (u_char) MEDGWYGATEWAYENCODINGSCHEME:	/* Create */
		*write_method = write_medGwyGatewayEncodingScheme;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayEncodingScheme);
		rval = (u_char *) &StorageTmp->medGwyGatewayEncodingScheme;
		break;
	case (u_char) MEDGWYGATEWAYPROTOCOL:	/* Create */
		*write_method = write_medGwyGatewayProtocol;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayProtocol);
		rval = (u_char *) &StorageTmp->medGwyGatewayProtocol;
		break;
	case (u_char) MEDGWYGATEWAYSIGNALINGTPTPROTOCOL:	/* Create */
		*write_method = write_medGwyGatewaySignalingTptProtocol;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewaySignalingTptProtocol);
		rval = (u_char *) &StorageTmp->medGwyGatewaySignalingTptProtocol;
		break;
	case (u_char) MEDGWYGATEWAYADMINSTATUS:	/* Create */
		*write_method = write_medGwyGatewayAdminStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayAdminStatus);
		rval = (u_char *) &StorageTmp->medGwyGatewayAdminStatus;
		break;
	case (u_char) MEDGWYGATEWAYOPERSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayOperStatus);
		rval = (u_char *) &StorageTmp->medGwyGatewayOperStatus;
		break;
	case (u_char) MEDGWYGATEWAYLASTSTATUSCHANGE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayLastStatusChange);
		rval = (u_char *) &StorageTmp->medGwyGatewayLastStatusChange;
		break;
	case (u_char) MEDGWYGATEWAYRESETSTATISTICS:	/* Create */
		*write_method = write_medGwyGatewayResetStatistics;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayResetStatistics);
		rval = (u_char *) &StorageTmp->medGwyGatewayResetStatistics;
		break;
	case (u_char) MEDGWYGATEWAYROWSTATUS:	/* Create */
		*write_method = write_medGwyGatewayRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayRowStatus);
		rval = (u_char *) &StorageTmp->medGwyGatewayRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_medGwyGatewayControllerTable_row(struct medGwyGatewayControllerTable_data *StorageTmp, struct medGwyGatewayControllerTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_medGwyGatewayControllerTable_row(struct medGwyGatewayControllerTable_data *StorageTmp, struct medGwyGatewayControllerTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_medGwyGatewayControllerTable_row(struct medGwyGatewayControllerTable_data *StorageTmp, struct medGwyGatewayControllerTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_medGwyGatewayControllerTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_medGwyGatewayControllerTable_row(struct medGwyGatewayControllerTable_data *StorageTmp, struct medGwyGatewayControllerTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	medGwyGatewayControllerTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_medGwyGatewayControllerTable_row(struct medGwyGatewayControllerTable_data *StorageTmp, struct medGwyGatewayControllerTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_medGwyGatewayControllerTable_row(struct medGwyGatewayControllerTable_data *StorageTmp, struct medGwyGatewayControllerTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_medGwyGatewayControllerTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_medGwyGatewayControllerTable_row(struct medGwyGatewayControllerTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the medGwyGatewayControllerTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct medGwyGatewayControllerTable_data *
refresh_medGwyGatewayControllerTable_row(struct medGwyGatewayControllerTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->medGwyGatewayControllerTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->medGwyGatewayControllerTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_medGwyGatewayControllerTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the medGwyGatewayControllerTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_medGwyGatewayControllerTable(int force)
{
	if (!force && medGwyGatewayControllerTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	medGwyGatewayControllerTable_refresh = 0;
}

/**
 * @fn u_char *var_medGwyGatewayControllerTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in medGwyGatewayControllerTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_megacoMIB above.
 */
u_char *
var_medGwyGatewayControllerTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct medGwyGatewayControllerTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("megacoMIB", "var_medGwyGatewayControllerTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_medGwyGatewayControllerTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(medGwyGatewayControllerTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_medGwyGatewayControllerTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MEDGWYGATEWAYCONTROLLERIPADDRESS:	/* Create */
		*write_method = write_medGwyGatewayControllerIPAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->medGwyGatewayControllerIPAddressLen;
		rval = (u_char *) StorageTmp->medGwyGatewayControllerIPAddress;
		break;
	case (u_char) MEDGWYGATEWAYCONTROLLERPORT:	/* Create */
		*write_method = write_medGwyGatewayControllerPort;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayControllerPort);
		rval = (u_char *) &StorageTmp->medGwyGatewayControllerPort;
		break;
	case (u_char) MEDGWYGATEWAYCONTROLLERADMINSTATUS:	/* Create */
		*write_method = write_medGwyGatewayControllerAdminStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayControllerAdminStatus);
		rval = (u_char *) &StorageTmp->medGwyGatewayControllerAdminStatus;
		break;
	case (u_char) MEDGWYGATEWAYCONTROLLEROPERSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayControllerOperStatus);
		rval = (u_char *) &StorageTmp->medGwyGatewayControllerOperStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_medGwyGatewayStatsTable_row(struct medGwyGatewayStatsTable_data *StorageTmp, struct medGwyGatewayStatsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_medGwyGatewayStatsTable_row(struct medGwyGatewayStatsTable_data *StorageTmp, struct medGwyGatewayStatsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_medGwyGatewayStatsTable_row(struct medGwyGatewayStatsTable_data *StorageTmp, struct medGwyGatewayStatsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_medGwyGatewayStatsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_medGwyGatewayStatsTable_row(struct medGwyGatewayStatsTable_data *StorageTmp, struct medGwyGatewayStatsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	medGwyGatewayStatsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_medGwyGatewayStatsTable_row(struct medGwyGatewayStatsTable_data *StorageTmp, struct medGwyGatewayStatsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_medGwyGatewayStatsTable_row(struct medGwyGatewayStatsTable_data *StorageTmp, struct medGwyGatewayStatsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_medGwyGatewayStatsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_medGwyGatewayStatsTable_row(struct medGwyGatewayStatsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the medGwyGatewayStatsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct medGwyGatewayStatsTable_data *
refresh_medGwyGatewayStatsTable_row(struct medGwyGatewayStatsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->medGwyGatewayStatsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->medGwyGatewayStatsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_medGwyGatewayStatsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the medGwyGatewayStatsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_medGwyGatewayStatsTable(int force)
{
	if (!force && medGwyGatewayStatsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	medGwyGatewayStatsTable_refresh = 0;
}

/**
 * @fn u_char *var_medGwyGatewayStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in medGwyGatewayStatsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_megacoMIB above.
 */
u_char *
var_medGwyGatewayStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct medGwyGatewayStatsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("megacoMIB", "var_medGwyGatewayStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_medGwyGatewayStatsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(medGwyGatewayStatsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_medGwyGatewayStatsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MEDGWYGATEWAYNUMINMESSAGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayNumInMessages);
		rval = (u_char *) &StorageTmp->medGwyGatewayNumInMessages;
		break;
	case (u_char) MEDGWYGATEWAYNUMINOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayNumInOctets);
		rval = (u_char *) &StorageTmp->medGwyGatewayNumInOctets;
		break;
	case (u_char) MEDGWYGATEWAYNUMOUTMESSAGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayNumOutMessages);
		rval = (u_char *) &StorageTmp->medGwyGatewayNumOutMessages;
		break;
	case (u_char) MEDGWYGATEWAYNUMOUTOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayNumOutOctets);
		rval = (u_char *) &StorageTmp->medGwyGatewayNumOutOctets;
		break;
	case (u_char) MEDGWYGATEWAYNUMERRORS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayNumErrors);
		rval = (u_char *) &StorageTmp->medGwyGatewayNumErrors;
		break;
	case (u_char) MEDGWYGATEWAYNUMTIMERRECOVERY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayNumTimerRecovery);
		rval = (u_char *) &StorageTmp->medGwyGatewayNumTimerRecovery;
		break;
	case (u_char) MEDGWYGATEWAYTRANSPORTNUMLOSSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayTransportNumLosses);
		rval = (u_char *) &StorageTmp->medGwyGatewayTransportNumLosses;
		break;
	case (u_char) MEDGWYGATEWAYTRANSPORTNUMSWITCHOVER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayTransportNumSwitchover);
		rval = (u_char *) &StorageTmp->medGwyGatewayTransportNumSwitchover;
		break;
	case (u_char) MEDGWYGATEWAYTRANSPORTTOTALNUMALARMS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayTransportTotalNumAlarms);
		rval = (u_char *) &StorageTmp->medGwyGatewayTransportTotalNumAlarms;
		break;
	case (u_char) MEDGWYGATEWAYTRANSPORTLASTEVENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayTransportLastEvent);
		rval = (u_char *) &StorageTmp->medGwyGatewayTransportLastEvent;
		break;
	case (u_char) MEDGWYGATEWAYTRANSPORTLASTEVENTTIME:	/* ReadWrite */
		*write_method = write_medGwyGatewayTransportLastEventTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayTransportLastEventTime);
		rval = (u_char *) &StorageTmp->medGwyGatewayTransportLastEventTime;
		break;
	case (u_char) MEDGWYGATEWAYLASTSTATISTICSRESET:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyGatewayLastStatisticsReset);
		rval = (u_char *) &StorageTmp->medGwyGatewayLastStatisticsReset;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_medGwyTermIdTable_row(struct medGwyTermIdTable_data *StorageTmp, struct medGwyTermIdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_medGwyTermIdTable_row(struct medGwyTermIdTable_data *StorageTmp, struct medGwyTermIdTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_medGwyTermIdTable_row(struct medGwyTermIdTable_data *StorageTmp, struct medGwyTermIdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_medGwyTermIdTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_medGwyTermIdTable_row(struct medGwyTermIdTable_data *StorageTmp, struct medGwyTermIdTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	medGwyTermIdTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_medGwyTermIdTable_row(struct medGwyTermIdTable_data *StorageTmp, struct medGwyTermIdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_medGwyTermIdTable_row(struct medGwyTermIdTable_data *StorageTmp, struct medGwyTermIdTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_medGwyTermIdTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_medGwyTermIdTable_row(struct medGwyTermIdTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the medGwyTermIdTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct medGwyTermIdTable_data *
refresh_medGwyTermIdTable_row(struct medGwyTermIdTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->medGwyTermIdTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->medGwyTermIdTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_medGwyTermIdTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the medGwyTermIdTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_medGwyTermIdTable(int force)
{
	if (!force && medGwyTermIdTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	medGwyTermIdTable_refresh = 0;
}

/**
 * @fn u_char *var_medGwyTermIdTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in medGwyTermIdTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_megacoMIB above.
 */
u_char *
var_medGwyTermIdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct medGwyTermIdTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("megacoMIB", "var_medGwyTermIdTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_medGwyTermIdTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(medGwyTermIdTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_medGwyTermIdTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MEDGWYNEXTTERMINATIONID:	/* ReadWrite */
		*write_method = write_medGwyNextTerminationId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyNextTerminationId);
		rval = (u_char *) &StorageTmp->medGwyNextTerminationId;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp, struct medGwyTerminationsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp, struct medGwyTerminationsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp, struct medGwyTerminationsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_medGwyTerminationsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp, struct medGwyTerminationsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	medGwyTerminationsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp, struct medGwyTerminationsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp, struct medGwyTerminationsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_medGwyTerminationsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the medGwyTerminationsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct medGwyTerminationsTable_data *
refresh_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->medGwyTerminationsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->medGwyTerminationsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_medGwyTerminationsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the medGwyTerminationsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_medGwyTerminationsTable(int force)
{
	if (!force && medGwyTerminationsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	medGwyTerminationsTable_refresh = 0;
}

/**
 * @fn u_char *var_medGwyTerminationsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in medGwyTerminationsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_megacoMIB above.
 */
u_char *
var_medGwyTerminationsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct medGwyTerminationsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("megacoMIB", "var_medGwyTerminationsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_medGwyTerminationsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(medGwyTerminationsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_medGwyTerminationsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MEDGWYTERMINATIONNAME:	/* Create */
		*write_method = write_medGwyTerminationName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->medGwyTerminationNameLen;
		rval = (u_char *) StorageTmp->medGwyTerminationName;
		break;
	case (u_char) MEDGWYTERMINATIONADMINSTATUS:	/* Create */
		*write_method = write_medGwyTerminationAdminStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyTerminationAdminStatus);
		rval = (u_char *) &StorageTmp->medGwyTerminationAdminStatus;
		break;
	case (u_char) MEDGWYTERMINATIONOPERSTATUS:	/* Create */
		*write_method = write_medGwyTerminationOperStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyTerminationOperStatus);
		rval = (u_char *) &StorageTmp->medGwyTerminationOperStatus;
		break;
	case (u_char) MEDGWYTERMINATIONINTERFACEIDENTIFIER:	/* Create */
		*write_method = write_medGwyTerminationInterfaceIdentifier;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyTerminationInterfaceIdentifier);
		rval = (u_char *) &StorageTmp->medGwyTerminationInterfaceIdentifier;
		break;
	case (u_char) MEDGWYTERMINATIONPROPERTYPROFILEID:	/* Create */
		*write_method = write_medGwyTerminationPropertyProfileId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyTerminationPropertyProfileId);
		rval = (u_char *) &StorageTmp->medGwyTerminationPropertyProfileId;
		break;
	case (u_char) MEDGWYTERMINATIONROWSTATUS:	/* Create */
		*write_method = write_medGwyTerminationRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyTerminationRowStatus);
		rval = (u_char *) &StorageTmp->medGwyTerminationRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp, struct medGwyPropertyProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp, struct medGwyPropertyProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp, struct medGwyPropertyProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_medGwyPropertyProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp, struct medGwyPropertyProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	medGwyPropertyProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp, struct medGwyPropertyProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp, struct medGwyPropertyProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_medGwyPropertyProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the medGwyPropertyProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct medGwyPropertyProfileTable_data *
refresh_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->medGwyPropertyProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->medGwyPropertyProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_medGwyPropertyProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the medGwyPropertyProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_medGwyPropertyProfileTable(int force)
{
	if (!force && medGwyPropertyProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	medGwyPropertyProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_medGwyPropertyProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in medGwyPropertyProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_megacoMIB above.
 */
u_char *
var_medGwyPropertyProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct medGwyPropertyProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("megacoMIB", "var_medGwyPropertyProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_medGwyPropertyProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(medGwyPropertyProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_medGwyPropertyProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MEDGWYPROPERTYPROFILEPROPERTY:	/* Create */
		*write_method = write_medGwyPropertyProfileProperty;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->medGwyPropertyProfilePropertyLen * sizeof(oid);
		rval = (u_char *) StorageTmp->medGwyPropertyProfileProperty;
		break;
	case (u_char) MEDGWYTERMPROPERTYPROFILESTATUS:	/* Create */
		*write_method = write_medGwyTermPropertyProfileStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->medGwyTermPropertyProfileStatus);
		rval = (u_char *) &StorageTmp->medGwyTermPropertyProfileStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_medGwyNextLinkId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyNextLinkId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyLinkIdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyNextLinkId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyLinkIdTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyNextLinkId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyNextLinkId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyNextLinkId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyLinkIdTable_old) == NULL)
			if (StorageTmp->medGwyLinkIdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyLinkIdTable_old = medGwyLinkIdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyLinkIdTable_rsvs++;
		StorageTmp->medGwyNextLinkId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyLinkIdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyLinkIdTable_tsts == 0)
				if ((ret = check_medGwyLinkIdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyLinkIdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyNextLinkId for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyLinkIdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyLinkIdTable_sets == 0)
				if ((ret = update_medGwyLinkIdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyLinkIdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyLinkIdTable_old) != NULL) {
			medGwyLinkIdTable_destroy(&StorageTmp->medGwyLinkIdTable_old);
			StorageTmp->medGwyLinkIdTable_rsvs = 0;
			StorageTmp->medGwyLinkIdTable_tsts = 0;
			StorageTmp->medGwyLinkIdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyLinkIdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyLinkIdTable_sets == 0)
			revert_medGwyLinkIdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyLinkIdTable_old) == NULL)
			break;
		StorageTmp->medGwyNextLinkId = StorageOld->medGwyNextLinkId;
		if (--StorageTmp->medGwyLinkIdTable_rsvs == 0)
			medGwyLinkIdTable_destroy(&StorageTmp->medGwyLinkIdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayLinkName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayLinkName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayLinkName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayConfigTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyGatewayRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayLinkName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayLinkName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayLinkName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			if (StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old = medGwyGatewayConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayConfigTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->medGwyGatewayLinkName);
		StorageTmp->medGwyGatewayLinkName = string;
		StorageTmp->medGwyGatewayLinkNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayConfigTable_tsts == 0)
				if ((ret = check_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayLinkName for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayConfigTable_sets == 0)
				if ((ret = update_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
			StorageTmp->medGwyGatewayConfigTable_rsvs = 0;
			StorageTmp->medGwyGatewayConfigTable_tsts = 0;
			StorageTmp->medGwyGatewayConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayConfigTable_sets == 0)
			revert_medGwyGatewayConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		if (StorageOld->medGwyGatewayLinkName != NULL) {
			SNMP_FREE(StorageTmp->medGwyGatewayLinkName);
			StorageTmp->medGwyGatewayLinkName = StorageOld->medGwyGatewayLinkName;
			StorageTmp->medGwyGatewayLinkNameLen = StorageOld->medGwyGatewayLinkNameLen;
			StorageOld->medGwyGatewayLinkName = NULL;
			StorageOld->medGwyGatewayLinkNameLen = 0;
		}
		if (--StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayIPAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayIPAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayIPAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayConfigTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyGatewayRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayIPAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_IPADDRESS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayIPAddress not ASN_IPADDRESS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayIPAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			if (StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old = medGwyGatewayConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayConfigTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->medGwyGatewayIPAddress);
		StorageTmp->medGwyGatewayIPAddress = string;
		StorageTmp->medGwyGatewayIPAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayConfigTable_tsts == 0)
				if ((ret = check_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayIPAddress for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayConfigTable_sets == 0)
				if ((ret = update_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
			StorageTmp->medGwyGatewayConfigTable_rsvs = 0;
			StorageTmp->medGwyGatewayConfigTable_tsts = 0;
			StorageTmp->medGwyGatewayConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayConfigTable_sets == 0)
			revert_medGwyGatewayConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		if (StorageOld->medGwyGatewayIPAddress != NULL) {
			SNMP_FREE(StorageTmp->medGwyGatewayIPAddress);
			StorageTmp->medGwyGatewayIPAddress = StorageOld->medGwyGatewayIPAddress;
			StorageTmp->medGwyGatewayIPAddressLen = StorageOld->medGwyGatewayIPAddressLen;
			StorageOld->medGwyGatewayIPAddress = NULL;
			StorageOld->medGwyGatewayIPAddressLen = 0;
		}
		if (--StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayPort entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayConfigTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyGatewayRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayPort: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2944 */
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayPort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			if (StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old = medGwyGatewayConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayConfigTable_rsvs++;
		StorageTmp->medGwyGatewayPort = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayConfigTable_tsts == 0)
				if ((ret = check_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayPort for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayConfigTable_sets == 0)
				if ((ret = update_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
			StorageTmp->medGwyGatewayConfigTable_rsvs = 0;
			StorageTmp->medGwyGatewayConfigTable_tsts = 0;
			StorageTmp->medGwyGatewayConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayConfigTable_sets == 0)
			revert_medGwyGatewayConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		StorageTmp->medGwyGatewayPort = StorageOld->medGwyGatewayPort;
		if (--StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayEncodingScheme entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayConfigTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyGatewayRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayEncodingScheme: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayEncodingScheme not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayEncodingScheme: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value text */
		switch (set_value) {
		case MEDGWYGATEWAYENCODINGSCHEME_TEXT:
		case MEDGWYGATEWAYENCODINGSCHEME_BINARY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayEncodingScheme: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			if (StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old = medGwyGatewayConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayConfigTable_rsvs++;
		StorageTmp->medGwyGatewayEncodingScheme = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayConfigTable_tsts == 0)
				if ((ret = check_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayEncodingScheme for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayConfigTable_sets == 0)
				if ((ret = update_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
			StorageTmp->medGwyGatewayConfigTable_rsvs = 0;
			StorageTmp->medGwyGatewayConfigTable_tsts = 0;
			StorageTmp->medGwyGatewayConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayConfigTable_sets == 0)
			revert_medGwyGatewayConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		StorageTmp->medGwyGatewayEncodingScheme = StorageOld->medGwyGatewayEncodingScheme;
		if (--StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayProtocol(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayProtocol(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayProtocol entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayConfigTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyGatewayRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayProtocol: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayProtocol not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayProtocol: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MEDGWYGATEWAYPROTOCOL_NOTAPPLICABLE:
		case MEDGWYGATEWAYPROTOCOL_OTHER:
		case MEDGWYGATEWAYPROTOCOL_DSS1IP:
		case MEDGWYGATEWAYPROTOCOL_IPDC:
		case MEDGWYGATEWAYPROTOCOL_MEGACOV1:
		case MEDGWYGATEWAYPROTOCOL_MEGACOV2:
		case MEDGWYGATEWAYPROTOCOL_MGCP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayProtocol: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			if (StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old = medGwyGatewayConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayConfigTable_rsvs++;
		StorageTmp->medGwyGatewayProtocol = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayConfigTable_tsts == 0)
				if ((ret = check_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayProtocol for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayConfigTable_sets == 0)
				if ((ret = update_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
			StorageTmp->medGwyGatewayConfigTable_rsvs = 0;
			StorageTmp->medGwyGatewayConfigTable_tsts = 0;
			StorageTmp->medGwyGatewayConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayConfigTable_sets == 0)
			revert_medGwyGatewayConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		StorageTmp->medGwyGatewayProtocol = StorageOld->medGwyGatewayProtocol;
		if (--StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewaySignalingTptProtocol(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewaySignalingTptProtocol(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewaySignalingTptProtocol entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayConfigTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyGatewayRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewaySignalingTptProtocol: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewaySignalingTptProtocol not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewaySignalingTptProtocol: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MEDGWYGATEWAYSIGNALINGTPTPROTOCOL_TCP:
		case MEDGWYGATEWAYSIGNALINGTPTPROTOCOL_UDP:
		case MEDGWYGATEWAYSIGNALINGTPTPROTOCOL_SCTP:
		case MEDGWYGATEWAYSIGNALINGTPTPROTOCOL_OTHER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewaySignalingTptProtocol: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			if (StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old = medGwyGatewayConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayConfigTable_rsvs++;
		StorageTmp->medGwyGatewaySignalingTptProtocol = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayConfigTable_tsts == 0)
				if ((ret = check_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewaySignalingTptProtocol for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayConfigTable_sets == 0)
				if ((ret = update_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
			StorageTmp->medGwyGatewayConfigTable_rsvs = 0;
			StorageTmp->medGwyGatewayConfigTable_tsts = 0;
			StorageTmp->medGwyGatewayConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayConfigTable_sets == 0)
			revert_medGwyGatewayConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		StorageTmp->medGwyGatewaySignalingTptProtocol = StorageOld->medGwyGatewaySignalingTptProtocol;
		if (--StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayAdminStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayAdminStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayAdminStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayConfigTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyGatewayRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayAdminStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayAdminStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayAdminStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MEDGWYGATEWAYADMINSTATUS_UP:
		case MEDGWYGATEWAYADMINSTATUS_DOWN:
		case MEDGWYGATEWAYADMINSTATUS_TESTING:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayAdminStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			if (StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old = medGwyGatewayConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayConfigTable_rsvs++;
		StorageTmp->medGwyGatewayAdminStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayConfigTable_tsts == 0)
				if ((ret = check_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayAdminStatus for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayConfigTable_sets == 0)
				if ((ret = update_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
			StorageTmp->medGwyGatewayConfigTable_rsvs = 0;
			StorageTmp->medGwyGatewayConfigTable_tsts = 0;
			StorageTmp->medGwyGatewayConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayConfigTable_sets == 0)
			revert_medGwyGatewayConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		StorageTmp->medGwyGatewayAdminStatus = StorageOld->medGwyGatewayAdminStatus;
		if (--StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayResetStatistics(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayResetStatistics(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayResetStatistics entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayConfigTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyGatewayRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayResetStatistics: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayResetStatistics not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayResetStatistics: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MEDGWYGATEWAYRESETSTATISTICS_NOTAPPLICABLE:
		case MEDGWYGATEWAYRESETSTATISTICS_OTHER:
		case MEDGWYGATEWAYRESETSTATISTICS_RESET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayResetStatistics: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			if (StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old = medGwyGatewayConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayConfigTable_rsvs++;
		StorageTmp->medGwyGatewayResetStatistics = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayConfigTable_tsts == 0)
				if ((ret = check_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayResetStatistics for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayConfigTable_sets == 0)
				if ((ret = update_medGwyGatewayConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
			StorageTmp->medGwyGatewayConfigTable_rsvs = 0;
			StorageTmp->medGwyGatewayConfigTable_tsts = 0;
			StorageTmp->medGwyGatewayConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayConfigTable_sets == 0)
			revert_medGwyGatewayConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
			break;
		StorageTmp->medGwyGatewayResetStatistics = StorageOld->medGwyGatewayResetStatistics;
		if (--StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
			medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayControllerIPAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayControllerIPAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayControllerTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayControllerIPAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayControllerTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_IPADDRESS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayControllerIPAddress not ASN_IPADDRESS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayControllerIPAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) == NULL)
			if (StorageTmp->medGwyGatewayControllerTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old = medGwyGatewayControllerTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayControllerTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->medGwyGatewayControllerIPAddress);
		StorageTmp->medGwyGatewayControllerIPAddress = string;
		StorageTmp->medGwyGatewayControllerIPAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayControllerTable_tsts == 0)
				if ((ret = check_medGwyGatewayControllerTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayControllerTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayControllerIPAddress for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayControllerTable_sets == 0)
				if ((ret = update_medGwyGatewayControllerTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayControllerTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) != NULL) {
			medGwyGatewayControllerTable_destroy(&StorageTmp->medGwyGatewayControllerTable_old);
			StorageTmp->medGwyGatewayControllerTable_rsvs = 0;
			StorageTmp->medGwyGatewayControllerTable_tsts = 0;
			StorageTmp->medGwyGatewayControllerTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayControllerTable_sets == 0)
			revert_medGwyGatewayControllerTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) == NULL)
			break;
		if (StorageOld->medGwyGatewayControllerIPAddress != NULL) {
			SNMP_FREE(StorageTmp->medGwyGatewayControllerIPAddress);
			StorageTmp->medGwyGatewayControllerIPAddress = StorageOld->medGwyGatewayControllerIPAddress;
			StorageTmp->medGwyGatewayControllerIPAddressLen = StorageOld->medGwyGatewayControllerIPAddressLen;
			StorageOld->medGwyGatewayControllerIPAddress = NULL;
			StorageOld->medGwyGatewayControllerIPAddressLen = 0;
		}
		if (--StorageTmp->medGwyGatewayControllerTable_rsvs == 0)
			medGwyGatewayControllerTable_destroy(&StorageTmp->medGwyGatewayControllerTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayControllerPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayControllerPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayControllerTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayControllerPort entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayControllerTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayControllerPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayControllerPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayControllerPort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) == NULL)
			if (StorageTmp->medGwyGatewayControllerTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old = medGwyGatewayControllerTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayControllerTable_rsvs++;
		StorageTmp->medGwyGatewayControllerPort = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayControllerTable_tsts == 0)
				if ((ret = check_medGwyGatewayControllerTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayControllerTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayControllerPort for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayControllerTable_sets == 0)
				if ((ret = update_medGwyGatewayControllerTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayControllerTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) != NULL) {
			medGwyGatewayControllerTable_destroy(&StorageTmp->medGwyGatewayControllerTable_old);
			StorageTmp->medGwyGatewayControllerTable_rsvs = 0;
			StorageTmp->medGwyGatewayControllerTable_tsts = 0;
			StorageTmp->medGwyGatewayControllerTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayControllerTable_sets == 0)
			revert_medGwyGatewayControllerTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) == NULL)
			break;
		StorageTmp->medGwyGatewayControllerPort = StorageOld->medGwyGatewayControllerPort;
		if (--StorageTmp->medGwyGatewayControllerTable_rsvs == 0)
			medGwyGatewayControllerTable_destroy(&StorageTmp->medGwyGatewayControllerTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayControllerAdminStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayControllerAdminStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayControllerTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayControllerAdminStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayControllerTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayControllerAdminStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayControllerAdminStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MEDGWYGATEWAYCONTROLLERADMINSTATUS_UP:
		case MEDGWYGATEWAYCONTROLLERADMINSTATUS_DOWN:
		case MEDGWYGATEWAYCONTROLLERADMINSTATUS_TESTING:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayControllerAdminStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) == NULL)
			if (StorageTmp->medGwyGatewayControllerTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old = medGwyGatewayControllerTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayControllerTable_rsvs++;
		StorageTmp->medGwyGatewayControllerAdminStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayControllerTable_tsts == 0)
				if ((ret = check_medGwyGatewayControllerTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayControllerTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayControllerAdminStatus for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayControllerTable_sets == 0)
				if ((ret = update_medGwyGatewayControllerTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayControllerTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) != NULL) {
			medGwyGatewayControllerTable_destroy(&StorageTmp->medGwyGatewayControllerTable_old);
			StorageTmp->medGwyGatewayControllerTable_rsvs = 0;
			StorageTmp->medGwyGatewayControllerTable_tsts = 0;
			StorageTmp->medGwyGatewayControllerTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayControllerTable_sets == 0)
			revert_medGwyGatewayControllerTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayControllerTable_old) == NULL)
			break;
		StorageTmp->medGwyGatewayControllerAdminStatus = StorageOld->medGwyGatewayControllerAdminStatus;
		if (--StorageTmp->medGwyGatewayControllerTable_rsvs == 0)
			medGwyGatewayControllerTable_destroy(&StorageTmp->medGwyGatewayControllerTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayTransportLastEventTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyGatewayTransportLastEventTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayStatsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayTransportLastEventTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyGatewayStatsTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayTransportLastEventTime not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayTransportLastEventTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayStatsTable_old) == NULL)
			if (StorageTmp->medGwyGatewayStatsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyGatewayStatsTable_old = medGwyGatewayStatsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyGatewayStatsTable_rsvs++;
		StorageTmp->medGwyGatewayTransportLastEventTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyGatewayStatsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyGatewayStatsTable_tsts == 0)
				if ((ret = check_medGwyGatewayStatsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayStatsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyGatewayTransportLastEventTime for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyGatewayStatsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyGatewayStatsTable_sets == 0)
				if ((ret = update_medGwyGatewayStatsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyGatewayStatsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyGatewayStatsTable_old) != NULL) {
			medGwyGatewayStatsTable_destroy(&StorageTmp->medGwyGatewayStatsTable_old);
			StorageTmp->medGwyGatewayStatsTable_rsvs = 0;
			StorageTmp->medGwyGatewayStatsTable_tsts = 0;
			StorageTmp->medGwyGatewayStatsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyGatewayStatsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyGatewayStatsTable_sets == 0)
			revert_medGwyGatewayStatsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyGatewayStatsTable_old) == NULL)
			break;
		StorageTmp->medGwyGatewayTransportLastEventTime = StorageOld->medGwyGatewayTransportLastEventTime;
		if (--StorageTmp->medGwyGatewayStatsTable_rsvs == 0)
			medGwyGatewayStatsTable_destroy(&StorageTmp->medGwyGatewayStatsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyNextTerminationId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyNextTerminationId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyTermIdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyNextTerminationId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyTermIdTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyNextTerminationId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyNextTerminationId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyNextTerminationId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyTermIdTable_old) == NULL)
			if (StorageTmp->medGwyTermIdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyTermIdTable_old = medGwyTermIdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyTermIdTable_rsvs++;
		StorageTmp->medGwyNextTerminationId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyTermIdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyTermIdTable_tsts == 0)
				if ((ret = check_medGwyTermIdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTermIdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyNextTerminationId for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyTermIdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyTermIdTable_sets == 0)
				if ((ret = update_medGwyTermIdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTermIdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyTermIdTable_old) != NULL) {
			medGwyTermIdTable_destroy(&StorageTmp->medGwyTermIdTable_old);
			StorageTmp->medGwyTermIdTable_rsvs = 0;
			StorageTmp->medGwyTermIdTable_tsts = 0;
			StorageTmp->medGwyTermIdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyTermIdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyTermIdTable_sets == 0)
			revert_medGwyTermIdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyTermIdTable_old) == NULL)
			break;
		StorageTmp->medGwyNextTerminationId = StorageOld->medGwyNextTerminationId;
		if (--StorageTmp->medGwyTermIdTable_rsvs == 0)
			medGwyTermIdTable_destroy(&StorageTmp->medGwyTermIdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyTerminationName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyTerminationName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyTerminationsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyTerminationName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyTerminationsTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyTerminationRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..64 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 64))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			if (StorageTmp->medGwyTerminationsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyTerminationsTable_old = medGwyTerminationsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyTerminationsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->medGwyTerminationName);
		StorageTmp->medGwyTerminationName = string;
		StorageTmp->medGwyTerminationNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyTerminationsTable_tsts == 0)
				if ((ret = check_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyTerminationName for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyTerminationsTable_sets == 0)
				if ((ret = update_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
			StorageTmp->medGwyTerminationsTable_rsvs = 0;
			StorageTmp->medGwyTerminationsTable_tsts = 0;
			StorageTmp->medGwyTerminationsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyTerminationsTable_sets == 0)
			revert_medGwyTerminationsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		if (StorageOld->medGwyTerminationName != NULL) {
			SNMP_FREE(StorageTmp->medGwyTerminationName);
			StorageTmp->medGwyTerminationName = StorageOld->medGwyTerminationName;
			StorageTmp->medGwyTerminationNameLen = StorageOld->medGwyTerminationNameLen;
			StorageOld->medGwyTerminationName = NULL;
			StorageOld->medGwyTerminationNameLen = 0;
		}
		if (--StorageTmp->medGwyTerminationsTable_rsvs == 0)
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyTerminationAdminStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyTerminationAdminStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyTerminationsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyTerminationAdminStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyTerminationsTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyTerminationRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationAdminStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationAdminStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationAdminStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MEDGWYTERMINATIONADMINSTATUS_INSERVICE:
		case MEDGWYTERMINATIONADMINSTATUS_OUTOFSERVICE:
		case MEDGWYTERMINATIONADMINSTATUS_TESTING:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationAdminStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			if (StorageTmp->medGwyTerminationsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyTerminationsTable_old = medGwyTerminationsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyTerminationsTable_rsvs++;
		StorageTmp->medGwyTerminationAdminStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyTerminationsTable_tsts == 0)
				if ((ret = check_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyTerminationAdminStatus for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyTerminationsTable_sets == 0)
				if ((ret = update_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
			StorageTmp->medGwyTerminationsTable_rsvs = 0;
			StorageTmp->medGwyTerminationsTable_tsts = 0;
			StorageTmp->medGwyTerminationsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyTerminationsTable_sets == 0)
			revert_medGwyTerminationsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		StorageTmp->medGwyTerminationAdminStatus = StorageOld->medGwyTerminationAdminStatus;
		if (--StorageTmp->medGwyTerminationsTable_rsvs == 0)
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyTerminationOperStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyTerminationOperStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyTerminationsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyTerminationOperStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyTerminationsTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyTerminationRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationOperStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationOperStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationOperStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MEDGWYTERMINATIONOPERSTATUS_UP:
		case MEDGWYTERMINATIONOPERSTATUS_DOWN:
		case MEDGWYTERMINATIONOPERSTATUS_TESTING:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationOperStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			if (StorageTmp->medGwyTerminationsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyTerminationsTable_old = medGwyTerminationsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyTerminationsTable_rsvs++;
		StorageTmp->medGwyTerminationOperStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyTerminationsTable_tsts == 0)
				if ((ret = check_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyTerminationOperStatus for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyTerminationsTable_sets == 0)
				if ((ret = update_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
			StorageTmp->medGwyTerminationsTable_rsvs = 0;
			StorageTmp->medGwyTerminationsTable_tsts = 0;
			StorageTmp->medGwyTerminationsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyTerminationsTable_sets == 0)
			revert_medGwyTerminationsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		StorageTmp->medGwyTerminationOperStatus = StorageOld->medGwyTerminationOperStatus;
		if (--StorageTmp->medGwyTerminationsTable_rsvs == 0)
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyTerminationInterfaceIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyTerminationInterfaceIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyTerminationsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyTerminationInterfaceIdentifier entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyTerminationsTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyTerminationRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationInterfaceIdentifier: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationInterfaceIdentifier not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationInterfaceIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..2147483647 */
		if ((1 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationInterfaceIdentifier: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			if (StorageTmp->medGwyTerminationsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyTerminationsTable_old = medGwyTerminationsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyTerminationsTable_rsvs++;
		StorageTmp->medGwyTerminationInterfaceIdentifier = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyTerminationsTable_tsts == 0)
				if ((ret = check_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyTerminationInterfaceIdentifier for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyTerminationsTable_sets == 0)
				if ((ret = update_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
			StorageTmp->medGwyTerminationsTable_rsvs = 0;
			StorageTmp->medGwyTerminationsTable_tsts = 0;
			StorageTmp->medGwyTerminationsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyTerminationsTable_sets == 0)
			revert_medGwyTerminationsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		StorageTmp->medGwyTerminationInterfaceIdentifier = StorageOld->medGwyTerminationInterfaceIdentifier;
		if (--StorageTmp->medGwyTerminationsTable_rsvs == 0)
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyTerminationPropertyProfileId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyTerminationPropertyProfileId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyTerminationsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyTerminationPropertyProfileId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyTerminationsTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyTerminationRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationPropertyProfileId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationPropertyProfileId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationPropertyProfileId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..2147483647 */
		if ((1 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationPropertyProfileId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			if (StorageTmp->medGwyTerminationsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyTerminationsTable_old = medGwyTerminationsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyTerminationsTable_rsvs++;
		StorageTmp->medGwyTerminationPropertyProfileId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyTerminationsTable_tsts == 0)
				if ((ret = check_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyTerminationPropertyProfileId for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyTerminationsTable_sets == 0)
				if ((ret = update_medGwyTerminationsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyTerminationsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
			StorageTmp->medGwyTerminationsTable_rsvs = 0;
			StorageTmp->medGwyTerminationsTable_tsts = 0;
			StorageTmp->medGwyTerminationsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyTerminationsTable_sets == 0)
			revert_medGwyTerminationsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
			break;
		StorageTmp->medGwyTerminationPropertyProfileId = StorageOld->medGwyTerminationPropertyProfileId;
		if (--StorageTmp->medGwyTerminationsTable_rsvs == 0)
			medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyPropertyProfileProperty(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_medGwyPropertyProfileProperty(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyPropertyProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("megacoMIB", "write_medGwyPropertyProfileProperty entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(medGwyPropertyProfileTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->medGwyTermPropertyProfileStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyPropertyProfileProperty: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyPropertyProfileProperty not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyPropertyProfileProperty: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old) == NULL)
			if (StorageTmp->medGwyPropertyProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old = medGwyPropertyProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->medGwyPropertyProfileTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->medGwyPropertyProfileProperty);
		StorageTmp->medGwyPropertyProfileProperty = objid;
		StorageTmp->medGwyPropertyProfilePropertyLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->medGwyPropertyProfileTable_tsts == 0)
				if ((ret = check_medGwyPropertyProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyPropertyProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->medGwyPropertyProfileProperty for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->medGwyPropertyProfileTable_sets == 0)
				if ((ret = update_medGwyPropertyProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->medGwyPropertyProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old) != NULL) {
			medGwyPropertyProfileTable_destroy(&StorageTmp->medGwyPropertyProfileTable_old);
			StorageTmp->medGwyPropertyProfileTable_rsvs = 0;
			StorageTmp->medGwyPropertyProfileTable_tsts = 0;
			StorageTmp->medGwyPropertyProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->medGwyPropertyProfileTable_sets == 0)
			revert_medGwyPropertyProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old) == NULL)
			break;
		if (StorageOld->medGwyPropertyProfileProperty != NULL) {
			SNMP_FREE(StorageTmp->medGwyPropertyProfileProperty);
			StorageTmp->medGwyPropertyProfileProperty = StorageOld->medGwyPropertyProfileProperty;
			StorageTmp->medGwyPropertyProfilePropertyLen = StorageOld->medGwyPropertyProfilePropertyLen;
			StorageOld->medGwyPropertyProfileProperty = NULL;
			StorageOld->medGwyPropertyProfilePropertyLen = 0;
		}
		if (--StorageTmp->medGwyPropertyProfileTable_rsvs == 0)
			medGwyPropertyProfileTable_destroy(&StorageTmp->medGwyPropertyProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_medGwyGatewayConfigTable_row(struct medGwyGatewayConfigTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_medGwyTerminationsTable_row(struct medGwyTerminationsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_medGwyPropertyProfileTable_row(struct medGwyPropertyProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyGatewayRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_medGwyGatewayRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyGatewayConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct medGwyGatewayConfigTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 12;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("megacoMIB", "write_medGwyGatewayRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(medGwyGatewayConfigTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyGatewayRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* medGwyGatewayId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* medGwyGatewayLinkId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[12]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* medGwyGatewayId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyGatewayId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..2147483647 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2147483647)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyGatewayId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* medGwyGatewayLinkId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyGatewayLinkId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..2147483647 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2147483647)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyGatewayLinkId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = medGwyGatewayConfigTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->medGwyGatewayConfigTable_rsvs = 1;
			vp = vars;
			StorageNew->medGwyGatewayId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->medGwyGatewayLinkId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&medGwyGatewayConfigTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->medGwyGatewayRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->medGwyGatewayConfigTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
				if (StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
					if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old = medGwyGatewayConfigTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->medGwyGatewayConfigTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->medGwyGatewayConfigTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				medGwyGatewayConfigTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_medGwyGatewayConfigTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->medGwyGatewayRowStatus != RS_ACTIVE)
				if ((ret = can_act_medGwyGatewayConfigTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->medGwyGatewayRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_medGwyGatewayConfigTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->medGwyGatewayRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_medGwyGatewayConfigTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->medGwyGatewayRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_medGwyGatewayConfigTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->medGwyGatewayRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_medGwyGatewayConfigTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->medGwyGatewayRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_medGwyGatewayConfigTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_medGwyGatewayConfigTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->medGwyGatewayRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->medGwyGatewayRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->medGwyGatewayRowStatus = set_value;
			if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) != NULL) {
				medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
				StorageTmp->medGwyGatewayConfigTable_rsvs = 0;
				StorageTmp->medGwyGatewayConfigTable_tsts = 0;
				StorageTmp->medGwyGatewayConfigTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			medGwyGatewayConfigTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_medGwyGatewayConfigTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->medGwyGatewayRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_medGwyGatewayConfigTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->medGwyGatewayRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_medGwyGatewayConfigTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				medGwyGatewayConfigTable_del(StorageNew);
				medGwyGatewayConfigTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->medGwyGatewayConfigTable_old) == NULL)
				break;
			if (--StorageTmp->medGwyGatewayConfigTable_rsvs == 0)
				medGwyGatewayConfigTable_destroy(&StorageTmp->medGwyGatewayConfigTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				medGwyGatewayConfigTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyTerminationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_medGwyTerminationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyTerminationsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct medGwyTerminationsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 12;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("megacoMIB", "write_medGwyTerminationRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(medGwyTerminationsTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTerminationRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* medGwyGatewayId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* medGwyTerminationId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[12]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* medGwyGatewayId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyGatewayId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..2147483647 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2147483647)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyGatewayId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* medGwyTerminationId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyTerminationId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..2147483647 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2147483647)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyTerminationId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = medGwyTerminationsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->medGwyTerminationsTable_rsvs = 1;
			vp = vars;
			StorageNew->medGwyGatewayId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->medGwyTerminationId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&medGwyTerminationsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->medGwyTerminationRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->medGwyTerminationsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
				if (StorageTmp->medGwyTerminationsTable_rsvs == 0)
					if ((StorageOld = StorageTmp->medGwyTerminationsTable_old = medGwyTerminationsTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->medGwyTerminationsTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->medGwyTerminationsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				medGwyTerminationsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_medGwyTerminationsTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->medGwyTerminationRowStatus != RS_ACTIVE)
				if ((ret = can_act_medGwyTerminationsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->medGwyTerminationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_medGwyTerminationsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->medGwyTerminationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_medGwyTerminationsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->medGwyTerminationRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_medGwyTerminationsTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->medGwyTerminationRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_medGwyTerminationsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->medGwyTerminationRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_medGwyTerminationsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_medGwyTerminationsTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->medGwyTerminationRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->medGwyTerminationRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->medGwyTerminationRowStatus = set_value;
			if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) != NULL) {
				medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
				StorageTmp->medGwyTerminationsTable_rsvs = 0;
				StorageTmp->medGwyTerminationsTable_tsts = 0;
				StorageTmp->medGwyTerminationsTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			medGwyTerminationsTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_medGwyTerminationsTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->medGwyTerminationRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_medGwyTerminationsTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->medGwyTerminationRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_medGwyTerminationsTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				medGwyTerminationsTable_del(StorageNew);
				medGwyTerminationsTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->medGwyTerminationsTable_old) == NULL)
				break;
			if (--StorageTmp->medGwyTerminationsTable_rsvs == 0)
				medGwyTerminationsTable_destroy(&StorageTmp->medGwyTerminationsTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				medGwyTerminationsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_medGwyTermPropertyProfileStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_medGwyTermPropertyProfileStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct medGwyPropertyProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct medGwyPropertyProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 12;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("megacoMIB", "write_medGwyTermPropertyProfileStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(medGwyPropertyProfileTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTermPropertyProfileStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to medGwyTermPropertyProfileStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* medGwyGatewayId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* medGwyPropertyProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* medGwyPropertyProfileIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[12]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* medGwyGatewayId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyGatewayId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..2147483647 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2147483647)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyGatewayId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* medGwyPropertyProfileId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyPropertyProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..2147483647 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2147483647)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyPropertyProfileId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* medGwyPropertyProfileIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyPropertyProfileIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..2147483647 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2147483647)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index medGwyPropertyProfileIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = medGwyPropertyProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->medGwyPropertyProfileTable_rsvs = 1;
			vp = vars;
			StorageNew->medGwyGatewayId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->medGwyPropertyProfileId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->medGwyPropertyProfileIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&medGwyPropertyProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->medGwyTermPropertyProfileStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->medGwyPropertyProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old) == NULL)
				if (StorageTmp->medGwyPropertyProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old = medGwyPropertyProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->medGwyPropertyProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->medGwyPropertyProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				medGwyPropertyProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_medGwyPropertyProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->medGwyTermPropertyProfileStatus != RS_ACTIVE)
				if ((ret = can_act_medGwyPropertyProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->medGwyTermPropertyProfileStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_medGwyPropertyProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->medGwyTermPropertyProfileStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_medGwyPropertyProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->medGwyTermPropertyProfileStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must 
		   be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_medGwyPropertyProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->medGwyTermPropertyProfileStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_medGwyPropertyProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->medGwyTermPropertyProfileStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_medGwyPropertyProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_medGwyPropertyProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->medGwyTermPropertyProfileStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->medGwyTermPropertyProfileStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->medGwyTermPropertyProfileStatus = set_value;
			if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old) != NULL) {
				medGwyPropertyProfileTable_destroy(&StorageTmp->medGwyPropertyProfileTable_old);
				StorageTmp->medGwyPropertyProfileTable_rsvs = 0;
				StorageTmp->medGwyPropertyProfileTable_tsts = 0;
				StorageTmp->medGwyPropertyProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			medGwyPropertyProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_medGwyPropertyProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->medGwyTermPropertyProfileStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_medGwyPropertyProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->medGwyTermPropertyProfileStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_medGwyPropertyProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				medGwyPropertyProfileTable_del(StorageNew);
				medGwyPropertyProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->medGwyPropertyProfileTable_old) == NULL)
				break;
			if (--StorageTmp->medGwyPropertyProfileTable_rsvs == 0)
				medGwyPropertyProfileTable_destroy(&StorageTmp->medGwyPropertyProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				medGwyPropertyProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

void
send_medGwyLinkStatusChange_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("megacoMIB", "send_medGwyLinkStatusChange_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = medGwyLinkStatusChange_oid;
	trap.val_len = sizeof(medGwyLinkStatusChange_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

void
send_medGwyInvalidControllerAddress_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("megacoMIB", "send_medGwyInvalidControllerAddress_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = medGwyInvalidControllerAddress_oid;
	trap.val_len = sizeof(medGwyInvalidControllerAddress_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

void
send_medGwyInvalidTerminationId_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("megacoMIB", "send_medGwyInvalidTerminationId_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = medGwyInvalidTerminationId_oid;
	trap.val_len = sizeof(medGwyInvalidTerminationId_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

void
send_medGwyInvalidPackageElement_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("megacoMIB", "send_medGwyInvalidPackageElement_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = medGwyInvalidPackageElement_oid;
	trap.val_len = sizeof(medGwyInvalidPackageElement_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

void
send_medGwyTerminationStatusChange_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("megacoMIB", "send_medGwyTerminationStatusChange_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = medGwyTerminationStatusChange_oid;
	trap.val_len = sizeof(medGwyTerminationStatusChange_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

void
send_medGwyGatewayHandoff_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("megacoMIB", "send_medGwyGatewayHandoff_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = medGwyGatewayHandoff_oid;
	trap.val_len = sizeof(medGwyGatewayHandoff_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

void
send_medGwyProtocolError_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("megacoMIB", "send_medGwyProtocolError_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = medGwyProtocolError_oid;
	trap.val_len = sizeof(medGwyProtocolError_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/**
 * @fn void megacoMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
megacoMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("megacoMIB", "megacoMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (megacoMIBold_signal_handler != NULL)
		(*megacoMIBold_signal_handler) (sig);
	DEBUGMSGTL(("megacoMIB", "done.\n"));
}

/**
 * @fn void megacoMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
megacoMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("megacoMIB", "megacoMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("megacoMIB", "done.\n"));
	return;
}
