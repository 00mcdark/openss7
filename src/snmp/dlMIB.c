/*****************************************************************************

 @(#) File: src/snmp/dlMIB.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] = "File: " __FILE__ "  Version: " PACKAGE_ENVR "  Date: " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "dlMIB.h"
#define MASTER 1
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "dlMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int dlMIB_refresh = 1;
volatile int communicationsEntityTable_refresh = 1;
volatile int sap1Table_refresh = 1;
volatile int sap2Table_refresh = 1;
volatile int clProtocolMachineTable_refresh = 1;
volatile int coProtocolMachineTable_refresh = 1;
volatile int singlePeerConnectionTable_refresh = 1;
volatile int physicalEntityTable_refresh = 1;
volatile int physicalSAPTable_refresh = 1;
volatile int dataCircuitTable_refresh = 1;
volatile int physicalConnectionTable_refresh = 1;
volatile int datalinkEntityTable_refresh = 1;
volatile int dLSAPTable_refresh = 1;
volatile int lAPBDLETable_refresh = 1;
volatile int sLPPMTable_refresh = 1;
volatile int sLPConnectionTable_refresh = 1;
volatile int sLPConnectionIVMOTable_refresh = 1;
volatile int mACDLETable_refresh = 1;
volatile int mACTable_refresh = 1;
volatile int lLCDLETable_refresh = 1;
volatile int lLCCLPMTable_refresh = 1;
volatile int lLCCOPMTable_refresh = 1;
volatile int resourceTypeIdTable_refresh = 1;
volatile int lLCStationTable_refresh = 1;
volatile int lLCSAPTable_refresh = 1;
volatile int rDESetupTable_refresh = 1;
volatile int rDEPairTable_refresh = 1;
volatile int lLCConnectionLessTable_refresh = 1;
volatile int lLCConnection2Table_refresh = 1;
volatile int lLCConnection2IVMOTable_refresh = 1;
volatile int lLCConnectionlessAckTable_refresh = 1;
volatile int lLCConnectionlessAckIVMOTable_refresh = 1;
volatile int networkEntityTable_refresh = 1;
volatile int nSAPTable_refresh = 1;
volatile int cLNSTable_refresh = 1;
volatile int cLNSISISTable_refresh = 1;
volatile int cLNSISISLevel2Table_refresh = 1;
volatile int linkageTable_refresh = 1;
volatile int cONSTable_refresh = 1;
volatile int networkConnectionTable_refresh = 1;
volatile int x25PLETable_refresh = 1;
volatile int x25PLE_DTETable_refresh = 1;
volatile int x25PLE_DCETable_refresh = 1;
volatile int x25PLEIVMOTable_refresh = 1;
volatile int x25PLEIVMO_DTETable_refresh = 1;
volatile int x25PLEIVMO_DCETable_refresh = 1;
volatile int virtualCallTable_refresh = 1;
volatile int virtualCircuitTable_refresh = 1;
volatile int virtualCircuit_DTETable_refresh = 1;
volatile int virtualCircuit_DCETable_refresh = 1;
volatile int permanentVirtualCircuitTable_refresh = 1;
volatile int permanentVirtualCircuit_DTETable_refresh = 1;
volatile int permanentVirtualCircuit_DCETable_refresh = 1;
volatile int virtualCallIVMOTable_refresh = 1;
volatile int switchedVirtualCallTable_refresh = 1;
volatile int virtualCall_DTETable_refresh = 1;
volatile int virtualCall_DCETable_refresh = 1;
volatile int dSeriesCountsTable_refresh = 1;
volatile int adjacencyTable_refresh = 1;
volatile int virtualAdjacencyTable_refresh = 1;
volatile int destinationTable_refresh = 1;
volatile int destinationSystemTable_refresh = 1;
volatile int destinationAreaTable_refresh = 1;
volatile int reachableAddressTable_refresh = 1;

/*
 * dlMIB_variables_oid: object identifier for dlMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid dlMIB_variables_oid[9] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212 };
oid physicalSAPTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 8, 1, 1 };
oid dataCircuitTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 9, 1, 1 };
oid physicalConnectionTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 10, 1, 1 };
oid datalinkEntityTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 11, 1, 1 };
oid dLSAPTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 12, 1, 1 };
oid lAPBDLETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 13, 1, 1 };
oid sLPPMTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 14, 1, 1 };
oid sLPConnectionTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 15, 1, 1 };
oid sLPConnectionIVMOTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 16, 1, 1 };
oid mACDLETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 17, 1, 1 };
oid mACTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 18, 1, 1 };
oid lLCDLETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 19, 1, 1 };
oid lLCCLPMTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 20, 1, 1 };
oid lLCCOPMTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 21, 1, 1 };
oid lLCConnectionlessAckIVMOTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 31, 1, 1 };
oid networkEntityTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 32, 1, 1 };
oid nSAPTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 33, 1, 1 };
oid cLNSTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 34, 1, 1 };
oid cLNSISISTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 35, 1, 1 };
oid cLNSISISLevel2Table_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 36, 1, 1 };
oid linkageTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 37, 1, 1 };
oid cONSTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 38, 1, 1 };
oid networkConnectionTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 39, 1, 1 };
oid x25PLETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 40, 1, 1 };
oid x25PLEIVMOTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 43, 1, 1 };
oid x25PLEIVMO_DTETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 44, 1, 1 };
oid x25PLEIVMO_DCETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 45, 1, 1 };
oid permanentVirtualCircuitTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 50, 1, 1 };
oid permanentVirtualCircuit_DTETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 51, 1, 1 };
oid permanentVirtualCircuit_DCETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 52, 1, 1 };
oid virtualCallIVMOTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 53, 1, 1 };
oid switchedVirtualCallTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 54, 1, 1 };
oid virtualCall_DTETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 55, 1, 1 };
oid virtualCall_DCETable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 56, 1, 1 };
oid dSeriesCountsTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 57, 1, 1 };
oid adjacencyTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 58, 1, 1 };
oid reachableAddressTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 1, 63, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid lLCConnection2Event_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 0, 1 };
oid lLCClessACKEvent_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 0, 2 };
oid lLCStationEvent_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 0, 3 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid physicalBitErrorThresholdReached_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 1 };
oid physicalConnectionError_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 2 };
oid phsyicalConnectionEstablished_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 3 };
oid physicalLossOfSignal_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 4 };
oid physicalLossOfSynchronization_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 5 };
oid fRMR_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 6 };
oid pdusDiscarded1_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 7 };
oid pdusDiscarded2_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 8 };
oid pduRetransmissions_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 9 };
oid acknowledgeTimeout_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 10 };
oid busyStateTimeout_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 11 };
oid rejectTimeout_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 12 };
oid pBitTimeout_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 13 };
oid type2Violation_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 14 };
oid retranmissions_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 15 };
oid type3Violation_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 16 };
oid noResponse_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 17 };
oid pdusDiscarded_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 18 };
oid bufferProblems_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 19 };
oid notificationPDUHeader_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 20 };
oid reachabilityChange_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 21 };
oid notificationData_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 22 };
oid constraintViolation_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 23 };
oid notificationReceivingAdjacency_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 24 };
oid notificationIDLength_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 25 };
oid notificationAreaAddress_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 26 };
oid notificationAreaAddresses_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 27 };
oid notificationSourceId_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 28 };
oid notificationMaximumAreaAddresses_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 29 };
oid notificationVirtualLinkChange_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 30 };
oid notificationVirtualLinkAddress_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 31 };
oid notificationSystemId_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 32 };
oid notificationVersion_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 33 };
oid notificationDesignatedIntermediateSystemChange_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 34 };
oid notificationOverloadStateChange_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 35 };
oid reservedName_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 36 };
oid notificationLSPHeader_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 1, 3, 37 };

/*
 * Other oids defined in this MIB.
 */
oid osiObjectGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 2, 1, 1 };
oid osiNotificationGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 2, 1, 2 };
oid osiTotalCompliance_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 212, 2, 2, 1 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 dlMIB_variables: tree for dlMIB
 * This variable defines function callbacks and type return information for the dlMIB mib section
 */
struct variable7 dlMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   COMMUNICATIONSENTITYLOCALSAPNAMES  1
	{(u_char) COMMUNICATIONSENTITYLOCALSAPNAMES, ASN_OBJECT_ID, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 2}},
#define   COMMUNICATIONSENTITYOPERATIONALSTATE  2
	{(u_char) COMMUNICATIONSENTITYOPERATIONALSTATE, ASN_INTEGER, RONLY, var_communicationsEntityTable, 6, {1, 1, 1, 1, 1, 3}},
#define   SAP1ADDRESS           3
	{(u_char) SAP1ADDRESS, ASN_UNSIGNED, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 2}},
#define   SAP1USERENTITYNAMES   4
	{(u_char) SAP1USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap1Table, 6, {1, 1, 2, 1, 1, 3}},
#define   SAP2ADDRESS           5
	{(u_char) SAP2ADDRESS, ASN_OCTET_STR, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 1}},
#define   SAP2USERENTITYNAMES   6
	{(u_char) SAP2USERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 2}},
#define   SAP2PROVIDERENTITYNAMES  7
	{(u_char) SAP2PROVIDERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_sap2Table, 6, {1, 1, 3, 1, 1, 3}},
#define   CLPROTOCOLMACHINEOPERATIONALSTATE  8
	{(u_char) CLPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 2}},
#define   CLPROTOCOLMACHINETOTALREMOTESAPS  9
	{(u_char) CLPROTOCOLMACHINETOTALREMOTESAPS, ASN_COUNTER, RONLY, var_clProtocolMachineTable, 6, {1, 1, 4, 1, 1, 3}},
#define   COPROTOCOLMACHINEOPERATIONALSTATE  10
	{(u_char) COPROTOCOLMACHINEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_coProtocolMachineTable, 6, {1, 1, 5, 1, 1, 2}},
#define   UNDERLYINGCONNECTIONNAMES  11
	{(u_char) UNDERLYINGCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 2}},
#define   SUPPPORTEDCONNECTIONNAMES  12
	{(u_char) SUPPPORTEDCONNECTIONNAMES, ASN_OBJECT_ID, RONLY, var_singlePeerConnectionTable, 6, {1, 1, 6, 1, 1, 3}},
#define   PHYSICALENTITYPHYSICALENTITYTITLES  13
	{(u_char) PHYSICALENTITYPHYSICALENTITYTITLES, ASN_OBJECT_ID, RWRITE, var_physicalEntityTable, 6, {1, 1, 7, 1, 1, 1}},
#define   PHYSICALSAPROWSTATUS  14
	{(u_char) PHYSICALSAPROWSTATUS, ASN_INTEGER, RWRITE, var_physicalSAPTable, 6, {1, 1, 8, 1, 1, 1}},
#define   DATACIRCUITBITERRORSRECEIVED  15
	{(u_char) DATACIRCUITBITERRORSRECEIVED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 1}},
#define   DATACIRCUITBITERRORSTRANSMITTED  16
	{(u_char) DATACIRCUITBITERRORSTRANSMITTED, ASN_COUNTER, RONLY, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 2}},
#define   DATACIRCUITBITERRORSTHRESHOLD  17
	{(u_char) DATACIRCUITBITERRORSTHRESHOLD, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 3}},
#define   DATACIRCUITTYPE       18
	{(u_char) DATACIRCUITTYPE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 4}},
#define   DATACIRCUITPHYSICALMEDIANAMES  19
	{(u_char) DATACIRCUITPHYSICALMEDIANAMES, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 5}},
#define   DATACIRCUITPHYSICALINTERFACETYPE  20
	{(u_char) DATACIRCUITPHYSICALINTERFACETYPE, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 6}},
#define   DATACIRCUITPHYSICALINTERFACESTANDARD  21
	{(u_char) DATACIRCUITPHYSICALINTERFACESTANDARD, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 7}},
#define   DATACIRCUITSYNCHRONIZATIONMODE  22
	{(u_char) DATACIRCUITSYNCHRONIZATIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 8}},
#define   DATACIRCUITTRANSMISSIONCODING  23
	{(u_char) DATACIRCUITTRANSMISSIONCODING, ASN_OCTET_STR, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 9}},
#define   DATACIRCUITTRANSMISSIONMODE  24
	{(u_char) DATACIRCUITTRANSMISSIONMODE, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 10}},
#define   DATACIRCUITTRANSMISSIONRATE  25
	{(u_char) DATACIRCUITTRANSMISSIONRATE, ASN_OPAQUE, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 11}},
#define   DATACIRCUITROWSTATUS  26
	{(u_char) DATACIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_dataCircuitTable, 6, {1, 1, 9, 1, 1, 12}},
#define   PHYSICALCONNECTIONENDPOINTIDENTIFIER  27
	{(u_char) PHYSICALCONNECTIONENDPOINTIDENTIFIER, ASN_OCTET_STR, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 1}},
#define   PHYSICALCONNECTIONPORTNUMBER  28
	{(u_char) PHYSICALCONNECTIONPORTNUMBER, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 2}},
#define   PHYSICALCONNECTIONROWSTATUS  29
	{(u_char) PHYSICALCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_physicalConnectionTable, 6, {1, 1, 10, 1, 1, 3}},
#define   DATALINKENTITYPROVIDERENTITYNAMES  30
	{(u_char) DATALINKENTITYPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 1}},
#define   DATALINKENTITYROWSTATUS  31
	{(u_char) DATALINKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_datalinkEntityTable, 6, {1, 1, 11, 1, 1, 2}},
#define   DLSAPROWSTATUS        32
	{(u_char) DLSAPROWSTATUS, ASN_INTEGER, RWRITE, var_dLSAPTable, 6, {1, 1, 12, 1, 1, 1}},
#define   LAPBDLEMT1TIMER       33
	{(u_char) LAPBDLEMT1TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 1}},
#define   LAPBDLEMT3TIMER       34
	{(u_char) LAPBDLEMT3TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 2}},
#define   LAPBDLEMW             35
	{(u_char) LAPBDLEMW, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 3}},
#define   LAPBDLEMXSEND         36
	{(u_char) LAPBDLEMXSEND, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 4}},
#define   LAPBDLEMXRECEIVE      37
	{(u_char) LAPBDLEMXRECEIVE, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 5}},
#define   LAPBDLEMT2TIMER       38
	{(u_char) LAPBDLEMT2TIMER, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 6}},
#define   LAPBDLERECEIVEDMLPRESETS  39
	{(u_char) LAPBDLERECEIVEDMLPRESETS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 7}},
#define   LAPBDLETIMESMT1EXPIRED  40
	{(u_char) LAPBDLETIMESMT1EXPIRED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 8}},
#define   LAPBDLEIFRAMESREASSIGNMENTS  41
	{(u_char) LAPBDLEIFRAMESREASSIGNMENTS, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 9}},
#define   LAPBDLEMLPFRAMESRECEIVED  42
	{(u_char) LAPBDLEMLPFRAMESRECEIVED, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 10}},
#define   LAPBDLEMLPFRAMESSENT  43
	{(u_char) LAPBDLEMLPFRAMESSENT, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 11}},
#define   LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD  44
	{(u_char) LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 12}},
#define   LAPBDLERECEIVEDMLPFRAMESINGUARDREGION  45
	{(u_char) LAPBDLERECEIVEDMLPFRAMESINGUARDREGION, ASN_COUNTER, RONLY, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 13}},
#define   LAPBDLEROWSTATUS      46
	{(u_char) LAPBDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lAPBDLETable, 6, {1, 1, 13, 1, 1, 14}},
#define   SLPPMADMINISTRATIVESTATE  47
	{(u_char) SLPPMADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 3}},
#define   SLPPMROWSTATUS        48
	{(u_char) SLPPMROWSTATUS, ASN_INTEGER, RWRITE, var_sLPPMTable, 6, {1, 1, 14, 1, 1, 4}},
#define   SLPCONNECTIONINTERFACETYPE  49
	{(u_char) SLPCONNECTIONINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 1}},
#define   SLPCONNECTIONK        50
	{(u_char) SLPCONNECTIONK, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 2}},
#define   SLPCONNECTIONN1       51
	{(u_char) SLPCONNECTIONN1, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 3}},
#define   SLPCONNECTIONN2       52
	{(u_char) SLPCONNECTIONN2, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 4}},
#define   SLPCONNECTIONSEQUENCEMODULUS  53
	{(u_char) SLPCONNECTIONSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 5}},
#define   SLPCONNECTIONT1TIMER  54
	{(u_char) SLPCONNECTIONT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 6}},
#define   SLPCONNECTIONT2TIMER  55
	{(u_char) SLPCONNECTIONT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 7}},
#define   SLPCONNECTIONFCSERRORSRECEIVED  56
	{(u_char) SLPCONNECTIONFCSERRORSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 8}},
#define   SLPCONNECTIONFRMRSRECEIVED  57
	{(u_char) SLPCONNECTIONFRMRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 9}},
#define   SLPCONNECTIONFRMRSSENT  58
	{(u_char) SLPCONNECTIONFRMRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 10}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED  59
	{(u_char) SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 11}},
#define   SLPCONNECTIONIFRAMEDATAOCTETSSENT  60
	{(u_char) SLPCONNECTIONIFRAMEDATAOCTETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 12}},
#define   SLPCONNECTIONIFRAMESRECEIVED  61
	{(u_char) SLPCONNECTIONIFRAMESRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 13}},
#define   SLPCONNECTIONIFRAMESSENT  62
	{(u_char) SLPCONNECTIONIFRAMESSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 14}},
#define   SLPCONNECTIONPOLLSRECEIVED  63
	{(u_char) SLPCONNECTIONPOLLSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 15}},
#define   SLPCONNECTIONREJSRECEIVED  64
	{(u_char) SLPCONNECTIONREJSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 16}},
#define   SLPCONNECTIONREJSSENT  65
	{(u_char) SLPCONNECTIONREJSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 17}},
#define   SLPCONNECTIONRNRSRECEIVED  66
	{(u_char) SLPCONNECTIONRNRSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 18}},
#define   SLPCONNECTIONRNRSSENT  67
	{(u_char) SLPCONNECTIONRNRSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 19}},
#define   SLPCONNECTIONSABMSRECEIVED  68
	{(u_char) SLPCONNECTIONSABMSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 20}},
#define   SLPCONNECTIONSABMSSENT  69
	{(u_char) SLPCONNECTIONSABMSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 21}},
#define   SLPCONNECTIONPROTOCOLSTATE  70
	{(u_char) SLPCONNECTIONPROTOCOLSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 22}},
#define   SLPCONNECTIONTIMEST1EXPIRED  71
	{(u_char) SLPCONNECTIONTIMEST1EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 23}},
#define   SLPCONNECTIONT3TIMER  72
	{(u_char) SLPCONNECTIONT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 24}},
#define   SLPCONNECTIONTIMEST3EXPIRED  73
	{(u_char) SLPCONNECTIONTIMEST3EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 25}},
#define   SLPCONNECTIONT4TIMER  74
	{(u_char) SLPCONNECTIONT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 26}},
#define   SLPCONNECTIONTIMEST4EXPIRED  75
	{(u_char) SLPCONNECTIONTIMEST4EXPIRED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 27}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED  76
	{(u_char) SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 28}},
#define   SLPCONNECTIONABNORMALLINKDISCONNECTSSENT  77
	{(u_char) SLPCONNECTIONABNORMALLINKDISCONNECTSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 29}},
#define   SLPCONNECTIONLINKRESETSRECEIVED  78
	{(u_char) SLPCONNECTIONLINKRESETSRECEIVED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 30}},
#define   SLPCONNECTIONLINKRESETSSENT  79
	{(u_char) SLPCONNECTIONLINKRESETSSENT, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 31}},
#define   SLPCONNECTIONTIMESN2REACHED  80
	{(u_char) SLPCONNECTIONTIMESN2REACHED, ASN_COUNTER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 32}},
#define   SLPCONNECTIONADMINISTRATIVESTATE  81
	{(u_char) SLPCONNECTIONADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 33}},
#define   SLPCONNECTIONOPERATIONALSTATE  82
	{(u_char) SLPCONNECTIONOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 34}},
#define   SLPCONNECTIONUSAGESTATE  83
	{(u_char) SLPCONNECTIONUSAGESTATE, ASN_INTEGER, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 35}},
#define   SLPCONNECTIONPROCEDURALSTATUS  84
	{(u_char) SLPCONNECTIONPROCEDURALSTATUS, ASN_OCTET_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 36}},
#define   SLPCONNECTIONALARMSTATUS  85
	{(u_char) SLPCONNECTIONALARMSTATUS, ASN_OCTET_STR, RONLY, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 37}},
#define   SLPCONNECTIONROWSTATUS  86
	{(u_char) SLPCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionTable, 6, {1, 1, 15, 1, 1, 38}},
#define   SLPCONNECTIONIVMOID   87
	{(u_char) SLPCONNECTIONIVMOID, ASN_OCTET_STR, RONLY, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 1}},
#define   SLPCONNECTIONIVMOINTERFACETYPE  88
	{(u_char) SLPCONNECTIONIVMOINTERFACETYPE, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   SLPCONNECTIONIVMOK    89
	{(u_char) SLPCONNECTIONIVMOK, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 3}},
#define   SLPCONNECTIONIVMON1   90
	{(u_char) SLPCONNECTIONIVMON1, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 4}},
#define   SLPCONNECTIONIVMON2   91
	{(u_char) SLPCONNECTIONIVMON2, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 5}},
#define   SLPCONNECTIONIVMOSEQUENCEMODULUS  92
	{(u_char) SLPCONNECTIONIVMOSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 6}},
#define   SLPCONNECTIONIVMOT1TIMER  93
	{(u_char) SLPCONNECTIONIVMOT1TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 7}},
#define   SLPCONNECTIONIVMOT2TIMER  94
	{(u_char) SLPCONNECTIONIVMOT2TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 8}},
#define   SLPCONNECTIONIVMOT3TIMER  95
	{(u_char) SLPCONNECTIONIVMOT3TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 9}},
#define   SLPCONNECTIONIVMOT4TIMER  96
	{(u_char) SLPCONNECTIONIVMOT4TIMER, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 10}},
#define   SLPCONNECTIONIVMOROWSTATUS  97
	{(u_char) SLPCONNECTIONIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_sLPConnectionIVMOTable, 6, {1, 1, 16, 1, 1, 11}},
#define   MACDLEROWSTATUS       98
	{(u_char) MACDLEROWSTATUS, ASN_INTEGER, RWRITE, var_mACDLETable, 6, {1, 1, 17, 1, 1, 1}},
#define   MACOPERATIONALSTATE   99
	{(u_char) MACOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mACTable, 6, {1, 1, 18, 1, 1, 1}},
#define   MACROWSTATUS          100
	{(u_char) MACROWSTATUS, ASN_INTEGER, RWRITE, var_mACTable, 6, {1, 1, 18, 1, 1, 3}},
#define   LLCDLEROWSTATUS       101
	{(u_char) LLCDLEROWSTATUS, ASN_INTEGER, RWRITE, var_lLCDLETable, 6, {1, 1, 19, 1, 1, 1}},
#define   LLCCLPMROWSTATUS      102
	{(u_char) LLCCLPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCLPMTable, 6, {1, 1, 20, 1, 1, 1}},
#define   LLCCOPMROWSTATUS      103
	{(u_char) LLCCOPMROWSTATUS, ASN_INTEGER, RWRITE, var_lLCCOPMTable, 6, {1, 1, 21, 1, 1, 1}},
#define   RESOURCETYPEIDNAME    104
	{(u_char) RESOURCETYPEIDNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 1}},
#define   RESOURCEINFOMANUFACTUREROUI  105
	{(u_char) RESOURCEINFOMANUFACTUREROUI, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 2}},
#define   RESOURCEINFOMANUFACTURERNAME  106
	{(u_char) RESOURCEINFOMANUFACTURERNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 3}},
#define   RESOURCEINFOMANUFACTURERPRODUCTNAME  107
	{(u_char) RESOURCEINFOMANUFACTURERPRODUCTNAME, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 4}},
#define   RESOURCEINFOMANUFACTURERPRODUCTVERSION  108
	{(u_char) RESOURCEINFOMANUFACTURERPRODUCTVERSION, ASN_OCTET_STR, RONLY, var_resourceTypeIdTable, 6, {1, 1, 22, 1, 1, 5}},
#define   LLCSTATIONLLCNAME     109
	{(u_char) LLCSTATIONLLCNAME, ASN_OCTET_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 1}},
#define   LLCSTATIONMAXIMUMLSAPSCONFIGURED  110
	{(u_char) LLCSTATIONMAXIMUMLSAPSCONFIGURED, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 2}},
#define   LLCSTATIONNUMBEROFACTIVELSAPS  111
	{(u_char) LLCSTATIONNUMBEROFACTIVELSAPS, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 3}},
#define   LLCSTATIONSUPPORTEDSERVICESTYPES  112
	{(u_char) LLCSTATIONSUPPORTEDSERVICESTYPES, ASN_OCTET_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 4}},
#define   LLCSTATIONSTATUS      113
	{(u_char) LLCSTATIONSTATUS, ASN_INTEGER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 5}},
#define   LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE  114
	{(u_char) LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 6}},
#define   LLCSTATIONTYPE1MAXIMUMRETRYCOUNT  115
	{(u_char) LLCSTATIONTYPE1MAXIMUMRETRYCOUNT, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 7}},
#define   LLCSTATIONMAXIMUMPDUN3  116
	{(u_char) LLCSTATIONMAXIMUMPDUN3, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 8}},
#define   LLCSTATIONMAXIMUMRETRANSMISSIONS4  117
	{(u_char) LLCSTATIONMAXIMUMRETRANSMISSIONS4, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 9}},
#define   LLCSTATIONRECEIVEVARIABLELIFETIME  118
	{(u_char) LLCSTATIONRECEIVEVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 10}},
#define   LLCSTATIONTRANSMITVARIABLELIFETIME  119
	{(u_char) LLCSTATIONTRANSMITVARIABLELIFETIME, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 11}},
#define   LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE  120
	{(u_char) LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 12}},
#define   LLCSTATIONTYPE3RETRANSMISSIONS  121
	{(u_char) LLCSTATIONTYPE3RETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 13}},
#define   LLCSTATIONAVGBUFFERUSESIZE  122
	{(u_char) LLCSTATIONAVGBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 14}},
#define   LLCSTATIONBUFFERPROBLEMS  123
	{(u_char) LLCSTATIONBUFFERPROBLEMS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 15}},
#define   LLCSTATIONBUFFERSIZE  124
	{(u_char) LLCSTATIONBUFFERSIZE, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 16}},
#define   LLCSTATIONMAXBUFFERUSESIZE  125
	{(u_char) LLCSTATIONMAXBUFFERUSESIZE, ASN_GAUGE, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 17}},
#define   LLCSTATIONINACTIVELSAP  126
	{(u_char) LLCSTATIONINACTIVELSAP, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 18}},
#define   LLCSTATIONPDUSDISCARD  127
	{(u_char) LLCSTATIONPDUSDISCARD, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 19}},
#define   LLCSTATIONSTRINDICATOR  128
	{(u_char) LLCSTATIONSTRINDICATOR, ASN_OCTET_STR, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 20}},
#define   LLCSTATIONVERSIONNUMBER  129
	{(u_char) LLCSTATIONVERSIONNUMBER, ASN_INTEGER, RWRITE, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 21}},
#define   LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS  130
	{(u_char) LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS, ASN_COUNTER, RONLY, var_lLCStationTable, 6, {1, 1, 23, 1, 1, 22}},
#define   LLCSAPADDRESS         131
	{(u_char) LLCSAPADDRESS, ASN_OCTET_STR, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 2}},
#define   LLCSAPRDE             132
	{(u_char) LLCSAPRDE, ASN_INTEGER, RONLY, var_lLCSAPTable, 6, {1, 1, 24, 1, 1, 3}},
#define   RDESETUPAGINGENABLED  133
	{(u_char) RDESETUPAGINGENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 1}},
#define   RDESETUPAGINGVALUE    134
	{(u_char) RDESETUPAGINGVALUE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 2}},
#define   RDESETUPENABLETYPE2RESET  135
	{(u_char) RDESETUPENABLETYPE2RESET, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 3}},
#define   RDESETUPMAXIMUMROUTEDESCRIPTORS  136
	{(u_char) RDESETUPMAXIMUMROUTEDESCRIPTORS, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 4}},
#define   RDESETUPMAXIMUMRESPONSETIME  137
	{(u_char) RDESETUPMAXIMUMRESPONSETIME, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 5}},
#define   RDESETUPMINIMUMPDUSIZE  138
	{(u_char) RDESETUPMINIMUMPDUSIZE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 6}},
#define   RDESETUPRDEHOLD       139
	{(u_char) RDESETUPRDEHOLD, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 7}},
#define   RDESETUPRDEREPLACE    140
	{(u_char) RDESETUPRDEREPLACE, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 8}},
#define   RDESETUPNAME          141
	{(u_char) RDESETUPNAME, ASN_INTEGER, RONLY, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 9}},
#define   RDESETUPRESETONTESTENABLED  142
	{(u_char) RDESETUPRESETONTESTENABLED, ASN_INTEGER, RWRITE, var_rDESetupTable, 6, {1, 1, 25, 1, 1, 10}},
#define   RDEPAIRDISCARDCOUNTER  143
	{(u_char) RDEPAIRDISCARDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 2}},
#define   RDEPAIRNSRPDUCOUNTER  144
	{(u_char) RDEPAIRNSRPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 3}},
#define   RDEPAIRNSRSELECTEDCOUNTER  145
	{(u_char) RDEPAIRNSRSELECTEDCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 4}},
#define   RDEPAIRRIF            146
	{(u_char) RDEPAIRRIF, ASN_OCTET_STR, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 5}},
#define   RDEPAIRSRFPDUCOUNTER  147
	{(u_char) RDEPAIRSRFPDUCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 6}},
#define   RDEPAIRQUERYCOUNTER   148
	{(u_char) RDEPAIRQUERYCOUNTER, ASN_COUNTER, RONLY, var_rDEPairTable, 6, {1, 1, 26, 1, 1, 7}},
#define   LLCCONNECTIONLESSNAME  149
	{(u_char) LLCCONNECTIONLESSNAME, ASN_OCTET_STR, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 1}},
#define   LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE  150
	{(u_char) LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 2}},
#define   LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE  151
	{(u_char) LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 3}},
#define   LLCCONNECTIONLESSTESTRECEIVEDCOMMAND  152
	{(u_char) LLCCONNECTIONLESSTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 4}},
#define   LLCCONNECTIONLESSTESTRECEIVEDRESPONSE  153
	{(u_char) LLCCONNECTIONLESSTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 5}},
#define   LLCCONNECTIONLESSTESTSENTABBRESPONSE  154
	{(u_char) LLCCONNECTIONLESSTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 6}},
#define   LLCCONNECTIONLESSTESTSENTCOMMAND  155
	{(u_char) LLCCONNECTIONLESSTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 7}},
#define   LLCCONNECTIONLESSTESTSENTRESPONSE  156
	{(u_char) LLCCONNECTIONLESSTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 8}},
#define   LLCCONNECTIONLESSUIRECEIVED  157
	{(u_char) LLCCONNECTIONLESSUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 9}},
#define   LLCCONNECTIONLESSUISENT  158
	{(u_char) LLCCONNECTIONLESSUISENT, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 10}},
#define   LLCCONNECTIONLESSXIDRECEIVEDCOMMAND  159
	{(u_char) LLCCONNECTIONLESSXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 11}},
#define   LLCCONNECTIONLESSXIDRECEIVEDRESPONSE  160
	{(u_char) LLCCONNECTIONLESSXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 12}},
#define   LLCCONNECTIONLESSXIDSENTCOMMAND  161
	{(u_char) LLCCONNECTIONLESSXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 13}},
#define   LLCCONNECTIONLESSXIDSENTRESPONSE  162
	{(u_char) LLCCONNECTIONLESSXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionLessTable, 6, {1, 1, 27, 1, 1, 14}},
#define   LLCCONNECTION2NAME    163
	{(u_char) LLCCONNECTION2NAME, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 1}},
#define   LLCCONNECTION2MAXIMUMRETRANSMISSIONS  164
	{(u_char) LLCCONNECTION2MAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 2}},
#define   LLCCONNECTION2RECEIVEDWINDOWSIZE  165
	{(u_char) LLCCONNECTION2RECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 3}},
#define   LLCCONNECTION2SENDWINDOWSIZE  166
	{(u_char) LLCCONNECTION2SENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 4}},
#define   LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE  167
	{(u_char) LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 5}},
#define   LLCCONNECTION2BUSYSTATETIMEOUTVALUE  168
	{(u_char) LLCCONNECTION2BUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 6}},
#define   LLCCONNECTION2PBITTIMEOUTVALUE  169
	{(u_char) LLCCONNECTION2PBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 7}},
#define   LLCCONNECTION2REJECTTIMEOUTVALUE  170
	{(u_char) LLCCONNECTION2REJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 8}},
#define   LLCCONNECTION2LOCALBUSY  171
	{(u_char) LLCCONNECTION2LOCALBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 9}},
#define   LLCCONNECTION2REMOTEBUSY  172
	{(u_char) LLCCONNECTION2REMOTEBUSY, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 10}},
#define   LLCCONNECTION2REMOTERESET  173
	{(u_char) LLCCONNECTION2REMOTERESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 11}},
#define   LLCCONNECTION2LOCALRESET  174
	{(u_char) LLCCONNECTION2LOCALRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 12}},
#define   LLCCONNECTION2PROVIDERRESET  175
	{(u_char) LLCCONNECTION2PROVIDERRESET, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 13}},
#define   LLCCONNECTION2ROUTE   176
	{(u_char) LLCCONNECTION2ROUTE, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 14}},
#define   LLCCONNECTION2KSTEP   177
	{(u_char) LLCCONNECTION2KSTEP, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 15}},
#define   LLCCONNECTION2MAXSENDWINDOWSIZE  178
	{(u_char) LLCCONNECTION2MAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 16}},
#define   LLCCONNECTION2RECEIVEDI  179
	{(u_char) LLCCONNECTION2RECEIVEDI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 17}},
#define   LLCCONNECTION2SENTI   180
	{(u_char) LLCCONNECTION2SENTI, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 18}},
#define   LLCCONNECTION2SENTACKS  181
	{(u_char) LLCCONNECTION2SENTACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 19}},
#define   LLCCONNECTION2RECEIVEDACKS  182
	{(u_char) LLCCONNECTION2RECEIVEDACKS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 20}},
#define   LLCCONNECTION2RECEIVEDFRMR  183
	{(u_char) LLCCONNECTION2RECEIVEDFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 21}},
#define   LLCCONNECTION2SENTFRMR  184
	{(u_char) LLCCONNECTION2SENTFRMR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 22}},
#define   LLCCONNECTION2RECEIVEDRR  185
	{(u_char) LLCCONNECTION2RECEIVEDRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 23}},
#define   LLCCONNECTION2SENTRR  186
	{(u_char) LLCCONNECTION2SENTRR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 24}},
#define   LLCCONNECTION2RECEIVEDRNR  187
	{(u_char) LLCCONNECTION2RECEIVEDRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 25}},
#define   LLCCONNECTION2SENTRNR  188
	{(u_char) LLCCONNECTION2SENTRNR, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 26}},
#define   LLCCONNECTION2RECEIVEDREJ  189
	{(u_char) LLCCONNECTION2RECEIVEDREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 27}},
#define   LLCCONNECTION2SENTREJ  190
	{(u_char) LLCCONNECTION2SENTREJ, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 28}},
#define   LLCCONNECTION2RECEIVEDSABME  191
	{(u_char) LLCCONNECTION2RECEIVEDSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 29}},
#define   LLCCONNECTION2SENTSABME  192
	{(u_char) LLCCONNECTION2SENTSABME, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 30}},
#define   LLCCONNECTION2RECEIVEDUA  193
	{(u_char) LLCCONNECTION2RECEIVEDUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 31}},
#define   LLCCONNECTION2SENTUA  194
	{(u_char) LLCCONNECTION2SENTUA, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 32}},
#define   LLCCONNECTION2RECEIVEDDISC  195
	{(u_char) LLCCONNECTION2RECEIVEDDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 33}},
#define   LLCCONNECTION2SENTDISC  196
	{(u_char) LLCCONNECTION2SENTDISC, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 34}},
#define   LLCCONNECTION2RECEIVEDDM  197
	{(u_char) LLCCONNECTION2RECEIVEDDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 35}},
#define   LLCCONNECTION2SENTDM  198
	{(u_char) LLCCONNECTION2SENTDM, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 36}},
#define   LLCCONNECTION2PDUSDISCARDED1  199
	{(u_char) LLCCONNECTION2PDUSDISCARDED1, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 37}},
#define   LLCCONNECTION2PDUSDISCARDED2  200
	{(u_char) LLCCONNECTION2PDUSDISCARDED2, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 38}},
#define   LLCCONNECTION2PDURETRANSMISSIONS  201
	{(u_char) LLCCONNECTION2PDURETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 39}},
#define   LLCCONNECTION2OPTIONALTOLERATIONIPDUS  202
	{(u_char) LLCCONNECTION2OPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 40}},
#define   LLCCONNECTION2DUPLICATEIPDUSRECEIVED  203
	{(u_char) LLCCONNECTION2DUPLICATEIPDUSRECEIVED, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 41}},
#define   LLCCONNECTION2VIOLATION  204
	{(u_char) LLCCONNECTION2VIOLATION, ASN_COUNTER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 42}},
#define   LLCCONNECTION2PROTOCOLSTATE  205
	{(u_char) LLCCONNECTION2PROTOCOLSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 43}},
#define   LLCCONNECTION2ADMINISTRATIVESTATE  206
	{(u_char) LLCCONNECTION2ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 44}},
#define   LLCCONNECTION2OPERATIONALSTATE  207
	{(u_char) LLCCONNECTION2OPERATIONALSTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 45}},
#define   LLCCONNECTION2USAGESTATE  208
	{(u_char) LLCCONNECTION2USAGESTATE, ASN_INTEGER, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 46}},
#define   LLCCONNECTION2PROCEDURALSTATUS  209
	{(u_char) LLCCONNECTION2PROCEDURALSTATUS, ASN_OCTET_STR, RONLY, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 47}},
#define   LLCCONNECTION2ALARMSTATUS  210
	{(u_char) LLCCONNECTION2ALARMSTATUS, ASN_OCTET_STR, RWRITE, var_lLCConnection2Table, 6, {1, 1, 28, 1, 1, 48}},
#define   LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS  211
	{(u_char) LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 2}},
#define   LLCCONNECTION2IVMORECEIVEDWINDOWSIZE  212
	{(u_char) LLCCONNECTION2IVMORECEIVEDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 3}},
#define   LLCCONNECTION2IVMOSENDWINDOWSIZE  213
	{(u_char) LLCCONNECTION2IVMOSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 4}},
#define   LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE  214
	{(u_char) LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 5}},
#define   LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE  215
	{(u_char) LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 6}},
#define   LLCCONNECTION2IVMOBITTIMEOUTVALUE  216
	{(u_char) LLCCONNECTION2IVMOBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 7}},
#define   LLCCONNECTION2IVMOREJECTTIMEOUTVALUE  217
	{(u_char) LLCCONNECTION2IVMOREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 8}},
#define   LLCCONNECTION2IVMOROUTE  218
	{(u_char) LLCCONNECTION2IVMOROUTE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 9}},
#define   LLCCONNECTION2IVMOKSTEP  219
	{(u_char) LLCCONNECTION2IVMOKSTEP, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 10}},
#define   LLCCONNECTION2IVMOMAXSENDWINDOWSIZE  220
	{(u_char) LLCCONNECTION2IVMOMAXSENDWINDOWSIZE, ASN_UNSIGNED, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 11}},
#define   LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS  221
	{(u_char) LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_lLCConnection2IVMOTable, 6, {1, 1, 29, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE  222
	{(u_char) LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS  223
	{(u_char) LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE  224
	{(u_char) LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 4}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND  225
	{(u_char) LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 5}},
#define   LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE  226
	{(u_char) LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 6}},
#define   LLCCONNECTIONLESSACKTESTSENTABBRESPONSE  227
	{(u_char) LLCCONNECTIONLESSACKTESTSENTABBRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 7}},
#define   LLCCONNECTIONLESSACKTESTSENTCOMMAND  228
	{(u_char) LLCCONNECTIONLESSACKTESTSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 8}},
#define   LLCCONNECTIONLESSACKTESTSENTRESPONSE  229
	{(u_char) LLCCONNECTIONLESSACKTESTSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 9}},
#define   LLCCONNECTIONLESSACKRECEIVERESOURCES  230
	{(u_char) LLCCONNECTIONLESSACKRECEIVERESOURCES, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 10}},
#define   LLCCONNECTIONLESSACKUIRECEIVED  231
	{(u_char) LLCCONNECTIONLESSACKUIRECEIVED, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 11}},
#define   LLCCONNECTIONLESSACKUISENT  232
	{(u_char) LLCCONNECTIONLESSACKUISENT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 12}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND  233
	{(u_char) LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 13}},
#define   LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE  234
	{(u_char) LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 14}},
#define   LLCCONNECTIONLESSACKXIDSENTCOMMAND  235
	{(u_char) LLCCONNECTIONLESSACKXIDSENTCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 15}},
#define   LLCCONNECTIONLESSACKXIDSENTRESPONSE  236
	{(u_char) LLCCONNECTIONLESSACKXIDSENTRESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 16}},
#define   LLCCONNECTIONLESSACKRETRANSMISSIONS  237
	{(u_char) LLCCONNECTIONLESSACKRETRANSMISSIONS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 17}},
#define   LLCCONNECTIONLESSACKNORESPONSE  238
	{(u_char) LLCCONNECTIONLESSACKNORESPONSE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 18}},
#define   LLCCONNECTIONLESSACKCOMMANDIP  239
	{(u_char) LLCCONNECTIONLESSACKCOMMANDIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 19}},
#define   LLCCONNECTIONLESSACKCOMMANDIT  240
	{(u_char) LLCCONNECTIONLESSACKCOMMANDIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 20}},
#define   LLCCONNECTIONLESSACKCOMMANDOK  241
	{(u_char) LLCCONNECTIONLESSACKCOMMANDOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 21}},
#define   LLCCONNECTIONLESSACKCOMMANDPE  242
	{(u_char) LLCCONNECTIONLESSACKCOMMANDPE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 22}},
#define   LLCCONNECTIONLESSACKCOMMANDRS  243
	{(u_char) LLCCONNECTIONLESSACKCOMMANDRS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 23}},
#define   LLCCONNECTIONLESSACKCOMMANDUE  244
	{(u_char) LLCCONNECTIONLESSACKCOMMANDUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 24}},
#define   LLCCONNECTIONLESSACKCOMMANDUN  245
	{(u_char) LLCCONNECTIONLESSACKCOMMANDUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 25}},
#define   LLCCONNECTIONLESSACKRECEIVEDACCOMMAND  246
	{(u_char) LLCCONNECTIONLESSACKRECEIVEDACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 26}},
#define   LLCCONNECTIONLESSACKSENTACCOMMAND  247
	{(u_char) LLCCONNECTIONLESSACKSENTACCOMMAND, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 27}},
#define   LLCCONNECTIONLESSACKRESPONSEIP  248
	{(u_char) LLCCONNECTIONLESSACKRESPONSEIP, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 28}},
#define   LLCCONNECTIONLESSACKRESPONSEIT  249
	{(u_char) LLCCONNECTIONLESSACKRESPONSEIT, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 29}},
#define   LLCCONNECTIONLESSACKRESPONSENE  250
	{(u_char) LLCCONNECTIONLESSACKRESPONSENE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 30}},
#define   LLCCONNECTIONLESSACKRESPONSENR  251
	{(u_char) LLCCONNECTIONLESSACKRESPONSENR, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 31}},
#define   LLCCONNECTIONLESSACKRESPONSEOK  252
	{(u_char) LLCCONNECTIONLESSACKRESPONSEOK, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 32}},
#define   LLCCONNECTIONLESSACKRESPONSERS  253
	{(u_char) LLCCONNECTIONLESSACKRESPONSERS, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 33}},
#define   LLCCONNECTIONLESSACKRESPONSEUE  254
	{(u_char) LLCCONNECTIONLESSACKRESPONSEUE, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 34}},
#define   LLCCONNECTIONLESSACKRESPONSEUN  255
	{(u_char) LLCCONNECTIONLESSACKRESPONSEUN, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 35}},
#define   LLCCONNECTIONLESSACKVIOLATION  256
	{(u_char) LLCCONNECTIONLESSACKVIOLATION, ASN_COUNTER, RONLY, var_lLCConnectionlessAckTable, 6, {1, 1, 30, 1, 1, 36}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE  257
	{(u_char) LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 2}},
#define   LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS  258
	{(u_char) LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 3}},
#define   LLCCONNECTIONLESSACKIVMOROWSTATUS  259
	{(u_char) LLCCONNECTIONLESSACKIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_lLCConnectionlessAckIVMOTable, 6, {1, 1, 31, 1, 1, 4}},
#define   NETWORKENTITYTITLES   260
	{(u_char) NETWORKENTITYTITLES, ASN_OCTET_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 1}},
#define   NETWORKENTITYSYSTEMTYPES  261
	{(u_char) NETWORKENTITYSYSTEMTYPES, ASN_OCTET_STR, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 2}},
#define   NETWORKENTITYROWSTATUS  262
	{(u_char) NETWORKENTITYROWSTATUS, ASN_INTEGER, RWRITE, var_networkEntityTable, 6, {1, 1, 32, 1, 1, 3}},
#define   NSAPROWSTATUS         263
	{(u_char) NSAPROWSTATUS, ASN_INTEGER, RWRITE, var_nSAPTable, 6, {1, 1, 33, 1, 1, 1}},
#define   CLNSADMINISTRATIVESTATE  264
	{(u_char) CLNSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 1}},
#define   CLNSSUPPORTEDPROTOCOLS  265
	{(u_char) CLNSSUPPORTEDPROTOCOLS, ASN_OCTET_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 2}},
#define   CLNSOPERATIONALSYSTEMTYPE  266
	{(u_char) CLNSOPERATIONALSYSTEMTYPE, ASN_OCTET_STR, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 3}},
#define   CLNSOCTETSSENTCOUNTER  267
	{(u_char) CLNSOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 4}},
#define   CLNSOCTETSRECEIVEDCOUNTER  268
	{(u_char) CLNSOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 5}},
#define   CLNSSEGMENTSRECEIVED  269
	{(u_char) CLNSSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 6}},
#define   CLNSSEGMENTSDISCARDED  270
	{(u_char) CLNSSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 7}},
#define   CLNSASSEMBLINGSEGMENTSDISCARDED  271
	{(u_char) CLNSASSEMBLINGSEGMENTSDISCARDED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 8}},
#define   CLNSERRORREPORTSRECEIVED  272
	{(u_char) CLNSERRORREPORTSRECEIVED, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 9}},
#define   CLNSPDUDISCARDS       273
	{(u_char) CLNSPDUDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 10}},
#define   CLNSCONGESTIONDISCARDS  274
	{(u_char) CLNSCONGESTIONDISCARDS, ASN_COUNTER, RONLY, var_cLNSTable, 6, {1, 1, 34, 1, 1, 11}},
#define   CLNSMAXIMUMLIFETIME   275
	{(u_char) CLNSMAXIMUMLIFETIME, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 12}},
#define   CLNSENABLECHECKSUM    276
	{(u_char) CLNSENABLECHECKSUM, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 13}},
#define   CLNSROWSTATUS         277
	{(u_char) CLNSROWSTATUS, ASN_INTEGER, RWRITE, var_cLNSTable, 6, {1, 1, 34, 1, 1, 14}},
#define   CLNSISISVERSION       278
	{(u_char) CLNSISISVERSION, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 1}},
#define   CLNSISISISTYPE        279
	{(u_char) CLNSISISISTYPE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 2}},
#define   CLNSISISSYSTEMID      280
	{(u_char) CLNSISISSYSTEMID, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 3}},
#define   CLNSISISMAXIMUMPATHSPLITS  281
	{(u_char) CLNSISISMAXIMUMPATHSPLITS, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 4}},
#define   CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL  282
	{(u_char) CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 5}},
#define   CLNSISISMAXIMUMLSPGENERATIONINTERVAL  283
	{(u_char) CLNSISISMAXIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 6}},
#define   CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL  284
	{(u_char) CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 7}},
#define   CLNSISISCOMPLETESNPINTERVAL  285
	{(u_char) CLNSISISCOMPLETESNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 8}},
#define   CLNSISISORIGINATINGL1LSPBUFFERSIZE  286
	{(u_char) CLNSISISORIGINATINGL1LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 9}},
#define   CLNSISISMANUALAREAADDRESSES  287
	{(u_char) CLNSISISMANUALAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 10}},
#define   CLNSISISMAXIMUMAREAADDRESSES  288
	{(u_char) CLNSISISMAXIMUMAREAADDRESSES, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 11}},
#define   CLNSISISMINIMUMLSPGENERATIONINTERVAL  289
	{(u_char) CLNSISISMINIMUMLSPGENERATIONINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 12}},
#define   CLNSISISPOLLESHELLORATE  290
	{(u_char) CLNSISISPOLLESHELLORATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 13}},
#define   CLNSISISPARTIALSNPINTERVAL  291
	{(u_char) CLNSISISPARTIALSNPINTERVAL, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 14}},
#define   CLNSISISWAITINGTIME   292
	{(u_char) CLNSISISWAITINGTIME, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 15}},
#define   CLNSISISDRISISHELLOTIMER  293
	{(u_char) CLNSISISDRISISHELLOTIMER, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 16}},
#define   CLNSISISL1STATE       294
	{(u_char) CLNSISISL1STATE, ASN_INTEGER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 17}},
#define   CLNSISISAREAADDRESSES  295
	{(u_char) CLNSISISAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 18}},
#define   CLNSISISCORRUPTEDLSPSDETECTED  296
	{(u_char) CLNSISISCORRUPTEDLSPSDETECTED, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 19}},
#define   CLNSISISLSPL1DATABASEOVERLOADS  297
	{(u_char) CLNSISISLSPL1DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 20}},
#define   CLNSISISMANUALADDRESSESDROPPEDFROMAREAS  298
	{(u_char) CLNSISISMANUALADDRESSESDROPPEDFROMAREAS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 21}},
#define   CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER  299
	{(u_char) CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 22}},
#define   CLNSISISSEQUENCENUMBERSKIPS  300
	{(u_char) CLNSISISSEQUENCENUMBERSKIPS, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 23}},
#define   CLNSISISOWNLSPPURGES  301
	{(u_char) CLNSISISOWNLSPPURGES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 24}},
#define   CLNSISISIDFIELDLENGTHMISMATCHES  302
	{(u_char) CLNSISISIDFIELDLENGTHMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 25}},
#define   CLNSISISMAXIMUMAREAADDRESSESMISMATCHES  303
	{(u_char) CLNSISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 26}},
#define   CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES  304
	{(u_char) CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 27}},
#define   CLNSISISLSPTOOLARGETOPROPAGATE  305
	{(u_char) CLNSISISLSPTOOLARGETOPROPAGATE, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 28}},
#define   CLNSISISAREATRANSMITPASSWORD  306
	{(u_char) CLNSISISAREATRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 29}},
#define   CLNSISISAREARECEIVEPASSWORDS  307
	{(u_char) CLNSISISAREARECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 30}},
#define   CLNSISISAUTHENTICATIONFAILURES  308
	{(u_char) CLNSISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 31}},
#define   CLNSISISROWSTATUS     309
	{(u_char) CLNSISISROWSTATUS, ASN_INTEGER, RWRITE, var_cLNSISISTable, 6, {1, 1, 35, 1, 1, 32}},
#define   CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES  310
	{(u_char) CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 1}},
#define   CLNSISISLEVEL2PARTITIONAREAADDRESSES  311
	{(u_char) CLNSISISLEVEL2PARTITIONAREAADDRESSES, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 2}},
#define   CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM  312
	{(u_char) CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 3}},
#define   CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES  313
	{(u_char) CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 4}},
#define   CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE  314
	{(u_char) CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 5}},
#define   CLNSISISLEVEL2L2STATE  315
	{(u_char) CLNSISISLEVEL2L2STATE, ASN_INTEGER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 6}},
#define   CLNSISISLEVEL2LSPL2DATABASEOVERLOADS  316
	{(u_char) CLNSISISLEVEL2LSPL2DATABASEOVERLOADS, ASN_COUNTER, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 7}},
#define   CLNSISISLEVEL2DOMAINTRANSMITPASSWORD  317
	{(u_char) CLNSISISLEVEL2DOMAINTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 8}},
#define   CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS  318
	{(u_char) CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS, ASN_OCTET_STR, RONLY, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 9}},
#define   CLNSISISLEVEL2ROWSTATUS  319
	{(u_char) CLNSISISLEVEL2ROWSTATUS, ASN_INTEGER, RWRITE, var_cLNSISISLevel2Table, 6, {1, 1, 36, 1, 1, 10}},
#define   LINKAGEOPERATIONALSTATE  320
	{(u_char) LINKAGEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 3}},
#define   LINKAGEADMINISTRATIVESTATE  321
	{(u_char) LINKAGEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 4}},
#define   LINKAGESNSERVICEPROVIDER  322
	{(u_char) LINKAGESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 5}},
#define   LINKAGESNSAP          323
	{(u_char) LINKAGESNSAP, ASN_OBJECT_ID, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 6}},
#define   LINKAGEOPERATIONALPROTOCOLS  324
	{(u_char) LINKAGEOPERATIONALPROTOCOLS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 7}},
#define   LINKAGEISISO9542OPERATIONALSUBSETS  325
	{(u_char) LINKAGEISISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 8}},
#define   LINKAGEISHOLDINGTIMERMULTIPLIER  326
	{(u_char) LINKAGEISHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 9}},
#define   LINKAGEISISCONFIGURATIONTIMER  327
	{(u_char) LINKAGEISISCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 10}},
#define   LINKAGEISSUGGESTEDESCONFIGURATIONTIMER  328
	{(u_char) LINKAGEISSUGGESTEDESCONFIGURATIONTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 11}},
#define   LINKAGEISREDIRECTHOLDINGTIME  329
	{(u_char) LINKAGEISREDIRECTHOLDINGTIME, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 12}},
#define   LINKAGEISESREACHABILITYCHANGES  330
	{(u_char) LINKAGEISESREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 13}},
#define   LINKAGEISINVALID9542PDUS  331
	{(u_char) LINKAGEISINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 14}},
#define   LINKAGEESISO9542OPERATIONALSUBSETS  332
	{(u_char) LINKAGEESISO9542OPERATIONALSUBSETS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 15}},
#define   LINKAGEESHOLDINGTIMERMULTIPLIER  333
	{(u_char) LINKAGEESHOLDINGTIMERMULTIPLIER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 16}},
#define   LINKAGEESMANUALISSNPAADDRESS  334
	{(u_char) LINKAGEESMANUALISSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 17}},
#define   LINKAGEESDEFAULTESCONFIGTIMER  335
	{(u_char) LINKAGEESDEFAULTESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 18}},
#define   LINKAGEESACTIVEESCONFIGTIMER  336
	{(u_char) LINKAGEESACTIVEESCONFIGTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 19}},
#define   LINKAGEESISREACHABILITYCHANGES  337
	{(u_char) LINKAGEESISREACHABILITYCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 20}},
#define   LINKAGEESINVALID9542PDUS  338
	{(u_char) LINKAGEESINVALID9542PDUS, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 21}},
#define   LINKAGEENABLECHECKSUM  339
	{(u_char) LINKAGEENABLECHECKSUM, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 22}},
#define   LINKAGEINITIALMINIMUMTIMER  340
	{(u_char) LINKAGEINITIALMINIMUMTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 23}},
#define   LINKAGERESERVETIMER   341
	{(u_char) LINKAGERESERVETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 24}},
#define   LINKAGEIDLETIMER      342
	{(u_char) LINKAGEIDLETIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 25}},
#define   LINKAGESNDCFCALLSPLACED  343
	{(u_char) LINKAGESNDCFCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 26}},
#define   LINKAGESNDCFCALLSFAILED  344
	{(u_char) LINKAGESNDCFCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 27}},
#define   LINKAGECODLCALLSPLACED  345
	{(u_char) LINKAGECODLCALLSPLACED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 28}},
#define   LINKAGECODLCALLSFAILED  346
	{(u_char) LINKAGECODLCALLSFAILED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 29}},
#define   LINKAGEISISTYPE       347
	{(u_char) LINKAGEISISTYPE, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 30}},
#define   LINKAGEISISISISHELLOTIMER  348
	{(u_char) LINKAGEISISISISHELLOTIMER, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 31}},
#define   LINKAGEISISL1DEFAULTMETRIC  349
	{(u_char) LINKAGEISISL1DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 32}},
#define   LINKAGEISISL1DELAYMETRIC  350
	{(u_char) LINKAGEISISL1DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 33}},
#define   LINKAGEISISL1EXPENSEMETRIC  351
	{(u_char) LINKAGEISISL1EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 34}},
#define   LINKAGEISISL1ERRORMETRIC  352
	{(u_char) LINKAGEISISL1ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 35}},
#define   LINKAGEISISEXTERNALDOMAIN  353
	{(u_char) LINKAGEISISEXTERNALDOMAIN, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 36}},
#define   LINKAGEISISCHANGEDINADJACENCYSTATE  354
	{(u_char) LINKAGEISISCHANGEDINADJACENCYSTATE, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 37}},
#define   LINKAGEISISINITIALISATIONFAILURES  355
	{(u_char) LINKAGEISISINITIALISATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 38}},
#define   LINKAGEISISREJECTEDADJACENCIES  356
	{(u_char) LINKAGEISISREJECTEDADJACENCIES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 39}},
#define   LINKAGEISISISISCONTROLPDUSSENT  357
	{(u_char) LINKAGEISISISISCONTROLPDUSSENT, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 40}},
#define   LINKAGEISISISISCONTROLPDUSRECEIVED  358
	{(u_char) LINKAGEISISISISCONTROLPDUSRECEIVED, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 41}},
#define   LINKAGEISISIDFIELDLENTHMISMATCHES  359
	{(u_char) LINKAGEISISIDFIELDLENTHMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 42}},
#define   LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES  360
	{(u_char) LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 43}},
#define   LINKAGEISISCIRCUITTRANSMITPASSWORD  361
	{(u_char) LINKAGEISISCIRCUITTRANSMITPASSWORD, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 44}},
#define   LINKAGEISISCIRCUITRECEIVEDPASSWORDS  362
	{(u_char) LINKAGEISISCIRCUITRECEIVEDPASSWORDS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 45}},
#define   LINKAGEISISAUTHENTICATIONFAILURES  363
	{(u_char) LINKAGEISISAUTHENTICATIONFAILURES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 46}},
#define   LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY  364
	{(u_char) LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 47}},
#define   LINKAGEISISL1CIRCUITID  365
	{(u_char) LINKAGEISISL1CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 48}},
#define   LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM  366
	{(u_char) LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 49}},
#define   LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES  367
	{(u_char) LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 50}},
#define   LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT  368
	{(u_char) LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 51}},
#define   LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT  369
	{(u_char) LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 52}},
#define   LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT  370
	{(u_char) LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 53}},
#define   LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT  371
	{(u_char) LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 54}},
#define   LINKAGEISISPTPTCIRCUITID  372
	{(u_char) LINKAGEISISPTPTCIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 55}},
#define   LINKAGEISISOUTGOINGCALLIVMO  373
	{(u_char) LINKAGEISISOUTGOINGCALLIVMO, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 56}},
#define   LINKAGEISISNEIGHBORSNPAADDRESS  374
	{(u_char) LINKAGEISISNEIGHBORSNPAADDRESS, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 57}},
#define   LINKAGEISISL2DEFAULTMETRIC  375
	{(u_char) LINKAGEISISL2DEFAULTMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 58}},
#define   LINKAGEISISL2DELAYMETRIC  376
	{(u_char) LINKAGEISISL2DELAYMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 59}},
#define   LINKAGEISISL2EXPENSEMETRIC  377
	{(u_char) LINKAGEISISL2EXPENSEMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 60}},
#define   LINKAGEISISL2ERRORMETRIC  378
	{(u_char) LINKAGEISISL2ERRORMETRIC, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 61}},
#define   LINKAGEISISMANUALL2ONLYMODE  379
	{(u_char) LINKAGEISISMANUALL2ONLYMODE, ASN_INTEGER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 62}},
#define   LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY  380
	{(u_char) LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 63}},
#define   LINKAGEISISL2CIRCUITID  381
	{(u_char) LINKAGEISISL2CIRCUITID, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 64}},
#define   LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM  382
	{(u_char) LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM, ASN_OCTET_STR, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 65}},
#define   LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES  383
	{(u_char) LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES, ASN_COUNTER, RONLY, var_linkageTable, 6, {1, 1, 37, 1, 1, 66}},
#define   LINKAGEROWSTATUS      384
	{(u_char) LINKAGEROWSTATUS, ASN_INTEGER, RWRITE, var_linkageTable, 6, {1, 1, 37, 1, 1, 67}},
#define   CONSADMINISTRATIVESTATE  385
	{(u_char) CONSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 1}},
#define   CONSOPERATIONALSYSTEMTYPE  386
	{(u_char) CONSOPERATIONALSYSTEMTYPE, ASN_OCTET_STR, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 2}},
#define   CONSROWSTATUS         387
	{(u_char) CONSROWSTATUS, ASN_INTEGER, RWRITE, var_cONSTable, 6, {1, 1, 38, 1, 1, 3}},
#define   NETWORKCONNECTIONLOCALNSAPMO  388
	{(u_char) NETWORKCONNECTIONLOCALNSAPMO, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 1}},
#define   NETWORKCONNECTIONREMOTENSAPADDRESS  389
	{(u_char) NETWORKCONNECTIONREMOTENSAPADDRESS, ASN_OCTET_STR, RONLY, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 2}},
#define   NETWORKCONNECTIONROWSTATUS  390
	{(u_char) NETWORKCONNECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_networkConnectionTable, 6, {1, 1, 39, 1, 1, 3}},
#define   X25PLEOPERATIONALSTATE  391
	{(u_char) X25PLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 2}},
#define   X25PLEADMINISTRATIVESTATE  392
	{(u_char) X25PLEADMINISTRATIVESTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 3}},
#define   X25PLEPROTOCOLVERSIONSUPPORTED  393
	{(u_char) X25PLEPROTOCOLVERSIONSUPPORTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 4}},
#define   X25PLELOCALDTEADDRESS  394
	{(u_char) X25PLELOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 5}},
#define   X25PLEMODE            395
	{(u_char) X25PLEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 6}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSES  396
	{(u_char) X25PLEDEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 7}},
#define   X25PLEFLOWCONTROLPARAMETERNEGOTIATION  397
	{(u_char) X25PLEFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 8}},
#define   X25PLEDEFAULTPACKAGESIZES  398
	{(u_char) X25PLEDEFAULTPACKAGESIZES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 9}},
#define   X25PLETHROUGHPUTCLASSNEGOTIATION  399
	{(u_char) X25PLETHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 10}},
#define   X25PLESNSERVICEPROVIDER  400
	{(u_char) X25PLESNSERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 11}},
#define   X25PLESNSAP           401
	{(u_char) X25PLESNSAP, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 12}},
#define   X25PELOGICALCHANNELASSIGNMENTS  402
	{(u_char) X25PELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 13}},
#define   X25PLEINTERFACEMODE   403
	{(u_char) X25PLEINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 14}},
#define   X25PLEDEFAULTTHROUGHPUTCLASS  404
	{(u_char) X25PLEDEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 15}},
#define   X25PLEFLOWCONTROLNEGOTIATIONPERMITTED  405
	{(u_char) X25PLEFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 16}},
#define   X25PLECALLDEFLECTIONSUBSCRIPTION  406
	{(u_char) X25PLECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 17}},
#define   X25PLEMAXACTIVECIRCUITS  407
	{(u_char) X25PLEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 18}},
#define   X25PLERESTARTTIME     408
	{(u_char) X25PLERESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 19}},
#define   X25PLEDEFAULTPACKETSIZE  409
	{(u_char) X25PLEDEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 20}},
#define   X25PLEDEFAULTWINDOWSIZE  410
	{(u_char) X25PLEDEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 21}},
#define   X25PLEMINIMUMRECALLTIMER  411
	{(u_char) X25PLEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 22}},
#define   X25PLERESTARTCOUNT    412
	{(u_char) X25PLERESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 23}},
#define   X25PLESN_SERVICEPROVIDER  413
	{(u_char) X25PLESN_SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 24}},
#define   X25PLESN_SA_P         414
	{(u_char) X25PLESN_SA_P, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 25}},
#define   X25PLELOGICALCHANNELASSIGNMENTS  415
	{(u_char) X25PLELOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 26}},
#define   X25PLEPACKETSEQUENCING  416
	{(u_char) X25PLEPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 27}},
#define   X25PLEOCTETSSENTCOUNTER  417
	{(u_char) X25PLEOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 28}},
#define   X25PLEOCTETSRECEIVEDCOUNTER  418
	{(u_char) X25PLEOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 29}},
#define   X25PLEDATAPACKETSSENT  419
	{(u_char) X25PLEDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 30}},
#define   X25PLEDATAPACKETSRECEIVED  420
	{(u_char) X25PLEDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 31}},
#define   X25PLECALLATTEMPTS    421
	{(u_char) X25PLECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 32}},
#define   X25PLECALLSCONNECTED  422
	{(u_char) X25PLECALLSCONNECTED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 33}},
#define   X25PLEPROVIDERINITIATEDDISCONNECTS  423
	{(u_char) X25PLEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 34}},
#define   X25PLECALLTIMEOUTS    424
	{(u_char) X25PLECALLTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 35}},
#define   X25PLECLEARTIMEOUTS   425
	{(u_char) X25PLECLEARTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 36}},
#define   X25PLEREMOTELYINITIATEDRESETS  426
	{(u_char) X25PLEREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 37}},
#define   X25PLEDATARETRANSMISSIONTIMEREXPIRIES  427
	{(u_char) X25PLEDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 38}},
#define   X25PLEPROVIDERINITIATEDRESETS  428
	{(u_char) X25PLEPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 39}},
#define   X25PLERESETTIMEOUTS   429
	{(u_char) X25PLERESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 40}},
#define   X25PLEREMOTELYINITIATEDRESTARTS  430
	{(u_char) X25PLEREMOTELYINITIATEDRESTARTS, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 41}},
#define   X25PLERESTARTCOUNTSEXCEEDED  431
	{(u_char) X25PLERESTARTCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 42}},
#define   X25PLEPROTOCOLERRORSDETECTEDLOCALLY  432
	{(u_char) X25PLEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 43}},
#define   X25PLEPROTOCOLERRORSACCUSEDOF  433
	{(u_char) X25PLEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 44}},
#define   X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  434
	{(u_char) X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 45}},
#define   X25PLECLEARCOUNTSEXCEEDED  435
	{(u_char) X25PLECLEARCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 46}},
#define   X25PLEPLECLIENTMONAME  436
	{(u_char) X25PLEPLECLIENTMONAME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 47}},
#define   X25PLEREGISTRATIONREQUESTTIME  437
	{(u_char) X25PLEREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 48}},
#define   X25PLEREGISTRATIONREQUESTCOUNT  438
	{(u_char) X25PLEREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 49}},
#define   X25PLEREGISTRATIONPERMITTED  439
	{(u_char) X25PLEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 40, 1, 1, 50}},
#define   X25PLEROWSTATUS       440
	{(u_char) X25PLEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 40, 1, 1, 51}},
#define   X25PLE_DTECALLDEFLECTIONSUBSCRIPTION  441
	{(u_char) X25PLE_DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 1}},
#define   X25PLE_DTECALLREQUESTRESPONSETIMER  442
	{(u_char) X25PLE_DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 2}},
#define   X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING  443
	{(u_char) X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 3}},
#define   X25PLE_DTEMAXACTIVECIRCUITS  444
	{(u_char) X25PLE_DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 4}},
#define   X25PLE_DTEMINIMUMRECALLTIMER  445
	{(u_char) X25PLE_DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 5}},
#define   X25PLE_DTERESETREQUESTRESPONSETIMER  446
	{(u_char) X25PLE_DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 6}},
#define   X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT  447
	{(u_char) X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 7}},
#define   X25PLE_DTERESTARTREQUESTRESPONSETIMER  448
	{(u_char) X25PLE_DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 8}},
#define   X25PLE_DTECLEARREQUESTRESPONSETIMER  449
	{(u_char) X25PLE_DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 9}},
#define   X25PLE_DTEINTERRUPTRESPONSETIMER  450
	{(u_char) X25PLE_DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 10}},
#define   X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT  451
	{(u_char) X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 11}},
#define   X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT  452
	{(u_char) X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 12}},
#define   X25PLE_DTECALLATTEMPTS  453
	{(u_char) X25PLE_DTECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 13}},
#define   X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY  454
	{(u_char) X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 14}},
#define   X25PLE_DTEPROTOCOLERRORSACCUSEDOF  455
	{(u_char) X25PLE_DTEPROTOCOLERRORSACCUSEDOF, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 15}},
#define   X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  456
	{(u_char) X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 16}},
#define   X25PLE_DTEOCTETSRECEIVEDCOUNTER  457
	{(u_char) X25PLE_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 17}},
#define   X25PLE_DTEOCTETSSENTCOUNTER  458
	{(u_char) X25PLE_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 18}},
#define   X25PLE_DTECALLTIMEOUTS  459
	{(u_char) X25PLE_DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 19}},
#define   X25PLE_DTECALLSCONNECTED  460
	{(u_char) X25PLE_DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 20}},
#define   X25PLE_DTECLEARCOUNTSEXCEEDED  461
	{(u_char) X25PLE_DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 21}},
#define   X25PLE_DTECLEARTIMEOUTS  462
	{(u_char) X25PLE_DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 22}},
#define   X25PLE_DTEDATAPACKETSRECEIVED  463
	{(u_char) X25PLE_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 23}},
#define   X25PLE_DTEDATAPACKETSSENT  464
	{(u_char) X25PLE_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 24}},
#define   X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES  465
	{(u_char) X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 25}},
#define   X25PLE_DTEPROVIDERINITIATEDRESETS  466
	{(u_char) X25PLE_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 26}},
#define   X25PLE_DTEPROVIDERINITIATEDDISCONNECTS  467
	{(u_char) X25PLE_DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 27}},
#define   X25PLE_DTEREMOTELYINITIATEDRESETS  468
	{(u_char) X25PLE_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 28}},
#define   X25PLE_DTEREMOTELYINITIATEDRESTARTS  469
	{(u_char) X25PLE_DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 29}},
#define   X25PLE_DTERESETTIMEOUTS  470
	{(u_char) X25PLE_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 30}},
#define   X25PLE_DTERESTARTCOUNTSEXCEEDED  471
	{(u_char) X25PLE_DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 31}},
#define   X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER  472
	{(u_char) X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 32}},
#define   X25PLE_DTEWINDOWROTATIONTIMER  473
	{(u_char) X25PLE_DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 33}},
#define   X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT  474
	{(u_char) X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 34}},
#define   X25PLE_DTEREJECTRESPONSETIMER  475
	{(u_char) X25PLE_DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 35}},
#define   X25PLE_DTEREJECTRETRANSMISSIONCOUNT  476
	{(u_char) X25PLE_DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 36}},
#define   X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER  477
	{(u_char) X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 37}},
#define   X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  478
	{(u_char) X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 38}},
#define   X25PLE_DTEREGISTRATIONPERMITTED  479
	{(u_char) X25PLE_DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLE_DTETable, 6, {1, 1, 41, 1, 1, 39}},
#define   X25PLE_DCECALLATTEMPTS  480
	{(u_char) X25PLE_DCECALLATTEMPTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 1}},
#define   X25PLE_DCECALLSCONNECTED  481
	{(u_char) X25PLE_DCECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 2}},
#define   X25PLE_DCECUG         482
	{(u_char) X25PLE_DCECUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 3}},
#define   X25PLE_DCEFASTSELECTACCEPTANCE  483
	{(u_char) X25PLE_DCEFASTSELECTACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 4}},
#define   X25PLE_DCEINCOMINGCALLSBARRED  484
	{(u_char) X25PLE_DCEINCOMINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 5}},
#define   X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING  485
	{(u_char) X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 6}},
#define   X25PLE_DCEOUTGOINGCALLSBARRED  486
	{(u_char) X25PLE_DCEOUTGOINGCALLSBARRED, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 7}},
#define   X25PLE_DCEDATAPACKETSRECEIVED  487
	{(u_char) X25PLE_DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 8}},
#define   X25PLE_DCEDATAPACKETSSENT  488
	{(u_char) X25PLE_DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 9}},
#define   X25PLE_DCEINTERRUPTPACKETSRECEIVED  489
	{(u_char) X25PLE_DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 10}},
#define   X25PLE_DCEINTERRUPTPACKETSSENT  490
	{(u_char) X25PLE_DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 11}},
#define   X25PLE_DCEINTERRUPTTIMEREXPIRIES  491
	{(u_char) X25PLE_DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 12}},
#define   X25PLE_DCEOCTETSRECEIVEDCOUNTER  492
	{(u_char) X25PLE_DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 13}},
#define   X25PLE_DCEOCTETSSENTCOUNTER  493
	{(u_char) X25PLE_DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 14}},
#define   X25PLE_DCEPROVIDERINITIATEDDISCONNECTS  494
	{(u_char) X25PLE_DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 15}},
#define   X25PLE_DCEPROVIDERINITIATEDRESETS  495
	{(u_char) X25PLE_DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 16}},
#define   X25PLE_DCEREMOTELYINITIATEDRESTARTS  496
	{(u_char) X25PLE_DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 17}},
#define   X25PLE_DCEREMOTELYINITIATEDRESETS  497
	{(u_char) X25PLE_DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 18}},
#define   X25PLE_DCERESETTIMEOUTS  498
	{(u_char) X25PLE_DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 19}},
#define   X25PLE_DCEX25SEGMENTSRECEIVED  499
	{(u_char) X25PLE_DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 20}},
#define   X25PLE_DCEX25SEGMENTSSENT  500
	{(u_char) X25PLE_DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 21}},
#define   X25PLE_DCEBILATERALCUG  501
	{(u_char) X25PLE_DCEBILATERALCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 22}},
#define   X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS  502
	{(u_char) X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 23}},
#define   X25PLE_DCECALLDEFLECTIONSUBSCRIPTION  503
	{(u_char) X25PLE_DCECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 24}},
#define   X25PLE_DCECALLREDIRECTION  504
	{(u_char) X25PLE_DCECALLREDIRECTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 25}},
#define   X25PLE_DCECHARGINGINFORMATION  505
	{(u_char) X25PLE_DCECHARGINGINFORMATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 26}},
#define   X25PLE_DCECUGWITHINCOMINGACCESS  506
	{(u_char) X25PLE_DCECUGWITHINCOMINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 27}},
#define   X25PLE_DCECUGWITHOUTGOINGACCESS  507
	{(u_char) X25PLE_DCECUGWITHOUTGOINGACCESS, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 28}},
#define   X25PLE_DCEDBITMODIFICATION  508
	{(u_char) X25PLE_DCEDBITMODIFICATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 29}},
#define   X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT  509
	{(u_char) X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 30}},
#define   X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING  510
	{(u_char) X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 31}},
#define   X25PLE_DCEHUNTGROUP   511
	{(u_char) X25PLE_DCEHUNTGROUP, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 32}},
#define   X25PLE_DCEINCOMINGCALLBARREDWITHINCUG  512
	{(u_char) X25PLE_DCEINCOMINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 33}},
#define   X25PLE_DCELOCALCHARGINGPREVENTION  513
	{(u_char) X25PLE_DCELOCALCHARGINGPREVENTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 34}},
#define   X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES  514
	{(u_char) X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 35}},
#define   X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES  515
	{(u_char) X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 36}},
#define   X25PLE_DCENUIOVERRIDE  516
	{(u_char) X25PLE_DCENUIOVERRIDE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 37}},
#define   X25PLE_DCENUISUBSCRIPTION  517
	{(u_char) X25PLE_DCENUISUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 38}},
#define   X25PLE_DCEONEWAYLOGICALCHANNELINCOMING  518
	{(u_char) X25PLE_DCEONEWAYLOGICALCHANNELINCOMING, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 39}},
#define   X25PLE_DCEONLINEFACILITYREGISTRATION  519
	{(u_char) X25PLE_DCEONLINEFACILITYREGISTRATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 40}},
#define   X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG  520
	{(u_char) X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 41}},
#define   X25PLE_DCEPACKETRETRANSMISSION  521
	{(u_char) X25PLE_DCEPACKETRETRANSMISSION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 42}},
#define   X25PLE_DCEREVERSECHARGINGACCEPTANCE  522
	{(u_char) X25PLE_DCEREVERSECHARGINGACCEPTANCE, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 43}},
#define   X25PLE_DCEROASUBSCRIPTION  523
	{(u_char) X25PLE_DCEROASUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 44}},
#define   X25PLE_DCECLEARINDICATION  524
	{(u_char) X25PLE_DCECLEARINDICATION, ASN_INTEGER, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 45}},
#define   X25PLE_DCEINCOMINGCALL  525
	{(u_char) X25PLE_DCEINCOMINGCALL, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 46}},
#define   X25PLE_DCERESETINDICATION  526
	{(u_char) X25PLE_DCERESETINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 47}},
#define   X25PLE_DCERESTARTINDICATION  527
	{(u_char) X25PLE_DCERESTARTINDICATION, ASN_OCTET_STR, RONLY, var_x25PLE_DCETable, 6, {1, 1, 42, 1, 1, 48}},
#define   X25PLEIVMOLOCALDTEADDRESS  528
	{(u_char) X25PLEIVMOLOCALDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 2}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTS  529
	{(u_char) X25PLEIVMOLOGICALCHANNELASSIGNMENTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 3}},
#define   X25PLEIVMOSN_SERVICEPROVIDER  530
	{(u_char) X25PLEIVMOSN_SERVICEPROVIDER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 4}},
#define   X25PLEIVMODEFAULTPACKETSIZES  531
	{(u_char) X25PLEIVMODEFAULTPACKETSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 5}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSES  532
	{(u_char) X25PLEIVMODEFAULTTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 6}},
#define   X25PLEIVMODEFAULTWINDOWSIZES  533
	{(u_char) X25PLEIVMODEFAULTWINDOWSIZES, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 7}},
#define   X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION  534
	{(u_char) X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 8}},
#define   X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION  535
	{(u_char) X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 9}},
#define   X25PLEIVMOX25PLEMODE  536
	{(u_char) X25PLEIVMOX25PLEMODE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 10}},
#define   X25PLEIVMOINTERFACEMODE  537
	{(u_char) X25PLEIVMOINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 11}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASS  538
	{(u_char) X25PLEIVMODEFAULTTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 12}},
#define   X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED  539
	{(u_char) X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 13}},
#define   X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION  540
	{(u_char) X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 14}},
#define   X25PLEIVMOMAXACTIVECIRCUITS  541
	{(u_char) X25PLEIVMOMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 15}},
#define   X25PLEIVMORESTARTTIME  542
	{(u_char) X25PLEIVMORESTARTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 16}},
#define   X25PLEIVMODEFAULTPACKETSIZE  543
	{(u_char) X25PLEIVMODEFAULTPACKETSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 17}},
#define   X25PLEIVMODEFAULTWINDOWSIZE  544
	{(u_char) X25PLEIVMODEFAULTWINDOWSIZE, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 18}},
#define   X25PLEIVMOMINIMUMRECALLTIMER  545
	{(u_char) X25PLEIVMOMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 19}},
#define   X25PLEIVMORESTARTCOUNT  546
	{(u_char) X25PLEIVMORESTARTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 20}},
#define   X25PLEIVMOPACKETSEQUENCING  547
	{(u_char) X25PLEIVMOPACKETSEQUENCING, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 21}},
#define   X25PLEIVMOREGISTRATIONREQUESTTIME  548
	{(u_char) X25PLEIVMOREGISTRATIONREQUESTTIME, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 22}},
#define   X25PLEIVMOREGISTRATIONREQUESTCOUNT  549
	{(u_char) X25PLEIVMOREGISTRATIONREQUESTCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 23}},
#define   X25PLEIVMOREGISTRATIONPERMITTED  550
	{(u_char) X25PLEIVMOREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 24}},
#define   X25PLEIVMOROWSTATUS   551
	{(u_char) X25PLEIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 43, 1, 1, 25}},
#define   X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION  552
	{(u_char) X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 1}},
#define   X25PLEIVMO_DTECALLREQUESTRESPONSETIMER  553
	{(u_char) X25PLEIVMO_DTECALLREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 2}},
#define   X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING  554
	{(u_char) X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 3}},
#define   X25PLEIVMO_DTEMAXACTIVECIRCUITS  555
	{(u_char) X25PLEIVMO_DTEMAXACTIVECIRCUITS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 4}},
#define   X25PLEIVMO_DTEMINIMUMRECALLTIMER  556
	{(u_char) X25PLEIVMO_DTEMINIMUMRECALLTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 5}},
#define   X25PLEIVMO_DTERESETREQUESTRESPONSETIMER  557
	{(u_char) X25PLEIVMO_DTERESETREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 6}},
#define   X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT  558
	{(u_char) X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 7}},
#define   X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER  559
	{(u_char) X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 8}},
#define   X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER  560
	{(u_char) X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 9}},
#define   X25PLEIVMO_DTEINTERRUPTRESPONSETIMER  561
	{(u_char) X25PLEIVMO_DTEINTERRUPTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 10}},
#define   X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT  562
	{(u_char) X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 11}},
#define   X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT  563
	{(u_char) X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 12}},
#define   X25PLEIVMO_DTECALLATTEMPTS  564
	{(u_char) X25PLEIVMO_DTECALLATTEMPTS, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 13}},
#define   X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY  565
	{(u_char) X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 14}},
#define   X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF  566
	{(u_char) X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 15}},
#define   X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED  567
	{(u_char) X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 16}},
#define   X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER  568
	{(u_char) X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 17}},
#define   X25PLEIVMO_DTEOCTETSSENTCOUNTER  569
	{(u_char) X25PLEIVMO_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 18}},
#define   X25PLEIVMO_DTECALLTIMEOUTS  570
	{(u_char) X25PLEIVMO_DTECALLTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 19}},
#define   X25PLEIVMO_DTECALLSCONNECTED  571
	{(u_char) X25PLEIVMO_DTECALLSCONNECTED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 20}},
#define   X25PLEIVMO_DTECLEARCOUNTSEXCEEDED  572
	{(u_char) X25PLEIVMO_DTECLEARCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 21}},
#define   X25PLEIVMO_DTECLEARTIMEOUTS  573
	{(u_char) X25PLEIVMO_DTECLEARTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 22}},
#define   X25PLEIVMO_DTEDATAPACKETSRECEIVED  574
	{(u_char) X25PLEIVMO_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 23}},
#define   X25PLEIVMO_DTEDATAPACKETSSENT  575
	{(u_char) X25PLEIVMO_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 24}},
#define   X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES  576
	{(u_char) X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 25}},
#define   X25PLEIVMO_DTEPROVIDERINITIATEDRESETS  577
	{(u_char) X25PLEIVMO_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 26}},
#define   X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS  578
	{(u_char) X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 27}},
#define   X25PLEIVMO_DTEREMOTELYINITIATEDRESETS  579
	{(u_char) X25PLEIVMO_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 28}},
#define   X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS  580
	{(u_char) X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 29}},
#define   X25PLEIVMO_DTERESETTIMEOUTS  581
	{(u_char) X25PLEIVMO_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 30}},
#define   X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED  582
	{(u_char) X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED, ASN_COUNTER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 31}},
#define   X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER  583
	{(u_char) X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 32}},
#define   X25PLEIVMO_DTEWINDOWROTATIONTIMER  584
	{(u_char) X25PLEIVMO_DTEWINDOWROTATIONTIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 33}},
#define   X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT  585
	{(u_char) X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 34}},
#define   X25PLEIVMO_DTEREJECTRESPONSETIMER  586
	{(u_char) X25PLEIVMO_DTEREJECTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 35}},
#define   X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT  587
	{(u_char) X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 36}},
#define   X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER  588
	{(u_char) X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 37}},
#define   X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT  589
	{(u_char) X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 38}},
#define   X25PLEIVMO_DTEREGISTRATIONPERMITTED  590
	{(u_char) X25PLEIVMO_DTEREGISTRATIONPERMITTED, ASN_INTEGER, RONLY, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 39}},
#define   X25PLEIVMO_DTEROWSTATUS  591
	{(u_char) X25PLEIVMO_DTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMO_DTETable, 6, {1, 1, 44, 1, 1, 40}},
#define   X25PLEIVMO_DCEROWSTATUS  592
	{(u_char) X25PLEIVMO_DCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMO_DCETable, 6, {1, 1, 45, 1, 1, 1}},
#define   VIRTUALCALLCHANNEL    593
	{(u_char) VIRTUALCALLCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 2}},
#define   VIRTUALCALLPACKETSIZE  594
	{(u_char) VIRTUALCALLPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 3}},
#define   VIRTUALCALLWINDOWSIZE  595
	{(u_char) VIRTUALCALLWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 4}},
#define   VIRTUALCALLOCTETSSENTCOUNTER  596
	{(u_char) VIRTUALCALLOCTETSSENTCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 5}},
#define   VIRTUALCALLOCTETSRECEIVEDCOUNTER  597
	{(u_char) VIRTUALCALLOCTETSRECEIVEDCOUNTER, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 6}},
#define   VIRTUALCALLDATAPACKETSSENT  598
	{(u_char) VIRTUALCALLDATAPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 7}},
#define   VIRTUALCALLDATAPACKETSRECEIVED  599
	{(u_char) VIRTUALCALLDATAPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 8}},
#define   VIRTUALCALLREMOTELYINITIATEDRESETS  600
	{(u_char) VIRTUALCALLREMOTELYINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 9}},
#define   VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES  601
	{(u_char) VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 10}},
#define   VIRTUALCALLPROVIDERINITIATEDRESETS  602
	{(u_char) VIRTUALCALLPROVIDERINITIATEDRESETS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 11}},
#define   VIRTUALCALLRESETTIMEOUTS  603
	{(u_char) VIRTUALCALLRESETTIMEOUTS, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 12}},
#define   VIRTUALCALLINTERRUPTPACKETSSENT  604
	{(u_char) VIRTUALCALLINTERRUPTPACKETSSENT, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 13}},
#define   VIRTUALCALLINTERRUPTPACKETSRECEIVED  605
	{(u_char) VIRTUALCALLINTERRUPTPACKETSRECEIVED, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 14}},
#define   VIRTUALCALLINTERRUPTTIMEREXPIRIES  606
	{(u_char) VIRTUALCALLINTERRUPTTIMEREXPIRIES, ASN_OCTET_STR, RONLY, var_virtualCallTable, 6, {1, 1, 46, 1, 1, 15}},
#define   VIRTUALCIRCUITLOGICALCHANNEL  607
	{(u_char) VIRTUALCIRCUITLOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 2}},
#define   VIRTUALCIRCUITPACKETSIZES  608
	{(u_char) VIRTUALCIRCUITPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 3}},
#define   VIRTUALCIRCUITTHROUGHPUTCLASSES  609
	{(u_char) VIRTUALCIRCUITTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 4}},
#define   VIRTUALCIRCUITWINDOWSIZES  610
	{(u_char) VIRTUALCIRCUITWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCircuitTable, 6, {1, 1, 47, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER  611
	{(u_char) VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 1}},
#define   VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER  612
	{(u_char) VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 2}},
#define   VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED  613
	{(u_char) VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 3}},
#define   VIRTUALCIRCUIT_DTEDATAPACKETSSENT  614
	{(u_char) VIRTUALCIRCUIT_DTEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 4}},
#define   VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES  615
	{(u_char) VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED  616
	{(u_char) VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 6}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT  617
	{(u_char) VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 7}},
#define   VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES  618
	{(u_char) VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 8}},
#define   VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS  619
	{(u_char) VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 9}},
#define   VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS  620
	{(u_char) VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 10}},
#define   VIRTUALCIRCUIT_DTERESETTIMEOUTS  621
	{(u_char) VIRTUALCIRCUIT_DTERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit_DTETable, 6, {1, 1, 48, 1, 1, 11}},
#define   VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED  622
	{(u_char) VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 1}},
#define   VIRTUALCIRCUIT_DCEDATAPACKETSSENT  623
	{(u_char) VIRTUALCIRCUIT_DCEDATAPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 2}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED  624
	{(u_char) VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 3}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT  625
	{(u_char) VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 4}},
#define   VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES  626
	{(u_char) VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 5}},
#define   VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER  627
	{(u_char) VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 6}},
#define   VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER  628
	{(u_char) VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 7}},
#define   VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS  629
	{(u_char) VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 8}},
#define   VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS  630
	{(u_char) VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 9}},
#define   VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS  631
	{(u_char) VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 10}},
#define   VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS  632
	{(u_char) VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 11}},
#define   VIRTUALCIRCUIT_DCERESETTIMEOUTS  633
	{(u_char) VIRTUALCIRCUIT_DCERESETTIMEOUTS, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 12}},
#define   VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED  634
	{(u_char) VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 13}},
#define   VIRTUALCIRCUIT_DCEX25SEGMENTSSENT  635
	{(u_char) VIRTUALCIRCUIT_DCEX25SEGMENTSSENT, ASN_COUNTER, RONLY, var_virtualCircuit_DCETable, 6, {1, 1, 49, 1, 1, 14}},
#define   PERMANENTVIRTUALCIRCUITCHANNEL  636
	{(u_char) PERMANENTVIRTUALCIRCUITCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUITROWSTATUS  637
	{(u_char) PERMANENTVIRTUALCIRCUITROWSTATUS, ASN_INTEGER, RWRITE, var_permanentVirtualCircuitTable, 6, {1, 1, 50, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL  638
	{(u_char) PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES  639
	{(u_char) PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES  640
	{(u_char) PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES  641
	{(u_char) PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS  642
	{(u_char) PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS, ASN_INTEGER, RWRITE, var_permanentVirtualCircuit_DTETable, 6, {1, 1, 51, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION  643
	{(u_char) PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 1}},
#define   PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL  644
	{(u_char) PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 2}},
#define   PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES  645
	{(u_char) PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 3}},
#define   PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES  646
	{(u_char) PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 4}},
#define   PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES  647
	{(u_char) PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 5}},
#define   PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE  648
	{(u_char) PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 6}},
#define   PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS  649
	{(u_char) PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 7}},
#define   PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL  650
	{(u_char) PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL, ASN_OCTET_STR, RONLY, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 8}},
#define   PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS  651
	{(u_char) PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS, ASN_INTEGER, RWRITE, var_permanentVirtualCircuit_DCETable, 6, {1, 1, 52, 1, 1, 9}},
#define   VIRTUALCALLIVMOFASTSELECT  652
	{(u_char) VIRTUALCALLIVMOFASTSELECT, ASN_INTEGER, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 2}},
#define   VIRTUALCALLIVMOPACKETSIZES  653
	{(u_char) VIRTUALCALLIVMOPACKETSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 3}},
#define   VIRTUALCALLIVMOREVERSECHARGING  654
	{(u_char) VIRTUALCALLIVMOREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 4}},
#define   VIRTUALCALLIVMOTHROUGHPUTCLASSES  655
	{(u_char) VIRTUALCALLIVMOTHROUGHPUTCLASSES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 5}},
#define   VIRTUALCALLIVMOWINDOWSIZES  656
	{(u_char) VIRTUALCALLIVMOWINDOWSIZES, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 6}},
#define   VIRTUALCALLIVMOPROPOSEDPACKETSIZE  657
	{(u_char) VIRTUALCALLIVMOPROPOSEDPACKETSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 7}},
#define   VIRTUALCALLIVMOPROPOSEDWINDOWSIZE  658
	{(u_char) VIRTUALCALLIVMOPROPOSEDWINDOWSIZE, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 8}},
#define   VIRTUALCALLIVMOACCEPTREVERSECHARGING  659
	{(u_char) VIRTUALCALLIVMOACCEPTREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 9}},
#define   VIRTUALCALLIVMOPROPOSEREVERSECHARGING  660
	{(u_char) VIRTUALCALLIVMOPROPOSEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 10}},
#define   VIRTUALCALLIVMOCALLTIME  661
	{(u_char) VIRTUALCALLIVMOCALLTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 11}},
#define   VIRTUALCALLIVMORESETTIME  662
	{(u_char) VIRTUALCALLIVMORESETTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 12}},
#define   VIRTUALCALLIVMOCLEARTIME  663
	{(u_char) VIRTUALCALLIVMOCLEARTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 13}},
#define   VIRTUALCALLIVMOINTERRUPTTIME  664
	{(u_char) VIRTUALCALLIVMOINTERRUPTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 14}},
#define   VIRTUALCALLIVMORESETCOUNT  665
	{(u_char) VIRTUALCALLIVMORESETCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 15}},
#define   VIRTUALCALLIVMOCLEARCOUNT  666
	{(u_char) VIRTUALCALLIVMOCLEARCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 16}},
#define   VIRTUALCALLIVMOWINDOWTIME  667
	{(u_char) VIRTUALCALLIVMOWINDOWTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 17}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONTIME  668
	{(u_char) VIRTUALCALLIVMODATARETRANSMISSIONTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 18}},
#define   VIRTUALCALLIVMODATARETRANSMISSIONCOUNT  669
	{(u_char) VIRTUALCALLIVMODATARETRANSMISSIONCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 19}},
#define   VIRTUALCALLIVMOREJECTTIME  670
	{(u_char) VIRTUALCALLIVMOREJECTTIME, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 20}},
#define   VIRTUALCALLIVMOREJECTCOUNT  671
	{(u_char) VIRTUALCALLIVMOREJECTCOUNT, ASN_OCTET_STR, RONLY, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 21}},
#define   VIRTUALCALLIVMOROWSTATUS  672
	{(u_char) VIRTUALCALLIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_virtualCallIVMOTable, 6, {1, 1, 53, 1, 1, 22}},
#define   SWITCHEDVIRTUALCALLDIRECTION  673
	{(u_char) SWITCHEDVIRTUALCALLDIRECTION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 1}},
#define   SWITCHEDVIRTUALCALLREMOTEDTEADDRESS  674
	{(u_char) SWITCHEDVIRTUALCALLREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 2}},
#define   SWITCHEDVIRTUALCALLTHROUGHPUTCLASS  675
	{(u_char) SWITCHEDVIRTUALCALLTHROUGHPUTCLASS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 3}},
#define   SWITCHEDVIRTUALCALLREDIRECTREASON  676
	{(u_char) SWITCHEDVIRTUALCALLREDIRECTREASON, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 4}},
#define   SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS  677
	{(u_char) SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 5}},
#define   SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION  678
	{(u_char) SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 6}},
#define   SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION  679
	{(u_char) SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 7}},
#define   SWITCHEDVIRTUALCALLROWSTATUS  680
	{(u_char) SWITCHEDVIRTUALCALLROWSTATUS, ASN_INTEGER, RWRITE, var_switchedVirtualCallTable, 6, {1, 1, 54, 1, 1, 8}},
#define   VIRTUALCALL_DTECALLINGADDRESSEXTENSION  681
	{(u_char) VIRTUALCALL_DTECALLINGADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 1}},
#define   VIRTUALCALL_DTECALLEDADDRESSEXTENSION  682
	{(u_char) VIRTUALCALL_DTECALLEDADDRESSEXTENSION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 2}},
#define   VIRTUALCALL_DTEDIRECTION  683
	{(u_char) VIRTUALCALL_DTEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 3}},
#define   VIRTUALCALL_DTEFASTSELECT  684
	{(u_char) VIRTUALCALL_DTEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 4}},
#define   VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS  685
	{(u_char) VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 5}},
#define   VIRTUALCALL_DTEREDIRECTREASON  686
	{(u_char) VIRTUALCALL_DTEREDIRECTREASON, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 6}},
#define   VIRTUALCALL_DTEREMOTEDTEADDRESS  687
	{(u_char) VIRTUALCALL_DTEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 7}},
#define   VIRTUALCALL_DTEREVERSECHARGING  688
	{(u_char) VIRTUALCALL_DTEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 8}},
#define   VIRTUALCALL_DTEROWSTATUS  689
	{(u_char) VIRTUALCALL_DTEROWSTATUS, ASN_INTEGER, RWRITE, var_virtualCall_DTETable, 6, {1, 1, 55, 1, 1, 9}},
#define   VIRTUALCALL_DCECHARGINGDIRECTION  690
	{(u_char) VIRTUALCALL_DCECHARGINGDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 1}},
#define   VIRTUALCALL_DCECUGSELECTION  691
	{(u_char) VIRTUALCALL_DCECUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 2}},
#define   VIRTUALCALL_DCEDIRECTION  692
	{(u_char) VIRTUALCALL_DCEDIRECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 3}},
#define   VIRTUALCALL_DCEFASTSELECT  693
	{(u_char) VIRTUALCALL_DCEFASTSELECT, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 4}},
#define   VIRTUALCALL_DCEREMOTEDTEADDRESS  694
	{(u_char) VIRTUALCALL_DCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 5}},
#define   VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION  695
	{(u_char) VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 6}},
#define   VIRTUALCALL_DCEBILATERALCUGSELECTION  696
	{(u_char) VIRTUALCALL_DCEBILATERALCUGSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 7}},
#define   VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION  697
	{(u_char) VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 8}},
#define   VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION  698
	{(u_char) VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION, ASN_INTEGER, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 9}},
#define   VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION  699
	{(u_char) VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 10}},
#define   VIRTUALCALL_DCENUISELECTION  700
	{(u_char) VIRTUALCALL_DCENUISELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 11}},
#define   VIRTUALCALL_DCEREVERSECHARGING  701
	{(u_char) VIRTUALCALL_DCEREVERSECHARGING, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 12}},
#define   VIRTUALCALL_DCEROASELECTION  702
	{(u_char) VIRTUALCALL_DCEROASELECTION, ASN_OCTET_STR, RONLY, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 13}},
#define   VIRTUALCALL_DCEROWSTATUS  703
	{(u_char) VIRTUALCALL_DCEROWSTATUS, ASN_INTEGER, RWRITE, var_virtualCall_DCETable, 6, {1, 1, 56, 1, 1, 14}},
#define   DSERIESRESETREQUESTINDICATIONPACKETS  704
	{(u_char) DSERIESRESETREQUESTINDICATIONPACKETS, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 2}},
#define   DSERIESSEGMENTSSENT   705
	{(u_char) DSERIESSEGMENTSSENT, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 3}},
#define   DSERIESSEGMENTSRECEIVED  706
	{(u_char) DSERIESSEGMENTSRECEIVED, ASN_COUNTER, RONLY, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 4}},
#define   DSERIESROWSTATUS      707
	{(u_char) DSERIESROWSTATUS, ASN_INTEGER, RWRITE, var_dSeriesCountsTable, 6, {1, 1, 57, 1, 1, 5}},
#define   ADJACENCYSTATE        708
	{(u_char) ADJACENCYSTATE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 2}},
#define   NEIGHBOURSNPAADDRESS  709
	{(u_char) NEIGHBOURSNPAADDRESS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 3}},
#define   NEIGHBOURSYSTEMTYPE   710
	{(u_char) NEIGHBOURSYSTEMTYPE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 4}},
#define   NEIGHBOURSYSTEMIDS    711
	{(u_char) NEIGHBOURSYSTEMIDS, ASN_OCTET_STR, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 5}},
#define   ADJACENCYUSAGE        712
	{(u_char) ADJACENCYUSAGE, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 6}},
#define   AREAADDRESSESOFNEIGHBOUR  713
	{(u_char) AREAADDRESSESOFNEIGHBOUR, ASN_OCTET_STR, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 7}},
#define   HOLDINGTIMER          714
	{(u_char) HOLDINGTIMER, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 8}},
#define   PRIORITYOFNEIGHBOUR   715
	{(u_char) PRIORITYOFNEIGHBOUR, ASN_INTEGER, RONLY, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 9}},
#define   ADJACENCYROWSTATUS    716
	{(u_char) ADJACENCYROWSTATUS, ASN_INTEGER, RWRITE, var_adjacencyTable, 6, {1, 1, 58, 1, 1, 10}},
#define   VIRTUALADJACENCYMETRIC  717
	{(u_char) VIRTUALADJACENCYMETRIC, ASN_INTEGER, RONLY, var_virtualAdjacencyTable, 6, {1, 1, 59, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICPATHCOST  718
	{(u_char) DESTINATIONDEFAULTMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 2}},
#define   DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES  719
	{(u_char) DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 3}},
#define   DESTINATIONDELAYMETRICPATHCOST  720
	{(u_char) DESTINATIONDELAYMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 4}},
#define   DESTINATIONDELAYMETRICOUTPUTADJACENCIES  721
	{(u_char) DESTINATIONDELAYMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 5}},
#define   DESTINATIONEXPENSEMETRICPATHCOST  722
	{(u_char) DESTINATIONEXPENSEMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 6}},
#define   DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES  723
	{(u_char) DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 7}},
#define   DESTINATIONERRORMETRICPATHCOST  724
	{(u_char) DESTINATIONERRORMETRICPATHCOST, ASN_INTEGER, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 8}},
#define   DESTINATIONERRORMETRICOUTPUTADJACENCIES  725
	{(u_char) DESTINATIONERRORMETRICOUTPUTADJACENCIES, ASN_OCTET_STR, RWRITE, var_destinationTable, 6, {1, 1, 60, 1, 1, 9}},
#define   DESINTATIONSYSTEMMETRIC  726
	{(u_char) DESINTATIONSYSTEMMETRIC, ASN_INTEGER, RONLY, var_destinationSystemTable, 6, {1, 1, 61, 1, 1, 3}},
#define   REACHABLEADDRESSPREFIX  728
	{(u_char) REACHABLEADDRESSPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 2}},
#define   REACHABLEADDRESSMAPPINGTYPE  729
	{(u_char) REACHABLEADDRESSMAPPINGTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 3}},
#define   REACHABLEADDRESSDEFAULTMETRIC  730
	{(u_char) REACHABLEADDRESSDEFAULTMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 4}},
#define   REACHABLEADDRESSDELAYMETRIC  731
	{(u_char) REACHABLEADDRESSDELAYMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 5}},
#define   REACHABLEADDRESSEXPENSEMETRIC  732
	{(u_char) REACHABLEADDRESSEXPENSEMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 6}},
#define   REACHABLEADDRESSERRORMETRIC  733
	{(u_char) REACHABLEADDRESSERRORMETRIC, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 7}},
#define   REACHABLEADDRESSDEFAULTMETRICTYPE  734
	{(u_char) REACHABLEADDRESSDEFAULTMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 8}},
#define   REACHABLEADDRESSDELAYMETRICTYPE  735
	{(u_char) REACHABLEADDRESSDELAYMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 9}},
#define   REACHABLEADDRESSEXPENSEMETRICTYPE  736
	{(u_char) REACHABLEADDRESSEXPENSEMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 10}},
#define   REACHABLEADDRESSERRORMETRICTYPE  737
	{(u_char) REACHABLEADDRESSERRORMETRICTYPE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 11}},
#define   REACHABLEADDRESSOPERATIONALSTATE  738
	{(u_char) REACHABLEADDRESSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 12}},
#define   REACHABLEADDRESSADMINISTRATIVESTATE  739
	{(u_char) REACHABLEADDRESSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 13}},
#define   REACHABLEADDRESSSNPAADDRESSES  740
	{(u_char) REACHABLEADDRESSSNPAADDRESSES, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 14}},
#define   REACHABLEADDRESSSNPAMASK  741
	{(u_char) REACHABLEADDRESSSNPAMASK, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 15}},
#define   REACHABLEADDRESSSNPAPREFIX  742
	{(u_char) REACHABLEADDRESSSNPAPREFIX, ASN_OCTET_STR, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 16}},
#define   REACHABLEADDRESSROWSTATUS  743
	{(u_char) REACHABLEADDRESSROWSTATUS, ASN_INTEGER, RWRITE, var_reachableAddressTable, 6, {1, 1, 63, 1, 1, 17}},
#define   LLCDISCONTINUITYTIME  744
	{(u_char) LLCDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_dlMIB, 4, {1, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTINTERFACETYPE  745
	{(u_char) SLPCONNECTIONDEFAULTINTERFACETYPE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 1}},
#define   SLPCONNECTIONDEFAULTK  746
	{(u_char) SLPCONNECTIONDEFAULTK, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 2}},
#define   SLPCONNECTIONDEFAULTN1  747
	{(u_char) SLPCONNECTIONDEFAULTN1, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 3}},
#define   SLPCONNECTIONDEFAULTN2  748
	{(u_char) SLPCONNECTIONDEFAULTN2, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 4}},
#define   SLPCONNECTIONDEFAULTSEQUENCEMODULUS  749
	{(u_char) SLPCONNECTIONDEFAULTSEQUENCEMODULUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 5}},
#define   SLPCONNECTIONDEFAULTT1TIMER  750
	{(u_char) SLPCONNECTIONDEFAULTT1TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 6}},
#define   SLPCONNECTIONDEFAULTT2TIMER  751
	{(u_char) SLPCONNECTIONDEFAULTT2TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 7}},
#define   SLPCONNECTIONDEFAULTT3TIMER  752
	{(u_char) SLPCONNECTIONDEFAULTT3TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 8}},
#define   SLPCONNECTIONDEFAULTT4TIMER  753
	{(u_char) SLPCONNECTIONDEFAULTT4TIMER, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 1, 9}},
#define   LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS  754
	{(u_char) LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 1}},
#define   LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE  755
	{(u_char) LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 2}},
#define   LLCCONNECTION2DEFAULTSENDWINDOWSIZE  756
	{(u_char) LLCCONNECTION2DEFAULTSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 3}},
#define   LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE  757
	{(u_char) LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 4}},
#define   LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE  758
	{(u_char) LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 5}},
#define   LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE  759
	{(u_char) LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 6}},
#define   LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE  760
	{(u_char) LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 7}},
#define   LLCCONNECTION2DEFAULTROUTE  761
	{(u_char) LLCCONNECTION2DEFAULTROUTE, ASN_OCTET_STR, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 8}},
#define   LLCCONNECTION2DEFAULTKSTEP  762
	{(u_char) LLCCONNECTION2DEFAULTKSTEP, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 9}},
#define   LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE  763
	{(u_char) LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 10}},
#define   LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS  764
	{(u_char) LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 2, 11}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE  765
	{(u_char) LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 1}},
#define   LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS  766
	{(u_char) LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS, ASN_INTEGER, RWRITE, var_dlMIB, 5, {1, 2, 2, 3, 2}},
};

/* (L = length of the oidsuffix) */
struct dlMIB_data *dlMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *communicationsEntityTableStorage = NULL;
struct header_complex_index *sap1TableStorage = NULL;
struct header_complex_index *sap2TableStorage = NULL;
struct header_complex_index *clProtocolMachineTableStorage = NULL;
struct header_complex_index *coProtocolMachineTableStorage = NULL;
struct header_complex_index *singlePeerConnectionTableStorage = NULL;
struct header_complex_index *physicalEntityTableStorage = NULL;
struct header_complex_index *physicalSAPTableStorage = NULL;
struct header_complex_index *dataCircuitTableStorage = NULL;
struct header_complex_index *physicalConnectionTableStorage = NULL;
struct header_complex_index *datalinkEntityTableStorage = NULL;
struct header_complex_index *dLSAPTableStorage = NULL;
struct header_complex_index *lAPBDLETableStorage = NULL;
struct header_complex_index *sLPPMTableStorage = NULL;
struct header_complex_index *sLPConnectionTableStorage = NULL;
struct header_complex_index *sLPConnectionIVMOTableStorage = NULL;
struct header_complex_index *mACDLETableStorage = NULL;
struct header_complex_index *mACTableStorage = NULL;
struct header_complex_index *lLCDLETableStorage = NULL;
struct header_complex_index *lLCCLPMTableStorage = NULL;
struct header_complex_index *lLCCOPMTableStorage = NULL;
struct header_complex_index *resourceTypeIdTableStorage = NULL;
struct header_complex_index *lLCStationTableStorage = NULL;
struct header_complex_index *lLCSAPTableStorage = NULL;
struct header_complex_index *rDESetupTableStorage = NULL;
struct header_complex_index *rDEPairTableStorage = NULL;
struct header_complex_index *lLCConnectionLessTableStorage = NULL;
struct header_complex_index *lLCConnection2TableStorage = NULL;
struct header_complex_index *lLCConnection2IVMOTableStorage = NULL;
struct header_complex_index *lLCConnectionlessAckTableStorage = NULL;
struct header_complex_index *lLCConnectionlessAckIVMOTableStorage = NULL;
struct header_complex_index *networkEntityTableStorage = NULL;
struct header_complex_index *nSAPTableStorage = NULL;
struct header_complex_index *cLNSTableStorage = NULL;
struct header_complex_index *cLNSISISTableStorage = NULL;
struct header_complex_index *cLNSISISLevel2TableStorage = NULL;
struct header_complex_index *linkageTableStorage = NULL;
struct header_complex_index *cONSTableStorage = NULL;
struct header_complex_index *networkConnectionTableStorage = NULL;
struct header_complex_index *x25PLETableStorage = NULL;
struct header_complex_index *x25PLE_DTETableStorage = NULL;
struct header_complex_index *x25PLE_DCETableStorage = NULL;
struct header_complex_index *x25PLEIVMOTableStorage = NULL;
struct header_complex_index *x25PLEIVMO_DTETableStorage = NULL;
struct header_complex_index *x25PLEIVMO_DCETableStorage = NULL;
struct header_complex_index *virtualCallTableStorage = NULL;
struct header_complex_index *virtualCircuitTableStorage = NULL;
struct header_complex_index *virtualCircuit_DTETableStorage = NULL;
struct header_complex_index *virtualCircuit_DCETableStorage = NULL;
struct header_complex_index *permanentVirtualCircuitTableStorage = NULL;
struct header_complex_index *permanentVirtualCircuit_DTETableStorage = NULL;
struct header_complex_index *permanentVirtualCircuit_DCETableStorage = NULL;
struct header_complex_index *virtualCallIVMOTableStorage = NULL;
struct header_complex_index *switchedVirtualCallTableStorage = NULL;
struct header_complex_index *virtualCall_DTETableStorage = NULL;
struct header_complex_index *virtualCall_DCETableStorage = NULL;
struct header_complex_index *dSeriesCountsTableStorage = NULL;
struct header_complex_index *adjacencyTableStorage = NULL;
struct header_complex_index *virtualAdjacencyTableStorage = NULL;
struct header_complex_index *destinationTableStorage = NULL;
struct header_complex_index *destinationSystemTableStorage = NULL;
struct header_complex_index *destinationAreaTableStorage = NULL;
struct header_complex_index *reachableAddressTableStorage = NULL;

void (*dlMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void dlMIB_loop_handler(int);
void dlMIB_fd_handler(int, void *);

/**
 * @fn void init_dlMIB(void)
 * @brief dlMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (dlMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_dlMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("dlMIB", "init_dlMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("dlMIB", dlMIB_variables, variable7, dlMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_dlMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("dlMIB", parse_dlMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("communicationsEntityTable", parse_communicationsEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sap1Table", parse_sap1Table, NULL, "HELP STRING");
	snmpd_register_config_handler("sap2Table", parse_sap2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("clProtocolMachineTable", parse_clProtocolMachineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("coProtocolMachineTable", parse_coProtocolMachineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("singlePeerConnectionTable", parse_singlePeerConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("physicalEntityTable", parse_physicalEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("physicalSAPTable", parse_physicalSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dataCircuitTable", parse_dataCircuitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("physicalConnectionTable", parse_physicalConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("datalinkEntityTable", parse_datalinkEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dLSAPTable", parse_dLSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lAPBDLETable", parse_lAPBDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPPMTable", parse_sLPPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPConnectionTable", parse_sLPConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sLPConnectionIVMOTable", parse_sLPConnectionIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mACDLETable", parse_mACDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("mACTable", parse_mACTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCDLETable", parse_lLCDLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCCLPMTable", parse_lLCCLPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCCOPMTable", parse_lLCCOPMTable, NULL, "HELP STRING");
	snmpd_register_config_handler("resourceTypeIdTable", parse_resourceTypeIdTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCStationTable", parse_lLCStationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCSAPTable", parse_lLCSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("rDESetupTable", parse_rDESetupTable, NULL, "HELP STRING");
	snmpd_register_config_handler("rDEPairTable", parse_rDEPairTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionLessTable", parse_lLCConnectionLessTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnection2Table", parse_lLCConnection2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnection2IVMOTable", parse_lLCConnection2IVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionlessAckTable", parse_lLCConnectionlessAckTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lLCConnectionlessAckIVMOTable", parse_lLCConnectionlessAckIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("networkEntityTable", parse_networkEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("nSAPTable", parse_nSAPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cLNSTable", parse_cLNSTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cLNSISISTable", parse_cLNSISISTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cLNSISISLevel2Table", parse_cLNSISISLevel2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("linkageTable", parse_linkageTable, NULL, "HELP STRING");
	snmpd_register_config_handler("cONSTable", parse_cONSTable, NULL, "HELP STRING");
	snmpd_register_config_handler("networkConnectionTable", parse_networkConnectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLETable", parse_x25PLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLE_DTETable", parse_x25PLE_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLE_DCETable", parse_x25PLE_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMOTable", parse_x25PLEIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMO_DTETable", parse_x25PLEIVMO_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMO_DCETable", parse_x25PLEIVMO_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCallTable", parse_virtualCallTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCircuitTable", parse_virtualCircuitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCircuit_DTETable", parse_virtualCircuit_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCircuit_DCETable", parse_virtualCircuit_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("permanentVirtualCircuitTable", parse_permanentVirtualCircuitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("permanentVirtualCircuit_DTETable", parse_permanentVirtualCircuit_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("permanentVirtualCircuit_DCETable", parse_permanentVirtualCircuit_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCallIVMOTable", parse_virtualCallIVMOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("switchedVirtualCallTable", parse_switchedVirtualCallTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCall_DTETable", parse_virtualCall_DTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualCall_DCETable", parse_virtualCall_DCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("dSeriesCountsTable", parse_dSeriesCountsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("adjacencyTable", parse_adjacencyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("virtualAdjacencyTable", parse_virtualAdjacencyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("destinationTable", parse_destinationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("destinationSystemTable", parse_destinationSystemTable, NULL, "HELP STRING");
	snmpd_register_config_handler("destinationAreaTable", parse_destinationAreaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("reachableAddressTable", parse_reachableAddressTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dlMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_communicationsEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sap1Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sap2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_clProtocolMachineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_coProtocolMachineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_singlePeerConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_physicalEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_physicalSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dataCircuitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_physicalConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_datalinkEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dLSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lAPBDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sLPConnectionIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mACDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mACTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCDLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCCLPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCCOPMTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_resourceTypeIdTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCStationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_rDESetupTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_rDEPairTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionLessTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnection2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnection2IVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionlessAckTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lLCConnectionlessAckIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_networkEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_nSAPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cLNSTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cLNSISISTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cLNSISISLevel2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_linkageTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_cONSTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_networkConnectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLE_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLE_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLEIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLEIVMO_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLEIVMO_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCallTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCircuitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCircuit_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCircuit_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_permanentVirtualCircuitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_permanentVirtualCircuit_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_permanentVirtualCircuit_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCallIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_switchedVirtualCallTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCall_DTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualCall_DCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dSeriesCountsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_adjacencyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_virtualAdjacencyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_destinationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_destinationSystemTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_destinationAreaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_reachableAddressTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, dlMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, dlMIB_fd_handler, (void *) 1);
	}
	dlMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &dlMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/**
 * @fn void deinit_dlMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (dlMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_dlMIB(void)
{
	DEBUGMSGTL(("dlMIB", "deinit_dlMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = dlMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(dlMIB_variables_oid, sizeof(dlMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("dlMIB");
	snmpd_unregister_config_handler("communicationsEntityTable");
	snmpd_unregister_config_handler("sap1Table");
	snmpd_unregister_config_handler("sap2Table");
	snmpd_unregister_config_handler("clProtocolMachineTable");
	snmpd_unregister_config_handler("coProtocolMachineTable");
	snmpd_unregister_config_handler("singlePeerConnectionTable");
	snmpd_unregister_config_handler("physicalEntityTable");
	snmpd_unregister_config_handler("physicalSAPTable");
	snmpd_unregister_config_handler("dataCircuitTable");
	snmpd_unregister_config_handler("physicalConnectionTable");
	snmpd_unregister_config_handler("datalinkEntityTable");
	snmpd_unregister_config_handler("dLSAPTable");
	snmpd_unregister_config_handler("lAPBDLETable");
	snmpd_unregister_config_handler("sLPPMTable");
	snmpd_unregister_config_handler("sLPConnectionTable");
	snmpd_unregister_config_handler("sLPConnectionIVMOTable");
	snmpd_unregister_config_handler("mACDLETable");
	snmpd_unregister_config_handler("mACTable");
	snmpd_unregister_config_handler("lLCDLETable");
	snmpd_unregister_config_handler("lLCCLPMTable");
	snmpd_unregister_config_handler("lLCCOPMTable");
	snmpd_unregister_config_handler("resourceTypeIdTable");
	snmpd_unregister_config_handler("lLCStationTable");
	snmpd_unregister_config_handler("lLCSAPTable");
	snmpd_unregister_config_handler("rDESetupTable");
	snmpd_unregister_config_handler("rDEPairTable");
	snmpd_unregister_config_handler("lLCConnectionLessTable");
	snmpd_unregister_config_handler("lLCConnection2Table");
	snmpd_unregister_config_handler("lLCConnection2IVMOTable");
	snmpd_unregister_config_handler("lLCConnectionlessAckTable");
	snmpd_unregister_config_handler("lLCConnectionlessAckIVMOTable");
	snmpd_unregister_config_handler("networkEntityTable");
	snmpd_unregister_config_handler("nSAPTable");
	snmpd_unregister_config_handler("cLNSTable");
	snmpd_unregister_config_handler("cLNSISISTable");
	snmpd_unregister_config_handler("cLNSISISLevel2Table");
	snmpd_unregister_config_handler("linkageTable");
	snmpd_unregister_config_handler("cONSTable");
	snmpd_unregister_config_handler("networkConnectionTable");
	snmpd_unregister_config_handler("x25PLETable");
	snmpd_unregister_config_handler("x25PLE_DTETable");
	snmpd_unregister_config_handler("x25PLE_DCETable");
	snmpd_unregister_config_handler("x25PLEIVMOTable");
	snmpd_unregister_config_handler("x25PLEIVMO_DTETable");
	snmpd_unregister_config_handler("x25PLEIVMO_DCETable");
	snmpd_unregister_config_handler("virtualCallTable");
	snmpd_unregister_config_handler("virtualCircuitTable");
	snmpd_unregister_config_handler("virtualCircuit_DTETable");
	snmpd_unregister_config_handler("virtualCircuit_DCETable");
	snmpd_unregister_config_handler("permanentVirtualCircuitTable");
	snmpd_unregister_config_handler("permanentVirtualCircuit_DTETable");
	snmpd_unregister_config_handler("permanentVirtualCircuit_DCETable");
	snmpd_unregister_config_handler("virtualCallIVMOTable");
	snmpd_unregister_config_handler("switchedVirtualCallTable");
	snmpd_unregister_config_handler("virtualCall_DTETable");
	snmpd_unregister_config_handler("virtualCall_DCETable");
	snmpd_unregister_config_handler("dSeriesCountsTable");
	snmpd_unregister_config_handler("adjacencyTable");
	snmpd_unregister_config_handler("virtualAdjacencyTable");
	snmpd_unregister_config_handler("destinationTable");
	snmpd_unregister_config_handler("destinationSystemTable");
	snmpd_unregister_config_handler("destinationAreaTable");
	snmpd_unregister_config_handler("reachableAddressTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

int
term_dlMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("dlMIB", "term_dlMIB: terminating...  "));
	deinit_dlMIB();
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct dlMIB_data *dlMIB_create(void)
 * @brief create a fresh data structure representing scalars in dlMIB.
 *
 * Creates a new dlMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in dlMIB.
 */
struct dlMIB_data *
dlMIB_create(void)
{
	struct dlMIB_data *StorageNew = SNMP_MALLOC_STRUCT(dlMIB_data);

	DEBUGMSGTL(("dlMIB", "dlMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->llcDiscontinuityTime = 0;
		StorageNew->sLPConnectionDefaultInterfaceType = SLPCONNECTIONDEFAULTINTERFACETYPE_DTE;
		StorageNew->sLPConnectionDefaultK = 0;
		StorageNew->sLPConnectionDefaultN1 = 0;
		StorageNew->sLPConnectionDefaultN2 = 0;
		StorageNew->sLPConnectionDefaultSequenceModulus = 0;
		StorageNew->sLPConnectionDefaultT1Timer = 0;
		StorageNew->sLPConnectionDefaultT2Timer = 0;
		StorageNew->sLPConnectionDefaultT3Timer = 0;
		StorageNew->sLPConnectionDefaultT4Timer = 0;
		StorageNew->lLCConnection2DefaultMaximumRetransmissions = 0;
		StorageNew->lLCConnection2DefaultReceivedWindowSize = 0;
		StorageNew->lLCConnection2DefaultSendWindowSize = 0;
		StorageNew->lLCConnection2DefaultAcknowledgeTimeoutValue = 0;
		StorageNew->lLCConnection2DefaultBusyStateTimeoutValue = 0;
		StorageNew->lLCConnection2DefaultPBitTimeoutValue = 0;
		StorageNew->lLCConnection2DefaultRejectTimeoutValue = 0;
		if ((StorageNew->lLCConnection2DefaultRoute = (uint8_t *) strdup("")) != NULL)
			StorageNew->lLCConnection2DefaultRouteLen = strlen("");
		StorageNew->lLCConnection2DefaultKStep = 0;
		StorageNew->lLCConnection2DefaultMaxSendWindowSize = 0;
		StorageNew->lLCConnection2DefaultOptionalTolerationIPDUs = 0;
		StorageNew->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize = 0;
		StorageNew->lLCConnectionlessAckDefaultMaximumRetransmissions = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int dlMIB_destroy(struct dlMIB_data **thedata)
 * @param thedata pointer to the data structure in dlMIB.
 * @brief delete a scalars structure from dlMIB.
 *
 * Frees scalars that were previously removed from dlMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dlMIB_destroy(struct dlMIB_data **thedata)
{
	struct dlMIB_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "dlMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lLCConnection2DefaultRoute);
		StorageDel->lLCConnection2DefaultRouteLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dlMIB_add(struct dlMIB_data *thedata)
 * @param thedata the structure representing dlMIB scalars.
 * @brief adds node to the dlMIB scalar data set.
 *
 * Adds a scalar structure to the dlMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
dlMIB_add(struct dlMIB_data *thedata)
{
	DEBUGMSGTL(("dlMIB", "dlMIB_add: adding data...  "));
	if (thedata)
		dlMIBStorage = thedata;
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dlMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dlMIB entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case dlMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_dlMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct dlMIB_data *StorageTmp = dlMIB_create();

	DEBUGMSGTL(("dlMIB", "parse_dlMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->llcDiscontinuityTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultInterfaceType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultK, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultN2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultSequenceModulus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT2Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionDefaultT4Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultPBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultRejectTimeoutValue, &tmpsize);
	SNMP_FREE(StorageTmp->lLCConnection2DefaultRoute);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2DefaultRoute, &StorageTmp->lLCConnection2DefaultRouteLen);
	if (StorageTmp->lLCConnection2DefaultRoute == NULL) {
		config_perror("invalid specification for lLCConnection2DefaultRoute");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultKStep, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultMaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions, &tmpsize);
	dlMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_dlMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_dlMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dlMIB_data *StorageTmp;

	DEBUGMSGTL(("dlMIB", "store_dlMIB: storing data...  "));
	refresh_dlMIB(1);
	if ((StorageTmp = dlMIBStorage) == NULL) {
		DEBUGMSGTL(("dlMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "dlMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->llcDiscontinuityTime, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultInterfaceType, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultK, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultN1, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultN2, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultSequenceModulus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT1Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT2Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT3Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionDefaultT4Timer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultMaximumRetransmissions, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultReceivedWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultSendWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultPBitTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultRejectTimeoutValue, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2DefaultRoute, &StorageTmp->lLCConnection2DefaultRouteLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultKStep, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultMaxSendWindowSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_dlMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of dlMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_dlMIB(int force)
{
	if (dlMIBStorage == NULL) {
		struct dlMIB_data *StorageNew;

		if ((StorageNew = dlMIB_create()) == NULL)
			return;
		dlMIBStorage = StorageNew;
		dlMIB_refresh = 1;
	}
	if (!force && dlMIB_refresh == 0)
		return;
	DEBUGMSGTL(("dlMIB", "refresh_dlMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	dlMIB_refresh = 0;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/**
 * @fn u_char * var_dlMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in dlMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_dlMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dlMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_dlMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_dlMIB(0);
	if ((StorageTmp = dlMIBStorage) == NULL) {
		DEBUGMSGTL(("dlMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCDISCONTINUITYTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->llcDiscontinuityTime);
		rval = (u_char *) &StorageTmp->llcDiscontinuityTime;
		break;
	case (u_char) SLPCONNECTIONDEFAULTINTERFACETYPE:	/* ReadWrite */
		*write_method = write_sLPConnectionDefaultInterfaceType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultInterfaceType);
		rval = (u_char *) &StorageTmp->sLPConnectionDefaultInterfaceType;
		break;
	case (u_char) SLPCONNECTIONDEFAULTK:	/* ReadWrite */
		*write_method = write_sLPConnectionDefaultK;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultK);
		rval = (u_char *) &StorageTmp->sLPConnectionDefaultK;
		break;
	case (u_char) SLPCONNECTIONDEFAULTN1:	/* ReadWrite */
		*write_method = write_sLPConnectionDefaultN1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultN1);
		rval = (u_char *) &StorageTmp->sLPConnectionDefaultN1;
		break;
	case (u_char) SLPCONNECTIONDEFAULTN2:	/* ReadWrite */
		*write_method = write_sLPConnectionDefaultN2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultN2);
		rval = (u_char *) &StorageTmp->sLPConnectionDefaultN2;
		break;
	case (u_char) SLPCONNECTIONDEFAULTSEQUENCEMODULUS:	/* ReadWrite */
		*write_method = write_sLPConnectionDefaultSequenceModulus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultSequenceModulus);
		rval = (u_char *) &StorageTmp->sLPConnectionDefaultSequenceModulus;
		break;
	case (u_char) SLPCONNECTIONDEFAULTT1TIMER:	/* ReadWrite */
		*write_method = write_sLPConnectionDefaultT1Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT1Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionDefaultT1Timer;
		break;
	case (u_char) SLPCONNECTIONDEFAULTT2TIMER:	/* ReadWrite */
		*write_method = write_sLPConnectionDefaultT2Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT2Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionDefaultT2Timer;
		break;
	case (u_char) SLPCONNECTIONDEFAULTT3TIMER:	/* ReadWrite */
		*write_method = write_sLPConnectionDefaultT3Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT3Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionDefaultT3Timer;
		break;
	case (u_char) SLPCONNECTIONDEFAULTT4TIMER:	/* ReadWrite */
		*write_method = write_sLPConnectionDefaultT4Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionDefaultT4Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionDefaultT4Timer;
		break;
	case (u_char) LLCCONNECTION2DEFAULTMAXIMUMRETRANSMISSIONS:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultMaximumRetransmissions;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultMaximumRetransmissions);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultMaximumRetransmissions;
		break;
	case (u_char) LLCCONNECTION2DEFAULTRECEIVEDWINDOWSIZE:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultReceivedWindowSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultReceivedWindowSize);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultReceivedWindowSize;
		break;
	case (u_char) LLCCONNECTION2DEFAULTSENDWINDOWSIZE:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultSendWindowSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultSendWindowSize);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultSendWindowSize;
		break;
	case (u_char) LLCCONNECTION2DEFAULTACKNOWLEDGETIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultAcknowledgeTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2DEFAULTBUSYSTATETIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultBusyStateTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2DEFAULTPBITTIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultPBitTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultPBitTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultPBitTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2DEFAULTREJECTTIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultRejectTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultRejectTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultRejectTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2DEFAULTROUTE:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultRoute;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCConnection2DefaultRouteLen;
		rval = (u_char *) StorageTmp->lLCConnection2DefaultRoute;
		break;
	case (u_char) LLCCONNECTION2DEFAULTKSTEP:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultKStep;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultKStep);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultKStep;
		break;
	case (u_char) LLCCONNECTION2DEFAULTMAXSENDWINDOWSIZE:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultMaxSendWindowSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultMaxSendWindowSize);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultMaxSendWindowSize;
		break;
	case (u_char) LLCCONNECTION2DEFAULTOPTIONALTOLERATIONIPDUS:	/* ReadWrite */
		*write_method = write_lLCConnection2DefaultOptionalTolerationIPDUs;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs);
		rval = (u_char *) &StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs;
		break;
	case (u_char) LLCCONNECTIONLESSACKDEFAULTMAXIMUMLLCINFORMATIONFIELDSIZE:	/* ReadWrite */
		*write_method = write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
		break;
	case (u_char) LLCCONNECTIONLESSACKDEFAULTMAXIMUMRETRANSMISSIONS:	/* ReadWrite */
		*write_method = write_lLCConnectionlessAckDefaultMaximumRetransmissions;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions;
		break;
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("dlMIB", "found.\n"));
	else
		DEBUGMSGTL(("dlMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct communicationsEntityTable_data *communicationsEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the communicationsEntityTable table.
 *
 * Creates a new communicationsEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct communicationsEntityTable_data *
communicationsEntityTable_create(void)
{
	struct communicationsEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(communicationsEntityTable_data);

	DEBUGMSGTL(("dlMIB", "communicationsEntityTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityLocalSapNames = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->communicationsEntityLocalSapNamesLen = 2;
		StorageNew->communicationsEntityOperationalState = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct communicationsEntityTable_data *communicationsEntityTable_duplicate(struct communicationsEntityTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct communicationsEntityTable_data *
communicationsEntityTable_duplicate(struct communicationsEntityTable_data *thedata)
{
	struct communicationsEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(communicationsEntityTable_data);

	DEBUGMSGTL(("dlMIB", "communicationsEntityTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	communicationsEntityTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int communicationsEntityTable_destroy(struct communicationsEntityTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
communicationsEntityTable_destroy(struct communicationsEntityTable_data **thedata)
{
	struct communicationsEntityTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "communicationsEntityTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->communicationsEntityLocalSapNames);
		StorageDel->communicationsEntityLocalSapNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int communicationsEntityTable_add(struct communicationsEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the communicationsEntityTable table data set.
 *
 * Adds a table row structure to the communicationsEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
communicationsEntityTable_add(struct communicationsEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "communicationsEntityTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		header_complex_add_data(&communicationsEntityTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int communicationsEntityTable_del(struct communicationsEntityTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the communicationsEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
communicationsEntityTable_del(struct communicationsEntityTable_data *thedata)
{
	struct communicationsEntityTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "communicationsEntityTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(communicationsEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&communicationsEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_communicationsEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for communicationsEntityTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case communicationsEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_communicationsEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct communicationsEntityTable_data *StorageTmp = communicationsEntityTable_create();

	DEBUGMSGTL(("dlMIB", "parse_communicationsEntityTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->communicationsEntityLocalSapNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->communicationsEntityLocalSapNames, &StorageTmp->communicationsEntityLocalSapNamesLen);
	if (StorageTmp->communicationsEntityLocalSapNames == NULL) {
		config_perror("invalid specification for communicationsEntityLocalSapNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->communicationsEntityOperationalState, &tmpsize);
	communicationsEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_communicationsEntityTable(): store configuraiton file for communicationsEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_communicationsEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct communicationsEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_communicationsEntityTable: storing data...  "));
	refresh_communicationsEntityTable(1);
	(void) tmpsize;
	for (hcindex = communicationsEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct communicationsEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "communicationsEntityTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->communicationsEntityLocalSapNames, &StorageTmp->communicationsEntityLocalSapNamesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->communicationsEntityOperationalState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sap1Table_data *sap1Table_create(void)
 * @brief create a fresh data structure representing a new row in the sap1Table table.
 *
 * Creates a new sap1Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sap1Table_data *
sap1Table_create(void)
{
	struct sap1Table_data *StorageNew = SNMP_MALLOC_STRUCT(sap1Table_data);

	DEBUGMSGTL(("dlMIB", "sap1Table_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		StorageNew->sap1Address = 0;
		if ((StorageNew->sap1UserEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->sap1UserEntityNamesLen = 2;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sap1Table_data *sap1Table_duplicate(struct sap1Table_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sap1Table_data *
sap1Table_duplicate(struct sap1Table_data *thedata)
{
	struct sap1Table_data *StorageNew = SNMP_MALLOC_STRUCT(sap1Table_data);

	DEBUGMSGTL(("dlMIB", "sap1Table_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sap1Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sap1Table_destroy(struct sap1Table_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sap1Table_destroy(struct sap1Table_data **thedata)
{
	struct sap1Table_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sap1Table_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->sap1UserEntityNames);
		StorageDel->sap1UserEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sap1Table_add(struct sap1Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sap1Table table data set.
 *
 * Adds a table row structure to the sap1Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sap1Table_add(struct sap1Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "sap1Table_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* sapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
		header_complex_add_data(&sap1TableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sap1Table_del(struct sap1Table_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sap1Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sap1Table_del(struct sap1Table_data *thedata)
{
	struct sap1Table_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sap1Table_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sap1TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sap1TableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sap1Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sap1Table entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sap1Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sap1Table(const char *token, char *line)
{
	size_t tmpsize;
	struct sap1Table_data *StorageTmp = sap1Table_create();

	DEBUGMSGTL(("dlMIB", "parse_sap1Table: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->sapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sap1Address, &tmpsize);
	SNMP_FREE(StorageTmp->sap1UserEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sap1UserEntityNames, &StorageTmp->sap1UserEntityNamesLen);
	if (StorageTmp->sap1UserEntityNames == NULL) {
		config_perror("invalid specification for sap1UserEntityNames");
		return;
	}
	sap1Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_sap1Table(): store configuraiton file for sap1Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_sap1Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sap1Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_sap1Table: storing data...  "));
	refresh_sap1Table(1);
	(void) tmpsize;
	for (hcindex = sap1TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sap1Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sap1Table ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sap1Address, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sap1UserEntityNames, &StorageTmp->sap1UserEntityNamesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sap2Table_data *sap2Table_create(void)
 * @brief create a fresh data structure representing a new row in the sap2Table table.
 *
 * Creates a new sap2Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sap2Table_data *
sap2Table_create(void)
{
	struct sap2Table_data *StorageNew = SNMP_MALLOC_STRUCT(sap2Table_data);

	DEBUGMSGTL(("dlMIB", "sap2Table_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->sapId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sapIdLen = strlen("");
		if ((StorageNew->sap2Address = (uint8_t *) strdup("")) != NULL)
			StorageNew->sap2AddressLen = strlen("");
		if ((StorageNew->sap2UserEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->sap2UserEntityNamesLen = 2;
		if ((StorageNew->sap2ProviderEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->sap2ProviderEntityNamesLen = 2;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sap2Table_data *sap2Table_duplicate(struct sap2Table_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sap2Table_data *
sap2Table_duplicate(struct sap2Table_data *thedata)
{
	struct sap2Table_data *StorageNew = SNMP_MALLOC_STRUCT(sap2Table_data);

	DEBUGMSGTL(("dlMIB", "sap2Table_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sap2Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sap2Table_destroy(struct sap2Table_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sap2Table_destroy(struct sap2Table_data **thedata)
{
	struct sap2Table_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sap2Table_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->sap2Address);
		StorageDel->sap2AddressLen = 0;
		SNMP_FREE(StorageDel->sap2UserEntityNames);
		StorageDel->sap2UserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->sap2ProviderEntityNames);
		StorageDel->sap2ProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sap2Table_add(struct sap2Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sap2Table table data set.
 *
 * Adds a table row structure to the sap2Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sap2Table_add(struct sap2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "sap2Table_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* sapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
		header_complex_add_data(&sap2TableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sap2Table_del(struct sap2Table_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sap2Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sap2Table_del(struct sap2Table_data *thedata)
{
	struct sap2Table_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sap2Table_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sap2TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sap2TableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sap2Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sap2Table entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sap2Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sap2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct sap2Table_data *StorageTmp = sap2Table_create();

	DEBUGMSGTL(("dlMIB", "parse_sap2Table: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->sapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	SNMP_FREE(StorageTmp->sap2Address);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sap2Address, &StorageTmp->sap2AddressLen);
	if (StorageTmp->sap2Address == NULL) {
		config_perror("invalid specification for sap2Address");
		return;
	}
	SNMP_FREE(StorageTmp->sap2UserEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sap2UserEntityNames, &StorageTmp->sap2UserEntityNamesLen);
	if (StorageTmp->sap2UserEntityNames == NULL) {
		config_perror("invalid specification for sap2UserEntityNames");
		return;
	}
	SNMP_FREE(StorageTmp->sap2ProviderEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sap2ProviderEntityNames, &StorageTmp->sap2ProviderEntityNamesLen);
	if (StorageTmp->sap2ProviderEntityNames == NULL) {
		config_perror("invalid specification for sap2ProviderEntityNames");
		return;
	}
	sap2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_sap2Table(): store configuraiton file for sap2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_sap2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sap2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_sap2Table: storing data...  "));
	refresh_sap2Table(1);
	(void) tmpsize;
	for (hcindex = sap2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sap2Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sap2Table ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sap2Address, &StorageTmp->sap2AddressLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sap2UserEntityNames, &StorageTmp->sap2UserEntityNamesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sap2ProviderEntityNames, &StorageTmp->sap2ProviderEntityNamesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct clProtocolMachineTable_data *clProtocolMachineTable_create(void)
 * @brief create a fresh data structure representing a new row in the clProtocolMachineTable table.
 *
 * Creates a new clProtocolMachineTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct clProtocolMachineTable_data *
clProtocolMachineTable_create(void)
{
	struct clProtocolMachineTable_data *StorageNew = SNMP_MALLOC_STRUCT(clProtocolMachineTable_data);

	DEBUGMSGTL(("dlMIB", "clProtocolMachineTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		StorageNew->clProtocolMachineOperationalState = 0;
		StorageNew->clProtocolMachineTotalRemoteSAPs = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct clProtocolMachineTable_data *clProtocolMachineTable_duplicate(struct clProtocolMachineTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct clProtocolMachineTable_data *
clProtocolMachineTable_duplicate(struct clProtocolMachineTable_data *thedata)
{
	struct clProtocolMachineTable_data *StorageNew = SNMP_MALLOC_STRUCT(clProtocolMachineTable_data);

	DEBUGMSGTL(("dlMIB", "clProtocolMachineTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	clProtocolMachineTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int clProtocolMachineTable_destroy(struct clProtocolMachineTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
clProtocolMachineTable_destroy(struct clProtocolMachineTable_data **thedata)
{
	struct clProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "clProtocolMachineTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int clProtocolMachineTable_add(struct clProtocolMachineTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the clProtocolMachineTable table data set.
 *
 * Adds a table row structure to the clProtocolMachineTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
clProtocolMachineTable_add(struct clProtocolMachineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "clProtocolMachineTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		header_complex_add_data(&clProtocolMachineTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int clProtocolMachineTable_del(struct clProtocolMachineTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the clProtocolMachineTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
clProtocolMachineTable_del(struct clProtocolMachineTable_data *thedata)
{
	struct clProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "clProtocolMachineTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(clProtocolMachineTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&clProtocolMachineTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_clProtocolMachineTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for clProtocolMachineTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case clProtocolMachineTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_clProtocolMachineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct clProtocolMachineTable_data *StorageTmp = clProtocolMachineTable_create();

	DEBUGMSGTL(("dlMIB", "parse_clProtocolMachineTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->clProtocolMachineOperationalState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->clProtocolMachineTotalRemoteSAPs, &tmpsize);
	clProtocolMachineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_clProtocolMachineTable(): store configuraiton file for clProtocolMachineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_clProtocolMachineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct clProtocolMachineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_clProtocolMachineTable: storing data...  "));
	refresh_clProtocolMachineTable(1);
	(void) tmpsize;
	for (hcindex = clProtocolMachineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct clProtocolMachineTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "clProtocolMachineTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->clProtocolMachineOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->clProtocolMachineTotalRemoteSAPs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct coProtocolMachineTable_data *coProtocolMachineTable_create(void)
 * @brief create a fresh data structure representing a new row in the coProtocolMachineTable table.
 *
 * Creates a new coProtocolMachineTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct coProtocolMachineTable_data *
coProtocolMachineTable_create(void)
{
	struct coProtocolMachineTable_data *StorageNew = SNMP_MALLOC_STRUCT(coProtocolMachineTable_data);

	DEBUGMSGTL(("dlMIB", "coProtocolMachineTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		StorageNew->coProtocolMachineOperationalState = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct coProtocolMachineTable_data *coProtocolMachineTable_duplicate(struct coProtocolMachineTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct coProtocolMachineTable_data *
coProtocolMachineTable_duplicate(struct coProtocolMachineTable_data *thedata)
{
	struct coProtocolMachineTable_data *StorageNew = SNMP_MALLOC_STRUCT(coProtocolMachineTable_data);

	DEBUGMSGTL(("dlMIB", "coProtocolMachineTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	coProtocolMachineTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int coProtocolMachineTable_destroy(struct coProtocolMachineTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
coProtocolMachineTable_destroy(struct coProtocolMachineTable_data **thedata)
{
	struct coProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "coProtocolMachineTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int coProtocolMachineTable_add(struct coProtocolMachineTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the coProtocolMachineTable table data set.
 *
 * Adds a table row structure to the coProtocolMachineTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
coProtocolMachineTable_add(struct coProtocolMachineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "coProtocolMachineTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		header_complex_add_data(&coProtocolMachineTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int coProtocolMachineTable_del(struct coProtocolMachineTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the coProtocolMachineTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
coProtocolMachineTable_del(struct coProtocolMachineTable_data *thedata)
{
	struct coProtocolMachineTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "coProtocolMachineTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(coProtocolMachineTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&coProtocolMachineTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_coProtocolMachineTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for coProtocolMachineTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case coProtocolMachineTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_coProtocolMachineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct coProtocolMachineTable_data *StorageTmp = coProtocolMachineTable_create();

	DEBUGMSGTL(("dlMIB", "parse_coProtocolMachineTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->coProtocolMachineOperationalState, &tmpsize);
	coProtocolMachineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_coProtocolMachineTable(): store configuraiton file for coProtocolMachineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_coProtocolMachineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct coProtocolMachineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_coProtocolMachineTable: storing data...  "));
	refresh_coProtocolMachineTable(1);
	(void) tmpsize;
	for (hcindex = coProtocolMachineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct coProtocolMachineTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "coProtocolMachineTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->coProtocolMachineOperationalState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct singlePeerConnectionTable_data *singlePeerConnectionTable_create(void)
 * @brief create a fresh data structure representing a new row in the singlePeerConnectionTable table.
 *
 * Creates a new singlePeerConnectionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct singlePeerConnectionTable_data *
singlePeerConnectionTable_create(void)
{
	struct singlePeerConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(singlePeerConnectionTable_data);

	DEBUGMSGTL(("dlMIB", "singlePeerConnectionTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		if ((StorageNew->underlyingConnectionNames = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->underlyingConnectionNamesLen = 2;
		if ((StorageNew->suppportedConnectionNames = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->suppportedConnectionNamesLen = 2;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct singlePeerConnectionTable_data *singlePeerConnectionTable_duplicate(struct singlePeerConnectionTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct singlePeerConnectionTable_data *
singlePeerConnectionTable_duplicate(struct singlePeerConnectionTable_data *thedata)
{
	struct singlePeerConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(singlePeerConnectionTable_data);

	DEBUGMSGTL(("dlMIB", "singlePeerConnectionTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	singlePeerConnectionTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int singlePeerConnectionTable_destroy(struct singlePeerConnectionTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
singlePeerConnectionTable_destroy(struct singlePeerConnectionTable_data **thedata)
{
	struct singlePeerConnectionTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "singlePeerConnectionTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->underlyingConnectionNames);
		StorageDel->underlyingConnectionNamesLen = 0;
		SNMP_FREE(StorageDel->suppportedConnectionNames);
		StorageDel->suppportedConnectionNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int singlePeerConnectionTable_add(struct singlePeerConnectionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the singlePeerConnectionTable table data set.
 *
 * Adds a table row structure to the singlePeerConnectionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
singlePeerConnectionTable_add(struct singlePeerConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "singlePeerConnectionTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* connectionId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
		header_complex_add_data(&singlePeerConnectionTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int singlePeerConnectionTable_del(struct singlePeerConnectionTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the singlePeerConnectionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
singlePeerConnectionTable_del(struct singlePeerConnectionTable_data *thedata)
{
	struct singlePeerConnectionTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "singlePeerConnectionTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(singlePeerConnectionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&singlePeerConnectionTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_singlePeerConnectionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for singlePeerConnectionTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case singlePeerConnectionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_singlePeerConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct singlePeerConnectionTable_data *StorageTmp = singlePeerConnectionTable_create();

	DEBUGMSGTL(("dlMIB", "parse_singlePeerConnectionTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->connectionId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	SNMP_FREE(StorageTmp->underlyingConnectionNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->underlyingConnectionNames, &StorageTmp->underlyingConnectionNamesLen);
	if (StorageTmp->underlyingConnectionNames == NULL) {
		config_perror("invalid specification for underlyingConnectionNames");
		return;
	}
	SNMP_FREE(StorageTmp->suppportedConnectionNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->suppportedConnectionNames, &StorageTmp->suppportedConnectionNamesLen);
	if (StorageTmp->suppportedConnectionNames == NULL) {
		config_perror("invalid specification for suppportedConnectionNames");
		return;
	}
	singlePeerConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_singlePeerConnectionTable(): store configuraiton file for singlePeerConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_singlePeerConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct singlePeerConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_singlePeerConnectionTable: storing data...  "));
	refresh_singlePeerConnectionTable(1);
	(void) tmpsize;
	for (hcindex = singlePeerConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct singlePeerConnectionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "singlePeerConnectionTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->underlyingConnectionNames, &StorageTmp->underlyingConnectionNamesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->suppportedConnectionNames, &StorageTmp->suppportedConnectionNamesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct physicalEntityTable_data *physicalEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the physicalEntityTable table.
 *
 * Creates a new physicalEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct physicalEntityTable_data *
physicalEntityTable_create(void)
{
	struct physicalEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(physicalEntityTable_data);

	DEBUGMSGTL(("dlMIB", "physicalEntityTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->physicalEntityPhysicalEntityTitles = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->physicalEntityPhysicalEntityTitlesLen = 2;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct physicalEntityTable_data *physicalEntityTable_duplicate(struct physicalEntityTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct physicalEntityTable_data *
physicalEntityTable_duplicate(struct physicalEntityTable_data *thedata)
{
	struct physicalEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(physicalEntityTable_data);

	DEBUGMSGTL(("dlMIB", "physicalEntityTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	physicalEntityTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int physicalEntityTable_destroy(struct physicalEntityTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
physicalEntityTable_destroy(struct physicalEntityTable_data **thedata)
{
	struct physicalEntityTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "physicalEntityTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->physicalEntityPhysicalEntityTitles);
		StorageDel->physicalEntityPhysicalEntityTitlesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalEntityTable_add(struct physicalEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the physicalEntityTable table data set.
 *
 * Adds a table row structure to the physicalEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
physicalEntityTable_add(struct physicalEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "physicalEntityTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		header_complex_add_data(&physicalEntityTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalEntityTable_del(struct physicalEntityTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the physicalEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
physicalEntityTable_del(struct physicalEntityTable_data *thedata)
{
	struct physicalEntityTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "physicalEntityTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(physicalEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&physicalEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_physicalEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for physicalEntityTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case physicalEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_physicalEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct physicalEntityTable_data *StorageTmp = physicalEntityTable_create();

	DEBUGMSGTL(("dlMIB", "parse_physicalEntityTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->physicalEntityPhysicalEntityTitles);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->physicalEntityPhysicalEntityTitles, &StorageTmp->physicalEntityPhysicalEntityTitlesLen);
	if (StorageTmp->physicalEntityPhysicalEntityTitles == NULL) {
		config_perror("invalid specification for physicalEntityPhysicalEntityTitles");
		return;
	}
	physicalEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_physicalEntityTable(): store configuraiton file for physicalEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_physicalEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct physicalEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_physicalEntityTable: storing data...  "));
	refresh_physicalEntityTable(1);
	(void) tmpsize;
	for (hcindex = physicalEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct physicalEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "physicalEntityTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->physicalEntityPhysicalEntityTitles, &StorageTmp->physicalEntityPhysicalEntityTitlesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct physicalSAPTable_data *physicalSAPTable_create(void)
 * @brief create a fresh data structure representing a new row in the physicalSAPTable table.
 *
 * Creates a new physicalSAPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct physicalSAPTable_data *
physicalSAPTable_create(void)
{
	struct physicalSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(physicalSAPTable_data);

	DEBUGMSGTL(("dlMIB", "physicalSAPTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->sapId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sapIdLen = strlen("");
		StorageNew->physicalSAPRowStatus = 0;
		StorageNew->physicalSAPRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct physicalSAPTable_data *physicalSAPTable_duplicate(struct physicalSAPTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct physicalSAPTable_data *
physicalSAPTable_duplicate(struct physicalSAPTable_data *thedata)
{
	struct physicalSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(physicalSAPTable_data);

	DEBUGMSGTL(("dlMIB", "physicalSAPTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	physicalSAPTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int physicalSAPTable_destroy(struct physicalSAPTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
physicalSAPTable_destroy(struct physicalSAPTable_data **thedata)
{
	struct physicalSAPTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "physicalSAPTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalSAPTable_add(struct physicalSAPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the physicalSAPTable table data set.
 *
 * Adds a table row structure to the physicalSAPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
physicalSAPTable_add(struct physicalSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "physicalSAPTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* sapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
		header_complex_add_data(&physicalSAPTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalSAPTable_del(struct physicalSAPTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the physicalSAPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
physicalSAPTable_del(struct physicalSAPTable_data *thedata)
{
	struct physicalSAPTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "physicalSAPTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(physicalSAPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&physicalSAPTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_physicalSAPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for physicalSAPTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case physicalSAPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_physicalSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct physicalSAPTable_data *StorageTmp = physicalSAPTable_create();

	DEBUGMSGTL(("dlMIB", "parse_physicalSAPTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->sapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->physicalSAPRowStatus, &tmpsize);
	physicalSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_physicalSAPTable(): store configuraiton file for physicalSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_physicalSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct physicalSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_physicalSAPTable: storing data...  "));
	refresh_physicalSAPTable(1);
	(void) tmpsize;
	for (hcindex = physicalSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct physicalSAPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "physicalSAPTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->physicalSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dataCircuitTable_data *dataCircuitTable_create(void)
 * @brief create a fresh data structure representing a new row in the dataCircuitTable table.
 *
 * Creates a new dataCircuitTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dataCircuitTable_data *
dataCircuitTable_create(void)
{
	struct dataCircuitTable_data *StorageNew = SNMP_MALLOC_STRUCT(dataCircuitTable_data);

	DEBUGMSGTL(("dlMIB", "dataCircuitTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		StorageNew->dataCircuitBitErrorsReceived = 0;
		StorageNew->dataCircuitBitErrorsTransmitted = 0;
		if ((StorageNew->dataCircuitBitErrorsThreshold = (uint8_t *) strdup("")) != NULL)
			StorageNew->dataCircuitBitErrorsThresholdLen = strlen("");
		StorageNew->dataCircuitType = 0;
		if ((StorageNew->dataCircuitPhysicalMediaNames = (uint8_t *) strdup("")) != NULL)
			StorageNew->dataCircuitPhysicalMediaNamesLen = strlen("");
		if ((StorageNew->dataCircuitPhysicalInterfaceType = (uint8_t *) strdup("")) != NULL)
			StorageNew->dataCircuitPhysicalInterfaceTypeLen = strlen("");
		if ((StorageNew->dataCircuitPhysicalInterfaceStandard = (uint8_t *) strdup("")) != NULL)
			StorageNew->dataCircuitPhysicalInterfaceStandardLen = strlen("");
		StorageNew->dataCircuitSynchronizationMode = 0;
		if ((StorageNew->dataCircuitTransmissionCoding = (uint8_t *) strdup("")) != NULL)
			StorageNew->dataCircuitTransmissionCodingLen = strlen("");
		StorageNew->dataCircuitTransmissionMode = 0;
		if ((StorageNew->dataCircuitTransmissionRate = (uint8_t *) strdup("")) != NULL)
			StorageNew->dataCircuitTransmissionRateLen = strlen("");
		StorageNew->dataCircuitRowStatus = 0;
		StorageNew->dataCircuitRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct dataCircuitTable_data *dataCircuitTable_duplicate(struct dataCircuitTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dataCircuitTable_data *
dataCircuitTable_duplicate(struct dataCircuitTable_data *thedata)
{
	struct dataCircuitTable_data *StorageNew = SNMP_MALLOC_STRUCT(dataCircuitTable_data);

	DEBUGMSGTL(("dlMIB", "dataCircuitTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dataCircuitTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dataCircuitTable_destroy(struct dataCircuitTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dataCircuitTable_destroy(struct dataCircuitTable_data **thedata)
{
	struct dataCircuitTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "dataCircuitTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->dataCircuitPhysicalMediaNames);
		StorageDel->dataCircuitPhysicalMediaNamesLen = 0;
		SNMP_FREE(StorageDel->dataCircuitPhysicalInterfaceType);
		StorageDel->dataCircuitPhysicalInterfaceTypeLen = 0;
		SNMP_FREE(StorageDel->dataCircuitPhysicalInterfaceStandard);
		StorageDel->dataCircuitPhysicalInterfaceStandardLen = 0;
		SNMP_FREE(StorageDel->dataCircuitTransmissionCoding);
		StorageDel->dataCircuitTransmissionCodingLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dataCircuitTable_add(struct dataCircuitTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dataCircuitTable table data set.
 *
 * Adds a table row structure to the dataCircuitTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dataCircuitTable_add(struct dataCircuitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "dataCircuitTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		header_complex_add_data(&dataCircuitTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dataCircuitTable_del(struct dataCircuitTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dataCircuitTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dataCircuitTable_del(struct dataCircuitTable_data *thedata)
{
	struct dataCircuitTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "dataCircuitTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dataCircuitTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dataCircuitTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dataCircuitTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dataCircuitTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case dataCircuitTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dataCircuitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dataCircuitTable_data *StorageTmp = dataCircuitTable_create();

	DEBUGMSGTL(("dlMIB", "parse_dataCircuitTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dataCircuitBitErrorsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dataCircuitBitErrorsTransmitted, &tmpsize);
	SNMP_FREE(StorageTmp->dataCircuitBitErrorsThreshold);
	line = read_config_read_data(ASN_OPAQUE, line, &StorageTmp->dataCircuitBitErrorsThreshold, &StorageTmp->dataCircuitBitErrorsThresholdLen);
	if (StorageTmp->dataCircuitBitErrorsThreshold == NULL) {
		config_perror("invalid specification for dataCircuitBitErrorsThreshold");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitType, &tmpsize);
	SNMP_FREE(StorageTmp->dataCircuitPhysicalMediaNames);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitPhysicalMediaNames, &StorageTmp->dataCircuitPhysicalMediaNamesLen);
	if (StorageTmp->dataCircuitPhysicalMediaNames == NULL) {
		config_perror("invalid specification for dataCircuitPhysicalMediaNames");
		return;
	}
	SNMP_FREE(StorageTmp->dataCircuitPhysicalInterfaceType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitPhysicalInterfaceType, &StorageTmp->dataCircuitPhysicalInterfaceTypeLen);
	if (StorageTmp->dataCircuitPhysicalInterfaceType == NULL) {
		config_perror("invalid specification for dataCircuitPhysicalInterfaceType");
		return;
	}
	SNMP_FREE(StorageTmp->dataCircuitPhysicalInterfaceStandard);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitPhysicalInterfaceStandard, &StorageTmp->dataCircuitPhysicalInterfaceStandardLen);
	if (StorageTmp->dataCircuitPhysicalInterfaceStandard == NULL) {
		config_perror("invalid specification for dataCircuitPhysicalInterfaceStandard");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitSynchronizationMode, &tmpsize);
	SNMP_FREE(StorageTmp->dataCircuitTransmissionCoding);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dataCircuitTransmissionCoding, &StorageTmp->dataCircuitTransmissionCodingLen);
	if (StorageTmp->dataCircuitTransmissionCoding == NULL) {
		config_perror("invalid specification for dataCircuitTransmissionCoding");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitTransmissionMode, &tmpsize);
	SNMP_FREE(StorageTmp->dataCircuitTransmissionRate);
	line = read_config_read_data(ASN_OPAQUE, line, &StorageTmp->dataCircuitTransmissionRate, &StorageTmp->dataCircuitTransmissionRateLen);
	if (StorageTmp->dataCircuitTransmissionRate == NULL) {
		config_perror("invalid specification for dataCircuitTransmissionRate");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dataCircuitRowStatus, &tmpsize);
	dataCircuitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_dataCircuitTable(): store configuraiton file for dataCircuitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dataCircuitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dataCircuitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_dataCircuitTable: storing data...  "));
	refresh_dataCircuitTable(1);
	(void) tmpsize;
	for (hcindex = dataCircuitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dataCircuitTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dataCircuitTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dataCircuitBitErrorsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dataCircuitBitErrorsTransmitted, &tmpsize);
			cptr = read_config_store_data(ASN_OPAQUE, cptr, &StorageTmp->dataCircuitBitErrorsThreshold, &StorageTmp->dataCircuitBitErrorsThresholdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitPhysicalMediaNames, &StorageTmp->dataCircuitPhysicalMediaNamesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitPhysicalInterfaceType, &StorageTmp->dataCircuitPhysicalInterfaceTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitPhysicalInterfaceStandard, &StorageTmp->dataCircuitPhysicalInterfaceStandardLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitSynchronizationMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dataCircuitTransmissionCoding, &StorageTmp->dataCircuitTransmissionCodingLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitTransmissionMode, &tmpsize);
			cptr = read_config_store_data(ASN_OPAQUE, cptr, &StorageTmp->dataCircuitTransmissionRate, &StorageTmp->dataCircuitTransmissionRateLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dataCircuitRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct physicalConnectionTable_data *physicalConnectionTable_create(void)
 * @brief create a fresh data structure representing a new row in the physicalConnectionTable table.
 *
 * Creates a new physicalConnectionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct physicalConnectionTable_data *
physicalConnectionTable_create(void)
{
	struct physicalConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(physicalConnectionTable_data);

	DEBUGMSGTL(("dlMIB", "physicalConnectionTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		if ((StorageNew->connectionId = (uint8_t *) strdup("")) != NULL)
			StorageNew->connectionIdLen = strlen("");
		if ((StorageNew->physicalConnectionEndpointIdentifier = (uint8_t *) strdup("")) != NULL)
			StorageNew->physicalConnectionEndpointIdentifierLen = strlen("");
		StorageNew->physicalConnectionPortNumber = 0;
		StorageNew->physicalConnectionRowStatus = 0;
		StorageNew->physicalConnectionRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct physicalConnectionTable_data *physicalConnectionTable_duplicate(struct physicalConnectionTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct physicalConnectionTable_data *
physicalConnectionTable_duplicate(struct physicalConnectionTable_data *thedata)
{
	struct physicalConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(physicalConnectionTable_data);

	DEBUGMSGTL(("dlMIB", "physicalConnectionTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	physicalConnectionTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int physicalConnectionTable_destroy(struct physicalConnectionTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
physicalConnectionTable_destroy(struct physicalConnectionTable_data **thedata)
{
	struct physicalConnectionTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "physicalConnectionTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->physicalConnectionEndpointIdentifier);
		StorageDel->physicalConnectionEndpointIdentifierLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalConnectionTable_add(struct physicalConnectionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the physicalConnectionTable table data set.
 *
 * Adds a table row structure to the physicalConnectionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
physicalConnectionTable_add(struct physicalConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "physicalConnectionTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* connectionId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
		header_complex_add_data(&physicalConnectionTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int physicalConnectionTable_del(struct physicalConnectionTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the physicalConnectionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
physicalConnectionTable_del(struct physicalConnectionTable_data *thedata)
{
	struct physicalConnectionTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "physicalConnectionTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(physicalConnectionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&physicalConnectionTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_physicalConnectionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for physicalConnectionTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case physicalConnectionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_physicalConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct physicalConnectionTable_data *StorageTmp = physicalConnectionTable_create();

	DEBUGMSGTL(("dlMIB", "parse_physicalConnectionTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->connectionId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	SNMP_FREE(StorageTmp->physicalConnectionEndpointIdentifier);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->physicalConnectionEndpointIdentifier, &StorageTmp->physicalConnectionEndpointIdentifierLen);
	if (StorageTmp->physicalConnectionEndpointIdentifier == NULL) {
		config_perror("invalid specification for physicalConnectionEndpointIdentifier");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->physicalConnectionPortNumber, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->physicalConnectionRowStatus, &tmpsize);
	physicalConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_physicalConnectionTable(): store configuraiton file for physicalConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_physicalConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct physicalConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_physicalConnectionTable: storing data...  "));
	refresh_physicalConnectionTable(1);
	(void) tmpsize;
	for (hcindex = physicalConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct physicalConnectionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "physicalConnectionTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->physicalConnectionEndpointIdentifier, &StorageTmp->physicalConnectionEndpointIdentifierLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->physicalConnectionPortNumber, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->physicalConnectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct datalinkEntityTable_data *datalinkEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the datalinkEntityTable table.
 *
 * Creates a new datalinkEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct datalinkEntityTable_data *
datalinkEntityTable_create(void)
{
	struct datalinkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(datalinkEntityTable_data);

	DEBUGMSGTL(("dlMIB", "datalinkEntityTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->datalinkEntityProviderEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->datalinkEntityProviderEntityNamesLen = 2;
		StorageNew->datalinkEntityRowStatus = 0;
		StorageNew->datalinkEntityRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct datalinkEntityTable_data *datalinkEntityTable_duplicate(struct datalinkEntityTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct datalinkEntityTable_data *
datalinkEntityTable_duplicate(struct datalinkEntityTable_data *thedata)
{
	struct datalinkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(datalinkEntityTable_data);

	DEBUGMSGTL(("dlMIB", "datalinkEntityTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	datalinkEntityTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int datalinkEntityTable_destroy(struct datalinkEntityTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
datalinkEntityTable_destroy(struct datalinkEntityTable_data **thedata)
{
	struct datalinkEntityTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "datalinkEntityTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->datalinkEntityProviderEntityNames);
		StorageDel->datalinkEntityProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int datalinkEntityTable_add(struct datalinkEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the datalinkEntityTable table data set.
 *
 * Adds a table row structure to the datalinkEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
datalinkEntityTable_add(struct datalinkEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "datalinkEntityTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		header_complex_add_data(&datalinkEntityTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int datalinkEntityTable_del(struct datalinkEntityTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the datalinkEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
datalinkEntityTable_del(struct datalinkEntityTable_data *thedata)
{
	struct datalinkEntityTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "datalinkEntityTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(datalinkEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&datalinkEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_datalinkEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for datalinkEntityTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case datalinkEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_datalinkEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct datalinkEntityTable_data *StorageTmp = datalinkEntityTable_create();

	DEBUGMSGTL(("dlMIB", "parse_datalinkEntityTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->datalinkEntityProviderEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->datalinkEntityProviderEntityNames, &StorageTmp->datalinkEntityProviderEntityNamesLen);
	if (StorageTmp->datalinkEntityProviderEntityNames == NULL) {
		config_perror("invalid specification for datalinkEntityProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->datalinkEntityRowStatus, &tmpsize);
	datalinkEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_datalinkEntityTable(): store configuraiton file for datalinkEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_datalinkEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct datalinkEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_datalinkEntityTable: storing data...  "));
	refresh_datalinkEntityTable(1);
	(void) tmpsize;
	for (hcindex = datalinkEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct datalinkEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "datalinkEntityTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->datalinkEntityProviderEntityNames, &StorageTmp->datalinkEntityProviderEntityNamesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->datalinkEntityRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dLSAPTable_data *dLSAPTable_create(void)
 * @brief create a fresh data structure representing a new row in the dLSAPTable table.
 *
 * Creates a new dLSAPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dLSAPTable_data *
dLSAPTable_create(void)
{
	struct dLSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(dLSAPTable_data);

	DEBUGMSGTL(("dlMIB", "dLSAPTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->sapId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sapIdLen = strlen("");
		StorageNew->dLSAPRowStatus = 0;
		StorageNew->dLSAPRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct dLSAPTable_data *dLSAPTable_duplicate(struct dLSAPTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dLSAPTable_data *
dLSAPTable_duplicate(struct dLSAPTable_data *thedata)
{
	struct dLSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(dLSAPTable_data);

	DEBUGMSGTL(("dlMIB", "dLSAPTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dLSAPTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dLSAPTable_destroy(struct dLSAPTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dLSAPTable_destroy(struct dLSAPTable_data **thedata)
{
	struct dLSAPTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "dLSAPTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dLSAPTable_add(struct dLSAPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dLSAPTable table data set.
 *
 * Adds a table row structure to the dLSAPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dLSAPTable_add(struct dLSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "dLSAPTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* sapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
		header_complex_add_data(&dLSAPTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dLSAPTable_del(struct dLSAPTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dLSAPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dLSAPTable_del(struct dLSAPTable_data *thedata)
{
	struct dLSAPTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "dLSAPTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dLSAPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dLSAPTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dLSAPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dLSAPTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case dLSAPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dLSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp = dLSAPTable_create();

	DEBUGMSGTL(("dlMIB", "parse_dLSAPTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->sapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dLSAPRowStatus, &tmpsize);
	dLSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_dLSAPTable(): store configuraiton file for dLSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dLSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dLSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_dLSAPTable: storing data...  "));
	refresh_dLSAPTable(1);
	(void) tmpsize;
	for (hcindex = dLSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dLSAPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dLSAPTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dLSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lAPBDLETable_data *lAPBDLETable_create(void)
 * @brief create a fresh data structure representing a new row in the lAPBDLETable table.
 *
 * Creates a new lAPBDLETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lAPBDLETable_data *
lAPBDLETable_create(void)
{
	struct lAPBDLETable_data *StorageNew = SNMP_MALLOC_STRUCT(lAPBDLETable_data);

	DEBUGMSGTL(("dlMIB", "lAPBDLETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		StorageNew->lAPBDLEmT1Timer = 0;
		StorageNew->lAPBDLEmT3Timer = 0;
		StorageNew->lAPBDLEmW = 0;
		StorageNew->lAPBDLEmXSend = 0;
		StorageNew->lAPBDLEmXReceive = 0;
		StorageNew->lAPBDLEmT2Timer = 0;
		StorageNew->lAPBDLEreceivedMlpResets = 0;
		StorageNew->lAPBDLEtimesMT1Expired = 0;
		StorageNew->lAPBDLEIframesReassignments = 0;
		StorageNew->lAPBDLEmlpFramesReceived = 0;
		StorageNew->lAPBDLEmlpFramesSent = 0;
		StorageNew->lAPBDLEmlpFramesOutsideWindowGuard = 0;
		StorageNew->lAPBDLEreceivedMlpFramesInGuardRegion = 0;
		StorageNew->lAPBDLERowStatus = 0;
		StorageNew->lAPBDLERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lAPBDLETable_data *lAPBDLETable_duplicate(struct lAPBDLETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lAPBDLETable_data *
lAPBDLETable_duplicate(struct lAPBDLETable_data *thedata)
{
	struct lAPBDLETable_data *StorageNew = SNMP_MALLOC_STRUCT(lAPBDLETable_data);

	DEBUGMSGTL(("dlMIB", "lAPBDLETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lAPBDLETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lAPBDLETable_destroy(struct lAPBDLETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lAPBDLETable_destroy(struct lAPBDLETable_data **thedata)
{
	struct lAPBDLETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lAPBDLETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lAPBDLETable_add(struct lAPBDLETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lAPBDLETable table data set.
 *
 * Adds a table row structure to the lAPBDLETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lAPBDLETable_add(struct lAPBDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lAPBDLETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		header_complex_add_data(&lAPBDLETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lAPBDLETable_del(struct lAPBDLETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lAPBDLETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lAPBDLETable_del(struct lAPBDLETable_data *thedata)
{
	struct lAPBDLETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lAPBDLETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lAPBDLETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lAPBDLETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lAPBDLETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lAPBDLETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lAPBDLETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lAPBDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct lAPBDLETable_data *StorageTmp = lAPBDLETable_create();

	DEBUGMSGTL(("dlMIB", "parse_lAPBDLETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmW, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmXSend, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmXReceive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLEmT2Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEreceivedMlpResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEtimesMT1Expired, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEIframesReassignments, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lAPBDLERowStatus, &tmpsize);
	lAPBDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lAPBDLETable(): store configuraiton file for lAPBDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lAPBDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lAPBDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lAPBDLETable: storing data...  "));
	refresh_lAPBDLETable(1);
	(void) tmpsize;
	for (hcindex = lAPBDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lAPBDLETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lAPBDLETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT1Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT3Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmW, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmXSend, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmXReceive, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLEmT2Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEreceivedMlpResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEtimesMT1Expired, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEIframesReassignments, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lAPBDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sLPPMTable_data *sLPPMTable_create(void)
 * @brief create a fresh data structure representing a new row in the sLPPMTable table.
 *
 * Creates a new sLPPMTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sLPPMTable_data *
sLPPMTable_create(void)
{
	struct sLPPMTable_data *StorageNew = SNMP_MALLOC_STRUCT(sLPPMTable_data);

	DEBUGMSGTL(("dlMIB", "sLPPMTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		StorageNew->sLPPMadministrativeState = 0;
		StorageNew->sLPPMRowStatus = 0;
		StorageNew->sLPPMRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sLPPMTable_data *sLPPMTable_duplicate(struct sLPPMTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sLPPMTable_data *
sLPPMTable_duplicate(struct sLPPMTable_data *thedata)
{
	struct sLPPMTable_data *StorageNew = SNMP_MALLOC_STRUCT(sLPPMTable_data);

	DEBUGMSGTL(("dlMIB", "sLPPMTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sLPPMTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sLPPMTable_destroy(struct sLPPMTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sLPPMTable_destroy(struct sLPPMTable_data **thedata)
{
	struct sLPPMTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sLPPMTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPPMTable_add(struct sLPPMTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sLPPMTable table data set.
 *
 * Adds a table row structure to the sLPPMTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sLPPMTable_add(struct sLPPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "sLPPMTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		header_complex_add_data(&sLPPMTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPPMTable_del(struct sLPPMTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sLPPMTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sLPPMTable_del(struct sLPPMTable_data *thedata)
{
	struct sLPPMTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sLPPMTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sLPPMTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sLPPMTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sLPPMTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sLPPMTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sLPPMTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sLPPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPPMTable_data *StorageTmp = sLPPMTable_create();

	DEBUGMSGTL(("dlMIB", "parse_sLPPMTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPPMadministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPPMRowStatus, &tmpsize);
	sLPPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_sLPPMTable(): store configuraiton file for sLPPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sLPPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_sLPPMTable: storing data...  "));
	refresh_sLPPMTable(1);
	(void) tmpsize;
	for (hcindex = sLPPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPPMTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sLPPMTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPPMadministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sLPConnectionTable_data *sLPConnectionTable_create(void)
 * @brief create a fresh data structure representing a new row in the sLPConnectionTable table.
 *
 * Creates a new sLPConnectionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sLPConnectionTable_data *
sLPConnectionTable_create(void)
{
	struct sLPConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionTable_data);

	DEBUGMSGTL(("dlMIB", "sLPConnectionTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		if ((StorageNew->connectionId = (uint8_t *) strdup("")) != NULL)
			StorageNew->connectionIdLen = strlen("");
		StorageNew->sLPConnectionInterfaceType = 0;
		StorageNew->sLPConnectionK = 0;
		StorageNew->sLPConnectionN1 = 0;
		StorageNew->sLPConnectionN2 = 0;
		StorageNew->sLPConnectionSequenceModulus = 0;
		StorageNew->sLPConnectionT1Timer = 0;
		StorageNew->sLPConnectionT2Timer = 0;
		StorageNew->sLPConnectionFCSErrorsReceived = 0;
		StorageNew->sLPConnectionFRMRsReceived = 0;
		StorageNew->sLPConnectionFRMRsSent = 0;
		StorageNew->sLPConnectionIFrameDataOctetsReceived = 0;
		StorageNew->sLPConnectionIFrameDataOctetsSent = 0;
		StorageNew->sLPConnectionIFramesReceived = 0;
		StorageNew->sLPConnectionIFramesSent = 0;
		StorageNew->sLPConnectionPollsReceived = 0;
		StorageNew->sLPConnectionREJsReceived = 0;
		StorageNew->sLPConnectionREJsSent = 0;
		StorageNew->sLPConnectionRNRsReceived = 0;
		StorageNew->sLPConnectionRNRsSent = 0;
		StorageNew->sLPConnectionSABMsReceived = 0;
		StorageNew->sLPConnectionSABMsSent = 0;
		StorageNew->sLPConnectionProtocolState = 0;
		StorageNew->sLPConnectionTimesT1Expired = 0;
		StorageNew->sLPConnectionT3Timer = 0;
		StorageNew->sLPConnectionTimesT3Expired = 0;
		StorageNew->sLPConnectionT4Timer = 0;
		StorageNew->sLPConnectionTimesT4Expired = 0;
		StorageNew->sLPConnectionAbnormalLinkDisconnectsReceived = 0;
		StorageNew->sLPConnectionAbnormalLinkDisconnectsSent = 0;
		StorageNew->sLPConnectionLinkResetsReceived = 0;
		StorageNew->sLPConnectionLinkResetsSent = 0;
		StorageNew->sLPConnectionTimesN2Reached = 0;
		StorageNew->sLPConnectionAdministrativeState = 0;
		StorageNew->sLPConnectionOperationalState = 0;
		StorageNew->sLPConnectionUsageState = 0;
		if (memdup((u_char **) &StorageNew->sLPConnectionProceduralStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sLPConnectionProceduralStatusLen = 1;
		if (memdup((u_char **) &StorageNew->sLPConnectionAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sLPConnectionAlarmStatusLen = 1;
		StorageNew->sLPConnectionRowStatus = 0;
		StorageNew->sLPConnectionRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sLPConnectionTable_data *sLPConnectionTable_duplicate(struct sLPConnectionTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sLPConnectionTable_data *
sLPConnectionTable_duplicate(struct sLPConnectionTable_data *thedata)
{
	struct sLPConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionTable_data);

	DEBUGMSGTL(("dlMIB", "sLPConnectionTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sLPConnectionTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sLPConnectionTable_destroy(struct sLPConnectionTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sLPConnectionTable_destroy(struct sLPConnectionTable_data **thedata)
{
	struct sLPConnectionTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sLPConnectionTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->sLPConnectionProceduralStatus);
		StorageDel->sLPConnectionProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->sLPConnectionAlarmStatus);
		StorageDel->sLPConnectionAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPConnectionTable_add(struct sLPConnectionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sLPConnectionTable table data set.
 *
 * Adds a table row structure to the sLPConnectionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sLPConnectionTable_add(struct sLPConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "sLPConnectionTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* connectionId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
		header_complex_add_data(&sLPConnectionTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPConnectionTable_del(struct sLPConnectionTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sLPConnectionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sLPConnectionTable_del(struct sLPConnectionTable_data *thedata)
{
	struct sLPConnectionTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sLPConnectionTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sLPConnectionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sLPConnectionTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sLPConnectionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sLPConnectionTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sLPConnectionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sLPConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPConnectionTable_data *StorageTmp = sLPConnectionTable_create();

	DEBUGMSGTL(("dlMIB", "parse_sLPConnectionTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->connectionId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionInterfaceType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionK, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionN2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionSequenceModulus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT2Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFCSErrorsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFRMRsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionFRMRsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFrameDataOctetsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFrameDataOctetsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFramesReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionIFramesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionPollsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionREJsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionREJsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionRNRsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionRNRsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionSABMsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionSABMsSent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionProtocolState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT1Expired, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT3Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT3Expired, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionT4Timer, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesT4Expired, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionLinkResetsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionLinkResetsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->sLPConnectionTimesN2Reached, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->sLPConnectionProceduralStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sLPConnectionProceduralStatus, &StorageTmp->sLPConnectionProceduralStatusLen);
	if (StorageTmp->sLPConnectionProceduralStatus == NULL) {
		config_perror("invalid specification for sLPConnectionProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->sLPConnectionAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sLPConnectionAlarmStatus, &StorageTmp->sLPConnectionAlarmStatusLen);
	if (StorageTmp->sLPConnectionAlarmStatus == NULL) {
		config_perror("invalid specification for sLPConnectionAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionRowStatus, &tmpsize);
	sLPConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_sLPConnectionTable(): store configuraiton file for sLPConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sLPConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_sLPConnectionTable: storing data...  "));
	refresh_sLPConnectionTable(1);
	(void) tmpsize;
	for (hcindex = sLPConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPConnectionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sLPConnectionTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionInterfaceType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionK, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionN2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionSequenceModulus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT1Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT2Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFCSErrorsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFRMRsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionFRMRsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFrameDataOctetsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFrameDataOctetsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFramesReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionIFramesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionPollsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionREJsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionREJsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionRNRsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionRNRsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionSABMsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionSABMsSent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionProtocolState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesT1Expired, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT3Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesT3Expired, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionT4Timer, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesT4Expired, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionLinkResetsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionLinkResetsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->sLPConnectionTimesN2Reached, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sLPConnectionProceduralStatus, &StorageTmp->sLPConnectionProceduralStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sLPConnectionAlarmStatus, &StorageTmp->sLPConnectionAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sLPConnectionIVMOTable_data *sLPConnectionIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the sLPConnectionIVMOTable table.
 *
 * Creates a new sLPConnectionIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sLPConnectionIVMOTable_data *
sLPConnectionIVMOTable_create(void)
{
	struct sLPConnectionIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionIVMOTable_data);

	DEBUGMSGTL(("dlMIB", "sLPConnectionIVMOTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		if ((StorageNew->connectionId = (uint8_t *) strdup("")) != NULL)
			StorageNew->connectionIdLen = strlen("");
		if ((StorageNew->sLPConnectionIVMOid = (uint8_t *) strdup("")) != NULL)
			StorageNew->sLPConnectionIVMOidLen = strlen("");
		StorageNew->sLPConnectionIVMOinterfaceType = 0;
		StorageNew->sLPConnectionIVMOk = 0;
		StorageNew->sLPConnectionIVMOn1 = 0;
		StorageNew->sLPConnectionIVMOn2 = 0;
		StorageNew->sLPConnectionIVMOsequenceModulus = 0;
		StorageNew->sLPConnectionIVMOt1Timer = 0;
		StorageNew->sLPConnectionIVMOt2Timer = 0;
		StorageNew->sLPConnectionIVMOt3Timer = 0;
		StorageNew->sLPConnectionIVMOt4Timer = 0;
		StorageNew->sLPConnectionIVMORowStatus = 0;
		StorageNew->sLPConnectionIVMORowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sLPConnectionIVMOTable_data *sLPConnectionIVMOTable_duplicate(struct sLPConnectionIVMOTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sLPConnectionIVMOTable_data *
sLPConnectionIVMOTable_duplicate(struct sLPConnectionIVMOTable_data *thedata)
{
	struct sLPConnectionIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(sLPConnectionIVMOTable_data);

	DEBUGMSGTL(("dlMIB", "sLPConnectionIVMOTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sLPConnectionIVMOTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sLPConnectionIVMOTable_destroy(struct sLPConnectionIVMOTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sLPConnectionIVMOTable_destroy(struct sLPConnectionIVMOTable_data **thedata)
{
	struct sLPConnectionIVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sLPConnectionIVMOTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->sLPConnectionIVMOid);
		StorageDel->sLPConnectionIVMOidLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPConnectionIVMOTable_add(struct sLPConnectionIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sLPConnectionIVMOTable table data set.
 *
 * Adds a table row structure to the sLPConnectionIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sLPConnectionIVMOTable_add(struct sLPConnectionIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "sLPConnectionIVMOTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* connectionId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
		header_complex_add_data(&sLPConnectionIVMOTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sLPConnectionIVMOTable_del(struct sLPConnectionIVMOTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sLPConnectionIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sLPConnectionIVMOTable_del(struct sLPConnectionIVMOTable_data *thedata)
{
	struct sLPConnectionIVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "sLPConnectionIVMOTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sLPConnectionIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sLPConnectionIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sLPConnectionIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sLPConnectionIVMOTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sLPConnectionIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sLPConnectionIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sLPConnectionIVMOTable_data *StorageTmp = sLPConnectionIVMOTable_create();

	DEBUGMSGTL(("dlMIB", "parse_sLPConnectionIVMOTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->connectionId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	SNMP_FREE(StorageTmp->sLPConnectionIVMOid);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sLPConnectionIVMOid, &StorageTmp->sLPConnectionIVMOidLen);
	if (StorageTmp->sLPConnectionIVMOid == NULL) {
		config_perror("invalid specification for sLPConnectionIVMOid");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOinterfaceType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOk, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOn1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOn2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOsequenceModulus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt1Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt2Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt3Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMOt4Timer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sLPConnectionIVMORowStatus, &tmpsize);
	sLPConnectionIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_sLPConnectionIVMOTable(): store configuraiton file for sLPConnectionIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sLPConnectionIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sLPConnectionIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_sLPConnectionIVMOTable: storing data...  "));
	refresh_sLPConnectionIVMOTable(1);
	(void) tmpsize;
	for (hcindex = sLPConnectionIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sLPConnectionIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sLPConnectionIVMOTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sLPConnectionIVMOid, &StorageTmp->sLPConnectionIVMOidLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOinterfaceType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOk, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOn1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOn2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOsequenceModulus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt1Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt2Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt3Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMOt4Timer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sLPConnectionIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mACDLETable_data *mACDLETable_create(void)
 * @brief create a fresh data structure representing a new row in the mACDLETable table.
 *
 * Creates a new mACDLETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mACDLETable_data *
mACDLETable_create(void)
{
	struct mACDLETable_data *StorageNew = SNMP_MALLOC_STRUCT(mACDLETable_data);

	DEBUGMSGTL(("dlMIB", "mACDLETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		StorageNew->mACDLERowStatus = 0;
		StorageNew->mACDLERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mACDLETable_data *mACDLETable_duplicate(struct mACDLETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mACDLETable_data *
mACDLETable_duplicate(struct mACDLETable_data *thedata)
{
	struct mACDLETable_data *StorageNew = SNMP_MALLOC_STRUCT(mACDLETable_data);

	DEBUGMSGTL(("dlMIB", "mACDLETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mACDLETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mACDLETable_destroy(struct mACDLETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mACDLETable_destroy(struct mACDLETable_data **thedata)
{
	struct mACDLETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "mACDLETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mACDLETable_add(struct mACDLETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mACDLETable table data set.
 *
 * Adds a table row structure to the mACDLETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mACDLETable_add(struct mACDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "mACDLETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		header_complex_add_data(&mACDLETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mACDLETable_del(struct mACDLETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mACDLETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mACDLETable_del(struct mACDLETable_data *thedata)
{
	struct mACDLETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "mACDLETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mACDLETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mACDLETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mACDLETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mACDLETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mACDLETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mACDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct mACDLETable_data *StorageTmp = mACDLETable_create();

	DEBUGMSGTL(("dlMIB", "parse_mACDLETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACDLERowStatus, &tmpsize);
	mACDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_mACDLETable(): store configuraiton file for mACDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mACDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mACDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_mACDLETable: storing data...  "));
	refresh_mACDLETable(1);
	(void) tmpsize;
	for (hcindex = mACDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mACDLETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mACDLETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mACTable_data *mACTable_create(void)
 * @brief create a fresh data structure representing a new row in the mACTable table.
 *
 * Creates a new mACTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mACTable_data *
mACTable_create(void)
{
	struct mACTable_data *StorageNew = SNMP_MALLOC_STRUCT(mACTable_data);

	DEBUGMSGTL(("dlMIB", "mACTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		StorageNew->mACOperationalState = 0;
		StorageNew->mACRowStatus = 0;
		StorageNew->mACRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mACTable_data *mACTable_duplicate(struct mACTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mACTable_data *
mACTable_duplicate(struct mACTable_data *thedata)
{
	struct mACTable_data *StorageNew = SNMP_MALLOC_STRUCT(mACTable_data);

	DEBUGMSGTL(("dlMIB", "mACTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mACTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mACTable_destroy(struct mACTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mACTable_destroy(struct mACTable_data **thedata)
{
	struct mACTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "mACTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->mACId);
		StorageDel->mACIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mACTable_add(struct mACTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mACTable table data set.
 *
 * Adds a table row structure to the mACTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mACTable_add(struct mACTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "mACTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* mACId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mACId, thedata->mACIdLen);
		header_complex_add_data(&mACTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mACTable_del(struct mACTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mACTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mACTable_del(struct mACTable_data *thedata)
{
	struct mACTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "mACTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mACTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mACTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mACTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mACTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mACTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mACTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mACTable_data *StorageTmp = mACTable_create();

	DEBUGMSGTL(("dlMIB", "parse_mACTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mACId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mACId, &StorageTmp->mACIdLen);
	if (StorageTmp->mACId == NULL) {
		config_perror("invalid specification for mACId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mACRowStatus, &tmpsize);
	mACTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_mACTable(): store configuraiton file for mACTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mACTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mACTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_mACTable: storing data...  "));
	refresh_mACTable(1);
	(void) tmpsize;
	for (hcindex = mACTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mACTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mACTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mACId, &StorageTmp->mACIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mACRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCDLETable_data *lLCDLETable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCDLETable table.
 *
 * Creates a new lLCDLETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCDLETable_data *
lLCDLETable_create(void)
{
	struct lLCDLETable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCDLETable_data);

	DEBUGMSGTL(("dlMIB", "lLCDLETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		StorageNew->lLCDLERowStatus = 0;
		StorageNew->lLCDLERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCDLETable_data *lLCDLETable_duplicate(struct lLCDLETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCDLETable_data *
lLCDLETable_duplicate(struct lLCDLETable_data *thedata)
{
	struct lLCDLETable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCDLETable_data);

	DEBUGMSGTL(("dlMIB", "lLCDLETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCDLETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCDLETable_destroy(struct lLCDLETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCDLETable_destroy(struct lLCDLETable_data **thedata)
{
	struct lLCDLETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCDLETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCDLETable_add(struct lLCDLETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCDLETable table data set.
 *
 * Adds a table row structure to the lLCDLETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCDLETable_add(struct lLCDLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCDLETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		header_complex_add_data(&lLCDLETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCDLETable_del(struct lLCDLETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCDLETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCDLETable_del(struct lLCDLETable_data *thedata)
{
	struct lLCDLETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCDLETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCDLETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCDLETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCDLETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCDLETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCDLETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCDLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCDLETable_data *StorageTmp = lLCDLETable_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCDLETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCDLERowStatus, &tmpsize);
	lLCDLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCDLETable(): store configuraiton file for lLCDLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCDLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCDLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCDLETable: storing data...  "));
	refresh_lLCDLETable(1);
	(void) tmpsize;
	for (hcindex = lLCDLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCDLETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCDLETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCDLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCCLPMTable_data *lLCCLPMTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCCLPMTable table.
 *
 * Creates a new lLCCLPMTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCCLPMTable_data *
lLCCLPMTable_create(void)
{
	struct lLCCLPMTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCCLPMTable_data);

	DEBUGMSGTL(("dlMIB", "lLCCLPMTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->clProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->clProtocolMachineIdLen = strlen("");
		StorageNew->lLCCLPMRowStatus = 0;
		StorageNew->lLCCLPMRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCCLPMTable_data *lLCCLPMTable_duplicate(struct lLCCLPMTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCCLPMTable_data *
lLCCLPMTable_duplicate(struct lLCCLPMTable_data *thedata)
{
	struct lLCCLPMTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCCLPMTable_data);

	DEBUGMSGTL(("dlMIB", "lLCCLPMTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCCLPMTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCCLPMTable_destroy(struct lLCCLPMTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCCLPMTable_destroy(struct lLCCLPMTable_data **thedata)
{
	struct lLCCLPMTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCCLPMTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCCLPMTable_add(struct lLCCLPMTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCCLPMTable table data set.
 *
 * Adds a table row structure to the lLCCLPMTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCCLPMTable_add(struct lLCCLPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCCLPMTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		header_complex_add_data(&lLCCLPMTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCCLPMTable_del(struct lLCCLPMTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCCLPMTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCCLPMTable_del(struct lLCCLPMTable_data *thedata)
{
	struct lLCCLPMTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCCLPMTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCCLPMTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCCLPMTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCCLPMTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCCLPMTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCCLPMTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCCLPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCCLPMTable_data *StorageTmp = lLCCLPMTable_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCCLPMTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCLPMRowStatus, &tmpsize);
	lLCCLPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCCLPMTable(): store configuraiton file for lLCCLPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCCLPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCCLPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCCLPMTable: storing data...  "));
	refresh_lLCCLPMTable(1);
	(void) tmpsize;
	for (hcindex = lLCCLPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCCLPMTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCCLPMTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCLPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCCOPMTable_data *lLCCOPMTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCCOPMTable table.
 *
 * Creates a new lLCCOPMTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCCOPMTable_data *
lLCCOPMTable_create(void)
{
	struct lLCCOPMTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCCOPMTable_data);

	DEBUGMSGTL(("dlMIB", "lLCCOPMTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		StorageNew->lLCCOPMRowStatus = 0;
		StorageNew->lLCCOPMRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCCOPMTable_data *lLCCOPMTable_duplicate(struct lLCCOPMTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCCOPMTable_data *
lLCCOPMTable_duplicate(struct lLCCOPMTable_data *thedata)
{
	struct lLCCOPMTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCCOPMTable_data);

	DEBUGMSGTL(("dlMIB", "lLCCOPMTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCCOPMTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCCOPMTable_destroy(struct lLCCOPMTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCCOPMTable_destroy(struct lLCCOPMTable_data **thedata)
{
	struct lLCCOPMTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCCOPMTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCCOPMTable_add(struct lLCCOPMTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCCOPMTable table data set.
 *
 * Adds a table row structure to the lLCCOPMTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCCOPMTable_add(struct lLCCOPMTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCCOPMTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		header_complex_add_data(&lLCCOPMTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCCOPMTable_del(struct lLCCOPMTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCCOPMTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCCOPMTable_del(struct lLCCOPMTable_data *thedata)
{
	struct lLCCOPMTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCCOPMTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCCOPMTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCCOPMTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCCOPMTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCCOPMTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCCOPMTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCCOPMTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCCOPMTable_data *StorageTmp = lLCCOPMTable_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCCOPMTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCCOPMRowStatus, &tmpsize);
	lLCCOPMTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCCOPMTable(): store configuraiton file for lLCCOPMTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCCOPMTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCCOPMTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCCOPMTable: storing data...  "));
	refresh_lLCCOPMTable(1);
	(void) tmpsize;
	for (hcindex = lLCCOPMTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCCOPMTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCCOPMTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCCOPMRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct resourceTypeIdTable_data *resourceTypeIdTable_create(void)
 * @brief create a fresh data structure representing a new row in the resourceTypeIdTable table.
 *
 * Creates a new resourceTypeIdTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct resourceTypeIdTable_data *
resourceTypeIdTable_create(void)
{
	struct resourceTypeIdTable_data *StorageNew = SNMP_MALLOC_STRUCT(resourceTypeIdTable_data);

	DEBUGMSGTL(("dlMIB", "resourceTypeIdTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->resourceTypeIdName = (uint8_t *) strdup("RTID")) != NULL)
			StorageNew->resourceTypeIdNameLen = strlen("RTID");
		if ((StorageNew->resourceInfoManufacturerOUI = (uint8_t *) strdup("")) != NULL)
			StorageNew->resourceInfoManufacturerOUILen = strlen("");
		if ((StorageNew->resourceInfoManufacturerName = (uint8_t *) strdup("")) != NULL)
			StorageNew->resourceInfoManufacturerNameLen = strlen("");
		if ((StorageNew->resourceInfoManufacturerProductName = (uint8_t *) strdup("")) != NULL)
			StorageNew->resourceInfoManufacturerProductNameLen = strlen("");
		if ((StorageNew->resourceInfoManufacturerProductVersion = (uint8_t *) strdup("")) != NULL)
			StorageNew->resourceInfoManufacturerProductVersionLen = strlen("");

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct resourceTypeIdTable_data *resourceTypeIdTable_duplicate(struct resourceTypeIdTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct resourceTypeIdTable_data *
resourceTypeIdTable_duplicate(struct resourceTypeIdTable_data *thedata)
{
	struct resourceTypeIdTable_data *StorageNew = SNMP_MALLOC_STRUCT(resourceTypeIdTable_data);

	DEBUGMSGTL(("dlMIB", "resourceTypeIdTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	resourceTypeIdTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int resourceTypeIdTable_destroy(struct resourceTypeIdTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
resourceTypeIdTable_destroy(struct resourceTypeIdTable_data **thedata)
{
	struct resourceTypeIdTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "resourceTypeIdTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->resourceTypeIdName);
		StorageDel->resourceTypeIdNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerOUI);
		StorageDel->resourceInfoManufacturerOUILen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerName);
		StorageDel->resourceInfoManufacturerNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerProductName);
		StorageDel->resourceInfoManufacturerProductNameLen = 0;
		SNMP_FREE(StorageDel->resourceInfoManufacturerProductVersion);
		StorageDel->resourceInfoManufacturerProductVersionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int resourceTypeIdTable_add(struct resourceTypeIdTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the resourceTypeIdTable table data set.
 *
 * Adds a table row structure to the resourceTypeIdTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
resourceTypeIdTable_add(struct resourceTypeIdTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "resourceTypeIdTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		header_complex_add_data(&resourceTypeIdTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int resourceTypeIdTable_del(struct resourceTypeIdTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the resourceTypeIdTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
resourceTypeIdTable_del(struct resourceTypeIdTable_data *thedata)
{
	struct resourceTypeIdTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "resourceTypeIdTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(resourceTypeIdTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&resourceTypeIdTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_resourceTypeIdTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for resourceTypeIdTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case resourceTypeIdTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_resourceTypeIdTable(const char *token, char *line)
{
	size_t tmpsize;
	struct resourceTypeIdTable_data *StorageTmp = resourceTypeIdTable_create();

	DEBUGMSGTL(("dlMIB", "parse_resourceTypeIdTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->resourceTypeIdName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceTypeIdName, &StorageTmp->resourceTypeIdNameLen);
	if (StorageTmp->resourceTypeIdName == NULL) {
		config_perror("invalid specification for resourceTypeIdName");
		return;
	}
	SNMP_FREE(StorageTmp->resourceInfoManufacturerOUI);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerOUI, &StorageTmp->resourceInfoManufacturerOUILen);
	if (StorageTmp->resourceInfoManufacturerOUI == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerOUI");
		return;
	}
	SNMP_FREE(StorageTmp->resourceInfoManufacturerName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerName, &StorageTmp->resourceInfoManufacturerNameLen);
	if (StorageTmp->resourceInfoManufacturerName == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerName");
		return;
	}
	SNMP_FREE(StorageTmp->resourceInfoManufacturerProductName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerProductName, &StorageTmp->resourceInfoManufacturerProductNameLen);
	if (StorageTmp->resourceInfoManufacturerProductName == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerProductName");
		return;
	}
	SNMP_FREE(StorageTmp->resourceInfoManufacturerProductVersion);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->resourceInfoManufacturerProductVersion, &StorageTmp->resourceInfoManufacturerProductVersionLen);
	if (StorageTmp->resourceInfoManufacturerProductVersion == NULL) {
		config_perror("invalid specification for resourceInfoManufacturerProductVersion");
		return;
	}
	resourceTypeIdTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_resourceTypeIdTable(): store configuraiton file for resourceTypeIdTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_resourceTypeIdTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct resourceTypeIdTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_resourceTypeIdTable: storing data...  "));
	refresh_resourceTypeIdTable(1);
	(void) tmpsize;
	for (hcindex = resourceTypeIdTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct resourceTypeIdTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "resourceTypeIdTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceTypeIdName, &StorageTmp->resourceTypeIdNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerOUI, &StorageTmp->resourceInfoManufacturerOUILen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerName, &StorageTmp->resourceInfoManufacturerNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerProductName, &StorageTmp->resourceInfoManufacturerProductNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->resourceInfoManufacturerProductVersion, &StorageTmp->resourceInfoManufacturerProductVersionLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCStationTable_data *lLCStationTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCStationTable table.
 *
 * Creates a new lLCStationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCStationTable_data *
lLCStationTable_create(void)
{
	struct lLCStationTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCStationTable_data);

	DEBUGMSGTL(("dlMIB", "lLCStationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->sapId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sapIdLen = strlen("");
		if ((StorageNew->lLCStationLLCName = (uint8_t *) strdup("")) != NULL)
			StorageNew->lLCStationLLCNameLen = strlen("");
		StorageNew->lLCStationMaximumLSAPsConfigured = 0;
		StorageNew->lLCStationNumberOfActiveLSAPs = 0;
		if (memdup((u_char **) &StorageNew->lLCStationSupportedServicesTypes, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->lLCStationSupportedServicesTypesLen = 1;
		StorageNew->lLCStationStatus = 0;
		StorageNew->lLCStationType1AcknowledgeTimeoutValue = 0;
		StorageNew->lLCStationType1MaximumRetryCount = 0;
		StorageNew->lLCStationMaximumPDUN3 = 0;
		StorageNew->lLCStationMaximumRetransmissions4 = 0;
		StorageNew->lLCStationReceiveVariableLifetime = 0;
		StorageNew->lLCStationTransmitVariableLifetime = 0;
		StorageNew->lLCStationType3AcknowledgeTimeoutValue = 0;
		StorageNew->lLCStationType3Retransmissions = 0;
		StorageNew->lLCStationAvgBufferUseSize = 0;
		StorageNew->lLCStationBufferProblems = 0;
		StorageNew->lLCStationBufferSize = 0;
		StorageNew->lLCStationMaxBufferUseSize = 0;
		StorageNew->lLCStationInactiveLSAP = 0;
		StorageNew->lLCStationPDUsDiscard = 0;
		if (memdup((u_char **) &StorageNew->lLCStationSTRIndicator, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->lLCStationSTRIndicatorLen = 1;
		StorageNew->lLCStationVersionNumber = 0;
		StorageNew->lLCStationType1AcknowledgmentTimerTimeouts = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCStationTable_data *lLCStationTable_duplicate(struct lLCStationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCStationTable_data *
lLCStationTable_duplicate(struct lLCStationTable_data *thedata)
{
	struct lLCStationTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCStationTable_data);

	DEBUGMSGTL(("dlMIB", "lLCStationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCStationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCStationTable_destroy(struct lLCStationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCStationTable_destroy(struct lLCStationTable_data **thedata)
{
	struct lLCStationTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCStationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->lLCStationLLCName);
		StorageDel->lLCStationLLCNameLen = 0;
		SNMP_FREE(StorageDel->lLCStationSupportedServicesTypes);
		StorageDel->lLCStationSupportedServicesTypesLen = 0;
		SNMP_FREE(StorageDel->lLCStationSTRIndicator);
		StorageDel->lLCStationSTRIndicatorLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCStationTable_add(struct lLCStationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCStationTable table data set.
 *
 * Adds a table row structure to the lLCStationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCStationTable_add(struct lLCStationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCStationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* sapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
		header_complex_add_data(&lLCStationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCStationTable_del(struct lLCStationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCStationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCStationTable_del(struct lLCStationTable_data *thedata)
{
	struct lLCStationTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCStationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCStationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCStationTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCStationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCStationTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCStationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCStationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCStationTable_data *StorageTmp = lLCStationTable_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCStationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->sapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	SNMP_FREE(StorageTmp->lLCStationLLCName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCStationLLCName, &StorageTmp->lLCStationLLCNameLen);
	if (StorageTmp->lLCStationLLCName == NULL) {
		config_perror("invalid specification for lLCStationLLCName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumLSAPsConfigured, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationNumberOfActiveLSAPs, &tmpsize);
	SNMP_FREE(StorageTmp->lLCStationSupportedServicesTypes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCStationSupportedServicesTypes, &StorageTmp->lLCStationSupportedServicesTypesLen);
	if (StorageTmp->lLCStationSupportedServicesTypes == NULL) {
		config_perror("invalid specification for lLCStationSupportedServicesTypes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType1AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType1MaximumRetryCount, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumPDUN3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationMaximumRetransmissions4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationReceiveVariableLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationTransmitVariableLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationType3AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationType3Retransmissions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationAvgBufferUseSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationBufferProblems, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationBufferSize, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lLCStationMaxBufferUseSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationInactiveLSAP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationPDUsDiscard, &tmpsize);
	SNMP_FREE(StorageTmp->lLCStationSTRIndicator);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCStationSTRIndicator, &StorageTmp->lLCStationSTRIndicatorLen);
	if (StorageTmp->lLCStationSTRIndicator == NULL) {
		config_perror("invalid specification for lLCStationSTRIndicator");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCStationVersionNumber, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts, &tmpsize);
	lLCStationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCStationTable(): store configuraiton file for lLCStationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCStationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCStationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCStationTable: storing data...  "));
	refresh_lLCStationTable(1);
	(void) tmpsize;
	for (hcindex = lLCStationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCStationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCStationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCStationLLCName, &StorageTmp->lLCStationLLCNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumLSAPsConfigured, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationNumberOfActiveLSAPs, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCStationSupportedServicesTypes, &StorageTmp->lLCStationSupportedServicesTypesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType1AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType1MaximumRetryCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumPDUN3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationMaximumRetransmissions4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationReceiveVariableLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationTransmitVariableLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationType3AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationType3Retransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationAvgBufferUseSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationBufferProblems, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationBufferSize, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lLCStationMaxBufferUseSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationInactiveLSAP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationPDUsDiscard, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCStationSTRIndicator, &StorageTmp->lLCStationSTRIndicatorLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCStationVersionNumber, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCSAPTable_data *lLCSAPTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCSAPTable table.
 *
 * Creates a new lLCSAPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCSAPTable_data *
lLCSAPTable_create(void)
{
	struct lLCSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCSAPTable_data);

	DEBUGMSGTL(("dlMIB", "lLCSAPTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->sapId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sapIdLen = strlen("");
		if ((StorageNew->lLCSAPName = (uint8_t *) strdup("")) != NULL)
			StorageNew->lLCSAPNameLen = strlen("");
		if ((StorageNew->lLCSAPAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->lLCSAPAddressLen = strlen("");
		StorageNew->lLCSAPRDE = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCSAPTable_data *lLCSAPTable_duplicate(struct lLCSAPTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCSAPTable_data *
lLCSAPTable_duplicate(struct lLCSAPTable_data *thedata)
{
	struct lLCSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCSAPTable_data);

	DEBUGMSGTL(("dlMIB", "lLCSAPTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCSAPTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCSAPTable_destroy(struct lLCSAPTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCSAPTable_destroy(struct lLCSAPTable_data **thedata)
{
	struct lLCSAPTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCSAPTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->lLCSAPName);
		StorageDel->lLCSAPNameLen = 0;
		SNMP_FREE(StorageDel->lLCSAPAddress);
		StorageDel->lLCSAPAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCSAPTable_add(struct lLCSAPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCSAPTable table data set.
 *
 * Adds a table row structure to the lLCSAPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCSAPTable_add(struct lLCSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCSAPTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* sapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
		header_complex_add_data(&lLCSAPTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCSAPTable_del(struct lLCSAPTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCSAPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCSAPTable_del(struct lLCSAPTable_data *thedata)
{
	struct lLCSAPTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCSAPTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCSAPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCSAPTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCSAPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCSAPTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCSAPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCSAPTable_data *StorageTmp = lLCSAPTable_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCSAPTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->sapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	SNMP_FREE(StorageTmp->lLCSAPName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCSAPName, &StorageTmp->lLCSAPNameLen);
	if (StorageTmp->lLCSAPName == NULL) {
		config_perror("invalid specification for lLCSAPName");
		return;
	}
	SNMP_FREE(StorageTmp->lLCSAPAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCSAPAddress, &StorageTmp->lLCSAPAddressLen);
	if (StorageTmp->lLCSAPAddress == NULL) {
		config_perror("invalid specification for lLCSAPAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCSAPRDE, &tmpsize);
	lLCSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCSAPTable(): store configuraiton file for lLCSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCSAPTable: storing data...  "));
	refresh_lLCSAPTable(1);
	(void) tmpsize;
	for (hcindex = lLCSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCSAPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCSAPTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCSAPName, &StorageTmp->lLCSAPNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCSAPAddress, &StorageTmp->lLCSAPAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCSAPRDE, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct rDESetupTable_data *rDESetupTable_create(void)
 * @brief create a fresh data structure representing a new row in the rDESetupTable table.
 *
 * Creates a new rDESetupTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct rDESetupTable_data *
rDESetupTable_create(void)
{
	struct rDESetupTable_data *StorageNew = SNMP_MALLOC_STRUCT(rDESetupTable_data);

	DEBUGMSGTL(("dlMIB", "rDESetupTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->sapId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sapIdLen = strlen("");
		StorageNew->rDESetupAgingEnabled = 0;
		StorageNew->rDESetupAgingValue = 0;
		StorageNew->rDESetupEnableType2Reset = 0;
		StorageNew->rDESetupMaximumRouteDescriptors = 0;
		StorageNew->rDESetupMaximumResponseTime = 0;
		StorageNew->rDESetupMinimumPDUSize = 0;
		StorageNew->rDESetupRDEHold = 0;
		StorageNew->rDESetupRDEReplace = 0;
		StorageNew->rDESetupName = 0;
		StorageNew->rDESetupResetOnTestEnabled = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct rDESetupTable_data *rDESetupTable_duplicate(struct rDESetupTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct rDESetupTable_data *
rDESetupTable_duplicate(struct rDESetupTable_data *thedata)
{
	struct rDESetupTable_data *StorageNew = SNMP_MALLOC_STRUCT(rDESetupTable_data);

	DEBUGMSGTL(("dlMIB", "rDESetupTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	rDESetupTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int rDESetupTable_destroy(struct rDESetupTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
rDESetupTable_destroy(struct rDESetupTable_data **thedata)
{
	struct rDESetupTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "rDESetupTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int rDESetupTable_add(struct rDESetupTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the rDESetupTable table data set.
 *
 * Adds a table row structure to the rDESetupTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
rDESetupTable_add(struct rDESetupTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "rDESetupTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* sapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
		header_complex_add_data(&rDESetupTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int rDESetupTable_del(struct rDESetupTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the rDESetupTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
rDESetupTable_del(struct rDESetupTable_data *thedata)
{
	struct rDESetupTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "rDESetupTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(rDESetupTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&rDESetupTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_rDESetupTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for rDESetupTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case rDESetupTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_rDESetupTable(const char *token, char *line)
{
	size_t tmpsize;
	struct rDESetupTable_data *StorageTmp = rDESetupTable_create();

	DEBUGMSGTL(("dlMIB", "parse_rDESetupTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->sapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupAgingEnabled, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupAgingValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupEnableType2Reset, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMaximumRouteDescriptors, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMaximumResponseTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupMinimumPDUSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupRDEHold, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupRDEReplace, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupName, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->rDESetupResetOnTestEnabled, &tmpsize);
	rDESetupTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_rDESetupTable(): store configuraiton file for rDESetupTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_rDESetupTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct rDESetupTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_rDESetupTable: storing data...  "));
	refresh_rDESetupTable(1);
	(void) tmpsize;
	for (hcindex = rDESetupTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct rDESetupTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "rDESetupTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupAgingEnabled, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupAgingValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupEnableType2Reset, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMaximumRouteDescriptors, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMaximumResponseTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupMinimumPDUSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupRDEHold, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupRDEReplace, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->rDESetupResetOnTestEnabled, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct rDEPairTable_data *rDEPairTable_create(void)
 * @brief create a fresh data structure representing a new row in the rDEPairTable table.
 *
 * Creates a new rDEPairTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct rDEPairTable_data *
rDEPairTable_create(void)
{
	struct rDEPairTable_data *StorageNew = SNMP_MALLOC_STRUCT(rDEPairTable_data);

	DEBUGMSGTL(("dlMIB", "rDEPairTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->sapId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sapIdLen = strlen("");
		StorageNew->rDEPairDiscardCounter = 0;
		StorageNew->rDEPairNSRPDUCounter = 0;
		StorageNew->rDEPairNSRSelectedCounter = 0;
		if ((StorageNew->rDEPairRIF = (uint8_t *) strdup("")) != NULL)
			StorageNew->rDEPairRIFLen = strlen("");
		StorageNew->rDEPairSRFPDUCounter = 0;
		StorageNew->rDEPairQueryCounter = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct rDEPairTable_data *rDEPairTable_duplicate(struct rDEPairTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct rDEPairTable_data *
rDEPairTable_duplicate(struct rDEPairTable_data *thedata)
{
	struct rDEPairTable_data *StorageNew = SNMP_MALLOC_STRUCT(rDEPairTable_data);

	DEBUGMSGTL(("dlMIB", "rDEPairTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	rDEPairTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int rDEPairTable_destroy(struct rDEPairTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
rDEPairTable_destroy(struct rDEPairTable_data **thedata)
{
	struct rDEPairTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "rDEPairTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel->rDEPairName);
		StorageDel->rDEPairNameLen = 0;
		SNMP_FREE(StorageDel->rDEPairRIF);
		StorageDel->rDEPairRIFLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int rDEPairTable_add(struct rDEPairTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the rDEPairTable table data set.
 *
 * Adds a table row structure to the rDEPairTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
rDEPairTable_add(struct rDEPairTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "rDEPairTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* sapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
		/* rDEPairName */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->rDEPairName, thedata->rDEPairNameLen);
		header_complex_add_data(&rDEPairTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int rDEPairTable_del(struct rDEPairTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the rDEPairTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
rDEPairTable_del(struct rDEPairTable_data *thedata)
{
	struct rDEPairTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "rDEPairTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(rDEPairTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&rDEPairTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_rDEPairTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for rDEPairTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case rDEPairTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_rDEPairTable(const char *token, char *line)
{
	size_t tmpsize;
	struct rDEPairTable_data *StorageTmp = rDEPairTable_create();

	DEBUGMSGTL(("dlMIB", "parse_rDEPairTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->sapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	SNMP_FREE(StorageTmp->rDEPairName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->rDEPairName, &StorageTmp->rDEPairNameLen);
	if (StorageTmp->rDEPairName == NULL) {
		config_perror("invalid specification for rDEPairName");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairDiscardCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairNSRPDUCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairNSRSelectedCounter, &tmpsize);
	SNMP_FREE(StorageTmp->rDEPairRIF);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->rDEPairRIF, &StorageTmp->rDEPairRIFLen);
	if (StorageTmp->rDEPairRIF == NULL) {
		config_perror("invalid specification for rDEPairRIF");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairSRFPDUCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->rDEPairQueryCounter, &tmpsize);
	rDEPairTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_rDEPairTable(): store configuraiton file for rDEPairTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_rDEPairTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct rDEPairTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_rDEPairTable: storing data...  "));
	refresh_rDEPairTable(1);
	(void) tmpsize;
	for (hcindex = rDEPairTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct rDEPairTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "rDEPairTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->rDEPairName, &StorageTmp->rDEPairNameLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairDiscardCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairNSRPDUCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairNSRSelectedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->rDEPairRIF, &StorageTmp->rDEPairRIFLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairSRFPDUCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->rDEPairQueryCounter, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnectionLessTable_data *lLCConnectionLessTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnectionLessTable table.
 *
 * Creates a new lLCConnectionLessTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnectionLessTable_data *
lLCConnectionLessTable_create(void)
{
	struct lLCConnectionLessTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionLessTable_data);

	DEBUGMSGTL(("dlMIB", "lLCConnectionLessTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->clProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->clProtocolMachineIdLen = strlen("");
		if ((StorageNew->clProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->clProtocolMachineIdLen = strlen("");
		if ((StorageNew->lLCConnectionlessName = (uint8_t *) strdup("")) != NULL)
			StorageNew->lLCConnectionlessNameLen = strlen("");
		StorageNew->lLCConnectionlessMaximumLLCInformationFieldSize = 0;
		StorageNew->lLCConnectionlessTESTReceivedABBResponse = 0;
		StorageNew->lLCConnectionlessTESTReceivedCommand = 0;
		StorageNew->lLCConnectionlessTESTReceivedResponse = 0;
		StorageNew->lLCConnectionlessTESTSentABBResponse = 0;
		StorageNew->lLCConnectionlessTESTSentCommand = 0;
		StorageNew->lLCConnectionlessTESTSentResponse = 0;
		StorageNew->lLCConnectionlessUIReceived = 0;
		StorageNew->lLCConnectionlessUISent = 0;
		StorageNew->lLCConnectionlessXIDReceivedCommand = 0;
		StorageNew->lLCConnectionlessXIDReceivedResponse = 0;
		StorageNew->lLCConnectionlessXIDSentCommand = 0;
		StorageNew->lLCConnectionlessXIDSentResponse = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCConnectionLessTable_data *lLCConnectionLessTable_duplicate(struct lLCConnectionLessTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCConnectionLessTable_data *
lLCConnectionLessTable_duplicate(struct lLCConnectionLessTable_data *thedata)
{
	struct lLCConnectionLessTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionLessTable_data);

	DEBUGMSGTL(("dlMIB", "lLCConnectionLessTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCConnectionLessTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCConnectionLessTable_destroy(struct lLCConnectionLessTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnectionLessTable_destroy(struct lLCConnectionLessTable_data **thedata)
{
	struct lLCConnectionLessTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnectionLessTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnectionlessName);
		StorageDel->lLCConnectionlessNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionLessTable_add(struct lLCConnectionLessTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnectionLessTable table data set.
 *
 * Adds a table row structure to the lLCConnectionLessTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnectionLessTable_add(struct lLCConnectionLessTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCConnectionLessTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		header_complex_add_data(&lLCConnectionLessTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionLessTable_del(struct lLCConnectionLessTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCConnectionLessTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnectionLessTable_del(struct lLCConnectionLessTable_data *thedata)
{
	struct lLCConnectionLessTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnectionLessTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnectionLessTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnectionLessTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnectionLessTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnectionLessTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnectionLessTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnectionLessTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionLessTable_data *StorageTmp = lLCConnectionLessTable_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCConnectionLessTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->lLCConnectionlessName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessName, &StorageTmp->lLCConnectionlessNameLen);
	if (StorageTmp->lLCConnectionlessName == NULL) {
		config_perror("invalid specification for lLCConnectionlessName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessTESTSentResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessUIReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessUISent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessXIDSentResponse, &tmpsize);
	lLCConnectionLessTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCConnectionLessTable(): store configuraiton file for lLCConnectionLessTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionLessTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionLessTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCConnectionLessTable: storing data...  "));
	refresh_lLCConnectionLessTable(1);
	(void) tmpsize;
	for (hcindex = lLCConnectionLessTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionLessTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionLessTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessName, &StorageTmp->lLCConnectionlessNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessTESTSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessUIReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessUISent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessXIDSentResponse, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnection2Table_data *lLCConnection2Table_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnection2Table table.
 *
 * Creates a new lLCConnection2Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnection2Table_data *
lLCConnection2Table_create(void)
{
	struct lLCConnection2Table_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnection2Table_data);

	DEBUGMSGTL(("dlMIB", "lLCConnection2Table_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		if ((StorageNew->lLCConnection2Name = (uint8_t *) strdup("")) != NULL)
			StorageNew->lLCConnection2NameLen = strlen("");
		StorageNew->lLCConnection2MaximumRetransmissions = 0;
		StorageNew->lLCConnection2ReceivedWindowSize = 0;
		StorageNew->lLCConnection2SendWindowSize = 0;
		StorageNew->lLCConnection2AcknowledgeTimeoutValue = 0;
		StorageNew->lLCConnection2BusyStateTimeoutValue = 0;
		StorageNew->lLCConnection2PBitTimeoutValue = 0;
		StorageNew->lLCConnection2RejectTimeoutValue = 0;
		StorageNew->lLCConnection2LocalBusy = 0;
		StorageNew->lLCConnection2RemoteBusy = 0;
		StorageNew->lLCConnection2RemoteReset = 0;
		StorageNew->lLCConnection2LocalReset = 0;
		StorageNew->lLCConnection2ProviderReset = 0;
		if ((StorageNew->lLCConnection2Route = (uint8_t *) strdup("")) != NULL)
			StorageNew->lLCConnection2RouteLen = strlen("");
		StorageNew->lLCConnection2KStep = 0;
		StorageNew->lLCConnection2MaxSendWindowSize = 0;
		StorageNew->lLCConnection2ReceivedI = 0;
		StorageNew->lLCConnection2SentI = 0;
		StorageNew->lLCConnection2SentAcks = 0;
		StorageNew->lLCConnection2ReceivedAcks = 0;
		StorageNew->lLCConnection2ReceivedFRMR = 0;
		StorageNew->lLCConnection2SentFRMR = 0;
		StorageNew->lLCConnection2ReceivedRR = 0;
		StorageNew->lLCConnection2SentRR = 0;
		StorageNew->lLCConnection2ReceivedRNR = 0;
		StorageNew->lLCConnection2SentRNR = 0;
		StorageNew->lLCConnection2ReceivedREJ = 0;
		StorageNew->lLCConnection2SentREJ = 0;
		StorageNew->lLCConnection2ReceivedSABME = 0;
		StorageNew->lLCConnection2SentSABME = 0;
		StorageNew->lLCConnection2ReceivedUA = 0;
		StorageNew->lLCConnection2SentUA = 0;
		StorageNew->lLCConnection2ReceivedDISC = 0;
		StorageNew->lLCConnection2SentDISC = 0;
		StorageNew->lLCConnection2ReceivedDM = 0;
		StorageNew->lLCConnection2SentDM = 0;
		StorageNew->lLCConnection2PDUsDiscarded1 = 0;
		StorageNew->lLCConnection2PDUsDiscarded2 = 0;
		StorageNew->lLCConnection2PDURetransmissions = 0;
		StorageNew->lLCConnection2OptionalTolerationIPDUs = 0;
		StorageNew->lLCConnection2DuplicateIPDUsReceived = 0;
		StorageNew->lLCConnection2Violation = 0;
		StorageNew->lLCConnection2ProtocolState = 0;
		StorageNew->lLCConnection2AdministrativeState = 0;
		StorageNew->lLCConnection2OperationalState = 0;
		StorageNew->lLCConnection2UsageState = 0;
		if (memdup((u_char **) &StorageNew->lLCConnection2ProceduralStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->lLCConnection2ProceduralStatusLen = 1;
		if (memdup((u_char **) &StorageNew->lLCConnection2AlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->lLCConnection2AlarmStatusLen = 1;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCConnection2Table_data *lLCConnection2Table_duplicate(struct lLCConnection2Table_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCConnection2Table_data *
lLCConnection2Table_duplicate(struct lLCConnection2Table_data *thedata)
{
	struct lLCConnection2Table_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnection2Table_data);

	DEBUGMSGTL(("dlMIB", "lLCConnection2Table_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCConnection2Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCConnection2Table_destroy(struct lLCConnection2Table_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnection2Table_destroy(struct lLCConnection2Table_data **thedata)
{
	struct lLCConnection2Table_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnection2Table_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2Name);
		StorageDel->lLCConnection2NameLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2Route);
		StorageDel->lLCConnection2RouteLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2ProceduralStatus);
		StorageDel->lLCConnection2ProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2AlarmStatus);
		StorageDel->lLCConnection2AlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnection2Table_add(struct lLCConnection2Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnection2Table table data set.
 *
 * Adds a table row structure to the lLCConnection2Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnection2Table_add(struct lLCConnection2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCConnection2Table_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		header_complex_add_data(&lLCConnection2TableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnection2Table_del(struct lLCConnection2Table_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCConnection2Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnection2Table_del(struct lLCConnection2Table_data *thedata)
{
	struct lLCConnection2Table_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnection2Table_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnection2TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnection2TableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnection2Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnection2Table entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnection2Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnection2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnection2Table_data *StorageTmp = lLCConnection2Table_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCConnection2Table: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->lLCConnection2Name);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2Name, &StorageTmp->lLCConnection2NameLen);
	if (StorageTmp->lLCConnection2Name == NULL) {
		config_perror("invalid specification for lLCConnection2Name");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2MaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2ReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2SendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2AcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2BusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2PBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2RejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2LocalBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2RemoteBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2RemoteReset, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2LocalReset, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ProviderReset, &tmpsize);
	SNMP_FREE(StorageTmp->lLCConnection2Route);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2Route, &StorageTmp->lLCConnection2RouteLen);
	if (StorageTmp->lLCConnection2Route == NULL) {
		config_perror("invalid specification for lLCConnection2Route");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2KStep, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2MaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedI, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentI, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentAcks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedAcks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedFRMR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentFRMR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedRR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentRR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedRNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentRNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedREJ, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentREJ, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedSABME, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentSABME, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedUA, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentUA, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedDISC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentDISC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2ReceivedDM, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2SentDM, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDUsDiscarded1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDUsDiscarded2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2PDURetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2OptionalTolerationIPDUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2DuplicateIPDUsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnection2Violation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2ProtocolState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2AdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2OperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2UsageState, &tmpsize);
	SNMP_FREE(StorageTmp->lLCConnection2ProceduralStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2ProceduralStatus, &StorageTmp->lLCConnection2ProceduralStatusLen);
	if (StorageTmp->lLCConnection2ProceduralStatus == NULL) {
		config_perror("invalid specification for lLCConnection2ProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->lLCConnection2AlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2AlarmStatus, &StorageTmp->lLCConnection2AlarmStatusLen);
	if (StorageTmp->lLCConnection2AlarmStatus == NULL) {
		config_perror("invalid specification for lLCConnection2AlarmStatus");
		return;
	}
	lLCConnection2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCConnection2Table(): store configuraiton file for lLCConnection2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnection2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnection2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCConnection2Table: storing data...  "));
	refresh_lLCConnection2Table(1);
	(void) tmpsize;
	for (hcindex = lLCConnection2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnection2Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnection2Table ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2Name, &StorageTmp->lLCConnection2NameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2MaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2ReceivedWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2SendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2AcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2BusyStateTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2PBitTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2RejectTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2LocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2RemoteBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2RemoteReset, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2LocalReset, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ProviderReset, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2Route, &StorageTmp->lLCConnection2RouteLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2KStep, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2MaxSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedI, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentI, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentAcks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedAcks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedFRMR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentFRMR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedRR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentRR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedRNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentRNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedREJ, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentREJ, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedSABME, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentSABME, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedUA, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentUA, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedDISC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentDISC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2ReceivedDM, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2SentDM, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDUsDiscarded1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDUsDiscarded2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2PDURetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2OptionalTolerationIPDUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2DuplicateIPDUsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnection2Violation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2ProtocolState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2AdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2OperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2UsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2ProceduralStatus, &StorageTmp->lLCConnection2ProceduralStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2AlarmStatus, &StorageTmp->lLCConnection2AlarmStatusLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnection2IVMOTable_data *lLCConnection2IVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnection2IVMOTable table.
 *
 * Creates a new lLCConnection2IVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnection2IVMOTable_data *
lLCConnection2IVMOTable_create(void)
{
	struct lLCConnection2IVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnection2IVMOTable_data);

	DEBUGMSGTL(("dlMIB", "lLCConnection2IVMOTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		if ((StorageNew->connectionId = (uint8_t *) strdup("")) != NULL)
			StorageNew->connectionIdLen = strlen("");
		if ((StorageNew->lLCConnection2IVMOName = (uint8_t *) strdup("")) != NULL)
			StorageNew->lLCConnection2IVMONameLen = strlen("");
		StorageNew->lLCConnection2IVMOMaximumRetransmissions = 0;
		StorageNew->lLCConnection2IVMOReceivedWindowSize = 0;
		StorageNew->lLCConnection2IVMOSendWindowSize = 0;
		StorageNew->lLCConnection2IVMOAcknowledgeTimeoutValue = 0;
		StorageNew->lLCConnection2IVMOBusyStateTimeoutValue = 0;
		StorageNew->lLCConnection2IVMOBitTimeoutValue = 0;
		StorageNew->lLCConnection2IVMORejectTimeoutValue = 0;
		StorageNew->lLCConnection2IVMORoute = 0;
		StorageNew->lLCConnection2IVMOKStep = 0;
		StorageNew->lLCConnection2IVMOMaxSendWindowSize = 0;
		StorageNew->lLCConnection2IVMOOptionalTolerationIPDUs = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCConnection2IVMOTable_data *lLCConnection2IVMOTable_duplicate(struct lLCConnection2IVMOTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCConnection2IVMOTable_data *
lLCConnection2IVMOTable_duplicate(struct lLCConnection2IVMOTable_data *thedata)
{
	struct lLCConnection2IVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnection2IVMOTable_data);

	DEBUGMSGTL(("dlMIB", "lLCConnection2IVMOTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCConnection2IVMOTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCConnection2IVMOTable_destroy(struct lLCConnection2IVMOTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnection2IVMOTable_destroy(struct lLCConnection2IVMOTable_data **thedata)
{
	struct lLCConnection2IVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnection2IVMOTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnection2IVMOName);
		StorageDel->lLCConnection2IVMONameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnection2IVMOTable_add(struct lLCConnection2IVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnection2IVMOTable table data set.
 *
 * Adds a table row structure to the lLCConnection2IVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnection2IVMOTable_add(struct lLCConnection2IVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCConnection2IVMOTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* connectionId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
		header_complex_add_data(&lLCConnection2IVMOTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnection2IVMOTable_del(struct lLCConnection2IVMOTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCConnection2IVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnection2IVMOTable_del(struct lLCConnection2IVMOTable_data *thedata)
{
	struct lLCConnection2IVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnection2IVMOTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnection2IVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnection2IVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnection2IVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnection2IVMOTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnection2IVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnection2IVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnection2IVMOTable_data *StorageTmp = lLCConnection2IVMOTable_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCConnection2IVMOTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->connectionId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	SNMP_FREE(StorageTmp->lLCConnection2IVMOName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnection2IVMOName, &StorageTmp->lLCConnection2IVMONameLen);
	if (StorageTmp->lLCConnection2IVMOName == NULL) {
		config_perror("invalid specification for lLCConnection2IVMOName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOReceivedWindowSize, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOBitTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMORejectTimeoutValue, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMORoute, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOKStep, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->lLCConnection2IVMOMaxSendWindowSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs, &tmpsize);
	lLCConnection2IVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCConnection2IVMOTable(): store configuraiton file for lLCConnection2IVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnection2IVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnection2IVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCConnection2IVMOTable: storing data...  "));
	refresh_lLCConnection2IVMOTable(1);
	(void) tmpsize;
	for (hcindex = lLCConnection2IVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnection2IVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnection2IVMOTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnection2IVMOName, &StorageTmp->lLCConnection2IVMONameLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOReceivedWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOBitTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMORejectTimeoutValue, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMORoute, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOKStep, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->lLCConnection2IVMOMaxSendWindowSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnectionlessAckTable_data *lLCConnectionlessAckTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnectionlessAckTable table.
 *
 * Creates a new lLCConnectionlessAckTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnectionlessAckTable_data *
lLCConnectionlessAckTable_create(void)
{
	struct lLCConnectionlessAckTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionlessAckTable_data);

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		StorageNew->lLCConnectionlessAckMaximumLLCInformationFieldSize = 0;
		StorageNew->lLCConnectionlessAckMaximumRetransmissions = 0;
		StorageNew->lLCConnectionlessAckTESTReceivedABBResponse = 0;
		StorageNew->lLCConnectionlessAckTESTReceivedCommand = 0;
		StorageNew->lLCConnectionlessAckTESTReceivedResponse = 0;
		StorageNew->lLCConnectionlessAckTESTSentABBResponse = 0;
		StorageNew->lLCConnectionlessAckTESTSentCommand = 0;
		StorageNew->lLCConnectionlessAckTESTSentResponse = 0;
		StorageNew->lLCConnectionlessAckReceiveResources = 0;
		StorageNew->lLCConnectionlessAckUIReceived = 0;
		StorageNew->lLCConnectionlessAckUISent = 0;
		StorageNew->lLCConnectionlessAckXIDReceivedCommand = 0;
		StorageNew->lLCConnectionlessAckXIDReceivedResponse = 0;
		StorageNew->lLCConnectionlessAckXIDSentCommand = 0;
		StorageNew->lLCConnectionlessAckXIDSentResponse = 0;
		StorageNew->lLCConnectionlessAckRetransmissions = 0;
		StorageNew->lLCConnectionlessAckNoResponse = 0;
		StorageNew->lLCConnectionlessAckCommandIP = 0;
		StorageNew->lLCConnectionlessAckCommandIT = 0;
		StorageNew->lLCConnectionlessAckCommandOK = 0;
		StorageNew->lLCConnectionlessAckCommandPE = 0;
		StorageNew->lLCConnectionlessAckCommandRS = 0;
		StorageNew->lLCConnectionlessAckCommandUE = 0;
		StorageNew->lLCConnectionlessAckCommandUN = 0;
		StorageNew->lLCConnectionlessAckReceivedACCommand = 0;
		StorageNew->lLCConnectionlessAckSentACCommand = 0;
		StorageNew->lLCConnectionlessAckResponseIP = 0;
		StorageNew->lLCConnectionlessAckResponseIT = 0;
		StorageNew->lLCConnectionlessAckResponseNE = 0;
		StorageNew->lLCConnectionlessAckResponseNR = 0;
		StorageNew->lLCConnectionlessAckResponseOK = 0;
		StorageNew->lLCConnectionlessAckResponseRS = 0;
		StorageNew->lLCConnectionlessAckResponseUE = 0;
		StorageNew->lLCConnectionlessAckResponseUN = 0;
		StorageNew->lLCConnectionlessAckViolation = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCConnectionlessAckTable_data *lLCConnectionlessAckTable_duplicate(struct lLCConnectionlessAckTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCConnectionlessAckTable_data *
lLCConnectionlessAckTable_duplicate(struct lLCConnectionlessAckTable_data *thedata)
{
	struct lLCConnectionlessAckTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionlessAckTable_data);

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCConnectionlessAckTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCConnectionlessAckTable_destroy(struct lLCConnectionlessAckTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnectionlessAckTable_destroy(struct lLCConnectionlessAckTable_data **thedata)
{
	struct lLCConnectionlessAckTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnectionlessAckName);
		StorageDel->lLCConnectionlessAckNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionlessAckTable_add(struct lLCConnectionlessAckTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnectionlessAckTable table data set.
 *
 * Adds a table row structure to the lLCConnectionlessAckTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnectionlessAckTable_add(struct lLCConnectionlessAckTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* lLCConnectionlessAckName */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCConnectionlessAckName, thedata->lLCConnectionlessAckNameLen);
		header_complex_add_data(&lLCConnectionlessAckTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionlessAckTable_del(struct lLCConnectionlessAckTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCConnectionlessAckTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnectionlessAckTable_del(struct lLCConnectionlessAckTable_data *thedata)
{
	struct lLCConnectionlessAckTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnectionlessAckTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnectionlessAckTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnectionlessAckTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnectionlessAckTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnectionlessAckTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnectionlessAckTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionlessAckTable_data *StorageTmp = lLCConnectionlessAckTable_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCConnectionlessAckTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->lLCConnectionlessAckName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessAckName, &StorageTmp->lLCConnectionlessAckNameLen);
	if (StorageTmp->lLCConnectionlessAckName == NULL) {
		config_perror("invalid specification for lLCConnectionlessAckName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentABBResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckTESTSentResponse, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckReceiveResources, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckUIReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckUISent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDReceivedCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDReceivedResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDSentCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckXIDSentResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckNoResponse, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandIP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandIT, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandOK, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandPE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandRS, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandUE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckCommandUN, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckReceivedACCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckSentACCommand, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseIP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseIT, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseNE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseNR, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseOK, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseRS, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseUE, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckResponseUN, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lLCConnectionlessAckViolation, &tmpsize);
	lLCConnectionlessAckTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCConnectionlessAckTable(): store configuraiton file for lLCConnectionlessAckTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionlessAckTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionlessAckTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCConnectionlessAckTable: storing data...  "));
	refresh_lLCConnectionlessAckTable(1);
	(void) tmpsize;
	for (hcindex = lLCConnectionlessAckTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionlessAckTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionlessAckTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessAckName, &StorageTmp->lLCConnectionlessAckNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentABBResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckTESTSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckReceiveResources, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckUIReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckUISent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDReceivedCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDReceivedResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDSentCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckXIDSentResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckNoResponse, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandIP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandIT, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandOK, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandPE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandRS, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandUE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckCommandUN, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckReceivedACCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckSentACCommand, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseIP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseIT, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseNE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseNR, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseOK, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseRS, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseUE, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckResponseUN, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lLCConnectionlessAckViolation, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lLCConnectionlessAckIVMOTable_data *lLCConnectionlessAckIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the lLCConnectionlessAckIVMOTable table.
 *
 * Creates a new lLCConnectionlessAckIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lLCConnectionlessAckIVMOTable_data *
lLCConnectionlessAckIVMOTable_create(void)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionlessAckIVMOTable_data);

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckIVMOTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		StorageNew->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize = 0;
		StorageNew->lLCConnectionlessAckIVMOMaximumRetransmissions = 0;
		StorageNew->lLCConnectionlessAckIVMORowStatus = 0;
		StorageNew->lLCConnectionlessAckIVMORowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct lLCConnectionlessAckIVMOTable_data *lLCConnectionlessAckIVMOTable_duplicate(struct lLCConnectionlessAckIVMOTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lLCConnectionlessAckIVMOTable_data *
lLCConnectionlessAckIVMOTable_duplicate(struct lLCConnectionlessAckIVMOTable_data *thedata)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(lLCConnectionlessAckIVMOTable_data);

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckIVMOTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lLCConnectionlessAckIVMOTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lLCConnectionlessAckIVMOTable_destroy(struct lLCConnectionlessAckIVMOTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lLCConnectionlessAckIVMOTable_destroy(struct lLCConnectionlessAckIVMOTable_data **thedata)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckIVMOTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->lLCConnectionlessAckIVMOName);
		StorageDel->lLCConnectionlessAckIVMONameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionlessAckIVMOTable_add(struct lLCConnectionlessAckIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lLCConnectionlessAckIVMOTable table data set.
 *
 * Adds a table row structure to the lLCConnectionlessAckIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lLCConnectionlessAckIVMOTable_add(struct lLCConnectionlessAckIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckIVMOTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* lLCConnectionlessAckIVMOName */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lLCConnectionlessAckIVMOName, thedata->lLCConnectionlessAckIVMONameLen);
		header_complex_add_data(&lLCConnectionlessAckIVMOTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lLCConnectionlessAckIVMOTable_del(struct lLCConnectionlessAckIVMOTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lLCConnectionlessAckIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lLCConnectionlessAckIVMOTable_del(struct lLCConnectionlessAckIVMOTable_data *thedata)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "lLCConnectionlessAckIVMOTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lLCConnectionlessAckIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lLCConnectionlessAckIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lLCConnectionlessAckIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lLCConnectionlessAckIVMOTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case lLCConnectionlessAckIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lLCConnectionlessAckIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = lLCConnectionlessAckIVMOTable_create();

	DEBUGMSGTL(("dlMIB", "parse_lLCConnectionlessAckIVMOTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->lLCConnectionlessAckIVMOName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lLCConnectionlessAckIVMOName, &StorageTmp->lLCConnectionlessAckIVMONameLen);
	if (StorageTmp->lLCConnectionlessAckIVMOName == NULL) {
		config_perror("invalid specification for lLCConnectionlessAckIVMOName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lLCConnectionlessAckIVMORowStatus, &tmpsize);
	lLCConnectionlessAckIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_lLCConnectionlessAckIVMOTable(): store configuraiton file for lLCConnectionlessAckIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lLCConnectionlessAckIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_lLCConnectionlessAckIVMOTable: storing data...  "));
	refresh_lLCConnectionlessAckIVMOTable(1);
	(void) tmpsize;
	for (hcindex = lLCConnectionlessAckIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lLCConnectionlessAckIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lLCConnectionlessAckIVMOTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lLCConnectionlessAckIVMOName, &StorageTmp->lLCConnectionlessAckIVMONameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lLCConnectionlessAckIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct networkEntityTable_data *networkEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the networkEntityTable table.
 *
 * Creates a new networkEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct networkEntityTable_data *
networkEntityTable_create(void)
{
	struct networkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(networkEntityTable_data);

	DEBUGMSGTL(("dlMIB", "networkEntityTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->networkEntityTitles = (uint8_t *) strdup("")) != NULL)
			StorageNew->networkEntityTitlesLen = strlen("");
		if (memdup((u_char **) &StorageNew->networkEntitySystemTypes, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->networkEntitySystemTypesLen = 1;
		StorageNew->networkEntityRowStatus = 0;
		StorageNew->networkEntityRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct networkEntityTable_data *networkEntityTable_duplicate(struct networkEntityTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct networkEntityTable_data *
networkEntityTable_duplicate(struct networkEntityTable_data *thedata)
{
	struct networkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(networkEntityTable_data);

	DEBUGMSGTL(("dlMIB", "networkEntityTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	networkEntityTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int networkEntityTable_destroy(struct networkEntityTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
networkEntityTable_destroy(struct networkEntityTable_data **thedata)
{
	struct networkEntityTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "networkEntityTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->networkEntityTitles);
		StorageDel->networkEntityTitlesLen = 0;
		SNMP_FREE(StorageDel->networkEntitySystemTypes);
		StorageDel->networkEntitySystemTypesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int networkEntityTable_add(struct networkEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the networkEntityTable table data set.
 *
 * Adds a table row structure to the networkEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
networkEntityTable_add(struct networkEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "networkEntityTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		header_complex_add_data(&networkEntityTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int networkEntityTable_del(struct networkEntityTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the networkEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
networkEntityTable_del(struct networkEntityTable_data *thedata)
{
	struct networkEntityTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "networkEntityTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(networkEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&networkEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_networkEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for networkEntityTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case networkEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_networkEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct networkEntityTable_data *StorageTmp = networkEntityTable_create();

	DEBUGMSGTL(("dlMIB", "parse_networkEntityTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->networkEntityTitles);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkEntityTitles, &StorageTmp->networkEntityTitlesLen);
	if (StorageTmp->networkEntityTitles == NULL) {
		config_perror("invalid specification for networkEntityTitles");
		return;
	}
	SNMP_FREE(StorageTmp->networkEntitySystemTypes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkEntitySystemTypes, &StorageTmp->networkEntitySystemTypesLen);
	if (StorageTmp->networkEntitySystemTypes == NULL) {
		config_perror("invalid specification for networkEntitySystemTypes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->networkEntityRowStatus, &tmpsize);
	networkEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_networkEntityTable(): store configuraiton file for networkEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_networkEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct networkEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_networkEntityTable: storing data...  "));
	refresh_networkEntityTable(1);
	(void) tmpsize;
	for (hcindex = networkEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct networkEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "networkEntityTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkEntityTitles, &StorageTmp->networkEntityTitlesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkEntitySystemTypes, &StorageTmp->networkEntitySystemTypesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->networkEntityRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct nSAPTable_data *nSAPTable_create(void)
 * @brief create a fresh data structure representing a new row in the nSAPTable table.
 *
 * Creates a new nSAPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct nSAPTable_data *
nSAPTable_create(void)
{
	struct nSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(nSAPTable_data);

	DEBUGMSGTL(("dlMIB", "nSAPTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->sapId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sapIdLen = strlen("");
		StorageNew->nSAPRowStatus = 0;
		StorageNew->nSAPRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct nSAPTable_data *nSAPTable_duplicate(struct nSAPTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct nSAPTable_data *
nSAPTable_duplicate(struct nSAPTable_data *thedata)
{
	struct nSAPTable_data *StorageNew = SNMP_MALLOC_STRUCT(nSAPTable_data);

	DEBUGMSGTL(("dlMIB", "nSAPTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	nSAPTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int nSAPTable_destroy(struct nSAPTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
nSAPTable_destroy(struct nSAPTable_data **thedata)
{
	struct nSAPTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "nSAPTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sapId);
		StorageDel->sapIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int nSAPTable_add(struct nSAPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the nSAPTable table data set.
 *
 * Adds a table row structure to the nSAPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
nSAPTable_add(struct nSAPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "nSAPTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* sapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sapId, thedata->sapIdLen);
		header_complex_add_data(&nSAPTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int nSAPTable_del(struct nSAPTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the nSAPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
nSAPTable_del(struct nSAPTable_data *thedata)
{
	struct nSAPTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "nSAPTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(nSAPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&nSAPTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_nSAPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for nSAPTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case nSAPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_nSAPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct nSAPTable_data *StorageTmp = nSAPTable_create();

	DEBUGMSGTL(("dlMIB", "parse_nSAPTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->sapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sapId, &StorageTmp->sapIdLen);
	if (StorageTmp->sapId == NULL) {
		config_perror("invalid specification for sapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->nSAPRowStatus, &tmpsize);
	nSAPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_nSAPTable(): store configuraiton file for nSAPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_nSAPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct nSAPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_nSAPTable: storing data...  "));
	refresh_nSAPTable(1);
	(void) tmpsize;
	for (hcindex = nSAPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct nSAPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "nSAPTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sapId, &StorageTmp->sapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->nSAPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct cLNSTable_data *cLNSTable_create(void)
 * @brief create a fresh data structure representing a new row in the cLNSTable table.
 *
 * Creates a new cLNSTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct cLNSTable_data *
cLNSTable_create(void)
{
	struct cLNSTable_data *StorageNew = SNMP_MALLOC_STRUCT(cLNSTable_data);

	DEBUGMSGTL(("dlMIB", "cLNSTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->clProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->clProtocolMachineIdLen = strlen("");
		StorageNew->cLNSAdministrativeState = 0;
		if ((StorageNew->cLNSSupportedProtocols = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSSupportedProtocolsLen = strlen("");
		if (memdup((u_char **) &StorageNew->cLNSOperationalSystemType, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->cLNSOperationalSystemTypeLen = 1;
		StorageNew->cLNSOctetsSentCounter = 0;
		StorageNew->cLNSOctetsReceivedCounter = 0;
		StorageNew->cLNSSegmentsReceived = 0;
		StorageNew->cLNSSegmentsDiscarded = 0;
		StorageNew->cLNSAssemblingSegmentsDiscarded = 0;
		StorageNew->cLNSErrorReportsReceived = 0;
		StorageNew->cLNSpDUDiscards = 0;
		StorageNew->cLNSCongestionDiscards = 0;
		StorageNew->cLNSMaximumLifetime = 0;
		StorageNew->cLNSEnableChecksum = TV_FALSE;
		StorageNew->cLNSRowStatus = 0;
		StorageNew->cLNSRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct cLNSTable_data *cLNSTable_duplicate(struct cLNSTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct cLNSTable_data *
cLNSTable_duplicate(struct cLNSTable_data *thedata)
{
	struct cLNSTable_data *StorageNew = SNMP_MALLOC_STRUCT(cLNSTable_data);

	DEBUGMSGTL(("dlMIB", "cLNSTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	cLNSTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int cLNSTable_destroy(struct cLNSTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
cLNSTable_destroy(struct cLNSTable_data **thedata)
{
	struct cLNSTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "cLNSTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cLNSSupportedProtocols);
		StorageDel->cLNSSupportedProtocolsLen = 0;
		SNMP_FREE(StorageDel->cLNSOperationalSystemType);
		StorageDel->cLNSOperationalSystemTypeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSTable_add(struct cLNSTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the cLNSTable table data set.
 *
 * Adds a table row structure to the cLNSTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
cLNSTable_add(struct cLNSTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "cLNSTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		header_complex_add_data(&cLNSTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSTable_del(struct cLNSTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the cLNSTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
cLNSTable_del(struct cLNSTable_data *thedata)
{
	struct cLNSTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "cLNSTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(cLNSTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&cLNSTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_cLNSTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for cLNSTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case cLNSTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_cLNSTable(const char *token, char *line)
{
	size_t tmpsize;
	struct cLNSTable_data *StorageTmp = cLNSTable_create();

	DEBUGMSGTL(("dlMIB", "parse_cLNSTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->cLNSSupportedProtocols);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSSupportedProtocols, &StorageTmp->cLNSSupportedProtocolsLen);
	if (StorageTmp->cLNSSupportedProtocols == NULL) {
		config_perror("invalid specification for cLNSSupportedProtocols");
		return;
	}
	SNMP_FREE(StorageTmp->cLNSOperationalSystemType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSOperationalSystemType, &StorageTmp->cLNSOperationalSystemTypeLen);
	if (StorageTmp->cLNSOperationalSystemType == NULL) {
		config_perror("invalid specification for cLNSOperationalSystemType");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSOctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSOctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSSegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSSegmentsDiscarded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSAssemblingSegmentsDiscarded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSErrorReportsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSpDUDiscards, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSCongestionDiscards, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSMaximumLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSEnableChecksum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSRowStatus, &tmpsize);
	cLNSTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_cLNSTable(): store configuraiton file for cLNSTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_cLNSTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cLNSTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_cLNSTable: storing data...  "));
	refresh_cLNSTable(1);
	(void) tmpsize;
	for (hcindex = cLNSTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cLNSTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cLNSTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSSupportedProtocols, &StorageTmp->cLNSSupportedProtocolsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSOperationalSystemType, &StorageTmp->cLNSOperationalSystemTypeLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSOctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSOctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSSegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSSegmentsDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSAssemblingSegmentsDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSErrorReportsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSpDUDiscards, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSCongestionDiscards, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSMaximumLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSEnableChecksum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct cLNSISISTable_data *cLNSISISTable_create(void)
 * @brief create a fresh data structure representing a new row in the cLNSISISTable table.
 *
 * Creates a new cLNSISISTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct cLNSISISTable_data *
cLNSISISTable_create(void)
{
	struct cLNSISISTable_data *StorageNew = SNMP_MALLOC_STRUCT(cLNSISISTable_data);

	DEBUGMSGTL(("dlMIB", "cLNSISISTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->clProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->clProtocolMachineIdLen = strlen("");
		if ((StorageNew->cLNSISISversion = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISversionLen = strlen("");
		StorageNew->cLNSISISiSType = 0;
		if ((StorageNew->cLNSISISsystemId = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISsystemIdLen = strlen("");
		StorageNew->cLNSISISmaximumPathSplits = 0;
		StorageNew->cLNSISISminimumLSPTransmissionInterval = 0;
		StorageNew->cLNSISISmaximumLSPGenerationInterval = 0;
		StorageNew->cLNSISISminimumBroadcastLSPTransmissionInterval = 0;
		StorageNew->cLNSISIScompleteSNPInterval = 0;
		StorageNew->cLNSISISoriginatingL1LSPBufferSize = 0;
		if ((StorageNew->cLNSISISmanualAreaAddresses = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISmanualAreaAddressesLen = strlen("");
		StorageNew->cLNSISISmaximumAreaAddresses = 0;
		StorageNew->cLNSISISminimumLSPGenerationInterval = 0;
		StorageNew->cLNSISISpollESHelloRate = 0;
		StorageNew->cLNSISISpartialSNPInterval = 0;
		StorageNew->cLNSISISwaitingTime = 0;
		StorageNew->cLNSISISdRISISHelloTimer = 0;
		StorageNew->cLNSISISl1State = 0;
		if ((StorageNew->cLNSISISareaAddresses = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISareaAddressesLen = strlen("");
		StorageNew->cLNSISIScorruptedLSPsDetected = 0;
		StorageNew->cLNSISISlSPL1DatabaseOverloads = 0;
		StorageNew->cLNSISISmanualAddressesDroppedFromAreas = 0;
		StorageNew->cLNSISISattemptsToExceedMaximumSequenceNumber = 0;
		StorageNew->cLNSISISsequenceNumberSkips = 0;
		StorageNew->cLNSISISownLSPPurges = 0;
		StorageNew->cLNSISISiDFieldLengthMismatches = 0;
		StorageNew->cLNSISISmaximumAreaAddressesMismatches = 0;
		StorageNew->cLNSISISoriginatingLSPBufferSizeMismatches = 0;
		StorageNew->cLNSISISlSPTooLargeToPropagate = 0;
		if ((StorageNew->cLNSISISareaTransmitPassword = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISareaTransmitPasswordLen = strlen("");
		if ((StorageNew->cLNSISISareaReceivePasswords = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISareaReceivePasswordsLen = strlen("");
		StorageNew->cLNSISISauthenticationFailures = 0;
		StorageNew->cLNSISISRowStatus = 0;
		StorageNew->cLNSISISRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct cLNSISISTable_data *cLNSISISTable_duplicate(struct cLNSISISTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct cLNSISISTable_data *
cLNSISISTable_duplicate(struct cLNSISISTable_data *thedata)
{
	struct cLNSISISTable_data *StorageNew = SNMP_MALLOC_STRUCT(cLNSISISTable_data);

	DEBUGMSGTL(("dlMIB", "cLNSISISTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	cLNSISISTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int cLNSISISTable_destroy(struct cLNSISISTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
cLNSISISTable_destroy(struct cLNSISISTable_data **thedata)
{
	struct cLNSISISTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "cLNSISISTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cLNSISISversion);
		StorageDel->cLNSISISversionLen = 0;
		SNMP_FREE(StorageDel->cLNSISISsystemId);
		StorageDel->cLNSISISsystemIdLen = 0;
		SNMP_FREE(StorageDel->cLNSISISmanualAreaAddresses);
		StorageDel->cLNSISISmanualAreaAddressesLen = 0;
		SNMP_FREE(StorageDel->cLNSISISareaAddresses);
		StorageDel->cLNSISISareaAddressesLen = 0;
		SNMP_FREE(StorageDel->cLNSISISareaTransmitPassword);
		StorageDel->cLNSISISareaTransmitPasswordLen = 0;
		SNMP_FREE(StorageDel->cLNSISISareaReceivePasswords);
		StorageDel->cLNSISISareaReceivePasswordsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSISISTable_add(struct cLNSISISTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the cLNSISISTable table data set.
 *
 * Adds a table row structure to the cLNSISISTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
cLNSISISTable_add(struct cLNSISISTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "cLNSISISTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		header_complex_add_data(&cLNSISISTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSISISTable_del(struct cLNSISISTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the cLNSISISTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
cLNSISISTable_del(struct cLNSISISTable_data *thedata)
{
	struct cLNSISISTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "cLNSISISTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(cLNSISISTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&cLNSISISTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_cLNSISISTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for cLNSISISTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case cLNSISISTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_cLNSISISTable(const char *token, char *line)
{
	size_t tmpsize;
	struct cLNSISISTable_data *StorageTmp = cLNSISISTable_create();

	DEBUGMSGTL(("dlMIB", "parse_cLNSISISTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->cLNSISISversion);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISversion, &StorageTmp->cLNSISISversionLen);
	if (StorageTmp->cLNSISISversion == NULL) {
		config_perror("invalid specification for cLNSISISversion");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISiSType, &tmpsize);
	SNMP_FREE(StorageTmp->cLNSISISsystemId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISsystemId, &StorageTmp->cLNSISISsystemIdLen);
	if (StorageTmp->cLNSISISsystemId == NULL) {
		config_perror("invalid specification for cLNSISISsystemId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISmaximumPathSplits, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISminimumLSPTransmissionInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISmaximumLSPGenerationInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISIScompleteSNPInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISoriginatingL1LSPBufferSize, &tmpsize);
	SNMP_FREE(StorageTmp->cLNSISISmanualAreaAddresses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISmanualAreaAddresses, &StorageTmp->cLNSISISmanualAreaAddressesLen);
	if (StorageTmp->cLNSISISmanualAreaAddresses == NULL) {
		config_perror("invalid specification for cLNSISISmanualAreaAddresses");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISmaximumAreaAddresses, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISminimumLSPGenerationInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISpollESHelloRate, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISpartialSNPInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISwaitingTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISdRISISHelloTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISl1State, &tmpsize);
	SNMP_FREE(StorageTmp->cLNSISISareaAddresses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISareaAddresses, &StorageTmp->cLNSISISareaAddressesLen);
	if (StorageTmp->cLNSISISareaAddresses == NULL) {
		config_perror("invalid specification for cLNSISISareaAddresses");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISIScorruptedLSPsDetected, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISlSPL1DatabaseOverloads, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISmanualAddressesDroppedFromAreas, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISsequenceNumberSkips, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISownLSPPurges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISiDFieldLengthMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISmaximumAreaAddressesMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISlSPTooLargeToPropagate, &tmpsize);
	SNMP_FREE(StorageTmp->cLNSISISareaTransmitPassword);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISareaTransmitPassword, &StorageTmp->cLNSISISareaTransmitPasswordLen);
	if (StorageTmp->cLNSISISareaTransmitPassword == NULL) {
		config_perror("invalid specification for cLNSISISareaTransmitPassword");
		return;
	}
	SNMP_FREE(StorageTmp->cLNSISISareaReceivePasswords);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISareaReceivePasswords, &StorageTmp->cLNSISISareaReceivePasswordsLen);
	if (StorageTmp->cLNSISISareaReceivePasswords == NULL) {
		config_perror("invalid specification for cLNSISISareaReceivePasswords");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISauthenticationFailures, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISRowStatus, &tmpsize);
	cLNSISISTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_cLNSISISTable(): store configuraiton file for cLNSISISTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_cLNSISISTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cLNSISISTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_cLNSISISTable: storing data...  "));
	refresh_cLNSISISTable(1);
	(void) tmpsize;
	for (hcindex = cLNSISISTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cLNSISISTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cLNSISISTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISversion, &StorageTmp->cLNSISISversionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISiSType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISsystemId, &StorageTmp->cLNSISISsystemIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISmaximumPathSplits, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISminimumLSPTransmissionInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISmaximumLSPGenerationInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISIScompleteSNPInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISoriginatingL1LSPBufferSize, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISmanualAreaAddresses, &StorageTmp->cLNSISISmanualAreaAddressesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISmaximumAreaAddresses, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISminimumLSPGenerationInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISpollESHelloRate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISpartialSNPInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISwaitingTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISdRISISHelloTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISl1State, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISareaAddresses, &StorageTmp->cLNSISISareaAddressesLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISIScorruptedLSPsDetected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISlSPL1DatabaseOverloads, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISmanualAddressesDroppedFromAreas, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISsequenceNumberSkips, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISownLSPPurges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISiDFieldLengthMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISmaximumAreaAddressesMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISlSPTooLargeToPropagate, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISareaTransmitPassword, &StorageTmp->cLNSISISareaTransmitPasswordLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISareaReceivePasswords, &StorageTmp->cLNSISISareaReceivePasswordsLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISauthenticationFailures, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct cLNSISISLevel2Table_data *cLNSISISLevel2Table_create(void)
 * @brief create a fresh data structure representing a new row in the cLNSISISLevel2Table table.
 *
 * Creates a new cLNSISISLevel2Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct cLNSISISLevel2Table_data *
cLNSISISLevel2Table_create(void)
{
	struct cLNSISISLevel2Table_data *StorageNew = SNMP_MALLOC_STRUCT(cLNSISISLevel2Table_data);

	DEBUGMSGTL(("dlMIB", "cLNSISISLevel2Table_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		StorageNew->cLNSISISLevel2maximumVirtualAdjacencies = 0;
		if ((StorageNew->cLNSISISLevel2partitionAreaAddresses = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISLevel2partitionAreaAddressesLen = strlen("");
		if ((StorageNew->cLNSISISLevel2partitionDesignatedL2IntermediateSystem = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen = strlen("");
		StorageNew->cLNSISISLevel2partitionVirtualLinkChanges = 0;
		StorageNew->cLNSISISLevel2originatingL2LSPBufferSize = 0;
		StorageNew->cLNSISISLevel2l2State = 0;
		StorageNew->cLNSISISLevel2lSPL2DatabaseOverloads = 0;
		if ((StorageNew->cLNSISISLevel2domainTransmitPassword = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISLevel2domainTransmitPasswordLen = strlen("");
		if ((StorageNew->cLNSISISLevel2domainReceivePasswords = (uint8_t *) strdup("")) != NULL)
			StorageNew->cLNSISISLevel2domainReceivePasswordsLen = strlen("");
		StorageNew->cLNSISISLevel2RowStatus = 0;
		StorageNew->cLNSISISLevel2RowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct cLNSISISLevel2Table_data *cLNSISISLevel2Table_duplicate(struct cLNSISISLevel2Table_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct cLNSISISLevel2Table_data *
cLNSISISLevel2Table_duplicate(struct cLNSISISLevel2Table_data *thedata)
{
	struct cLNSISISLevel2Table_data *StorageNew = SNMP_MALLOC_STRUCT(cLNSISISLevel2Table_data);

	DEBUGMSGTL(("dlMIB", "cLNSISISLevel2Table_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	cLNSISISLevel2Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int cLNSISISLevel2Table_destroy(struct cLNSISISLevel2Table_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
cLNSISISLevel2Table_destroy(struct cLNSISISLevel2Table_data **thedata)
{
	struct cLNSISISLevel2Table_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "cLNSISISLevel2Table_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2partitionAreaAddresses);
		StorageDel->cLNSISISLevel2partitionAreaAddressesLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2partitionDesignatedL2IntermediateSystem);
		StorageDel->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2domainTransmitPassword);
		StorageDel->cLNSISISLevel2domainTransmitPasswordLen = 0;
		SNMP_FREE(StorageDel->cLNSISISLevel2domainReceivePasswords);
		StorageDel->cLNSISISLevel2domainReceivePasswordsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSISISLevel2Table_add(struct cLNSISISLevel2Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the cLNSISISLevel2Table table data set.
 *
 * Adds a table row structure to the cLNSISISLevel2Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
cLNSISISLevel2Table_add(struct cLNSISISLevel2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "cLNSISISLevel2Table_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		header_complex_add_data(&cLNSISISLevel2TableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cLNSISISLevel2Table_del(struct cLNSISISLevel2Table_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the cLNSISISLevel2Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
cLNSISISLevel2Table_del(struct cLNSISISLevel2Table_data *thedata)
{
	struct cLNSISISLevel2Table_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "cLNSISISLevel2Table_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(cLNSISISLevel2TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&cLNSISISLevel2TableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_cLNSISISLevel2Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for cLNSISISLevel2Table entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case cLNSISISLevel2Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_cLNSISISLevel2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct cLNSISISLevel2Table_data *StorageTmp = cLNSISISLevel2Table_create();

	DEBUGMSGTL(("dlMIB", "parse_cLNSISISLevel2Table: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies, &tmpsize);
	SNMP_FREE(StorageTmp->cLNSISISLevel2partitionAreaAddresses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2partitionAreaAddresses, &StorageTmp->cLNSISISLevel2partitionAreaAddressesLen);
	if (StorageTmp->cLNSISISLevel2partitionAreaAddresses == NULL) {
		config_perror("invalid specification for cLNSISISLevel2partitionAreaAddresses");
		return;
	}
	SNMP_FREE(StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem, &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen);
	if (StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem == NULL) {
		config_perror("invalid specification for cLNSISISLevel2partitionDesignatedL2IntermediateSystem");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2l2State, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads, &tmpsize);
	SNMP_FREE(StorageTmp->cLNSISISLevel2domainTransmitPassword);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2domainTransmitPassword, &StorageTmp->cLNSISISLevel2domainTransmitPasswordLen);
	if (StorageTmp->cLNSISISLevel2domainTransmitPassword == NULL) {
		config_perror("invalid specification for cLNSISISLevel2domainTransmitPassword");
		return;
	}
	SNMP_FREE(StorageTmp->cLNSISISLevel2domainReceivePasswords);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cLNSISISLevel2domainReceivePasswords, &StorageTmp->cLNSISISLevel2domainReceivePasswordsLen);
	if (StorageTmp->cLNSISISLevel2domainReceivePasswords == NULL) {
		config_perror("invalid specification for cLNSISISLevel2domainReceivePasswords");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cLNSISISLevel2RowStatus, &tmpsize);
	cLNSISISLevel2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_cLNSISISLevel2Table(): store configuraiton file for cLNSISISLevel2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_cLNSISISLevel2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cLNSISISLevel2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_cLNSISISLevel2Table: storing data...  "));
	refresh_cLNSISISLevel2Table(1);
	(void) tmpsize;
	for (hcindex = cLNSISISLevel2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cLNSISISLevel2Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cLNSISISLevel2Table ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2partitionAreaAddresses, &StorageTmp->cLNSISISLevel2partitionAreaAddressesLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem,
						   &StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2l2State, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2domainTransmitPassword, &StorageTmp->cLNSISISLevel2domainTransmitPasswordLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cLNSISISLevel2domainReceivePasswords, &StorageTmp->cLNSISISLevel2domainReceivePasswordsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cLNSISISLevel2RowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct linkageTable_data *linkageTable_create(void)
 * @brief create a fresh data structure representing a new row in the linkageTable table.
 *
 * Creates a new linkageTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct linkageTable_data *
linkageTable_create(void)
{
	struct linkageTable_data *StorageNew = SNMP_MALLOC_STRUCT(linkageTable_data);

	DEBUGMSGTL(("dlMIB", "linkageTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		StorageNew->linkageOperationalState = 0;
		StorageNew->linkageAdministrativeState = 0;
		if ((StorageNew->linkageSnServiceProvider = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageSnServiceProviderLen = strlen("");
		if ((StorageNew->linkageSnSAP = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->linkageSnSAPLen = 2;
		if ((StorageNew->linkageOperationalProtocols = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageOperationalProtocolsLen = strlen("");
		if ((StorageNew->linkageISiSO9542OperationalSubsets = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISiSO9542OperationalSubsetsLen = strlen("");
		if ((StorageNew->linkageISHoldingTimerMultiplier = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISHoldingTimerMultiplierLen = strlen("");
		if ((StorageNew->linkageISISConfigurationTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISConfigurationTimerLen = strlen("");
		if ((StorageNew->linkageISSuggestedEsConfigurationTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISSuggestedEsConfigurationTimerLen = strlen("");
		if ((StorageNew->linkageISRedirectHoldingTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISRedirectHoldingTimeLen = strlen("");
		StorageNew->linkageISESReachabilityChanges = 0;
		StorageNew->linkageISInvalid9542PDUs = 0;
		if ((StorageNew->linkageESiSO9542OperationalSubsets = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageESiSO9542OperationalSubsetsLen = strlen("");
		if ((StorageNew->linkageESHoldingTimerMultiplier = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageESHoldingTimerMultiplierLen = strlen("");
		if ((StorageNew->linkageESManualISSNPAAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageESManualISSNPAAddressLen = strlen("");
		if ((StorageNew->linkageESDefaultESConfigTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageESDefaultESConfigTimerLen = strlen("");
		if ((StorageNew->linkageESActiveESConfigTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageESActiveESConfigTimerLen = strlen("");
		StorageNew->linkageESISReachabilityChanges = 0;
		StorageNew->linkageESInvalid9542PDUs = 0;
		StorageNew->linkageEnableChecksum = 0;
		if ((StorageNew->linkageInitialMinimumTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageInitialMinimumTimerLen = strlen("");
		if ((StorageNew->linkageReserveTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageReserveTimerLen = strlen("");
		if ((StorageNew->linkageIdleTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageIdleTimerLen = strlen("");
		StorageNew->linkageSNDCFCallsPlaced = 0;
		StorageNew->linkageSNDCFCallsFailed = 0;
		StorageNew->linkageCODLCallsPlaced = 0;
		StorageNew->linkageCODLCallsFailed = 0;
		if ((StorageNew->linkageISISType = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISTypeLen = strlen("");
		if ((StorageNew->linkageISISiSISHelloTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISiSISHelloTimerLen = strlen("");
		if ((StorageNew->linkageISISl1DefaultMetric = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl1DefaultMetricLen = strlen("");
		if ((StorageNew->linkageISISl1DelayMetric = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl1DelayMetricLen = strlen("");
		if ((StorageNew->linkageISISl1ExpenseMetric = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl1ExpenseMetricLen = strlen("");
		if ((StorageNew->linkageISISl1ErrorMetric = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl1ErrorMetricLen = strlen("");
		if ((StorageNew->linkageISISexternalDomain = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISexternalDomainLen = strlen("");
		StorageNew->linkageISISchangedInAdjacencyState = 0;
		StorageNew->linkageISISinitialisationFailures = 0;
		StorageNew->linkageISISrejectedAdjacencies = 0;
		StorageNew->linkageISISiSISControlPDUsSent = 0;
		StorageNew->linkageISISiSISControlPDUsReceived = 0;
		StorageNew->linkageISISiDFieldLenthMismatches = 0;
		StorageNew->linkageISISmaximumAreaAddressesMismatches = 0;
		if ((StorageNew->linkageISIScircuitTransmitPassword = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISIScircuitTransmitPasswordLen = strlen("");
		if ((StorageNew->linkageISIScircuitReceivedPasswords = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISIScircuitReceivedPasswordsLen = strlen("");
		StorageNew->linkageISISauthenticationFailures = 0;
		if ((StorageNew->linkageISISl1IntermediateSystemPriority = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl1IntermediateSystemPriorityLen = strlen("");
		if ((StorageNew->linkageISISl1CircuitID = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl1CircuitIDLen = strlen("");
		if ((StorageNew->linkageISISl1DesignatedIntermediateSystem = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl1DesignatedIntermediateSystemLen = strlen("");
		StorageNew->linkageISISlanL1DesignatedIntermediateSystemChanges = 0;
		if ((StorageNew->linkageISIScallEstablishmentDefaultMetricIncrement = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISIScallEstablishmentDefaultMetricIncrementLen = strlen("");
		if ((StorageNew->linkageISIScallEstablishmentDelayMetricIncrement = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISIScallEstablishmentDelayMetricIncrementLen = strlen("");
		if ((StorageNew->linkageISIScallEstablishmentExpenseMetricIncrement = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISIScallEstablishmentExpenseMetricIncrementLen = strlen("");
		if ((StorageNew->linkageISIScallEstablishmentErrorMetricIncrement = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISIScallEstablishmentErrorMetricIncrementLen = strlen("");
		if ((StorageNew->linkageISISptPtCircuitID = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISptPtCircuitIDLen = strlen("");
		if ((StorageNew->linkageISISoutgoingCallIVMO = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISoutgoingCallIVMOLen = strlen("");
		if ((StorageNew->linkageISISneighborSNPAAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISneighborSNPAAddressLen = strlen("");
		if ((StorageNew->linkageISISl2DefaultMetric = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl2DefaultMetricLen = strlen("");
		if ((StorageNew->linkageISISl2DelayMetric = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl2DelayMetricLen = strlen("");
		if ((StorageNew->linkageISISl2ExpenseMetric = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl2ExpenseMetricLen = strlen("");
		if ((StorageNew->linkageISISl2ErrorMetric = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl2ErrorMetricLen = strlen("");
		StorageNew->linkageISISmanualL2OnlyMode = 0;
		if ((StorageNew->linkageISISl2IntermediateSystemPriority = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl2IntermediateSystemPriorityLen = strlen("");
		if ((StorageNew->linkageISISl2CircuitID = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl2CircuitIDLen = strlen("");
		if ((StorageNew->linkageISISl2DesignatedIntermediateSystem = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageISISl2DesignatedIntermediateSystemLen = strlen("");
		StorageNew->linkageISISlanL2DesignatedIntermediteSystemChanges = 0;
		StorageNew->linkageRowStatus = 0;
		StorageNew->linkageRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct linkageTable_data *linkageTable_duplicate(struct linkageTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct linkageTable_data *
linkageTable_duplicate(struct linkageTable_data *thedata)
{
	struct linkageTable_data *StorageNew = SNMP_MALLOC_STRUCT(linkageTable_data);

	DEBUGMSGTL(("dlMIB", "linkageTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	linkageTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int linkageTable_destroy(struct linkageTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
linkageTable_destroy(struct linkageTable_data **thedata)
{
	struct linkageTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "linkageTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->protocolMachineId);
		StorageDel->protocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->linkageId);
		StorageDel->linkageIdLen = 0;
		SNMP_FREE(StorageDel->linkageSnServiceProvider);
		StorageDel->linkageSnServiceProviderLen = 0;
		SNMP_FREE(StorageDel->linkageSnSAP);
		StorageDel->linkageSnSAPLen = 0;
		SNMP_FREE(StorageDel->linkageOperationalProtocols);
		StorageDel->linkageOperationalProtocolsLen = 0;
		SNMP_FREE(StorageDel->linkageISiSO9542OperationalSubsets);
		StorageDel->linkageISiSO9542OperationalSubsetsLen = 0;
		SNMP_FREE(StorageDel->linkageISHoldingTimerMultiplier);
		StorageDel->linkageISHoldingTimerMultiplierLen = 0;
		SNMP_FREE(StorageDel->linkageISISConfigurationTimer);
		StorageDel->linkageISISConfigurationTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISSuggestedEsConfigurationTimer);
		StorageDel->linkageISSuggestedEsConfigurationTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISRedirectHoldingTime);
		StorageDel->linkageISRedirectHoldingTimeLen = 0;
		SNMP_FREE(StorageDel->linkageESiSO9542OperationalSubsets);
		StorageDel->linkageESiSO9542OperationalSubsetsLen = 0;
		SNMP_FREE(StorageDel->linkageESHoldingTimerMultiplier);
		StorageDel->linkageESHoldingTimerMultiplierLen = 0;
		SNMP_FREE(StorageDel->linkageESManualISSNPAAddress);
		StorageDel->linkageESManualISSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->linkageESDefaultESConfigTimer);
		StorageDel->linkageESDefaultESConfigTimerLen = 0;
		SNMP_FREE(StorageDel->linkageESActiveESConfigTimer);
		StorageDel->linkageESActiveESConfigTimerLen = 0;
		SNMP_FREE(StorageDel->linkageInitialMinimumTimer);
		StorageDel->linkageInitialMinimumTimerLen = 0;
		SNMP_FREE(StorageDel->linkageReserveTimer);
		StorageDel->linkageReserveTimerLen = 0;
		SNMP_FREE(StorageDel->linkageIdleTimer);
		StorageDel->linkageIdleTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISISType);
		StorageDel->linkageISISTypeLen = 0;
		SNMP_FREE(StorageDel->linkageISISiSISHelloTimer);
		StorageDel->linkageISISiSISHelloTimerLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1DefaultMetric);
		StorageDel->linkageISISl1DefaultMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1DelayMetric);
		StorageDel->linkageISISl1DelayMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1ExpenseMetric);
		StorageDel->linkageISISl1ExpenseMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1ErrorMetric);
		StorageDel->linkageISISl1ErrorMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISexternalDomain);
		StorageDel->linkageISISexternalDomainLen = 0;
		SNMP_FREE(StorageDel->linkageISIScircuitTransmitPassword);
		StorageDel->linkageISIScircuitTransmitPasswordLen = 0;
		SNMP_FREE(StorageDel->linkageISIScircuitReceivedPasswords);
		StorageDel->linkageISIScircuitReceivedPasswordsLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1IntermediateSystemPriority);
		StorageDel->linkageISISl1IntermediateSystemPriorityLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1CircuitID);
		StorageDel->linkageISISl1CircuitIDLen = 0;
		SNMP_FREE(StorageDel->linkageISISl1DesignatedIntermediateSystem);
		StorageDel->linkageISISl1DesignatedIntermediateSystemLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentDefaultMetricIncrement);
		StorageDel->linkageISIScallEstablishmentDefaultMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentDelayMetricIncrement);
		StorageDel->linkageISIScallEstablishmentDelayMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentExpenseMetricIncrement);
		StorageDel->linkageISIScallEstablishmentExpenseMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISIScallEstablishmentErrorMetricIncrement);
		StorageDel->linkageISIScallEstablishmentErrorMetricIncrementLen = 0;
		SNMP_FREE(StorageDel->linkageISISptPtCircuitID);
		StorageDel->linkageISISptPtCircuitIDLen = 0;
		SNMP_FREE(StorageDel->linkageISISoutgoingCallIVMO);
		StorageDel->linkageISISoutgoingCallIVMOLen = 0;
		SNMP_FREE(StorageDel->linkageISISneighborSNPAAddress);
		StorageDel->linkageISISneighborSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2DefaultMetric);
		StorageDel->linkageISISl2DefaultMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2DelayMetric);
		StorageDel->linkageISISl2DelayMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2ExpenseMetric);
		StorageDel->linkageISISl2ExpenseMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2ErrorMetric);
		StorageDel->linkageISISl2ErrorMetricLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2IntermediateSystemPriority);
		StorageDel->linkageISISl2IntermediateSystemPriorityLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2CircuitID);
		StorageDel->linkageISISl2CircuitIDLen = 0;
		SNMP_FREE(StorageDel->linkageISISl2DesignatedIntermediateSystem);
		StorageDel->linkageISISl2DesignatedIntermediateSystemLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int linkageTable_add(struct linkageTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the linkageTable table data set.
 *
 * Adds a table row structure to the linkageTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
linkageTable_add(struct linkageTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "linkageTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* protocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->protocolMachineId, thedata->protocolMachineIdLen);
		/* linkageId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->linkageId, thedata->linkageIdLen);
		header_complex_add_data(&linkageTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int linkageTable_del(struct linkageTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the linkageTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
linkageTable_del(struct linkageTable_data *thedata)
{
	struct linkageTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "linkageTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(linkageTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&linkageTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_linkageTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for linkageTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case linkageTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_linkageTable(const char *token, char *line)
{
	size_t tmpsize;
	struct linkageTable_data *StorageTmp = linkageTable_create();

	DEBUGMSGTL(("dlMIB", "parse_linkageTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->protocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->protocolMachineId, &StorageTmp->protocolMachineIdLen);
	if (StorageTmp->protocolMachineId == NULL) {
		config_perror("invalid specification for protocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->linkageId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageId, &StorageTmp->linkageIdLen);
	if (StorageTmp->linkageId == NULL) {
		config_perror("invalid specification for linkageId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->linkageSnServiceProvider);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageSnServiceProvider, &StorageTmp->linkageSnServiceProviderLen);
	if (StorageTmp->linkageSnServiceProvider == NULL) {
		config_perror("invalid specification for linkageSnServiceProvider");
		return;
	}
	SNMP_FREE(StorageTmp->linkageSnSAP);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->linkageSnSAP, &StorageTmp->linkageSnSAPLen);
	if (StorageTmp->linkageSnSAP == NULL) {
		config_perror("invalid specification for linkageSnSAP");
		return;
	}
	SNMP_FREE(StorageTmp->linkageOperationalProtocols);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageOperationalProtocols, &StorageTmp->linkageOperationalProtocolsLen);
	if (StorageTmp->linkageOperationalProtocols == NULL) {
		config_perror("invalid specification for linkageOperationalProtocols");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISiSO9542OperationalSubsets);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISiSO9542OperationalSubsets, &StorageTmp->linkageISiSO9542OperationalSubsetsLen);
	if (StorageTmp->linkageISiSO9542OperationalSubsets == NULL) {
		config_perror("invalid specification for linkageISiSO9542OperationalSubsets");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISHoldingTimerMultiplier);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISHoldingTimerMultiplier, &StorageTmp->linkageISHoldingTimerMultiplierLen);
	if (StorageTmp->linkageISHoldingTimerMultiplier == NULL) {
		config_perror("invalid specification for linkageISHoldingTimerMultiplier");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISConfigurationTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISConfigurationTimer, &StorageTmp->linkageISISConfigurationTimerLen);
	if (StorageTmp->linkageISISConfigurationTimer == NULL) {
		config_perror("invalid specification for linkageISISConfigurationTimer");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISSuggestedEsConfigurationTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISSuggestedEsConfigurationTimer, &StorageTmp->linkageISSuggestedEsConfigurationTimerLen);
	if (StorageTmp->linkageISSuggestedEsConfigurationTimer == NULL) {
		config_perror("invalid specification for linkageISSuggestedEsConfigurationTimer");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISRedirectHoldingTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISRedirectHoldingTime, &StorageTmp->linkageISRedirectHoldingTimeLen);
	if (StorageTmp->linkageISRedirectHoldingTime == NULL) {
		config_perror("invalid specification for linkageISRedirectHoldingTime");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISESReachabilityChanges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISInvalid9542PDUs, &tmpsize);
	SNMP_FREE(StorageTmp->linkageESiSO9542OperationalSubsets);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESiSO9542OperationalSubsets, &StorageTmp->linkageESiSO9542OperationalSubsetsLen);
	if (StorageTmp->linkageESiSO9542OperationalSubsets == NULL) {
		config_perror("invalid specification for linkageESiSO9542OperationalSubsets");
		return;
	}
	SNMP_FREE(StorageTmp->linkageESHoldingTimerMultiplier);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESHoldingTimerMultiplier, &StorageTmp->linkageESHoldingTimerMultiplierLen);
	if (StorageTmp->linkageESHoldingTimerMultiplier == NULL) {
		config_perror("invalid specification for linkageESHoldingTimerMultiplier");
		return;
	}
	SNMP_FREE(StorageTmp->linkageESManualISSNPAAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESManualISSNPAAddress, &StorageTmp->linkageESManualISSNPAAddressLen);
	if (StorageTmp->linkageESManualISSNPAAddress == NULL) {
		config_perror("invalid specification for linkageESManualISSNPAAddress");
		return;
	}
	SNMP_FREE(StorageTmp->linkageESDefaultESConfigTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESDefaultESConfigTimer, &StorageTmp->linkageESDefaultESConfigTimerLen);
	if (StorageTmp->linkageESDefaultESConfigTimer == NULL) {
		config_perror("invalid specification for linkageESDefaultESConfigTimer");
		return;
	}
	SNMP_FREE(StorageTmp->linkageESActiveESConfigTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageESActiveESConfigTimer, &StorageTmp->linkageESActiveESConfigTimerLen);
	if (StorageTmp->linkageESActiveESConfigTimer == NULL) {
		config_perror("invalid specification for linkageESActiveESConfigTimer");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageESISReachabilityChanges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageESInvalid9542PDUs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageEnableChecksum, &tmpsize);
	SNMP_FREE(StorageTmp->linkageInitialMinimumTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageInitialMinimumTimer, &StorageTmp->linkageInitialMinimumTimerLen);
	if (StorageTmp->linkageInitialMinimumTimer == NULL) {
		config_perror("invalid specification for linkageInitialMinimumTimer");
		return;
	}
	SNMP_FREE(StorageTmp->linkageReserveTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageReserveTimer, &StorageTmp->linkageReserveTimerLen);
	if (StorageTmp->linkageReserveTimer == NULL) {
		config_perror("invalid specification for linkageReserveTimer");
		return;
	}
	SNMP_FREE(StorageTmp->linkageIdleTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageIdleTimer, &StorageTmp->linkageIdleTimerLen);
	if (StorageTmp->linkageIdleTimer == NULL) {
		config_perror("invalid specification for linkageIdleTimer");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageSNDCFCallsPlaced, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageSNDCFCallsFailed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageCODLCallsPlaced, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageCODLCallsFailed, &tmpsize);
	SNMP_FREE(StorageTmp->linkageISISType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISType, &StorageTmp->linkageISISTypeLen);
	if (StorageTmp->linkageISISType == NULL) {
		config_perror("invalid specification for linkageISISType");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISiSISHelloTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISiSISHelloTimer, &StorageTmp->linkageISISiSISHelloTimerLen);
	if (StorageTmp->linkageISISiSISHelloTimer == NULL) {
		config_perror("invalid specification for linkageISISiSISHelloTimer");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl1DefaultMetric);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1DefaultMetric, &StorageTmp->linkageISISl1DefaultMetricLen);
	if (StorageTmp->linkageISISl1DefaultMetric == NULL) {
		config_perror("invalid specification for linkageISISl1DefaultMetric");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl1DelayMetric);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1DelayMetric, &StorageTmp->linkageISISl1DelayMetricLen);
	if (StorageTmp->linkageISISl1DelayMetric == NULL) {
		config_perror("invalid specification for linkageISISl1DelayMetric");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl1ExpenseMetric);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1ExpenseMetric, &StorageTmp->linkageISISl1ExpenseMetricLen);
	if (StorageTmp->linkageISISl1ExpenseMetric == NULL) {
		config_perror("invalid specification for linkageISISl1ExpenseMetric");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl1ErrorMetric);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1ErrorMetric, &StorageTmp->linkageISISl1ErrorMetricLen);
	if (StorageTmp->linkageISISl1ErrorMetric == NULL) {
		config_perror("invalid specification for linkageISISl1ErrorMetric");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISexternalDomain);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISexternalDomain, &StorageTmp->linkageISISexternalDomainLen);
	if (StorageTmp->linkageISISexternalDomain == NULL) {
		config_perror("invalid specification for linkageISISexternalDomain");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISchangedInAdjacencyState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISinitialisationFailures, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISrejectedAdjacencies, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISiSISControlPDUsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISiSISControlPDUsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISiDFieldLenthMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISmaximumAreaAddressesMismatches, &tmpsize);
	SNMP_FREE(StorageTmp->linkageISIScircuitTransmitPassword);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScircuitTransmitPassword, &StorageTmp->linkageISIScircuitTransmitPasswordLen);
	if (StorageTmp->linkageISIScircuitTransmitPassword == NULL) {
		config_perror("invalid specification for linkageISIScircuitTransmitPassword");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISIScircuitReceivedPasswords);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScircuitReceivedPasswords, &StorageTmp->linkageISIScircuitReceivedPasswordsLen);
	if (StorageTmp->linkageISIScircuitReceivedPasswords == NULL) {
		config_perror("invalid specification for linkageISIScircuitReceivedPasswords");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISauthenticationFailures, &tmpsize);
	SNMP_FREE(StorageTmp->linkageISISl1IntermediateSystemPriority);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1IntermediateSystemPriority, &StorageTmp->linkageISISl1IntermediateSystemPriorityLen);
	if (StorageTmp->linkageISISl1IntermediateSystemPriority == NULL) {
		config_perror("invalid specification for linkageISISl1IntermediateSystemPriority");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl1CircuitID);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1CircuitID, &StorageTmp->linkageISISl1CircuitIDLen);
	if (StorageTmp->linkageISISl1CircuitID == NULL) {
		config_perror("invalid specification for linkageISISl1CircuitID");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl1DesignatedIntermediateSystem);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl1DesignatedIntermediateSystem, &StorageTmp->linkageISISl1DesignatedIntermediateSystemLen);
	if (StorageTmp->linkageISISl1DesignatedIntermediateSystem == NULL) {
		config_perror("invalid specification for linkageISISl1DesignatedIntermediateSystem");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges, &tmpsize);
	SNMP_FREE(StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement, &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrementLen);
	if (StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentDefaultMetricIncrement");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement, &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrementLen);
	if (StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentDelayMetricIncrement");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement, &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrementLen);
	if (StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentExpenseMetricIncrement");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement, &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrementLen);
	if (StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement == NULL) {
		config_perror("invalid specification for linkageISIScallEstablishmentErrorMetricIncrement");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISptPtCircuitID);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISptPtCircuitID, &StorageTmp->linkageISISptPtCircuitIDLen);
	if (StorageTmp->linkageISISptPtCircuitID == NULL) {
		config_perror("invalid specification for linkageISISptPtCircuitID");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISoutgoingCallIVMO);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISoutgoingCallIVMO, &StorageTmp->linkageISISoutgoingCallIVMOLen);
	if (StorageTmp->linkageISISoutgoingCallIVMO == NULL) {
		config_perror("invalid specification for linkageISISoutgoingCallIVMO");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISneighborSNPAAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISneighborSNPAAddress, &StorageTmp->linkageISISneighborSNPAAddressLen);
	if (StorageTmp->linkageISISneighborSNPAAddress == NULL) {
		config_perror("invalid specification for linkageISISneighborSNPAAddress");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl2DefaultMetric);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2DefaultMetric, &StorageTmp->linkageISISl2DefaultMetricLen);
	if (StorageTmp->linkageISISl2DefaultMetric == NULL) {
		config_perror("invalid specification for linkageISISl2DefaultMetric");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl2DelayMetric);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2DelayMetric, &StorageTmp->linkageISISl2DelayMetricLen);
	if (StorageTmp->linkageISISl2DelayMetric == NULL) {
		config_perror("invalid specification for linkageISISl2DelayMetric");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl2ExpenseMetric);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2ExpenseMetric, &StorageTmp->linkageISISl2ExpenseMetricLen);
	if (StorageTmp->linkageISISl2ExpenseMetric == NULL) {
		config_perror("invalid specification for linkageISISl2ExpenseMetric");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl2ErrorMetric);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2ErrorMetric, &StorageTmp->linkageISISl2ErrorMetricLen);
	if (StorageTmp->linkageISISl2ErrorMetric == NULL) {
		config_perror("invalid specification for linkageISISl2ErrorMetric");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageISISmanualL2OnlyMode, &tmpsize);
	SNMP_FREE(StorageTmp->linkageISISl2IntermediateSystemPriority);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2IntermediateSystemPriority, &StorageTmp->linkageISISl2IntermediateSystemPriorityLen);
	if (StorageTmp->linkageISISl2IntermediateSystemPriority == NULL) {
		config_perror("invalid specification for linkageISISl2IntermediateSystemPriority");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl2CircuitID);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2CircuitID, &StorageTmp->linkageISISl2CircuitIDLen);
	if (StorageTmp->linkageISISl2CircuitID == NULL) {
		config_perror("invalid specification for linkageISISl2CircuitID");
		return;
	}
	SNMP_FREE(StorageTmp->linkageISISl2DesignatedIntermediateSystem);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageISISl2DesignatedIntermediateSystem, &StorageTmp->linkageISISl2DesignatedIntermediateSystemLen);
	if (StorageTmp->linkageISISl2DesignatedIntermediateSystem == NULL) {
		config_perror("invalid specification for linkageISISl2DesignatedIntermediateSystem");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->linkageRowStatus, &tmpsize);
	linkageTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_linkageTable(): store configuraiton file for linkageTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_linkageTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct linkageTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_linkageTable: storing data...  "));
	refresh_linkageTable(1);
	(void) tmpsize;
	for (hcindex = linkageTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct linkageTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "linkageTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->protocolMachineId, &StorageTmp->protocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageId, &StorageTmp->linkageIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageSnServiceProvider, &StorageTmp->linkageSnServiceProviderLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->linkageSnSAP, &StorageTmp->linkageSnSAPLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageOperationalProtocols, &StorageTmp->linkageOperationalProtocolsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISiSO9542OperationalSubsets, &StorageTmp->linkageISiSO9542OperationalSubsetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISHoldingTimerMultiplier, &StorageTmp->linkageISHoldingTimerMultiplierLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISConfigurationTimer, &StorageTmp->linkageISISConfigurationTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISSuggestedEsConfigurationTimer, &StorageTmp->linkageISSuggestedEsConfigurationTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISRedirectHoldingTime, &StorageTmp->linkageISRedirectHoldingTimeLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISESReachabilityChanges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISInvalid9542PDUs, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESiSO9542OperationalSubsets, &StorageTmp->linkageESiSO9542OperationalSubsetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESHoldingTimerMultiplier, &StorageTmp->linkageESHoldingTimerMultiplierLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESManualISSNPAAddress, &StorageTmp->linkageESManualISSNPAAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESDefaultESConfigTimer, &StorageTmp->linkageESDefaultESConfigTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageESActiveESConfigTimer, &StorageTmp->linkageESActiveESConfigTimerLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageESISReachabilityChanges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageESInvalid9542PDUs, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageEnableChecksum, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageInitialMinimumTimer, &StorageTmp->linkageInitialMinimumTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageReserveTimer, &StorageTmp->linkageReserveTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageIdleTimer, &StorageTmp->linkageIdleTimerLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageSNDCFCallsPlaced, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageSNDCFCallsFailed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageCODLCallsPlaced, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageCODLCallsFailed, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISType, &StorageTmp->linkageISISTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISiSISHelloTimer, &StorageTmp->linkageISISiSISHelloTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1DefaultMetric, &StorageTmp->linkageISISl1DefaultMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1DelayMetric, &StorageTmp->linkageISISl1DelayMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1ExpenseMetric, &StorageTmp->linkageISISl1ExpenseMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1ErrorMetric, &StorageTmp->linkageISISl1ErrorMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISexternalDomain, &StorageTmp->linkageISISexternalDomainLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISchangedInAdjacencyState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISinitialisationFailures, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISrejectedAdjacencies, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISiSISControlPDUsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISiSISControlPDUsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISiDFieldLenthMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISmaximumAreaAddressesMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScircuitTransmitPassword, &StorageTmp->linkageISIScircuitTransmitPasswordLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScircuitReceivedPasswords, &StorageTmp->linkageISIScircuitReceivedPasswordsLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISauthenticationFailures, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1IntermediateSystemPriority, &StorageTmp->linkageISISl1IntermediateSystemPriorityLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1CircuitID, &StorageTmp->linkageISISl1CircuitIDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl1DesignatedIntermediateSystem, &StorageTmp->linkageISISl1DesignatedIntermediateSystemLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement,
						   &StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrementLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement,
						   &StorageTmp->linkageISIScallEstablishmentDelayMetricIncrementLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement,
						   &StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrementLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement,
						   &StorageTmp->linkageISIScallEstablishmentErrorMetricIncrementLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISptPtCircuitID, &StorageTmp->linkageISISptPtCircuitIDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISoutgoingCallIVMO, &StorageTmp->linkageISISoutgoingCallIVMOLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISneighborSNPAAddress, &StorageTmp->linkageISISneighborSNPAAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2DefaultMetric, &StorageTmp->linkageISISl2DefaultMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2DelayMetric, &StorageTmp->linkageISISl2DelayMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2ExpenseMetric, &StorageTmp->linkageISISl2ExpenseMetricLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2ErrorMetric, &StorageTmp->linkageISISl2ErrorMetricLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageISISmanualL2OnlyMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2IntermediateSystemPriority, &StorageTmp->linkageISISl2IntermediateSystemPriorityLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2CircuitID, &StorageTmp->linkageISISl2CircuitIDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageISISl2DesignatedIntermediateSystem, &StorageTmp->linkageISISl2DesignatedIntermediateSystemLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->linkageRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct cONSTable_data *cONSTable_create(void)
 * @brief create a fresh data structure representing a new row in the cONSTable table.
 *
 * Creates a new cONSTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct cONSTable_data *
cONSTable_create(void)
{
	struct cONSTable_data *StorageNew = SNMP_MALLOC_STRUCT(cONSTable_data);

	DEBUGMSGTL(("dlMIB", "cONSTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		StorageNew->cONSAdministrativeState = 0;
		if (memdup((u_char **) &StorageNew->cONSOperationalSystemType, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->cONSOperationalSystemTypeLen = 1;
		StorageNew->cONSRowStatus = 0;
		StorageNew->cONSRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct cONSTable_data *cONSTable_duplicate(struct cONSTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct cONSTable_data *
cONSTable_duplicate(struct cONSTable_data *thedata)
{
	struct cONSTable_data *StorageNew = SNMP_MALLOC_STRUCT(cONSTable_data);

	DEBUGMSGTL(("dlMIB", "cONSTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	cONSTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int cONSTable_destroy(struct cONSTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
cONSTable_destroy(struct cONSTable_data **thedata)
{
	struct cONSTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "cONSTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->cONSOperationalSystemType);
		StorageDel->cONSOperationalSystemTypeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cONSTable_add(struct cONSTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the cONSTable table data set.
 *
 * Adds a table row structure to the cONSTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
cONSTable_add(struct cONSTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "cONSTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		header_complex_add_data(&cONSTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int cONSTable_del(struct cONSTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the cONSTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
cONSTable_del(struct cONSTable_data *thedata)
{
	struct cONSTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "cONSTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(cONSTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&cONSTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_cONSTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for cONSTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case cONSTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_cONSTable(const char *token, char *line)
{
	size_t tmpsize;
	struct cONSTable_data *StorageTmp = cONSTable_create();

	DEBUGMSGTL(("dlMIB", "parse_cONSTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cONSAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->cONSOperationalSystemType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->cONSOperationalSystemType, &StorageTmp->cONSOperationalSystemTypeLen);
	if (StorageTmp->cONSOperationalSystemType == NULL) {
		config_perror("invalid specification for cONSOperationalSystemType");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->cONSRowStatus, &tmpsize);
	cONSTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_cONSTable(): store configuraiton file for cONSTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_cONSTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct cONSTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_cONSTable: storing data...  "));
	refresh_cONSTable(1);
	(void) tmpsize;
	for (hcindex = cONSTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct cONSTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "cONSTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cONSAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->cONSOperationalSystemType, &StorageTmp->cONSOperationalSystemTypeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->cONSRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct networkConnectionTable_data *networkConnectionTable_create(void)
 * @brief create a fresh data structure representing a new row in the networkConnectionTable table.
 *
 * Creates a new networkConnectionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct networkConnectionTable_data *
networkConnectionTable_create(void)
{
	struct networkConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(networkConnectionTable_data);

	DEBUGMSGTL(("dlMIB", "networkConnectionTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->coProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->coProtocolMachineIdLen = strlen("");
		if ((StorageNew->connectionId = (uint8_t *) strdup("")) != NULL)
			StorageNew->connectionIdLen = strlen("");
		if ((StorageNew->networkConnectionLocalNSAPMO = (uint8_t *) strdup("")) != NULL)
			StorageNew->networkConnectionLocalNSAPMOLen = strlen("");
		if ((StorageNew->networkConnectionRemoteNSAPAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->networkConnectionRemoteNSAPAddressLen = strlen("");
		StorageNew->networkConnectionRowStatus = 0;
		StorageNew->networkConnectionRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct networkConnectionTable_data *networkConnectionTable_duplicate(struct networkConnectionTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct networkConnectionTable_data *
networkConnectionTable_duplicate(struct networkConnectionTable_data *thedata)
{
	struct networkConnectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(networkConnectionTable_data);

	DEBUGMSGTL(("dlMIB", "networkConnectionTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	networkConnectionTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int networkConnectionTable_destroy(struct networkConnectionTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
networkConnectionTable_destroy(struct networkConnectionTable_data **thedata)
{
	struct networkConnectionTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "networkConnectionTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->coProtocolMachineId);
		StorageDel->coProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->connectionId);
		StorageDel->connectionIdLen = 0;
		SNMP_FREE(StorageDel->networkConnectionLocalNSAPMO);
		StorageDel->networkConnectionLocalNSAPMOLen = 0;
		SNMP_FREE(StorageDel->networkConnectionRemoteNSAPAddress);
		StorageDel->networkConnectionRemoteNSAPAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int networkConnectionTable_add(struct networkConnectionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the networkConnectionTable table data set.
 *
 * Adds a table row structure to the networkConnectionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
networkConnectionTable_add(struct networkConnectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "networkConnectionTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* coProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->coProtocolMachineId, thedata->coProtocolMachineIdLen);
		/* connectionId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->connectionId, thedata->connectionIdLen);
		header_complex_add_data(&networkConnectionTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int networkConnectionTable_del(struct networkConnectionTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the networkConnectionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
networkConnectionTable_del(struct networkConnectionTable_data *thedata)
{
	struct networkConnectionTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "networkConnectionTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(networkConnectionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&networkConnectionTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_networkConnectionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for networkConnectionTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case networkConnectionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_networkConnectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct networkConnectionTable_data *StorageTmp = networkConnectionTable_create();

	DEBUGMSGTL(("dlMIB", "parse_networkConnectionTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->coProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
	if (StorageTmp->coProtocolMachineId == NULL) {
		config_perror("invalid specification for coProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->connectionId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
	if (StorageTmp->connectionId == NULL) {
		config_perror("invalid specification for connectionId");
		return;
	}
	SNMP_FREE(StorageTmp->networkConnectionLocalNSAPMO);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkConnectionLocalNSAPMO, &StorageTmp->networkConnectionLocalNSAPMOLen);
	if (StorageTmp->networkConnectionLocalNSAPMO == NULL) {
		config_perror("invalid specification for networkConnectionLocalNSAPMO");
		return;
	}
	SNMP_FREE(StorageTmp->networkConnectionRemoteNSAPAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->networkConnectionRemoteNSAPAddress, &StorageTmp->networkConnectionRemoteNSAPAddressLen);
	if (StorageTmp->networkConnectionRemoteNSAPAddress == NULL) {
		config_perror("invalid specification for networkConnectionRemoteNSAPAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->networkConnectionRowStatus, &tmpsize);
	networkConnectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_networkConnectionTable(): store configuraiton file for networkConnectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_networkConnectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct networkConnectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_networkConnectionTable: storing data...  "));
	refresh_networkConnectionTable(1);
	(void) tmpsize;
	for (hcindex = networkConnectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct networkConnectionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "networkConnectionTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->coProtocolMachineId, &StorageTmp->coProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->connectionId, &StorageTmp->connectionIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkConnectionLocalNSAPMO, &StorageTmp->networkConnectionLocalNSAPMOLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->networkConnectionRemoteNSAPAddress, &StorageTmp->networkConnectionRemoteNSAPAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->networkConnectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLETable_data *x25PLETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLETable table.
 *
 * Creates a new x25PLETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLETable_data *
x25PLETable_create(void)
{
	struct x25PLETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEoperationalState = 0;
		StorageNew->x25PLEadministrativeState = 0;
		if ((StorageNew->x25PLEprotocolVersionSupported = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEprotocolVersionSupportedLen = strlen("");
		if ((StorageNew->x25PLElocalDTEAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLElocalDTEAddressLen = strlen("");
		StorageNew->x25PLEMode = 0;
		if ((StorageNew->x25PLEdefaultThroughputClasses = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEdefaultThroughputClassesLen = strlen("");
		if ((StorageNew->x25PLEflowControlParameterNegotiation = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEflowControlParameterNegotiationLen = strlen("");
		if ((StorageNew->x25PLEdefaultPackageSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEdefaultPackageSizesLen = strlen("");
		if ((StorageNew->x25PLEthroughputClassNegotiation = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEthroughputClassNegotiationLen = strlen("");
		if ((StorageNew->x25PLEsNserviceProvider = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEsNserviceProviderLen = strlen("");
		if ((StorageNew->x25PLEsNsAP = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEsNsAPLen = strlen("");
		if ((StorageNew->x25PElogicalChannelAssignments = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PElogicalChannelAssignmentsLen = strlen("");
		StorageNew->x25PLEinterfaceMode = 0;
		if ((StorageNew->x25PLEdefaultThroughputClass = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEdefaultThroughputClassLen = strlen("");
		if ((StorageNew->x25PLEflowControlNegotiationPermitted = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEflowControlNegotiationPermittedLen = strlen("");
		StorageNew->x25PLEcallDeflectionSubscription = 0;
		if ((StorageNew->x25PLEmaxActiveCircuits = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEmaxActiveCircuitsLen = strlen("");
		if ((StorageNew->x25PLErestartTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLErestartTimeLen = strlen("");
		if ((StorageNew->x25PLEdefaultPacketSize = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEdefaultPacketSizeLen = strlen("");
		if ((StorageNew->x25PLEdefaultWindowSize = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEdefaultWindowSizeLen = strlen("");
		if ((StorageNew->x25PLEminimumRecallTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEminimumRecallTimerLen = strlen("");
		if ((StorageNew->x25PLErestartCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLErestartCountLen = strlen("");
		if ((StorageNew->x25PLEsN_ServiceProvider = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEsN_ServiceProviderLen = strlen("");
		if ((StorageNew->x25PLEsN_SA_P = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEsN_SA_PLen = strlen("");
		if ((StorageNew->x25PLElogicalChannelAssignments = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLElogicalChannelAssignmentsLen = strlen("");
		if ((StorageNew->x25PLEpacketSequencing = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEpacketSequencingLen = strlen("");
		if ((StorageNew->x25PLEoctetsSentCounter = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEoctetsSentCounterLen = strlen("");
		if ((StorageNew->x25PLEoctetsReceivedCounter = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEoctetsReceivedCounterLen = strlen("");
		if ((StorageNew->x25PLEdataPacketsSent = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEdataPacketsSentLen = strlen("");
		if ((StorageNew->x25PLEdataPacketsReceived = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEdataPacketsReceivedLen = strlen("");
		if ((StorageNew->x25PLEcallAttempts = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEcallAttemptsLen = strlen("");
		if ((StorageNew->x25PLEcallsConnected = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEcallsConnectedLen = strlen("");
		StorageNew->x25PLEproviderInitiatedDisconnects = 0;
		if ((StorageNew->x25PLEcallTimeouts = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEcallTimeoutsLen = strlen("");
		if ((StorageNew->x25PLEclearTimeouts = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEclearTimeoutsLen = strlen("");
		if ((StorageNew->x25PLEremotelyInitiatedResets = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEremotelyInitiatedResetsLen = strlen("");
		if ((StorageNew->x25PLEdataRetransmissionTimerExpiries = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEdataRetransmissionTimerExpiriesLen = strlen("");
		if ((StorageNew->x25PLEproviderInitiatedResets = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEproviderInitiatedResetsLen = strlen("");
		if ((StorageNew->x25PLEresetTimeouts = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEresetTimeoutsLen = strlen("");
		if ((StorageNew->x25PLEremotelyInitiatedRestarts = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEremotelyInitiatedRestartsLen = strlen("");
		if ((StorageNew->x25PLErestartCountsExceeded = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLErestartCountsExceededLen = strlen("");
		if ((StorageNew->x25PLEprotocolErrorsDetectedLocally = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEprotocolErrorsDetectedLocallyLen = strlen("");
		if ((StorageNew->x25PLEprotocolErrorsAccusedOf = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEprotocolErrorsAccusedOfLen = strlen("");
		if ((StorageNew->x25PLEcallEstablishmentRetryCountsExceeded = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEcallEstablishmentRetryCountsExceededLen = strlen("");
		if ((StorageNew->x25PLEclearCountsExceeded = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEclearCountsExceededLen = strlen("");
		if ((StorageNew->x25PLEpLEClientMOName = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEpLEClientMONameLen = strlen("");
		if ((StorageNew->x25PLEregistrationRequestTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEregistrationRequestTimeLen = strlen("");
		if ((StorageNew->x25PLEregistrationRequestCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEregistrationRequestCountLen = strlen("");
		StorageNew->x25PLEregistrationPermitted = 0;
		StorageNew->x25PLERowStatus = 0;
		StorageNew->x25PLERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct x25PLETable_data *x25PLETable_duplicate(struct x25PLETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct x25PLETable_data *
x25PLETable_duplicate(struct x25PLETable_data *thedata)
{
	struct x25PLETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	x25PLETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int x25PLETable_destroy(struct x25PLETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLETable_destroy(struct x25PLETable_data **thedata)
{
	struct x25PLETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEprotocolVersionSupported);
		StorageDel->x25PLEprotocolVersionSupportedLen = 0;
		SNMP_FREE(StorageDel->x25PLElocalDTEAddress);
		StorageDel->x25PLElocalDTEAddressLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultThroughputClasses);
		StorageDel->x25PLEdefaultThroughputClassesLen = 0;
		SNMP_FREE(StorageDel->x25PLEflowControlParameterNegotiation);
		StorageDel->x25PLEflowControlParameterNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultPackageSizes);
		StorageDel->x25PLEdefaultPackageSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLEthroughputClassNegotiation);
		StorageDel->x25PLEthroughputClassNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEsNserviceProvider);
		StorageDel->x25PLEsNserviceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLEsNsAP);
		StorageDel->x25PLEsNsAPLen = 0;
		SNMP_FREE(StorageDel->x25PElogicalChannelAssignments);
		StorageDel->x25PElogicalChannelAssignmentsLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultThroughputClass);
		StorageDel->x25PLEdefaultThroughputClassLen = 0;
		SNMP_FREE(StorageDel->x25PLEflowControlNegotiationPermitted);
		StorageDel->x25PLEflowControlNegotiationPermittedLen = 0;
		SNMP_FREE(StorageDel->x25PLEmaxActiveCircuits);
		StorageDel->x25PLEmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLErestartTime);
		StorageDel->x25PLErestartTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultPacketSize);
		StorageDel->x25PLEdefaultPacketSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEdefaultWindowSize);
		StorageDel->x25PLEdefaultWindowSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEminimumRecallTimer);
		StorageDel->x25PLEminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLErestartCount);
		StorageDel->x25PLErestartCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEsN_ServiceProvider);
		StorageDel->x25PLEsN_ServiceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLEsN_SA_P);
		StorageDel->x25PLEsN_SA_PLen = 0;
		SNMP_FREE(StorageDel->x25PLElogicalChannelAssignments);
		StorageDel->x25PLElogicalChannelAssignmentsLen = 0;
		SNMP_FREE(StorageDel->x25PLEpacketSequencing);
		StorageDel->x25PLEpacketSequencingLen = 0;
		SNMP_FREE(StorageDel->x25PLEoctetsSentCounter);
		StorageDel->x25PLEoctetsSentCounterLen = 0;
		SNMP_FREE(StorageDel->x25PLEoctetsReceivedCounter);
		StorageDel->x25PLEoctetsReceivedCounterLen = 0;
		SNMP_FREE(StorageDel->x25PLEdataPacketsSent);
		StorageDel->x25PLEdataPacketsSentLen = 0;
		SNMP_FREE(StorageDel->x25PLEdataPacketsReceived);
		StorageDel->x25PLEdataPacketsReceivedLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallAttempts);
		StorageDel->x25PLEcallAttemptsLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallsConnected);
		StorageDel->x25PLEcallsConnectedLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallTimeouts);
		StorageDel->x25PLEcallTimeoutsLen = 0;
		SNMP_FREE(StorageDel->x25PLEclearTimeouts);
		StorageDel->x25PLEclearTimeoutsLen = 0;
		SNMP_FREE(StorageDel->x25PLEremotelyInitiatedResets);
		StorageDel->x25PLEremotelyInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->x25PLEdataRetransmissionTimerExpiries);
		StorageDel->x25PLEdataRetransmissionTimerExpiriesLen = 0;
		SNMP_FREE(StorageDel->x25PLEproviderInitiatedResets);
		StorageDel->x25PLEproviderInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->x25PLEresetTimeouts);
		StorageDel->x25PLEresetTimeoutsLen = 0;
		SNMP_FREE(StorageDel->x25PLEremotelyInitiatedRestarts);
		StorageDel->x25PLEremotelyInitiatedRestartsLen = 0;
		SNMP_FREE(StorageDel->x25PLErestartCountsExceeded);
		StorageDel->x25PLErestartCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEprotocolErrorsDetectedLocally);
		StorageDel->x25PLEprotocolErrorsDetectedLocallyLen = 0;
		SNMP_FREE(StorageDel->x25PLEprotocolErrorsAccusedOf);
		StorageDel->x25PLEprotocolErrorsAccusedOfLen = 0;
		SNMP_FREE(StorageDel->x25PLEcallEstablishmentRetryCountsExceeded);
		StorageDel->x25PLEcallEstablishmentRetryCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEclearCountsExceeded);
		StorageDel->x25PLEclearCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEpLEClientMOName);
		StorageDel->x25PLEpLEClientMONameLen = 0;
		SNMP_FREE(StorageDel->x25PLEregistrationRequestTime);
		StorageDel->x25PLEregistrationRequestTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEregistrationRequestCount);
		StorageDel->x25PLEregistrationRequestCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLETable_add(struct x25PLETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLETable table data set.
 *
 * Adds a table row structure to the x25PLETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLETable_add(struct x25PLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "x25PLETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		header_complex_add_data(&x25PLETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLETable_del(struct x25PLETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the x25PLETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLETable_del(struct x25PLETable_data *thedata)
{
	struct x25PLETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp = x25PLETable_create();

	DEBUGMSGTL(("dlMIB", "parse_x25PLETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEoperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEadministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLEprotocolVersionSupported);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEprotocolVersionSupported, &StorageTmp->x25PLEprotocolVersionSupportedLen);
	if (StorageTmp->x25PLEprotocolVersionSupported == NULL) {
		config_perror("invalid specification for x25PLEprotocolVersionSupported");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLElocalDTEAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLElocalDTEAddress, &StorageTmp->x25PLElocalDTEAddressLen);
	if (StorageTmp->x25PLElocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLElocalDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEMode, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLEdefaultThroughputClasses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultThroughputClasses, &StorageTmp->x25PLEdefaultThroughputClassesLen);
	if (StorageTmp->x25PLEdefaultThroughputClasses == NULL) {
		config_perror("invalid specification for x25PLEdefaultThroughputClasses");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEflowControlParameterNegotiation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEflowControlParameterNegotiation, &StorageTmp->x25PLEflowControlParameterNegotiationLen);
	if (StorageTmp->x25PLEflowControlParameterNegotiation == NULL) {
		config_perror("invalid specification for x25PLEflowControlParameterNegotiation");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEdefaultPackageSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultPackageSizes, &StorageTmp->x25PLEdefaultPackageSizesLen);
	if (StorageTmp->x25PLEdefaultPackageSizes == NULL) {
		config_perror("invalid specification for x25PLEdefaultPackageSizes");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEthroughputClassNegotiation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEthroughputClassNegotiation, &StorageTmp->x25PLEthroughputClassNegotiationLen);
	if (StorageTmp->x25PLEthroughputClassNegotiation == NULL) {
		config_perror("invalid specification for x25PLEthroughputClassNegotiation");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEsNserviceProvider);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsNserviceProvider, &StorageTmp->x25PLEsNserviceProviderLen);
	if (StorageTmp->x25PLEsNserviceProvider == NULL) {
		config_perror("invalid specification for x25PLEsNserviceProvider");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEsNsAP);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsNsAP, &StorageTmp->x25PLEsNsAPLen);
	if (StorageTmp->x25PLEsNsAP == NULL) {
		config_perror("invalid specification for x25PLEsNsAP");
		return;
	}
	SNMP_FREE(StorageTmp->x25PElogicalChannelAssignments);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PElogicalChannelAssignments, &StorageTmp->x25PElogicalChannelAssignmentsLen);
	if (StorageTmp->x25PElogicalChannelAssignments == NULL) {
		config_perror("invalid specification for x25PElogicalChannelAssignments");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEinterfaceMode, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLEdefaultThroughputClass);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultThroughputClass, &StorageTmp->x25PLEdefaultThroughputClassLen);
	if (StorageTmp->x25PLEdefaultThroughputClass == NULL) {
		config_perror("invalid specification for x25PLEdefaultThroughputClass");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEflowControlNegotiationPermitted);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEflowControlNegotiationPermitted, &StorageTmp->x25PLEflowControlNegotiationPermittedLen);
	if (StorageTmp->x25PLEflowControlNegotiationPermitted == NULL) {
		config_perror("invalid specification for x25PLEflowControlNegotiationPermitted");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEcallDeflectionSubscription, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLEmaxActiveCircuits);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEmaxActiveCircuits, &StorageTmp->x25PLEmaxActiveCircuitsLen);
	if (StorageTmp->x25PLEmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLEmaxActiveCircuits");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLErestartTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLErestartTime, &StorageTmp->x25PLErestartTimeLen);
	if (StorageTmp->x25PLErestartTime == NULL) {
		config_perror("invalid specification for x25PLErestartTime");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEdefaultPacketSize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultPacketSize, &StorageTmp->x25PLEdefaultPacketSizeLen);
	if (StorageTmp->x25PLEdefaultPacketSize == NULL) {
		config_perror("invalid specification for x25PLEdefaultPacketSize");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEdefaultWindowSize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdefaultWindowSize, &StorageTmp->x25PLEdefaultWindowSizeLen);
	if (StorageTmp->x25PLEdefaultWindowSize == NULL) {
		config_perror("invalid specification for x25PLEdefaultWindowSize");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEminimumRecallTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEminimumRecallTimer, &StorageTmp->x25PLEminimumRecallTimerLen);
	if (StorageTmp->x25PLEminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLEminimumRecallTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLErestartCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLErestartCount, &StorageTmp->x25PLErestartCountLen);
	if (StorageTmp->x25PLErestartCount == NULL) {
		config_perror("invalid specification for x25PLErestartCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEsN_ServiceProvider);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsN_ServiceProvider, &StorageTmp->x25PLEsN_ServiceProviderLen);
	if (StorageTmp->x25PLEsN_ServiceProvider == NULL) {
		config_perror("invalid specification for x25PLEsN_ServiceProvider");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEsN_SA_P);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEsN_SA_P, &StorageTmp->x25PLEsN_SA_PLen);
	if (StorageTmp->x25PLEsN_SA_P == NULL) {
		config_perror("invalid specification for x25PLEsN_SA_P");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLElogicalChannelAssignments);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLElogicalChannelAssignments, &StorageTmp->x25PLElogicalChannelAssignmentsLen);
	if (StorageTmp->x25PLElogicalChannelAssignments == NULL) {
		config_perror("invalid specification for x25PLElogicalChannelAssignments");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEpacketSequencing);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEpacketSequencing, &StorageTmp->x25PLEpacketSequencingLen);
	if (StorageTmp->x25PLEpacketSequencing == NULL) {
		config_perror("invalid specification for x25PLEpacketSequencing");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEoctetsSentCounter);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEoctetsSentCounter, &StorageTmp->x25PLEoctetsSentCounterLen);
	if (StorageTmp->x25PLEoctetsSentCounter == NULL) {
		config_perror("invalid specification for x25PLEoctetsSentCounter");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEoctetsReceivedCounter);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEoctetsReceivedCounter, &StorageTmp->x25PLEoctetsReceivedCounterLen);
	if (StorageTmp->x25PLEoctetsReceivedCounter == NULL) {
		config_perror("invalid specification for x25PLEoctetsReceivedCounter");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEdataPacketsSent);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdataPacketsSent, &StorageTmp->x25PLEdataPacketsSentLen);
	if (StorageTmp->x25PLEdataPacketsSent == NULL) {
		config_perror("invalid specification for x25PLEdataPacketsSent");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEdataPacketsReceived);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdataPacketsReceived, &StorageTmp->x25PLEdataPacketsReceivedLen);
	if (StorageTmp->x25PLEdataPacketsReceived == NULL) {
		config_perror("invalid specification for x25PLEdataPacketsReceived");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEcallAttempts);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallAttempts, &StorageTmp->x25PLEcallAttemptsLen);
	if (StorageTmp->x25PLEcallAttempts == NULL) {
		config_perror("invalid specification for x25PLEcallAttempts");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEcallsConnected);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallsConnected, &StorageTmp->x25PLEcallsConnectedLen);
	if (StorageTmp->x25PLEcallsConnected == NULL) {
		config_perror("invalid specification for x25PLEcallsConnected");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEproviderInitiatedDisconnects, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLEcallTimeouts);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallTimeouts, &StorageTmp->x25PLEcallTimeoutsLen);
	if (StorageTmp->x25PLEcallTimeouts == NULL) {
		config_perror("invalid specification for x25PLEcallTimeouts");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEclearTimeouts);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEclearTimeouts, &StorageTmp->x25PLEclearTimeoutsLen);
	if (StorageTmp->x25PLEclearTimeouts == NULL) {
		config_perror("invalid specification for x25PLEclearTimeouts");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEremotelyInitiatedResets);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEremotelyInitiatedResets, &StorageTmp->x25PLEremotelyInitiatedResetsLen);
	if (StorageTmp->x25PLEremotelyInitiatedResets == NULL) {
		config_perror("invalid specification for x25PLEremotelyInitiatedResets");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEdataRetransmissionTimerExpiries);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEdataRetransmissionTimerExpiries, &StorageTmp->x25PLEdataRetransmissionTimerExpiriesLen);
	if (StorageTmp->x25PLEdataRetransmissionTimerExpiries == NULL) {
		config_perror("invalid specification for x25PLEdataRetransmissionTimerExpiries");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEproviderInitiatedResets);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEproviderInitiatedResets, &StorageTmp->x25PLEproviderInitiatedResetsLen);
	if (StorageTmp->x25PLEproviderInitiatedResets == NULL) {
		config_perror("invalid specification for x25PLEproviderInitiatedResets");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEresetTimeouts);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEresetTimeouts, &StorageTmp->x25PLEresetTimeoutsLen);
	if (StorageTmp->x25PLEresetTimeouts == NULL) {
		config_perror("invalid specification for x25PLEresetTimeouts");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEremotelyInitiatedRestarts);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEremotelyInitiatedRestarts, &StorageTmp->x25PLEremotelyInitiatedRestartsLen);
	if (StorageTmp->x25PLEremotelyInitiatedRestarts == NULL) {
		config_perror("invalid specification for x25PLEremotelyInitiatedRestarts");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLErestartCountsExceeded);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLErestartCountsExceeded, &StorageTmp->x25PLErestartCountsExceededLen);
	if (StorageTmp->x25PLErestartCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLErestartCountsExceeded");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEprotocolErrorsDetectedLocally);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEprotocolErrorsDetectedLocally, &StorageTmp->x25PLEprotocolErrorsDetectedLocallyLen);
	if (StorageTmp->x25PLEprotocolErrorsDetectedLocally == NULL) {
		config_perror("invalid specification for x25PLEprotocolErrorsDetectedLocally");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEprotocolErrorsAccusedOf);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEprotocolErrorsAccusedOf, &StorageTmp->x25PLEprotocolErrorsAccusedOfLen);
	if (StorageTmp->x25PLEprotocolErrorsAccusedOf == NULL) {
		config_perror("invalid specification for x25PLEprotocolErrorsAccusedOf");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceededLen);
	if (StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLEcallEstablishmentRetryCountsExceeded");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEclearCountsExceeded);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEclearCountsExceeded, &StorageTmp->x25PLEclearCountsExceededLen);
	if (StorageTmp->x25PLEclearCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLEclearCountsExceeded");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEpLEClientMOName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEpLEClientMOName, &StorageTmp->x25PLEpLEClientMONameLen);
	if (StorageTmp->x25PLEpLEClientMOName == NULL) {
		config_perror("invalid specification for x25PLEpLEClientMOName");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEregistrationRequestTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEregistrationRequestTime, &StorageTmp->x25PLEregistrationRequestTimeLen);
	if (StorageTmp->x25PLEregistrationRequestTime == NULL) {
		config_perror("invalid specification for x25PLEregistrationRequestTime");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEregistrationRequestCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEregistrationRequestCount, &StorageTmp->x25PLEregistrationRequestCountLen);
	if (StorageTmp->x25PLEregistrationRequestCount == NULL) {
		config_perror("invalid specification for x25PLEregistrationRequestCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEregistrationPermitted, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLERowStatus, &tmpsize);
	x25PLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_x25PLETable(): store configuraiton file for x25PLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_x25PLETable: storing data...  "));
	refresh_x25PLETable(1);
	(void) tmpsize;
	for (hcindex = x25PLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEoperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEadministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEprotocolVersionSupported, &StorageTmp->x25PLEprotocolVersionSupportedLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLElocalDTEAddress, &StorageTmp->x25PLElocalDTEAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultThroughputClasses, &StorageTmp->x25PLEdefaultThroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEflowControlParameterNegotiation, &StorageTmp->x25PLEflowControlParameterNegotiationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultPackageSizes, &StorageTmp->x25PLEdefaultPackageSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEthroughputClassNegotiation, &StorageTmp->x25PLEthroughputClassNegotiationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsNserviceProvider, &StorageTmp->x25PLEsNserviceProviderLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsNsAP, &StorageTmp->x25PLEsNsAPLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PElogicalChannelAssignments, &StorageTmp->x25PElogicalChannelAssignmentsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEinterfaceMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultThroughputClass, &StorageTmp->x25PLEdefaultThroughputClassLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEflowControlNegotiationPermitted, &StorageTmp->x25PLEflowControlNegotiationPermittedLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEmaxActiveCircuits, &StorageTmp->x25PLEmaxActiveCircuitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLErestartTime, &StorageTmp->x25PLErestartTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultPacketSize, &StorageTmp->x25PLEdefaultPacketSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdefaultWindowSize, &StorageTmp->x25PLEdefaultWindowSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEminimumRecallTimer, &StorageTmp->x25PLEminimumRecallTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLErestartCount, &StorageTmp->x25PLErestartCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsN_ServiceProvider, &StorageTmp->x25PLEsN_ServiceProviderLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEsN_SA_P, &StorageTmp->x25PLEsN_SA_PLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLElogicalChannelAssignments, &StorageTmp->x25PLElogicalChannelAssignmentsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEpacketSequencing, &StorageTmp->x25PLEpacketSequencingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEoctetsSentCounter, &StorageTmp->x25PLEoctetsSentCounterLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEoctetsReceivedCounter, &StorageTmp->x25PLEoctetsReceivedCounterLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdataPacketsSent, &StorageTmp->x25PLEdataPacketsSentLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdataPacketsReceived, &StorageTmp->x25PLEdataPacketsReceivedLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallAttempts, &StorageTmp->x25PLEcallAttemptsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallsConnected, &StorageTmp->x25PLEcallsConnectedLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallTimeouts, &StorageTmp->x25PLEcallTimeoutsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEclearTimeouts, &StorageTmp->x25PLEclearTimeoutsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEremotelyInitiatedResets, &StorageTmp->x25PLEremotelyInitiatedResetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEdataRetransmissionTimerExpiries, &StorageTmp->x25PLEdataRetransmissionTimerExpiriesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEproviderInitiatedResets, &StorageTmp->x25PLEproviderInitiatedResetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEresetTimeouts, &StorageTmp->x25PLEresetTimeoutsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEremotelyInitiatedRestarts, &StorageTmp->x25PLEremotelyInitiatedRestartsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLErestartCountsExceeded, &StorageTmp->x25PLErestartCountsExceededLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEprotocolErrorsDetectedLocally, &StorageTmp->x25PLEprotocolErrorsDetectedLocallyLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEprotocolErrorsAccusedOf, &StorageTmp->x25PLEprotocolErrorsAccusedOfLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded, &StorageTmp->x25PLEcallEstablishmentRetryCountsExceededLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEclearCountsExceeded, &StorageTmp->x25PLEclearCountsExceededLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEpLEClientMOName, &StorageTmp->x25PLEpLEClientMONameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEregistrationRequestTime, &StorageTmp->x25PLEregistrationRequestTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEregistrationRequestCount, &StorageTmp->x25PLEregistrationRequestCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEregistrationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLE_DTETable_data *x25PLE_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLE_DTETable table.
 *
 * Creates a new x25PLE_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLE_DTETable_data *
x25PLE_DTETable_create(void)
{
	struct x25PLE_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLE_DTETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLE_DTETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		StorageNew->x25PLE_DTEcallDeflectionSubscription = 0;
		if ((StorageNew->x25PLE_DTEcallRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEcallRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTEextendedPacketSequenceNumbering = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEextendedPacketSequenceNumberingLen = strlen("");
		if ((StorageNew->x25PLE_DTEmaxActiveCircuits = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEmaxActiveCircuitsLen = strlen("");
		if ((StorageNew->x25PLE_DTEminimumRecallTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEminimumRecallTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTEresetRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEresetRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTErestartRequestRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTErestartRequestRetransmissionCountLen = strlen("");
		if ((StorageNew->x25PLE_DTErestartRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTErestartRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTEclearRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEclearRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTEinterruptResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEinterruptResponseTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTEresetRequestRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEresetRequestRetransmissionCountLen = strlen("");
		if ((StorageNew->x25PLE_DTEclearRequestRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEclearRequestRetransmissionCountLen = strlen("");
		StorageNew->x25PLE_DTEcallAttempts = 0;
		StorageNew->x25PLE_DTEprotocolErrorsDetectedLocally = 0;
		StorageNew->x25PLE_DTEprotocolErrorsAccusedOf = 0;
		StorageNew->x25PLE_DTEcallEstablishmentRetryCountsExceeded = 0;
		StorageNew->x25PLE_DTEoctetsReceivedCounter = 0;
		StorageNew->x25PLE_DTEoctetsSentCounter = 0;
		StorageNew->x25PLE_DTEcallTimeouts = 0;
		StorageNew->x25PLE_DTEcallsConnected = 0;
		StorageNew->x25PLE_DTEclearCountsExceeded = 0;
		StorageNew->x25PLE_DTEclearTimeouts = 0;
		StorageNew->x25PLE_DTEdataPacketsReceived = 0;
		StorageNew->x25PLE_DTEdataPacketsSent = 0;
		StorageNew->x25PLE_DTEdataRetransmissionTimerExpiries = 0;
		StorageNew->x25PLE_DTEproviderInitiatedResets = 0;
		StorageNew->x25PLE_DTEproviderInitiatedDisconnects = 0;
		StorageNew->x25PLE_DTEremotelyInitiatedResets = 0;
		StorageNew->x25PLE_DTEremotelyInitiatedRestarts = 0;
		StorageNew->x25PLE_DTEresetTimeouts = 0;
		StorageNew->x25PLE_DTErestartCountsExceeded = 0;
		if ((StorageNew->x25PLE_DTEwindowStatusTransmissionTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEwindowStatusTransmissionTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTEwindowRotationTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEwindowRotationTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTEdataPacketRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEdataPacketRetransmissionCountLen = strlen("");
		if ((StorageNew->x25PLE_DTErejectResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTErejectResponseTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTErejectRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTErejectRetransmissionCountLen = strlen("");
		if ((StorageNew->x25PLE_DTEregistrationRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEregistrationRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLE_DTEregistrationRequestRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DTEregistrationRequestRetransmissionCountLen = strlen("");
		StorageNew->x25PLE_DTEregistrationPermitted = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct x25PLE_DTETable_data *x25PLE_DTETable_duplicate(struct x25PLE_DTETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct x25PLE_DTETable_data *
x25PLE_DTETable_duplicate(struct x25PLE_DTETable_data *thedata)
{
	struct x25PLE_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLE_DTETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLE_DTETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	x25PLE_DTETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int x25PLE_DTETable_destroy(struct x25PLE_DTETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLE_DTETable_destroy(struct x25PLE_DTETable_data **thedata)
{
	struct x25PLE_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLE_DTETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEcallRequestResponseTimer);
		StorageDel->x25PLE_DTEcallRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEextendedPacketSequenceNumbering);
		StorageDel->x25PLE_DTEextendedPacketSequenceNumberingLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEmaxActiveCircuits);
		StorageDel->x25PLE_DTEmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEminimumRecallTimer);
		StorageDel->x25PLE_DTEminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEresetRequestResponseTimer);
		StorageDel->x25PLE_DTEresetRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTErestartRequestRetransmissionCount);
		StorageDel->x25PLE_DTErestartRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTErestartRequestResponseTimer);
		StorageDel->x25PLE_DTErestartRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEclearRequestResponseTimer);
		StorageDel->x25PLE_DTEclearRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEinterruptResponseTimer);
		StorageDel->x25PLE_DTEinterruptResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEresetRequestRetransmissionCount);
		StorageDel->x25PLE_DTEresetRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEclearRequestRetransmissionCount);
		StorageDel->x25PLE_DTEclearRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEwindowStatusTransmissionTimer);
		StorageDel->x25PLE_DTEwindowStatusTransmissionTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEwindowRotationTimer);
		StorageDel->x25PLE_DTEwindowRotationTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEdataPacketRetransmissionCount);
		StorageDel->x25PLE_DTEdataPacketRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTErejectResponseTimer);
		StorageDel->x25PLE_DTErejectResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTErejectRetransmissionCount);
		StorageDel->x25PLE_DTErejectRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEregistrationRequestResponseTimer);
		StorageDel->x25PLE_DTEregistrationRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DTEregistrationRequestRetransmissionCount);
		StorageDel->x25PLE_DTEregistrationRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLE_DTETable_add(struct x25PLE_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLE_DTETable table data set.
 *
 * Adds a table row structure to the x25PLE_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLE_DTETable_add(struct x25PLE_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "x25PLE_DTETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		header_complex_add_data(&x25PLE_DTETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLE_DTETable_del(struct x25PLE_DTETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the x25PLE_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLE_DTETable_del(struct x25PLE_DTETable_data *thedata)
{
	struct x25PLE_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLE_DTETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLE_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLE_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLE_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLE_DTETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLE_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLE_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLE_DTETable_data *StorageTmp = x25PLE_DTETable_create();

	DEBUGMSGTL(("dlMIB", "parse_x25PLE_DTETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DTEcallDeflectionSubscription, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLE_DTEcallRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEcallRequestResponseTimer, &StorageTmp->x25PLE_DTEcallRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTEcallRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEcallRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEextendedPacketSequenceNumbering);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEextendedPacketSequenceNumbering, &StorageTmp->x25PLE_DTEextendedPacketSequenceNumberingLen);
	if (StorageTmp->x25PLE_DTEextendedPacketSequenceNumbering == NULL) {
		config_perror("invalid specification for x25PLE_DTEextendedPacketSequenceNumbering");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEmaxActiveCircuits);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEmaxActiveCircuits, &StorageTmp->x25PLE_DTEmaxActiveCircuitsLen);
	if (StorageTmp->x25PLE_DTEmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLE_DTEmaxActiveCircuits");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEminimumRecallTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEminimumRecallTimer, &StorageTmp->x25PLE_DTEminimumRecallTimerLen);
	if (StorageTmp->x25PLE_DTEminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEminimumRecallTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEresetRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEresetRequestResponseTimer, &StorageTmp->x25PLE_DTEresetRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTEresetRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEresetRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTErestartRequestRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTErestartRequestRetransmissionCount, &StorageTmp->x25PLE_DTErestartRequestRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTErestartRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTErestartRequestRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTErestartRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTErestartRequestResponseTimer, &StorageTmp->x25PLE_DTErestartRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTErestartRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTErestartRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEclearRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEclearRequestResponseTimer, &StorageTmp->x25PLE_DTEclearRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTEclearRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEclearRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEinterruptResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEinterruptResponseTimer, &StorageTmp->x25PLE_DTEinterruptResponseTimerLen);
	if (StorageTmp->x25PLE_DTEinterruptResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEinterruptResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEresetRequestRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEresetRequestRetransmissionCount, &StorageTmp->x25PLE_DTEresetRequestRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTEresetRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTEresetRequestRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEclearRequestRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEclearRequestRetransmissionCount, &StorageTmp->x25PLE_DTEclearRequestRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTEclearRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTEclearRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEcallAttempts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEprotocolErrorsDetectedLocally, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEprotocolErrorsAccusedOf, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEcallEstablishmentRetryCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEcallTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEcallsConnected, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEclearCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEclearTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEdataRetransmissionTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DTErestartCountsExceeded, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLE_DTEwindowStatusTransmissionTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEwindowStatusTransmissionTimer, &StorageTmp->x25PLE_DTEwindowStatusTransmissionTimerLen);
	if (StorageTmp->x25PLE_DTEwindowStatusTransmissionTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEwindowStatusTransmissionTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEwindowRotationTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEwindowRotationTimer, &StorageTmp->x25PLE_DTEwindowRotationTimerLen);
	if (StorageTmp->x25PLE_DTEwindowRotationTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEwindowRotationTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEdataPacketRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEdataPacketRetransmissionCount, &StorageTmp->x25PLE_DTEdataPacketRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTEdataPacketRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTEdataPacketRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTErejectResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTErejectResponseTimer, &StorageTmp->x25PLE_DTErejectResponseTimerLen);
	if (StorageTmp->x25PLE_DTErejectResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTErejectResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTErejectRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTErejectRetransmissionCount, &StorageTmp->x25PLE_DTErejectRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTErejectRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTErejectRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEregistrationRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEregistrationRequestResponseTimer, &StorageTmp->x25PLE_DTEregistrationRequestResponseTimerLen);
	if (StorageTmp->x25PLE_DTEregistrationRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLE_DTEregistrationRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCount, &StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCountLen);
	if (StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLE_DTEregistrationRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DTEregistrationPermitted, &tmpsize);
	x25PLE_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_x25PLE_DTETable(): store configuraiton file for x25PLE_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLE_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLE_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_x25PLE_DTETable: storing data...  "));
	refresh_x25PLE_DTETable(1);
	(void) tmpsize;
	for (hcindex = x25PLE_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLE_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLE_DTETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DTEcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEcallRequestResponseTimer, &StorageTmp->x25PLE_DTEcallRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEextendedPacketSequenceNumbering, &StorageTmp->x25PLE_DTEextendedPacketSequenceNumberingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEmaxActiveCircuits, &StorageTmp->x25PLE_DTEmaxActiveCircuitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEminimumRecallTimer, &StorageTmp->x25PLE_DTEminimumRecallTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEresetRequestResponseTimer, &StorageTmp->x25PLE_DTEresetRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTErestartRequestRetransmissionCount, &StorageTmp->x25PLE_DTErestartRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTErestartRequestResponseTimer, &StorageTmp->x25PLE_DTErestartRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEclearRequestResponseTimer, &StorageTmp->x25PLE_DTEclearRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEinterruptResponseTimer, &StorageTmp->x25PLE_DTEinterruptResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEresetRequestRetransmissionCount, &StorageTmp->x25PLE_DTEresetRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEclearRequestRetransmissionCount, &StorageTmp->x25PLE_DTEclearRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEcallAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEprotocolErrorsDetectedLocally, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEprotocolErrorsAccusedOf, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEcallEstablishmentRetryCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEcallTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEclearCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEclearTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEdataRetransmissionTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DTErestartCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEwindowStatusTransmissionTimer, &StorageTmp->x25PLE_DTEwindowStatusTransmissionTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEwindowRotationTimer, &StorageTmp->x25PLE_DTEwindowRotationTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEdataPacketRetransmissionCount, &StorageTmp->x25PLE_DTEdataPacketRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTErejectResponseTimer, &StorageTmp->x25PLE_DTErejectResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTErejectRetransmissionCount, &StorageTmp->x25PLE_DTErejectRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEregistrationRequestResponseTimer, &StorageTmp->x25PLE_DTEregistrationRequestResponseTimerLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCount,
						   &StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DTEregistrationPermitted, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLE_DCETable_data *x25PLE_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLE_DCETable table.
 *
 * Creates a new x25PLE_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLE_DCETable_data *
x25PLE_DCETable_create(void)
{
	struct x25PLE_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLE_DCETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLE_DCETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		StorageNew->x25PLE_DCEcallAttempts = 0;
		StorageNew->x25PLE_DCEcallsConnected = 0;
		StorageNew->x25PLE_DCEcUG = 0;
		StorageNew->x25PLE_DCEfastSelectAcceptance = 0;
		StorageNew->x25PLE_DCEincomingCallsBarred = 0;
		StorageNew->x25PLE_DCEoneWayLogicalChannelOutgoing = 0;
		StorageNew->x25PLE_DCEoutgoingCallsBarred = 0;
		StorageNew->x25PLE_DCEdataPacketsReceived = 0;
		StorageNew->x25PLE_DCEdataPacketsSent = 0;
		StorageNew->x25PLE_DCEinterruptPacketsReceived = 0;
		StorageNew->x25PLE_DCEinterruptPacketsSent = 0;
		StorageNew->x25PLE_DCEinterruptTimerExpiries = 0;
		StorageNew->x25PLE_DCEoctetsReceivedCounter = 0;
		StorageNew->x25PLE_DCEoctetsSentCounter = 0;
		StorageNew->x25PLE_DCEproviderInitiatedDisconnects = 0;
		StorageNew->x25PLE_DCEproviderInitiatedResets = 0;
		StorageNew->x25PLE_DCEremotelyInitiatedRestarts = 0;
		StorageNew->x25PLE_DCEremotelyInitiatedResets = 0;
		StorageNew->x25PLE_DCEresetTimeouts = 0;
		StorageNew->x25PLE_DCEx25SegmentsReceived = 0;
		StorageNew->x25PLE_DCEx25SegmentsSent = 0;
		StorageNew->x25PLE_DCEbilateralCUG = 0;
		StorageNew->x25PLE_DCEbilateralCUGWithOutgoingAccess = 0;
		StorageNew->x25PLE_DCEcallDeflectionSubscription = 0;
		StorageNew->x25PLE_DCEcallRedirection = 0;
		StorageNew->x25PLE_DCEchargingInformation = 0;
		StorageNew->x25PLE_DCEcUGWithIncomingAccess = 0;
		StorageNew->x25PLE_DCEcUGWithOutgoingAccess = 0;
		StorageNew->x25PLE_DCEdBitModification = 0;
		if ((StorageNew->x25PLE_DCEdefaultThroughputClassesAssignment = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DCEdefaultThroughputClassesAssignmentLen = strlen("");
		if ((StorageNew->x25PLE_DCEextendedPacketSequenceNumbering = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DCEextendedPacketSequenceNumberingLen = strlen("");
		StorageNew->x25PLE_DCEhuntGroup = 0;
		StorageNew->x25PLE_DCEincomingCallBarredWithinCUG = 0;
		StorageNew->x25PLE_DCElocalChargingPrevention = 0;
		if ((StorageNew->x25PLE_DCEnonStandardDefaultPacketSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DCEnonStandardDefaultPacketSizesLen = strlen("");
		if ((StorageNew->x25PLE_DCEnonStandardDefaultWindowSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DCEnonStandardDefaultWindowSizesLen = strlen("");
		StorageNew->x25PLE_DCEnUIOverride = 0;
		StorageNew->x25PLE_DCEnUISubscription = 0;
		StorageNew->x25PLE_DCEoneWayLogicalChannelIncoming = 0;
		StorageNew->x25PLE_DCEonlineFacilityRegistration = 0;
		StorageNew->x25PLE_DCEoutgoingCallBarredWithinCUG = 0;
		StorageNew->x25PLE_DCEpacketRetransmission = 0;
		StorageNew->x25PLE_DCEreverseChargingAcceptance = 0;
		StorageNew->x25PLE_DCErOASubscription = 0;
		StorageNew->x25PLE_DCEclearIndication = 0;
		if ((StorageNew->x25PLE_DCEincomingCall = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DCEincomingCallLen = strlen("");
		if ((StorageNew->x25PLE_DCEresetIndication = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DCEresetIndicationLen = strlen("");
		if ((StorageNew->x25PLE_DCErestartIndication = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLE_DCErestartIndicationLen = strlen("");

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct x25PLE_DCETable_data *x25PLE_DCETable_duplicate(struct x25PLE_DCETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct x25PLE_DCETable_data *
x25PLE_DCETable_duplicate(struct x25PLE_DCETable_data *thedata)
{
	struct x25PLE_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLE_DCETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLE_DCETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	x25PLE_DCETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int x25PLE_DCETable_destroy(struct x25PLE_DCETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLE_DCETable_destroy(struct x25PLE_DCETable_data **thedata)
{
	struct x25PLE_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLE_DCETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEdefaultThroughputClassesAssignment);
		StorageDel->x25PLE_DCEdefaultThroughputClassesAssignmentLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEextendedPacketSequenceNumbering);
		StorageDel->x25PLE_DCEextendedPacketSequenceNumberingLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEnonStandardDefaultPacketSizes);
		StorageDel->x25PLE_DCEnonStandardDefaultPacketSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEnonStandardDefaultWindowSizes);
		StorageDel->x25PLE_DCEnonStandardDefaultWindowSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEincomingCall);
		StorageDel->x25PLE_DCEincomingCallLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCEresetIndication);
		StorageDel->x25PLE_DCEresetIndicationLen = 0;
		SNMP_FREE(StorageDel->x25PLE_DCErestartIndication);
		StorageDel->x25PLE_DCErestartIndicationLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLE_DCETable_add(struct x25PLE_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLE_DCETable table data set.
 *
 * Adds a table row structure to the x25PLE_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLE_DCETable_add(struct x25PLE_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "x25PLE_DCETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		header_complex_add_data(&x25PLE_DCETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLE_DCETable_del(struct x25PLE_DCETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the x25PLE_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLE_DCETable_del(struct x25PLE_DCETable_data *thedata)
{
	struct x25PLE_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLE_DCETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLE_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLE_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLE_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLE_DCETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLE_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLE_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLE_DCETable_data *StorageTmp = x25PLE_DCETable_create();

	DEBUGMSGTL(("dlMIB", "parse_x25PLE_DCETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEcallAttempts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEcallsConnected, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEfastSelectAcceptance, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEincomingCallsBarred, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEoneWayLogicalChannelOutgoing, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEoutgoingCallsBarred, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEinterruptPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEinterruptPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEinterruptTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEx25SegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLE_DCEx25SegmentsSent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEbilateralCUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEbilateralCUGWithOutgoingAccess, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcallRedirection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEchargingInformation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcUGWithIncomingAccess, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEcUGWithOutgoingAccess, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEdBitModification, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignment);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignment, &StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignmentLen);
	if (StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignment == NULL) {
		config_perror("invalid specification for x25PLE_DCEdefaultThroughputClassesAssignment");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DCEextendedPacketSequenceNumbering);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEextendedPacketSequenceNumbering, &StorageTmp->x25PLE_DCEextendedPacketSequenceNumberingLen);
	if (StorageTmp->x25PLE_DCEextendedPacketSequenceNumbering == NULL) {
		config_perror("invalid specification for x25PLE_DCEextendedPacketSequenceNumbering");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEhuntGroup, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEincomingCallBarredWithinCUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCElocalChargingPrevention, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizes, &StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizesLen);
	if (StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizes == NULL) {
		config_perror("invalid specification for x25PLE_DCEnonStandardDefaultPacketSizes");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizes, &StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizesLen);
	if (StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizes == NULL) {
		config_perror("invalid specification for x25PLE_DCEnonStandardDefaultWindowSizes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEnUIOverride, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEnUISubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEoneWayLogicalChannelIncoming, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEonlineFacilityRegistration, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEoutgoingCallBarredWithinCUG, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEpacketRetransmission, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEreverseChargingAcceptance, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCErOASubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLE_DCEclearIndication, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLE_DCEincomingCall);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEincomingCall, &StorageTmp->x25PLE_DCEincomingCallLen);
	if (StorageTmp->x25PLE_DCEincomingCall == NULL) {
		config_perror("invalid specification for x25PLE_DCEincomingCall");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DCEresetIndication);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCEresetIndication, &StorageTmp->x25PLE_DCEresetIndicationLen);
	if (StorageTmp->x25PLE_DCEresetIndication == NULL) {
		config_perror("invalid specification for x25PLE_DCEresetIndication");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLE_DCErestartIndication);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLE_DCErestartIndication, &StorageTmp->x25PLE_DCErestartIndicationLen);
	if (StorageTmp->x25PLE_DCErestartIndication == NULL) {
		config_perror("invalid specification for x25PLE_DCErestartIndication");
		return;
	}
	x25PLE_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_x25PLE_DCETable(): store configuraiton file for x25PLE_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLE_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLE_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_x25PLE_DCETable: storing data...  "));
	refresh_x25PLE_DCETable(1);
	(void) tmpsize;
	for (hcindex = x25PLE_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLE_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLE_DCETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEcallAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEfastSelectAcceptance, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEincomingCallsBarred, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEoneWayLogicalChannelOutgoing, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEoutgoingCallsBarred, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEinterruptPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEinterruptPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEinterruptTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEx25SegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLE_DCEx25SegmentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEbilateralCUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEbilateralCUGWithOutgoingAccess, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcallRedirection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEchargingInformation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcUGWithIncomingAccess, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEcUGWithOutgoingAccess, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEdBitModification, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignment, &StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignmentLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEextendedPacketSequenceNumbering, &StorageTmp->x25PLE_DCEextendedPacketSequenceNumberingLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEhuntGroup, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEincomingCallBarredWithinCUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCElocalChargingPrevention, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizes, &StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizes, &StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEnUIOverride, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEnUISubscription, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEoneWayLogicalChannelIncoming, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEonlineFacilityRegistration, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEoutgoingCallBarredWithinCUG, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEpacketRetransmission, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEreverseChargingAcceptance, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCErOASubscription, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLE_DCEclearIndication, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEincomingCall, &StorageTmp->x25PLE_DCEincomingCallLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCEresetIndication, &StorageTmp->x25PLE_DCEresetIndicationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLE_DCErestartIndication, &StorageTmp->x25PLE_DCErestartIndicationLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMOTable_data *x25PLEIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMOTable table.
 *
 * Creates a new x25PLEIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMOTable_data *
x25PLEIVMOTable_create(void)
{
	struct x25PLEIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMOTable_data);

	DEBUGMSGTL(("dlMIB", "x25PLEIVMOTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEIVMOlocalDTEAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOlocalDTEAddressLen = strlen("");
		if ((StorageNew->x25PLEIVMOlogicalChannelAssignments = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOlogicalChannelAssignmentsLen = strlen("");
		if ((StorageNew->x25PLEIVMOsN_ServiceProvider = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOsN_ServiceProviderLen = strlen("");
		if ((StorageNew->x25PLEIVMOdefaultPacketSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOdefaultPacketSizesLen = strlen("");
		if ((StorageNew->x25PLEIVMOdefaultThroughputClasses = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOdefaultThroughputClassesLen = strlen("");
		if ((StorageNew->x25PLEIVMOdefaultWindowSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOdefaultWindowSizesLen = strlen("");
		if ((StorageNew->x25PLEIVMOflowControlParameterNegotiation = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOflowControlParameterNegotiationLen = strlen("");
		if ((StorageNew->x25PLEIVMOthroughputClassNegotiation = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOthroughputClassNegotiationLen = strlen("");
		if ((StorageNew->x25PLEIVMOx25PLEMode = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOx25PLEModeLen = strlen("");
		StorageNew->x25PLEIVMOinterfaceMode = 0;
		if ((StorageNew->x25PLEIVMOdefaultThroughputClass = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOdefaultThroughputClassLen = strlen("");
		if ((StorageNew->x25PLEIVMOflowControlNegotiationPermitted = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOflowControlNegotiationPermittedLen = strlen("");
		StorageNew->x25PLEIVMOcallDeflectionSubscription = 0;
		if ((StorageNew->x25PLEIVMOmaxActiveCircuits = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOmaxActiveCircuitsLen = strlen("");
		if ((StorageNew->x25PLEIVMOrestartTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOrestartTimeLen = strlen("");
		if ((StorageNew->x25PLEIVMOdefaultPacketSize = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOdefaultPacketSizeLen = strlen("");
		if ((StorageNew->x25PLEIVMOdefaultWindowSize = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOdefaultWindowSizeLen = strlen("");
		if ((StorageNew->x25PLEIVMOminimumRecallTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOminimumRecallTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMOrestartCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOrestartCountLen = strlen("");
		if ((StorageNew->x25PLEIVMOpacketSequencing = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOpacketSequencingLen = strlen("");
		if ((StorageNew->x25PLEIVMOregistrationRequestTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOregistrationRequestTimeLen = strlen("");
		if ((StorageNew->x25PLEIVMOregistrationRequestCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOregistrationRequestCountLen = strlen("");
		StorageNew->x25PLEIVMOregistrationPermitted = 0;
		StorageNew->x25PLEIVMORowStatus = 0;
		StorageNew->x25PLEIVMORowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct x25PLEIVMOTable_data *x25PLEIVMOTable_duplicate(struct x25PLEIVMOTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct x25PLEIVMOTable_data *
x25PLEIVMOTable_duplicate(struct x25PLEIVMOTable_data *thedata)
{
	struct x25PLEIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMOTable_data);

	DEBUGMSGTL(("dlMIB", "x25PLEIVMOTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	x25PLEIVMOTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int x25PLEIVMOTable_destroy(struct x25PLEIVMOTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMOTable_destroy(struct x25PLEIVMOTable_data **thedata)
{
	struct x25PLEIVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLEIVMOTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOlocalDTEAddress);
		StorageDel->x25PLEIVMOlocalDTEAddressLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOlogicalChannelAssignments);
		StorageDel->x25PLEIVMOlogicalChannelAssignmentsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOsN_ServiceProvider);
		StorageDel->x25PLEIVMOsN_ServiceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultPacketSizes);
		StorageDel->x25PLEIVMOdefaultPacketSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultThroughputClasses);
		StorageDel->x25PLEIVMOdefaultThroughputClassesLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultWindowSizes);
		StorageDel->x25PLEIVMOdefaultWindowSizesLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOflowControlParameterNegotiation);
		StorageDel->x25PLEIVMOflowControlParameterNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOthroughputClassNegotiation);
		StorageDel->x25PLEIVMOthroughputClassNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOx25PLEMode);
		StorageDel->x25PLEIVMOx25PLEModeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultThroughputClass);
		StorageDel->x25PLEIVMOdefaultThroughputClassLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOflowControlNegotiationPermitted);
		StorageDel->x25PLEIVMOflowControlNegotiationPermittedLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOmaxActiveCircuits);
		StorageDel->x25PLEIVMOmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOrestartTime);
		StorageDel->x25PLEIVMOrestartTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultPacketSize);
		StorageDel->x25PLEIVMOdefaultPacketSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOdefaultWindowSize);
		StorageDel->x25PLEIVMOdefaultWindowSizeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOminimumRecallTimer);
		StorageDel->x25PLEIVMOminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOrestartCount);
		StorageDel->x25PLEIVMOrestartCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOpacketSequencing);
		StorageDel->x25PLEIVMOpacketSequencingLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOregistrationRequestTime);
		StorageDel->x25PLEIVMOregistrationRequestTimeLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOregistrationRequestCount);
		StorageDel->x25PLEIVMOregistrationRequestCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMOTable_add(struct x25PLEIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMOTable table data set.
 *
 * Adds a table row structure to the x25PLEIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMOTable_add(struct x25PLEIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "x25PLEIVMOTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEIVMOId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId, thedata->x25PLEIVMOIdLen);
		header_complex_add_data(&x25PLEIVMOTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMOTable_del(struct x25PLEIVMOTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the x25PLEIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMOTable_del(struct x25PLEIVMOTable_data *thedata)
{
	struct x25PLEIVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLEIVMOTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLEIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMOTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp = x25PLEIVMOTable_create();

	DEBUGMSGTL(("dlMIB", "parse_x25PLEIVMOTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEIVMOId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOlocalDTEAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOlocalDTEAddress, &StorageTmp->x25PLEIVMOlocalDTEAddressLen);
	if (StorageTmp->x25PLEIVMOlocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLEIVMOlocalDTEAddress");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOlogicalChannelAssignments);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOlogicalChannelAssignments, &StorageTmp->x25PLEIVMOlogicalChannelAssignmentsLen);
	if (StorageTmp->x25PLEIVMOlogicalChannelAssignments == NULL) {
		config_perror("invalid specification for x25PLEIVMOlogicalChannelAssignments");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOsN_ServiceProvider);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOsN_ServiceProvider, &StorageTmp->x25PLEIVMOsN_ServiceProviderLen);
	if (StorageTmp->x25PLEIVMOsN_ServiceProvider == NULL) {
		config_perror("invalid specification for x25PLEIVMOsN_ServiceProvider");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOdefaultPacketSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultPacketSizes, &StorageTmp->x25PLEIVMOdefaultPacketSizesLen);
	if (StorageTmp->x25PLEIVMOdefaultPacketSizes == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultPacketSizes");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOdefaultThroughputClasses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultThroughputClasses, &StorageTmp->x25PLEIVMOdefaultThroughputClassesLen);
	if (StorageTmp->x25PLEIVMOdefaultThroughputClasses == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultThroughputClasses");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOdefaultWindowSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultWindowSizes, &StorageTmp->x25PLEIVMOdefaultWindowSizesLen);
	if (StorageTmp->x25PLEIVMOdefaultWindowSizes == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultWindowSizes");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOflowControlParameterNegotiation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOflowControlParameterNegotiation, &StorageTmp->x25PLEIVMOflowControlParameterNegotiationLen);
	if (StorageTmp->x25PLEIVMOflowControlParameterNegotiation == NULL) {
		config_perror("invalid specification for x25PLEIVMOflowControlParameterNegotiation");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOthroughputClassNegotiation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOthroughputClassNegotiation, &StorageTmp->x25PLEIVMOthroughputClassNegotiationLen);
	if (StorageTmp->x25PLEIVMOthroughputClassNegotiation == NULL) {
		config_perror("invalid specification for x25PLEIVMOthroughputClassNegotiation");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOx25PLEMode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOx25PLEMode, &StorageTmp->x25PLEIVMOx25PLEModeLen);
	if (StorageTmp->x25PLEIVMOx25PLEMode == NULL) {
		config_perror("invalid specification for x25PLEIVMOx25PLEMode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOinterfaceMode, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLEIVMOdefaultThroughputClass);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultThroughputClass, &StorageTmp->x25PLEIVMOdefaultThroughputClassLen);
	if (StorageTmp->x25PLEIVMOdefaultThroughputClass == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultThroughputClass");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOflowControlNegotiationPermitted);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOflowControlNegotiationPermitted, &StorageTmp->x25PLEIVMOflowControlNegotiationPermittedLen);
	if (StorageTmp->x25PLEIVMOflowControlNegotiationPermitted == NULL) {
		config_perror("invalid specification for x25PLEIVMOflowControlNegotiationPermitted");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOcallDeflectionSubscription, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLEIVMOmaxActiveCircuits);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOmaxActiveCircuits, &StorageTmp->x25PLEIVMOmaxActiveCircuitsLen);
	if (StorageTmp->x25PLEIVMOmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLEIVMOmaxActiveCircuits");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOrestartTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOrestartTime, &StorageTmp->x25PLEIVMOrestartTimeLen);
	if (StorageTmp->x25PLEIVMOrestartTime == NULL) {
		config_perror("invalid specification for x25PLEIVMOrestartTime");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOdefaultPacketSize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultPacketSize, &StorageTmp->x25PLEIVMOdefaultPacketSizeLen);
	if (StorageTmp->x25PLEIVMOdefaultPacketSize == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultPacketSize");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOdefaultWindowSize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOdefaultWindowSize, &StorageTmp->x25PLEIVMOdefaultWindowSizeLen);
	if (StorageTmp->x25PLEIVMOdefaultWindowSize == NULL) {
		config_perror("invalid specification for x25PLEIVMOdefaultWindowSize");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOminimumRecallTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOminimumRecallTimer, &StorageTmp->x25PLEIVMOminimumRecallTimerLen);
	if (StorageTmp->x25PLEIVMOminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMOminimumRecallTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOrestartCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOrestartCount, &StorageTmp->x25PLEIVMOrestartCountLen);
	if (StorageTmp->x25PLEIVMOrestartCount == NULL) {
		config_perror("invalid specification for x25PLEIVMOrestartCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOpacketSequencing);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOpacketSequencing, &StorageTmp->x25PLEIVMOpacketSequencingLen);
	if (StorageTmp->x25PLEIVMOpacketSequencing == NULL) {
		config_perror("invalid specification for x25PLEIVMOpacketSequencing");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOregistrationRequestTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOregistrationRequestTime, &StorageTmp->x25PLEIVMOregistrationRequestTimeLen);
	if (StorageTmp->x25PLEIVMOregistrationRequestTime == NULL) {
		config_perror("invalid specification for x25PLEIVMOregistrationRequestTime");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMOregistrationRequestCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOregistrationRequestCount, &StorageTmp->x25PLEIVMOregistrationRequestCountLen);
	if (StorageTmp->x25PLEIVMOregistrationRequestCount == NULL) {
		config_perror("invalid specification for x25PLEIVMOregistrationRequestCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOregistrationPermitted, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMORowStatus, &tmpsize);
	x25PLEIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_x25PLEIVMOTable(): store configuraiton file for x25PLEIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_x25PLEIVMOTable: storing data...  "));
	refresh_x25PLEIVMOTable(1);
	(void) tmpsize;
	for (hcindex = x25PLEIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMOTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOlocalDTEAddress, &StorageTmp->x25PLEIVMOlocalDTEAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOlogicalChannelAssignments, &StorageTmp->x25PLEIVMOlogicalChannelAssignmentsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOsN_ServiceProvider, &StorageTmp->x25PLEIVMOsN_ServiceProviderLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultPacketSizes, &StorageTmp->x25PLEIVMOdefaultPacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultThroughputClasses, &StorageTmp->x25PLEIVMOdefaultThroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultWindowSizes, &StorageTmp->x25PLEIVMOdefaultWindowSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOflowControlParameterNegotiation, &StorageTmp->x25PLEIVMOflowControlParameterNegotiationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOthroughputClassNegotiation, &StorageTmp->x25PLEIVMOthroughputClassNegotiationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOx25PLEMode, &StorageTmp->x25PLEIVMOx25PLEModeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOinterfaceMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultThroughputClass, &StorageTmp->x25PLEIVMOdefaultThroughputClassLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOflowControlNegotiationPermitted, &StorageTmp->x25PLEIVMOflowControlNegotiationPermittedLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOmaxActiveCircuits, &StorageTmp->x25PLEIVMOmaxActiveCircuitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOrestartTime, &StorageTmp->x25PLEIVMOrestartTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultPacketSize, &StorageTmp->x25PLEIVMOdefaultPacketSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOdefaultWindowSize, &StorageTmp->x25PLEIVMOdefaultWindowSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOminimumRecallTimer, &StorageTmp->x25PLEIVMOminimumRecallTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOrestartCount, &StorageTmp->x25PLEIVMOrestartCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOpacketSequencing, &StorageTmp->x25PLEIVMOpacketSequencingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOregistrationRequestTime, &StorageTmp->x25PLEIVMOregistrationRequestTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOregistrationRequestCount, &StorageTmp->x25PLEIVMOregistrationRequestCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOregistrationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMO_DTETable_data *x25PLEIVMO_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMO_DTETable table.
 *
 * Creates a new x25PLEIVMO_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMO_DTETable_data *
x25PLEIVMO_DTETable_create(void)
{
	struct x25PLEIVMO_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMO_DTETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DTETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEIVMOId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOIdLen = strlen("");
		StorageNew->x25PLEIVMO_DTEcallDeflectionSubscription = 0;
		if ((StorageNew->x25PLEIVMO_DTEcallRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEcallRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEextendedPacketSequenceNumbering = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEextendedPacketSequenceNumberingLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEmaxActiveCircuits = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEmaxActiveCircuitsLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEminimumRecallTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEminimumRecallTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEresetRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEresetRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTErestartRequestRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTErestartRequestRetransmissionCountLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTErestartRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTErestartRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEclearRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEclearRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEinterruptResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEinterruptResponseTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEresetRequestRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEresetRequestRetransmissionCountLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEclearRequestRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEclearRequestRetransmissionCountLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEcallAttempts = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEcallAttemptsLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEprotocolErrorsDetectedLocally = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEprotocolErrorsDetectedLocallyLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEprotocolErrorsAccusedOf = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEprotocolErrorsAccusedOfLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceededLen = strlen("");
		StorageNew->x25PLEIVMO_DTEoctetsReceivedCounter = 0;
		StorageNew->x25PLEIVMO_DTEoctetsSentCounter = 0;
		StorageNew->x25PLEIVMO_DTEcallTimeouts = 0;
		StorageNew->x25PLEIVMO_DTEcallsConnected = 0;
		StorageNew->x25PLEIVMO_DTEclearCountsExceeded = 0;
		StorageNew->x25PLEIVMO_DTEclearTimeouts = 0;
		StorageNew->x25PLEIVMO_DTEdataPacketsReceived = 0;
		StorageNew->x25PLEIVMO_DTEdataPacketsSent = 0;
		StorageNew->x25PLEIVMO_DTEdataRetransmissionTimerExpiries = 0;
		StorageNew->x25PLEIVMO_DTEproviderInitiatedResets = 0;
		StorageNew->x25PLEIVMO_DTEproviderInitiatedDisconnects = 0;
		StorageNew->x25PLEIVMO_DTEremotelyInitiatedResets = 0;
		StorageNew->x25PLEIVMO_DTEremotelyInitiatedRestarts = 0;
		StorageNew->x25PLEIVMO_DTEresetTimeouts = 0;
		StorageNew->x25PLEIVMO_DTErestartCountsExceeded = 0;
		if ((StorageNew->x25PLEIVMO_DTEwindowStatusTransmissionTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEwindowStatusTransmissionTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEwindowRotationTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEwindowRotationTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEdataPacketRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEdataPacketRetransmissionCountLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTErejectResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTErejectResponseTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTErejectRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTErejectRetransmissionCountLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEregistrationRequestResponseTimer = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEregistrationRequestResponseTimerLen = strlen("");
		if ((StorageNew->x25PLEIVMO_DTEregistrationRequestRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMO_DTEregistrationRequestRetransmissionCountLen = strlen("");
		StorageNew->x25PLEIVMO_DTEregistrationPermitted = 0;
		StorageNew->x25PLEIVMO_DTERowStatus = 0;
		StorageNew->x25PLEIVMO_DTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct x25PLEIVMO_DTETable_data *x25PLEIVMO_DTETable_duplicate(struct x25PLEIVMO_DTETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct x25PLEIVMO_DTETable_data *
x25PLEIVMO_DTETable_duplicate(struct x25PLEIVMO_DTETable_data *thedata)
{
	struct x25PLEIVMO_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMO_DTETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DTETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	x25PLEIVMO_DTETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int x25PLEIVMO_DTETable_destroy(struct x25PLEIVMO_DTETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMO_DTETable_destroy(struct x25PLEIVMO_DTETable_data **thedata)
{
	struct x25PLEIVMO_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DTETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEcallRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTEcallRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEextendedPacketSequenceNumbering);
		StorageDel->x25PLEIVMO_DTEextendedPacketSequenceNumberingLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEmaxActiveCircuits);
		StorageDel->x25PLEIVMO_DTEmaxActiveCircuitsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEminimumRecallTimer);
		StorageDel->x25PLEIVMO_DTEminimumRecallTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEresetRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTEresetRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTErestartRequestRetransmissionCount);
		StorageDel->x25PLEIVMO_DTErestartRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTErestartRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTErestartRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEclearRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTEclearRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEinterruptResponseTimer);
		StorageDel->x25PLEIVMO_DTEinterruptResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEresetRequestRetransmissionCount);
		StorageDel->x25PLEIVMO_DTEresetRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEclearRequestRetransmissionCount);
		StorageDel->x25PLEIVMO_DTEclearRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEcallAttempts);
		StorageDel->x25PLEIVMO_DTEcallAttemptsLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEprotocolErrorsDetectedLocally);
		StorageDel->x25PLEIVMO_DTEprotocolErrorsDetectedLocallyLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEprotocolErrorsAccusedOf);
		StorageDel->x25PLEIVMO_DTEprotocolErrorsAccusedOfLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded);
		StorageDel->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceededLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEwindowStatusTransmissionTimer);
		StorageDel->x25PLEIVMO_DTEwindowStatusTransmissionTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEwindowRotationTimer);
		StorageDel->x25PLEIVMO_DTEwindowRotationTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEdataPacketRetransmissionCount);
		StorageDel->x25PLEIVMO_DTEdataPacketRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTErejectResponseTimer);
		StorageDel->x25PLEIVMO_DTErejectResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTErejectRetransmissionCount);
		StorageDel->x25PLEIVMO_DTErejectRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEregistrationRequestResponseTimer);
		StorageDel->x25PLEIVMO_DTEregistrationRequestResponseTimerLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMO_DTEregistrationRequestRetransmissionCount);
		StorageDel->x25PLEIVMO_DTEregistrationRequestRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMO_DTETable_add(struct x25PLEIVMO_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMO_DTETable table data set.
 *
 * Adds a table row structure to the x25PLEIVMO_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMO_DTETable_add(struct x25PLEIVMO_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DTETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEIVMOId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId, thedata->x25PLEIVMOIdLen);
		header_complex_add_data(&x25PLEIVMO_DTETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMO_DTETable_del(struct x25PLEIVMO_DTETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the x25PLEIVMO_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMO_DTETable_del(struct x25PLEIVMO_DTETable_data *thedata)
{
	struct x25PLEIVMO_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DTETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLEIVMO_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMO_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMO_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMO_DTETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMO_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMO_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMO_DTETable_data *StorageTmp = x25PLEIVMO_DTETable_create();

	DEBUGMSGTL(("dlMIB", "parse_x25PLEIVMO_DTETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEIVMOId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO_DTEcallDeflectionSubscription, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEcallRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumbering);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumbering, &StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumberingLen);
	if (StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumbering == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEextendedPacketSequenceNumbering");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEmaxActiveCircuits);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEmaxActiveCircuits, &StorageTmp->x25PLEIVMO_DTEmaxActiveCircuitsLen);
	if (StorageTmp->x25PLEIVMO_DTEmaxActiveCircuits == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEmaxActiveCircuits");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEminimumRecallTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEminimumRecallTimer, &StorageTmp->x25PLEIVMO_DTEminimumRecallTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEminimumRecallTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEminimumRecallTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEresetRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTErestartRequestRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTErestartRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEclearRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEinterruptResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEinterruptResponseTimer, &StorageTmp->x25PLEIVMO_DTEinterruptResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEinterruptResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEinterruptResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEresetRequestRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEclearRequestRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEcallAttempts);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEcallAttempts, &StorageTmp->x25PLEIVMO_DTEcallAttemptsLen);
	if (StorageTmp->x25PLEIVMO_DTEcallAttempts == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEcallAttempts");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocally);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocally, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocallyLen);
	if (StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocally == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEprotocolErrorsDetectedLocally");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOf);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOf, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOfLen);
	if (StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOf == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEprotocolErrorsAccusedOf");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded, &StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceededLen);
	if (StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEcallTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEcallsConnected, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEclearCountsExceeded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEclearTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEdataRetransmissionTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->x25PLEIVMO_DTErestartCountsExceeded, &tmpsize);
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimer, &StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEwindowStatusTransmissionTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEwindowRotationTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEwindowRotationTimer, &StorageTmp->x25PLEIVMO_DTEwindowRotationTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEwindowRotationTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEwindowRotationTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEdataPacketRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTErejectResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTErejectResponseTimer, &StorageTmp->x25PLEIVMO_DTErejectResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTErejectResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTErejectResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTErejectRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTErejectRetransmissionCount, &StorageTmp->x25PLEIVMO_DTErejectRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTErejectRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTErejectRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimerLen);
	if (StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimer == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEregistrationRequestResponseTimer");
		return;
	}
	SNMP_FREE(StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCountLen);
	if (StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCount == NULL) {
		config_perror("invalid specification for x25PLEIVMO_DTEregistrationRequestRetransmissionCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO_DTEregistrationPermitted, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO_DTERowStatus, &tmpsize);
	x25PLEIVMO_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_x25PLEIVMO_DTETable(): store configuraiton file for x25PLEIVMO_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMO_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMO_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_x25PLEIVMO_DTETable: storing data...  "));
	refresh_x25PLEIVMO_DTETable(1);
	(void) tmpsize;
	for (hcindex = x25PLEIVMO_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMO_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMO_DTETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO_DTEcallDeflectionSubscription, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumbering, &StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumberingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEmaxActiveCircuits, &StorageTmp->x25PLEIVMO_DTEmaxActiveCircuitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEminimumRecallTimer, &StorageTmp->x25PLEIVMO_DTEminimumRecallTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimerLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEinterruptResponseTimer, &StorageTmp->x25PLEIVMO_DTEinterruptResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEcallAttempts, &StorageTmp->x25PLEIVMO_DTEcallAttemptsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocally, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocallyLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOf, &StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOfLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded,
						   &StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceededLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEcallTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEcallsConnected, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEclearCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEclearTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEdataRetransmissionTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->x25PLEIVMO_DTErestartCountsExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimer, &StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEwindowRotationTimer, &StorageTmp->x25PLEIVMO_DTEwindowRotationTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCount, &StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTErejectResponseTimer, &StorageTmp->x25PLEIVMO_DTErejectResponseTimerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTErejectRetransmissionCount, &StorageTmp->x25PLEIVMO_DTErejectRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimer, &StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimerLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCount,
						   &StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO_DTEregistrationPermitted, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO_DTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMO_DCETable_data *x25PLEIVMO_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMO_DCETable table.
 *
 * Creates a new x25PLEIVMO_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMO_DCETable_data *
x25PLEIVMO_DCETable_create(void)
{
	struct x25PLEIVMO_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMO_DCETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DCETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEIVMOId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIVMOIdLen = strlen("");
		StorageNew->x25PLEIVMO_DCERowStatus = 0;
		StorageNew->x25PLEIVMO_DCERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct x25PLEIVMO_DCETable_data *x25PLEIVMO_DCETable_duplicate(struct x25PLEIVMO_DCETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct x25PLEIVMO_DCETable_data *
x25PLEIVMO_DCETable_duplicate(struct x25PLEIVMO_DCETable_data *thedata)
{
	struct x25PLEIVMO_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMO_DCETable_data);

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DCETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	x25PLEIVMO_DCETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int x25PLEIVMO_DCETable_destroy(struct x25PLEIVMO_DCETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMO_DCETable_destroy(struct x25PLEIVMO_DCETable_data **thedata)
{
	struct x25PLEIVMO_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DCETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMO_DCETable_add(struct x25PLEIVMO_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMO_DCETable table data set.
 *
 * Adds a table row structure to the x25PLEIVMO_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMO_DCETable_add(struct x25PLEIVMO_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DCETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEIVMOId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId, thedata->x25PLEIVMOIdLen);
		header_complex_add_data(&x25PLEIVMO_DCETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMO_DCETable_del(struct x25PLEIVMO_DCETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the x25PLEIVMO_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMO_DCETable_del(struct x25PLEIVMO_DCETable_data *thedata)
{
	struct x25PLEIVMO_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "x25PLEIVMO_DCETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLEIVMO_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMO_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMO_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMO_DCETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMO_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMO_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMO_DCETable_data *StorageTmp = x25PLEIVMO_DCETable_create();

	DEBUGMSGTL(("dlMIB", "parse_x25PLEIVMO_DCETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEIVMOId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMO_DCERowStatus, &tmpsize);
	x25PLEIVMO_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_x25PLEIVMO_DCETable(): store configuraiton file for x25PLEIVMO_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMO_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMO_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_x25PLEIVMO_DCETable: storing data...  "));
	refresh_x25PLEIVMO_DCETable(1);
	(void) tmpsize;
	for (hcindex = x25PLEIVMO_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMO_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMO_DCETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId, &StorageTmp->x25PLEIVMOIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMO_DCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCallTable_data *virtualCallTable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCallTable table.
 *
 * Creates a new virtualCallTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCallTable_data *
virtualCallTable_create(void)
{
	struct virtualCallTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCallTable_data);

	DEBUGMSGTL(("dlMIB", "virtualCallTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->virtualCallChannel = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallChannelLen = strlen("");
		if ((StorageNew->virtualCallPacketSize = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallPacketSizeLen = strlen("");
		if ((StorageNew->virtualCallWindowSize = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallWindowSizeLen = strlen("");
		if ((StorageNew->virtualCallOctetsSentCounter = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallOctetsSentCounterLen = strlen("");
		if ((StorageNew->virtualCallOctetsReceivedCounter = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallOctetsReceivedCounterLen = strlen("");
		if ((StorageNew->virtualCallDataPacketsSent = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallDataPacketsSentLen = strlen("");
		if ((StorageNew->virtualCallDataPacketsReceived = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallDataPacketsReceivedLen = strlen("");
		if ((StorageNew->virtualCallRemotelyInitiatedResets = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallRemotelyInitiatedResetsLen = strlen("");
		if ((StorageNew->virtualCallDataRetransmissionTimerExpiries = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallDataRetransmissionTimerExpiriesLen = strlen("");
		if ((StorageNew->virtualCallProviderInitiatedResets = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallProviderInitiatedResetsLen = strlen("");
		if ((StorageNew->virtualCallResetTimeouts = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallResetTimeoutsLen = strlen("");
		if ((StorageNew->virtualCallInterruptPacketsSent = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallInterruptPacketsSentLen = strlen("");
		if ((StorageNew->virtualCallInterruptPacketsReceived = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallInterruptPacketsReceivedLen = strlen("");
		if ((StorageNew->virtualCallInterruptTimerExpiries = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallInterruptTimerExpiriesLen = strlen("");

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct virtualCallTable_data *virtualCallTable_duplicate(struct virtualCallTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct virtualCallTable_data *
virtualCallTable_duplicate(struct virtualCallTable_data *thedata)
{
	struct virtualCallTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCallTable_data);

	DEBUGMSGTL(("dlMIB", "virtualCallTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	virtualCallTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int virtualCallTable_destroy(struct virtualCallTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCallTable_destroy(struct virtualCallTable_data **thedata)
{
	struct virtualCallTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCallTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCallId);
		StorageDel->virtualCallIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallChannel);
		StorageDel->virtualCallChannelLen = 0;
		SNMP_FREE(StorageDel->virtualCallPacketSize);
		StorageDel->virtualCallPacketSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallWindowSize);
		StorageDel->virtualCallWindowSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallOctetsSentCounter);
		StorageDel->virtualCallOctetsSentCounterLen = 0;
		SNMP_FREE(StorageDel->virtualCallOctetsReceivedCounter);
		StorageDel->virtualCallOctetsReceivedCounterLen = 0;
		SNMP_FREE(StorageDel->virtualCallDataPacketsSent);
		StorageDel->virtualCallDataPacketsSentLen = 0;
		SNMP_FREE(StorageDel->virtualCallDataPacketsReceived);
		StorageDel->virtualCallDataPacketsReceivedLen = 0;
		SNMP_FREE(StorageDel->virtualCallRemotelyInitiatedResets);
		StorageDel->virtualCallRemotelyInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->virtualCallDataRetransmissionTimerExpiries);
		StorageDel->virtualCallDataRetransmissionTimerExpiriesLen = 0;
		SNMP_FREE(StorageDel->virtualCallProviderInitiatedResets);
		StorageDel->virtualCallProviderInitiatedResetsLen = 0;
		SNMP_FREE(StorageDel->virtualCallResetTimeouts);
		StorageDel->virtualCallResetTimeoutsLen = 0;
		SNMP_FREE(StorageDel->virtualCallInterruptPacketsSent);
		StorageDel->virtualCallInterruptPacketsSentLen = 0;
		SNMP_FREE(StorageDel->virtualCallInterruptPacketsReceived);
		StorageDel->virtualCallInterruptPacketsReceivedLen = 0;
		SNMP_FREE(StorageDel->virtualCallInterruptTimerExpiries);
		StorageDel->virtualCallInterruptTimerExpiriesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCallTable_add(struct virtualCallTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCallTable table data set.
 *
 * Adds a table row structure to the virtualCallTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCallTable_add(struct virtualCallTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "virtualCallTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* virtualCallId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallId, thedata->virtualCallIdLen);
		header_complex_add_data(&virtualCallTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCallTable_del(struct virtualCallTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the virtualCallTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCallTable_del(struct virtualCallTable_data *thedata)
{
	struct virtualCallTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCallTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCallTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCallTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCallTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCallTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCallTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCallTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCallTable_data *StorageTmp = virtualCallTable_create();

	DEBUGMSGTL(("dlMIB", "parse_virtualCallTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->virtualCallId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
	if (StorageTmp->virtualCallId == NULL) {
		config_perror("invalid specification for virtualCallId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallChannel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallChannel, &StorageTmp->virtualCallChannelLen);
	if (StorageTmp->virtualCallChannel == NULL) {
		config_perror("invalid specification for virtualCallChannel");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallPacketSize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallPacketSize, &StorageTmp->virtualCallPacketSizeLen);
	if (StorageTmp->virtualCallPacketSize == NULL) {
		config_perror("invalid specification for virtualCallPacketSize");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallWindowSize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallWindowSize, &StorageTmp->virtualCallWindowSizeLen);
	if (StorageTmp->virtualCallWindowSize == NULL) {
		config_perror("invalid specification for virtualCallWindowSize");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallOctetsSentCounter);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallOctetsSentCounter, &StorageTmp->virtualCallOctetsSentCounterLen);
	if (StorageTmp->virtualCallOctetsSentCounter == NULL) {
		config_perror("invalid specification for virtualCallOctetsSentCounter");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallOctetsReceivedCounter);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallOctetsReceivedCounter, &StorageTmp->virtualCallOctetsReceivedCounterLen);
	if (StorageTmp->virtualCallOctetsReceivedCounter == NULL) {
		config_perror("invalid specification for virtualCallOctetsReceivedCounter");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallDataPacketsSent);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallDataPacketsSent, &StorageTmp->virtualCallDataPacketsSentLen);
	if (StorageTmp->virtualCallDataPacketsSent == NULL) {
		config_perror("invalid specification for virtualCallDataPacketsSent");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallDataPacketsReceived);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallDataPacketsReceived, &StorageTmp->virtualCallDataPacketsReceivedLen);
	if (StorageTmp->virtualCallDataPacketsReceived == NULL) {
		config_perror("invalid specification for virtualCallDataPacketsReceived");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallRemotelyInitiatedResets);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallRemotelyInitiatedResets, &StorageTmp->virtualCallRemotelyInitiatedResetsLen);
	if (StorageTmp->virtualCallRemotelyInitiatedResets == NULL) {
		config_perror("invalid specification for virtualCallRemotelyInitiatedResets");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallDataRetransmissionTimerExpiries);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallDataRetransmissionTimerExpiries, &StorageTmp->virtualCallDataRetransmissionTimerExpiriesLen);
	if (StorageTmp->virtualCallDataRetransmissionTimerExpiries == NULL) {
		config_perror("invalid specification for virtualCallDataRetransmissionTimerExpiries");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallProviderInitiatedResets);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallProviderInitiatedResets, &StorageTmp->virtualCallProviderInitiatedResetsLen);
	if (StorageTmp->virtualCallProviderInitiatedResets == NULL) {
		config_perror("invalid specification for virtualCallProviderInitiatedResets");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallResetTimeouts);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallResetTimeouts, &StorageTmp->virtualCallResetTimeoutsLen);
	if (StorageTmp->virtualCallResetTimeouts == NULL) {
		config_perror("invalid specification for virtualCallResetTimeouts");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallInterruptPacketsSent);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallInterruptPacketsSent, &StorageTmp->virtualCallInterruptPacketsSentLen);
	if (StorageTmp->virtualCallInterruptPacketsSent == NULL) {
		config_perror("invalid specification for virtualCallInterruptPacketsSent");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallInterruptPacketsReceived);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallInterruptPacketsReceived, &StorageTmp->virtualCallInterruptPacketsReceivedLen);
	if (StorageTmp->virtualCallInterruptPacketsReceived == NULL) {
		config_perror("invalid specification for virtualCallInterruptPacketsReceived");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallInterruptTimerExpiries);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallInterruptTimerExpiries, &StorageTmp->virtualCallInterruptTimerExpiriesLen);
	if (StorageTmp->virtualCallInterruptTimerExpiries == NULL) {
		config_perror("invalid specification for virtualCallInterruptTimerExpiries");
		return;
	}
	virtualCallTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_virtualCallTable(): store configuraiton file for virtualCallTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCallTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCallTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_virtualCallTable: storing data...  "));
	refresh_virtualCallTable(1);
	(void) tmpsize;
	for (hcindex = virtualCallTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCallTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCallTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallChannel, &StorageTmp->virtualCallChannelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallPacketSize, &StorageTmp->virtualCallPacketSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallWindowSize, &StorageTmp->virtualCallWindowSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallOctetsSentCounter, &StorageTmp->virtualCallOctetsSentCounterLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallOctetsReceivedCounter, &StorageTmp->virtualCallOctetsReceivedCounterLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallDataPacketsSent, &StorageTmp->virtualCallDataPacketsSentLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallDataPacketsReceived, &StorageTmp->virtualCallDataPacketsReceivedLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallRemotelyInitiatedResets, &StorageTmp->virtualCallRemotelyInitiatedResetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallDataRetransmissionTimerExpiries, &StorageTmp->virtualCallDataRetransmissionTimerExpiriesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallProviderInitiatedResets, &StorageTmp->virtualCallProviderInitiatedResetsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallResetTimeouts, &StorageTmp->virtualCallResetTimeoutsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallInterruptPacketsSent, &StorageTmp->virtualCallInterruptPacketsSentLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallInterruptPacketsReceived, &StorageTmp->virtualCallInterruptPacketsReceivedLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallInterruptTimerExpiries, &StorageTmp->virtualCallInterruptTimerExpiriesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCircuitTable_data *virtualCircuitTable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCircuitTable table.
 *
 * Creates a new virtualCircuitTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCircuitTable_data *
virtualCircuitTable_create(void)
{
	struct virtualCircuitTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCircuitTable_data);

	DEBUGMSGTL(("dlMIB", "virtualCircuitTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->virtualCircuitLogicalChannel = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitLogicalChannelLen = strlen("");
		if ((StorageNew->virtualCircuitPacketSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitPacketSizesLen = strlen("");
		if ((StorageNew->virtualCircuitThroughputClasses = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitThroughputClassesLen = strlen("");
		if ((StorageNew->virtualCircuitWindowSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitWindowSizesLen = strlen("");

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct virtualCircuitTable_data *virtualCircuitTable_duplicate(struct virtualCircuitTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct virtualCircuitTable_data *
virtualCircuitTable_duplicate(struct virtualCircuitTable_data *thedata)
{
	struct virtualCircuitTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCircuitTable_data);

	DEBUGMSGTL(("dlMIB", "virtualCircuitTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	virtualCircuitTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int virtualCircuitTable_destroy(struct virtualCircuitTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCircuitTable_destroy(struct virtualCircuitTable_data **thedata)
{
	struct virtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCircuitTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitLogicalChannel);
		StorageDel->virtualCircuitLogicalChannelLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitPacketSizes);
		StorageDel->virtualCircuitPacketSizesLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitThroughputClasses);
		StorageDel->virtualCircuitThroughputClassesLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitWindowSizes);
		StorageDel->virtualCircuitWindowSizesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuitTable_add(struct virtualCircuitTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCircuitTable table data set.
 *
 * Adds a table row structure to the virtualCircuitTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCircuitTable_add(struct virtualCircuitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "virtualCircuitTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* virtualCircuitId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
		header_complex_add_data(&virtualCircuitTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuitTable_del(struct virtualCircuitTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the virtualCircuitTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCircuitTable_del(struct virtualCircuitTable_data *thedata)
{
	struct virtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCircuitTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCircuitTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCircuitTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCircuitTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCircuitTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCircuitTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCircuitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCircuitTable_data *StorageTmp = virtualCircuitTable_create();

	DEBUGMSGTL(("dlMIB", "parse_virtualCircuitTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->virtualCircuitId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCircuitLogicalChannel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitLogicalChannel, &StorageTmp->virtualCircuitLogicalChannelLen);
	if (StorageTmp->virtualCircuitLogicalChannel == NULL) {
		config_perror("invalid specification for virtualCircuitLogicalChannel");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCircuitPacketSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitPacketSizes, &StorageTmp->virtualCircuitPacketSizesLen);
	if (StorageTmp->virtualCircuitPacketSizes == NULL) {
		config_perror("invalid specification for virtualCircuitPacketSizes");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCircuitThroughputClasses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitThroughputClasses, &StorageTmp->virtualCircuitThroughputClassesLen);
	if (StorageTmp->virtualCircuitThroughputClasses == NULL) {
		config_perror("invalid specification for virtualCircuitThroughputClasses");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCircuitWindowSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitWindowSizes, &StorageTmp->virtualCircuitWindowSizesLen);
	if (StorageTmp->virtualCircuitWindowSizes == NULL) {
		config_perror("invalid specification for virtualCircuitWindowSizes");
		return;
	}
	virtualCircuitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_virtualCircuitTable(): store configuraiton file for virtualCircuitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCircuitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCircuitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_virtualCircuitTable: storing data...  "));
	refresh_virtualCircuitTable(1);
	(void) tmpsize;
	for (hcindex = virtualCircuitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCircuitTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCircuitTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitLogicalChannel, &StorageTmp->virtualCircuitLogicalChannelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitPacketSizes, &StorageTmp->virtualCircuitPacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitThroughputClasses, &StorageTmp->virtualCircuitThroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitWindowSizes, &StorageTmp->virtualCircuitWindowSizesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCircuit_DTETable_data *virtualCircuit_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCircuit_DTETable table.
 *
 * Creates a new virtualCircuit_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCircuit_DTETable_data *
virtualCircuit_DTETable_create(void)
{
	struct virtualCircuit_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCircuit_DTETable_data);

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DTETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->virtualCircuitId = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitIdLen = strlen("");
		StorageNew->virtualCircuit_DTEoctetsSentCounter = 0;
		StorageNew->virtualCircuit_DTEoctetsReceivedCounter = 0;
		StorageNew->virtualCircuit_DTEdataPacketsReceived = 0;
		StorageNew->virtualCircuit_DTEdataPacketsSent = 0;
		StorageNew->virtualCircuit_DTEdataRetransmissionTimerExpiries = 0;
		StorageNew->virtualCircuit_DTEinterruptPacketsReceived = 0;
		StorageNew->virtualCircuit_DTEinterruptPacketsSent = 0;
		StorageNew->virtualCircuit_DTEinterruptTimerExpiries = 0;
		StorageNew->virtualCircuit_DTEproviderInitiatedResets = 0;
		StorageNew->virtualCircuit_DTEremotelyInitiatedResets = 0;
		StorageNew->virtualCircuit_DTEresetTimeouts = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct virtualCircuit_DTETable_data *virtualCircuit_DTETable_duplicate(struct virtualCircuit_DTETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct virtualCircuit_DTETable_data *
virtualCircuit_DTETable_duplicate(struct virtualCircuit_DTETable_data *thedata)
{
	struct virtualCircuit_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCircuit_DTETable_data);

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DTETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	virtualCircuit_DTETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int virtualCircuit_DTETable_destroy(struct virtualCircuit_DTETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCircuit_DTETable_destroy(struct virtualCircuit_DTETable_data **thedata)
{
	struct virtualCircuit_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DTETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuit_DTETable_add(struct virtualCircuit_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCircuit_DTETable table data set.
 *
 * Adds a table row structure to the virtualCircuit_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCircuit_DTETable_add(struct virtualCircuit_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DTETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* virtualCircuitId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
		header_complex_add_data(&virtualCircuit_DTETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuit_DTETable_del(struct virtualCircuit_DTETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the virtualCircuit_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCircuit_DTETable_del(struct virtualCircuit_DTETable_data *thedata)
{
	struct virtualCircuit_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DTETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCircuit_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCircuit_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCircuit_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCircuit_DTETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCircuit_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCircuit_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCircuit_DTETable_data *StorageTmp = virtualCircuit_DTETable_create();

	DEBUGMSGTL(("dlMIB", "parse_virtualCircuit_DTETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->virtualCircuitId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEdataRetransmissionTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEinterruptPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEinterruptPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEinterruptTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DTEresetTimeouts, &tmpsize);
	virtualCircuit_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_virtualCircuit_DTETable(): store configuraiton file for virtualCircuit_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCircuit_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCircuit_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_virtualCircuit_DTETable: storing data...  "));
	refresh_virtualCircuit_DTETable(1);
	(void) tmpsize;
	for (hcindex = virtualCircuit_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCircuit_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCircuit_DTETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEdataRetransmissionTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEinterruptPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEinterruptPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEinterruptTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DTEresetTimeouts, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCircuit_DCETable_data *virtualCircuit_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCircuit_DCETable table.
 *
 * Creates a new virtualCircuit_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCircuit_DCETable_data *
virtualCircuit_DCETable_create(void)
{
	struct virtualCircuit_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCircuit_DCETable_data);

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DCETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->virtualCircuitId = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitIdLen = strlen("");
		StorageNew->virtualCircuit_DCEdataPacketsReceived = 0;
		StorageNew->virtualCircuit_DCEdataPacketsSent = 0;
		StorageNew->virtualCircuit_DCEinterruptPacketsReceived = 0;
		StorageNew->virtualCircuit_DCEinterruptPacketsSent = 0;
		StorageNew->virtualCircuit_DCEinterruptTimerExpiries = 0;
		StorageNew->virtualCircuit_DCEoctetsReceivedCounter = 0;
		StorageNew->virtualCircuit_DCEoctetsSentCounter = 0;
		StorageNew->virtualCircuit_DCEproviderInitiatedDisconnects = 0;
		StorageNew->virtualCircuit_DCEproviderInitiatedResets = 0;
		StorageNew->virtualCircuit_DCEremotelyInitiatedRestarts = 0;
		StorageNew->virtualCircuit_DCEremotelyInitiatedResets = 0;
		StorageNew->virtualCircuit_DCEresetTimeouts = 0;
		StorageNew->virtualCircuit_DCEx25SegmentsReceived = 0;
		StorageNew->virtualCircuit_DCEx25SegmentsSent = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct virtualCircuit_DCETable_data *virtualCircuit_DCETable_duplicate(struct virtualCircuit_DCETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct virtualCircuit_DCETable_data *
virtualCircuit_DCETable_duplicate(struct virtualCircuit_DCETable_data *thedata)
{
	struct virtualCircuit_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCircuit_DCETable_data);

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DCETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	virtualCircuit_DCETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int virtualCircuit_DCETable_destroy(struct virtualCircuit_DCETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCircuit_DCETable_destroy(struct virtualCircuit_DCETable_data **thedata)
{
	struct virtualCircuit_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DCETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuit_DCETable_add(struct virtualCircuit_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCircuit_DCETable table data set.
 *
 * Adds a table row structure to the virtualCircuit_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCircuit_DCETable_add(struct virtualCircuit_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DCETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* virtualCircuitId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
		header_complex_add_data(&virtualCircuit_DCETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCircuit_DCETable_del(struct virtualCircuit_DCETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the virtualCircuit_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCircuit_DCETable_del(struct virtualCircuit_DCETable_data *thedata)
{
	struct virtualCircuit_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCircuit_DCETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCircuit_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCircuit_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCircuit_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCircuit_DCETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCircuit_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCircuit_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCircuit_DCETable_data *StorageTmp = virtualCircuit_DCETable_create();

	DEBUGMSGTL(("dlMIB", "parse_virtualCircuit_DCETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->virtualCircuitId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEdataPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEdataPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEinterruptPacketsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEinterruptPacketsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEinterruptTimerExpiries, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEoctetsReceivedCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEoctetsSentCounter, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEproviderInitiatedDisconnects, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEproviderInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEremotelyInitiatedRestarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEremotelyInitiatedResets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEresetTimeouts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEx25SegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->virtualCircuit_DCEx25SegmentsSent, &tmpsize);
	virtualCircuit_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_virtualCircuit_DCETable(): store configuraiton file for virtualCircuit_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCircuit_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCircuit_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_virtualCircuit_DCETable: storing data...  "));
	refresh_virtualCircuit_DCETable(1);
	(void) tmpsize;
	for (hcindex = virtualCircuit_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCircuit_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCircuit_DCETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEdataPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEdataPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEinterruptPacketsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEinterruptPacketsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEinterruptTimerExpiries, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEoctetsReceivedCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEoctetsSentCounter, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEproviderInitiatedDisconnects, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEproviderInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEremotelyInitiatedRestarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEremotelyInitiatedResets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEresetTimeouts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEx25SegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->virtualCircuit_DCEx25SegmentsSent, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct permanentVirtualCircuitTable_data *permanentVirtualCircuitTable_create(void)
 * @brief create a fresh data structure representing a new row in the permanentVirtualCircuitTable table.
 *
 * Creates a new permanentVirtualCircuitTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct permanentVirtualCircuitTable_data *
permanentVirtualCircuitTable_create(void)
{
	struct permanentVirtualCircuitTable_data *StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuitTable_data);

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuitTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		if ((StorageNew->virtualCallId = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIdLen = strlen("");
		if ((StorageNew->permanentVirtualCircuitChannel = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuitChannelLen = strlen("");
		StorageNew->permanentVirtualCircuitRowStatus = 0;
		StorageNew->permanentVirtualCircuitRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct permanentVirtualCircuitTable_data *permanentVirtualCircuitTable_duplicate(struct permanentVirtualCircuitTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct permanentVirtualCircuitTable_data *
permanentVirtualCircuitTable_duplicate(struct permanentVirtualCircuitTable_data *thedata)
{
	struct permanentVirtualCircuitTable_data *StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuitTable_data);

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuitTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	permanentVirtualCircuitTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int permanentVirtualCircuitTable_destroy(struct permanentVirtualCircuitTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
permanentVirtualCircuitTable_destroy(struct permanentVirtualCircuitTable_data **thedata)
{
	struct permanentVirtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuitTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallId);
		StorageDel->virtualCallIdLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuitChannel);
		StorageDel->permanentVirtualCircuitChannelLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuitTable_add(struct permanentVirtualCircuitTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the permanentVirtualCircuitTable table data set.
 *
 * Adds a table row structure to the permanentVirtualCircuitTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
permanentVirtualCircuitTable_add(struct permanentVirtualCircuitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuitTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		/* virtualCallId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallId, thedata->virtualCallIdLen);
		header_complex_add_data(&permanentVirtualCircuitTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuitTable_del(struct permanentVirtualCircuitTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the permanentVirtualCircuitTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
permanentVirtualCircuitTable_del(struct permanentVirtualCircuitTable_data *thedata)
{
	struct permanentVirtualCircuitTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuitTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(permanentVirtualCircuitTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&permanentVirtualCircuitTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_permanentVirtualCircuitTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for permanentVirtualCircuitTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case permanentVirtualCircuitTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_permanentVirtualCircuitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct permanentVirtualCircuitTable_data *StorageTmp = permanentVirtualCircuitTable_create();

	DEBUGMSGTL(("dlMIB", "parse_permanentVirtualCircuitTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
	if (StorageTmp->virtualCallId == NULL) {
		config_perror("invalid specification for virtualCallId");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuitChannel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuitChannel, &StorageTmp->permanentVirtualCircuitChannelLen);
	if (StorageTmp->permanentVirtualCircuitChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuitChannel");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuitRowStatus, &tmpsize);
	permanentVirtualCircuitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_permanentVirtualCircuitTable(): store configuraiton file for permanentVirtualCircuitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_permanentVirtualCircuitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct permanentVirtualCircuitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_permanentVirtualCircuitTable: storing data...  "));
	refresh_permanentVirtualCircuitTable(1);
	(void) tmpsize;
	for (hcindex = permanentVirtualCircuitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct permanentVirtualCircuitTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "permanentVirtualCircuitTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuitChannel, &StorageTmp->permanentVirtualCircuitChannelLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuitRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct permanentVirtualCircuit_DTETable_data *permanentVirtualCircuit_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the permanentVirtualCircuit_DTETable table.
 *
 * Creates a new permanentVirtualCircuit_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct permanentVirtualCircuit_DTETable_data *
permanentVirtualCircuit_DTETable_create(void)
{
	struct permanentVirtualCircuit_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuit_DTETable_data);

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DTETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		if ((StorageNew->virtualCircuitId = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitIdLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DTElogicalChannel = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DTElogicalChannelLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DTEpacketSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DTEpacketSizesLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DTEthroughputClasses = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DTEthroughputClassesLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DTEwindowSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DTEwindowSizesLen = strlen("");
		StorageNew->permanentVirtualCircuit_DTERowStatus = 0;
		StorageNew->permanentVirtualCircuit_DTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct permanentVirtualCircuit_DTETable_data *permanentVirtualCircuit_DTETable_duplicate(struct permanentVirtualCircuit_DTETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct permanentVirtualCircuit_DTETable_data *
permanentVirtualCircuit_DTETable_duplicate(struct permanentVirtualCircuit_DTETable_data *thedata)
{
	struct permanentVirtualCircuit_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuit_DTETable_data);

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DTETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	permanentVirtualCircuit_DTETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int permanentVirtualCircuit_DTETable_destroy(struct permanentVirtualCircuit_DTETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
permanentVirtualCircuit_DTETable_destroy(struct permanentVirtualCircuit_DTETable_data **thedata)
{
	struct permanentVirtualCircuit_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DTETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DTElogicalChannel);
		StorageDel->permanentVirtualCircuit_DTElogicalChannelLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DTEpacketSizes);
		StorageDel->permanentVirtualCircuit_DTEpacketSizesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DTEthroughputClasses);
		StorageDel->permanentVirtualCircuit_DTEthroughputClassesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DTEwindowSizes);
		StorageDel->permanentVirtualCircuit_DTEwindowSizesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuit_DTETable_add(struct permanentVirtualCircuit_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the permanentVirtualCircuit_DTETable table data set.
 *
 * Adds a table row structure to the permanentVirtualCircuit_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
permanentVirtualCircuit_DTETable_add(struct permanentVirtualCircuit_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DTETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		/* virtualCircuitId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
		header_complex_add_data(&permanentVirtualCircuit_DTETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuit_DTETable_del(struct permanentVirtualCircuit_DTETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the permanentVirtualCircuit_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
permanentVirtualCircuit_DTETable_del(struct permanentVirtualCircuit_DTETable_data *thedata)
{
	struct permanentVirtualCircuit_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DTETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(permanentVirtualCircuit_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&permanentVirtualCircuit_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_permanentVirtualCircuit_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for permanentVirtualCircuit_DTETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case permanentVirtualCircuit_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_permanentVirtualCircuit_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct permanentVirtualCircuit_DTETable_data *StorageTmp = permanentVirtualCircuit_DTETable_create();

	DEBUGMSGTL(("dlMIB", "parse_permanentVirtualCircuit_DTETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCircuitId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DTElogicalChannel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DTElogicalChannel, &StorageTmp->permanentVirtualCircuit_DTElogicalChannelLen);
	if (StorageTmp->permanentVirtualCircuit_DTElogicalChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DTElogicalChannel");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DTEpacketSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DTEpacketSizes, &StorageTmp->permanentVirtualCircuit_DTEpacketSizesLen);
	if (StorageTmp->permanentVirtualCircuit_DTEpacketSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DTEpacketSizes");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DTEthroughputClasses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DTEthroughputClasses, &StorageTmp->permanentVirtualCircuit_DTEthroughputClassesLen);
	if (StorageTmp->permanentVirtualCircuit_DTEthroughputClasses == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DTEthroughputClasses");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DTEwindowSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DTEwindowSizes, &StorageTmp->permanentVirtualCircuit_DTEwindowSizesLen);
	if (StorageTmp->permanentVirtualCircuit_DTEwindowSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DTEwindowSizes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuit_DTERowStatus, &tmpsize);
	permanentVirtualCircuit_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_permanentVirtualCircuit_DTETable(): store configuraiton file for permanentVirtualCircuit_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_permanentVirtualCircuit_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct permanentVirtualCircuit_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_permanentVirtualCircuit_DTETable: storing data...  "));
	refresh_permanentVirtualCircuit_DTETable(1);
	(void) tmpsize;
	for (hcindex = permanentVirtualCircuit_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct permanentVirtualCircuit_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "permanentVirtualCircuit_DTETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DTElogicalChannel, &StorageTmp->permanentVirtualCircuit_DTElogicalChannelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DTEpacketSizes, &StorageTmp->permanentVirtualCircuit_DTEpacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DTEthroughputClasses, &StorageTmp->permanentVirtualCircuit_DTEthroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DTEwindowSizes, &StorageTmp->permanentVirtualCircuit_DTEwindowSizesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuit_DTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct permanentVirtualCircuit_DCETable_data *permanentVirtualCircuit_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the permanentVirtualCircuit_DCETable table.
 *
 * Creates a new permanentVirtualCircuit_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct permanentVirtualCircuit_DCETable_data *
permanentVirtualCircuit_DCETable_create(void)
{
	struct permanentVirtualCircuit_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuit_DCETable_data);

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DCETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		if ((StorageNew->virtualCircuitId = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitIdLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DCEchargingDirection = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DCEchargingDirectionLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DCElogicalChannel = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DCElogicalChannelLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DCEpacketSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DCEpacketSizesLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DCEthroughputClasses = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DCEthroughputClassesLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DCEwindowSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DCEwindowSizesLen = strlen("");
		StorageNew->permanentVirtualCircuit_DCEoperationalState = 0;
		if ((StorageNew->permanentVirtualCircuit_DCEremoteDTEAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DCEremoteDTEAddressLen = strlen("");
		if ((StorageNew->permanentVirtualCircuit_DCEremoteLogicalChannel = (uint8_t *) strdup("")) != NULL)
			StorageNew->permanentVirtualCircuit_DCEremoteLogicalChannelLen = strlen("");
		StorageNew->permanentVirtualCircuit_DCERowStatus = 0;
		StorageNew->permanentVirtualCircuit_DCERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct permanentVirtualCircuit_DCETable_data *permanentVirtualCircuit_DCETable_duplicate(struct permanentVirtualCircuit_DCETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct permanentVirtualCircuit_DCETable_data *
permanentVirtualCircuit_DCETable_duplicate(struct permanentVirtualCircuit_DCETable_data *thedata)
{
	struct permanentVirtualCircuit_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(permanentVirtualCircuit_DCETable_data);

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DCETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	permanentVirtualCircuit_DCETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int permanentVirtualCircuit_DCETable_destroy(struct permanentVirtualCircuit_DCETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
permanentVirtualCircuit_DCETable_destroy(struct permanentVirtualCircuit_DCETable_data **thedata)
{
	struct permanentVirtualCircuit_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DCETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEchargingDirection);
		StorageDel->permanentVirtualCircuit_DCEchargingDirectionLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCElogicalChannel);
		StorageDel->permanentVirtualCircuit_DCElogicalChannelLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEpacketSizes);
		StorageDel->permanentVirtualCircuit_DCEpacketSizesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEthroughputClasses);
		StorageDel->permanentVirtualCircuit_DCEthroughputClassesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEwindowSizes);
		StorageDel->permanentVirtualCircuit_DCEwindowSizesLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEremoteDTEAddress);
		StorageDel->permanentVirtualCircuit_DCEremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->permanentVirtualCircuit_DCEremoteLogicalChannel);
		StorageDel->permanentVirtualCircuit_DCEremoteLogicalChannelLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuit_DCETable_add(struct permanentVirtualCircuit_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the permanentVirtualCircuit_DCETable table data set.
 *
 * Adds a table row structure to the permanentVirtualCircuit_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
permanentVirtualCircuit_DCETable_add(struct permanentVirtualCircuit_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DCETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		/* virtualCircuitId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
		header_complex_add_data(&permanentVirtualCircuit_DCETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int permanentVirtualCircuit_DCETable_del(struct permanentVirtualCircuit_DCETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the permanentVirtualCircuit_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
permanentVirtualCircuit_DCETable_del(struct permanentVirtualCircuit_DCETable_data *thedata)
{
	struct permanentVirtualCircuit_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "permanentVirtualCircuit_DCETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(permanentVirtualCircuit_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&permanentVirtualCircuit_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_permanentVirtualCircuit_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for permanentVirtualCircuit_DCETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case permanentVirtualCircuit_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_permanentVirtualCircuit_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct permanentVirtualCircuit_DCETable_data *StorageTmp = permanentVirtualCircuit_DCETable_create();

	DEBUGMSGTL(("dlMIB", "parse_permanentVirtualCircuit_DCETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCircuitId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DCEchargingDirection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEchargingDirection, &StorageTmp->permanentVirtualCircuit_DCEchargingDirectionLen);
	if (StorageTmp->permanentVirtualCircuit_DCEchargingDirection == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEchargingDirection");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DCElogicalChannel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCElogicalChannel, &StorageTmp->permanentVirtualCircuit_DCElogicalChannelLen);
	if (StorageTmp->permanentVirtualCircuit_DCElogicalChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCElogicalChannel");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DCEpacketSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEpacketSizes, &StorageTmp->permanentVirtualCircuit_DCEpacketSizesLen);
	if (StorageTmp->permanentVirtualCircuit_DCEpacketSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEpacketSizes");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DCEthroughputClasses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEthroughputClasses, &StorageTmp->permanentVirtualCircuit_DCEthroughputClassesLen);
	if (StorageTmp->permanentVirtualCircuit_DCEthroughputClasses == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEthroughputClasses");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DCEwindowSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEwindowSizes, &StorageTmp->permanentVirtualCircuit_DCEwindowSizesLen);
	if (StorageTmp->permanentVirtualCircuit_DCEwindowSizes == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEwindowSizes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuit_DCEoperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddress, &StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddressLen);
	if (StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddress == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEremoteDTEAddress");
		return;
	}
	SNMP_FREE(StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannel, &StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannelLen);
	if (StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannel == NULL) {
		config_perror("invalid specification for permanentVirtualCircuit_DCEremoteLogicalChannel");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->permanentVirtualCircuit_DCERowStatus, &tmpsize);
	permanentVirtualCircuit_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_permanentVirtualCircuit_DCETable(): store configuraiton file for permanentVirtualCircuit_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_permanentVirtualCircuit_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct permanentVirtualCircuit_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_permanentVirtualCircuit_DCETable: storing data...  "));
	refresh_permanentVirtualCircuit_DCETable(1);
	(void) tmpsize;
	for (hcindex = permanentVirtualCircuit_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct permanentVirtualCircuit_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "permanentVirtualCircuit_DCETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEchargingDirection, &StorageTmp->permanentVirtualCircuit_DCEchargingDirectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCElogicalChannel, &StorageTmp->permanentVirtualCircuit_DCElogicalChannelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEpacketSizes, &StorageTmp->permanentVirtualCircuit_DCEpacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEthroughputClasses, &StorageTmp->permanentVirtualCircuit_DCEthroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEwindowSizes, &StorageTmp->permanentVirtualCircuit_DCEwindowSizesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuit_DCEoperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddress, &StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannel, &StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannelLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->permanentVirtualCircuit_DCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCallIVMOTable_data *virtualCallIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCallIVMOTable table.
 *
 * Creates a new virtualCallIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCallIVMOTable_data *
virtualCallIVMOTable_create(void)
{
	struct virtualCallIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCallIVMOTable_data);

	DEBUGMSGTL(("dlMIB", "virtualCallIVMOTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		StorageNew->virtualCallIVMOfastSelect = 0;
		if ((StorageNew->virtualCallIVMOpacketSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOpacketSizesLen = strlen("");
		if ((StorageNew->virtualCallIVMOreverseCharging = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOreverseChargingLen = strlen("");
		if ((StorageNew->virtualCallIVMOthroughputClasses = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOthroughputClassesLen = strlen("");
		if ((StorageNew->virtualCallIVMOwindowSizes = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOwindowSizesLen = strlen("");
		if ((StorageNew->virtualCallIVMOproposedPacketSize = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOproposedPacketSizeLen = strlen("");
		if ((StorageNew->virtualCallIVMOproposedWindowSize = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOproposedWindowSizeLen = strlen("");
		if ((StorageNew->virtualCallIVMOacceptReverseCharging = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOacceptReverseChargingLen = strlen("");
		if ((StorageNew->virtualCallIVMOproposeReverseCharging = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOproposeReverseChargingLen = strlen("");
		if ((StorageNew->virtualCallIVMOcallTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOcallTimeLen = strlen("");
		if ((StorageNew->virtualCallIVMOresetTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOresetTimeLen = strlen("");
		if ((StorageNew->virtualCallIVMOclearTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOclearTimeLen = strlen("");
		if ((StorageNew->virtualCallIVMOinterruptTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOinterruptTimeLen = strlen("");
		if ((StorageNew->virtualCallIVMOresetCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOresetCountLen = strlen("");
		if ((StorageNew->virtualCallIVMOclearCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOclearCountLen = strlen("");
		if ((StorageNew->virtualCallIVMOwindowTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOwindowTimeLen = strlen("");
		if ((StorageNew->virtualCallIVMOdataRetransmissionTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOdataRetransmissionTimeLen = strlen("");
		if ((StorageNew->virtualCallIVMOdataRetransmissionCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOdataRetransmissionCountLen = strlen("");
		if ((StorageNew->virtualCallIVMOrejectTime = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOrejectTimeLen = strlen("");
		if ((StorageNew->virtualCallIVMOrejectCount = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIVMOrejectCountLen = strlen("");
		StorageNew->virtualCallIVMORowStatus = 0;
		StorageNew->virtualCallIVMORowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct virtualCallIVMOTable_data *virtualCallIVMOTable_duplicate(struct virtualCallIVMOTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct virtualCallIVMOTable_data *
virtualCallIVMOTable_duplicate(struct virtualCallIVMOTable_data *thedata)
{
	struct virtualCallIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCallIVMOTable_data);

	DEBUGMSGTL(("dlMIB", "virtualCallIVMOTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	virtualCallIVMOTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int virtualCallIVMOTable_destroy(struct virtualCallIVMOTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCallIVMOTable_destroy(struct virtualCallIVMOTable_data **thedata)
{
	struct virtualCallIVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCallIVMOTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOId);
		StorageDel->virtualCallIVMOIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOpacketSizes);
		StorageDel->virtualCallIVMOpacketSizesLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOreverseCharging);
		StorageDel->virtualCallIVMOreverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOthroughputClasses);
		StorageDel->virtualCallIVMOthroughputClassesLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOwindowSizes);
		StorageDel->virtualCallIVMOwindowSizesLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOproposedPacketSize);
		StorageDel->virtualCallIVMOproposedPacketSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOproposedWindowSize);
		StorageDel->virtualCallIVMOproposedWindowSizeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOacceptReverseCharging);
		StorageDel->virtualCallIVMOacceptReverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOproposeReverseCharging);
		StorageDel->virtualCallIVMOproposeReverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOcallTime);
		StorageDel->virtualCallIVMOcallTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOresetTime);
		StorageDel->virtualCallIVMOresetTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOclearTime);
		StorageDel->virtualCallIVMOclearTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOinterruptTime);
		StorageDel->virtualCallIVMOinterruptTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOresetCount);
		StorageDel->virtualCallIVMOresetCountLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOclearCount);
		StorageDel->virtualCallIVMOclearCountLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOwindowTime);
		StorageDel->virtualCallIVMOwindowTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOdataRetransmissionTime);
		StorageDel->virtualCallIVMOdataRetransmissionTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOdataRetransmissionCount);
		StorageDel->virtualCallIVMOdataRetransmissionCountLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOrejectTime);
		StorageDel->virtualCallIVMOrejectTimeLen = 0;
		SNMP_FREE(StorageDel->virtualCallIVMOrejectCount);
		StorageDel->virtualCallIVMOrejectCountLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCallIVMOTable_add(struct virtualCallIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCallIVMOTable table data set.
 *
 * Adds a table row structure to the virtualCallIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCallIVMOTable_add(struct virtualCallIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "virtualCallIVMOTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		/* virtualCallIVMOId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallIVMOId, thedata->virtualCallIVMOIdLen);
		header_complex_add_data(&virtualCallIVMOTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCallIVMOTable_del(struct virtualCallIVMOTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the virtualCallIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCallIVMOTable_del(struct virtualCallIVMOTable_data *thedata)
{
	struct virtualCallIVMOTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCallIVMOTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCallIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCallIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCallIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCallIVMOTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCallIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCallIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCallIVMOTable_data *StorageTmp = virtualCallIVMOTable_create();

	DEBUGMSGTL(("dlMIB", "parse_virtualCallIVMOTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOId, &StorageTmp->virtualCallIVMOIdLen);
	if (StorageTmp->virtualCallIVMOId == NULL) {
		config_perror("invalid specification for virtualCallIVMOId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCallIVMOfastSelect, &tmpsize);
	SNMP_FREE(StorageTmp->virtualCallIVMOpacketSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOpacketSizes, &StorageTmp->virtualCallIVMOpacketSizesLen);
	if (StorageTmp->virtualCallIVMOpacketSizes == NULL) {
		config_perror("invalid specification for virtualCallIVMOpacketSizes");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOreverseCharging);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOreverseCharging, &StorageTmp->virtualCallIVMOreverseChargingLen);
	if (StorageTmp->virtualCallIVMOreverseCharging == NULL) {
		config_perror("invalid specification for virtualCallIVMOreverseCharging");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOthroughputClasses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOthroughputClasses, &StorageTmp->virtualCallIVMOthroughputClassesLen);
	if (StorageTmp->virtualCallIVMOthroughputClasses == NULL) {
		config_perror("invalid specification for virtualCallIVMOthroughputClasses");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOwindowSizes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOwindowSizes, &StorageTmp->virtualCallIVMOwindowSizesLen);
	if (StorageTmp->virtualCallIVMOwindowSizes == NULL) {
		config_perror("invalid specification for virtualCallIVMOwindowSizes");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOproposedPacketSize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOproposedPacketSize, &StorageTmp->virtualCallIVMOproposedPacketSizeLen);
	if (StorageTmp->virtualCallIVMOproposedPacketSize == NULL) {
		config_perror("invalid specification for virtualCallIVMOproposedPacketSize");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOproposedWindowSize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOproposedWindowSize, &StorageTmp->virtualCallIVMOproposedWindowSizeLen);
	if (StorageTmp->virtualCallIVMOproposedWindowSize == NULL) {
		config_perror("invalid specification for virtualCallIVMOproposedWindowSize");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOacceptReverseCharging);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOacceptReverseCharging, &StorageTmp->virtualCallIVMOacceptReverseChargingLen);
	if (StorageTmp->virtualCallIVMOacceptReverseCharging == NULL) {
		config_perror("invalid specification for virtualCallIVMOacceptReverseCharging");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOproposeReverseCharging);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOproposeReverseCharging, &StorageTmp->virtualCallIVMOproposeReverseChargingLen);
	if (StorageTmp->virtualCallIVMOproposeReverseCharging == NULL) {
		config_perror("invalid specification for virtualCallIVMOproposeReverseCharging");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOcallTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOcallTime, &StorageTmp->virtualCallIVMOcallTimeLen);
	if (StorageTmp->virtualCallIVMOcallTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOcallTime");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOresetTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOresetTime, &StorageTmp->virtualCallIVMOresetTimeLen);
	if (StorageTmp->virtualCallIVMOresetTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOresetTime");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOclearTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOclearTime, &StorageTmp->virtualCallIVMOclearTimeLen);
	if (StorageTmp->virtualCallIVMOclearTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOclearTime");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOinterruptTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOinterruptTime, &StorageTmp->virtualCallIVMOinterruptTimeLen);
	if (StorageTmp->virtualCallIVMOinterruptTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOinterruptTime");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOresetCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOresetCount, &StorageTmp->virtualCallIVMOresetCountLen);
	if (StorageTmp->virtualCallIVMOresetCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOresetCount");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOclearCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOclearCount, &StorageTmp->virtualCallIVMOclearCountLen);
	if (StorageTmp->virtualCallIVMOclearCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOclearCount");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOwindowTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOwindowTime, &StorageTmp->virtualCallIVMOwindowTimeLen);
	if (StorageTmp->virtualCallIVMOwindowTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOwindowTime");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOdataRetransmissionTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOdataRetransmissionTime, &StorageTmp->virtualCallIVMOdataRetransmissionTimeLen);
	if (StorageTmp->virtualCallIVMOdataRetransmissionTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOdataRetransmissionTime");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOdataRetransmissionCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOdataRetransmissionCount, &StorageTmp->virtualCallIVMOdataRetransmissionCountLen);
	if (StorageTmp->virtualCallIVMOdataRetransmissionCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOdataRetransmissionCount");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOrejectTime);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOrejectTime, &StorageTmp->virtualCallIVMOrejectTimeLen);
	if (StorageTmp->virtualCallIVMOrejectTime == NULL) {
		config_perror("invalid specification for virtualCallIVMOrejectTime");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallIVMOrejectCount);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallIVMOrejectCount, &StorageTmp->virtualCallIVMOrejectCountLen);
	if (StorageTmp->virtualCallIVMOrejectCount == NULL) {
		config_perror("invalid specification for virtualCallIVMOrejectCount");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCallIVMORowStatus, &tmpsize);
	virtualCallIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_virtualCallIVMOTable(): store configuraiton file for virtualCallIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCallIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCallIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_virtualCallIVMOTable: storing data...  "));
	refresh_virtualCallIVMOTable(1);
	(void) tmpsize;
	for (hcindex = virtualCallIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCallIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCallIVMOTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOId, &StorageTmp->virtualCallIVMOIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCallIVMOfastSelect, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOpacketSizes, &StorageTmp->virtualCallIVMOpacketSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOreverseCharging, &StorageTmp->virtualCallIVMOreverseChargingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOthroughputClasses, &StorageTmp->virtualCallIVMOthroughputClassesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOwindowSizes, &StorageTmp->virtualCallIVMOwindowSizesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOproposedPacketSize, &StorageTmp->virtualCallIVMOproposedPacketSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOproposedWindowSize, &StorageTmp->virtualCallIVMOproposedWindowSizeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOacceptReverseCharging, &StorageTmp->virtualCallIVMOacceptReverseChargingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOproposeReverseCharging, &StorageTmp->virtualCallIVMOproposeReverseChargingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOcallTime, &StorageTmp->virtualCallIVMOcallTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOresetTime, &StorageTmp->virtualCallIVMOresetTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOclearTime, &StorageTmp->virtualCallIVMOclearTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOinterruptTime, &StorageTmp->virtualCallIVMOinterruptTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOresetCount, &StorageTmp->virtualCallIVMOresetCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOclearCount, &StorageTmp->virtualCallIVMOclearCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOwindowTime, &StorageTmp->virtualCallIVMOwindowTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOdataRetransmissionTime, &StorageTmp->virtualCallIVMOdataRetransmissionTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOdataRetransmissionCount, &StorageTmp->virtualCallIVMOdataRetransmissionCountLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOrejectTime, &StorageTmp->virtualCallIVMOrejectTimeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallIVMOrejectCount, &StorageTmp->virtualCallIVMOrejectCountLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCallIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct switchedVirtualCallTable_data *switchedVirtualCallTable_create(void)
 * @brief create a fresh data structure representing a new row in the switchedVirtualCallTable table.
 *
 * Creates a new switchedVirtualCallTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct switchedVirtualCallTable_data *
switchedVirtualCallTable_create(void)
{
	struct switchedVirtualCallTable_data *StorageNew = SNMP_MALLOC_STRUCT(switchedVirtualCallTable_data);

	DEBUGMSGTL(("dlMIB", "switchedVirtualCallTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		if ((StorageNew->virtualCallId = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCallIdLen = strlen("");
		if ((StorageNew->switchedVirtualCalldirection = (uint8_t *) strdup("")) != NULL)
			StorageNew->switchedVirtualCalldirectionLen = strlen("");
		if ((StorageNew->switchedVirtualCallremoteDTEAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->switchedVirtualCallremoteDTEAddressLen = strlen("");
		if ((StorageNew->switchedVirtualCallthroughputClass = (uint8_t *) strdup("")) != NULL)
			StorageNew->switchedVirtualCallthroughputClassLen = strlen("");
		if ((StorageNew->switchedVirtualCallredirectReason = (uint8_t *) strdup("")) != NULL)
			StorageNew->switchedVirtualCallredirectReasonLen = strlen("");
		if ((StorageNew->switchedVirtualCalloriginallyCalledAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->switchedVirtualCalloriginallyCalledAddressLen = strlen("");
		if ((StorageNew->switchedVirtualCallcallingAddressExtension = (uint8_t *) strdup("")) != NULL)
			StorageNew->switchedVirtualCallcallingAddressExtensionLen = strlen("");
		if ((StorageNew->switchedVirtualCallcalledAddressExtension = (uint8_t *) strdup("")) != NULL)
			StorageNew->switchedVirtualCallcalledAddressExtensionLen = strlen("");
		StorageNew->switchedVirtualCallRowStatus = 0;
		StorageNew->switchedVirtualCallRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct switchedVirtualCallTable_data *switchedVirtualCallTable_duplicate(struct switchedVirtualCallTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct switchedVirtualCallTable_data *
switchedVirtualCallTable_duplicate(struct switchedVirtualCallTable_data *thedata)
{
	struct switchedVirtualCallTable_data *StorageNew = SNMP_MALLOC_STRUCT(switchedVirtualCallTable_data);

	DEBUGMSGTL(("dlMIB", "switchedVirtualCallTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	switchedVirtualCallTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int switchedVirtualCallTable_destroy(struct switchedVirtualCallTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
switchedVirtualCallTable_destroy(struct switchedVirtualCallTable_data **thedata)
{
	struct switchedVirtualCallTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "switchedVirtualCallTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCallId);
		StorageDel->virtualCallIdLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCalldirection);
		StorageDel->switchedVirtualCalldirectionLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallremoteDTEAddress);
		StorageDel->switchedVirtualCallremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallthroughputClass);
		StorageDel->switchedVirtualCallthroughputClassLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallredirectReason);
		StorageDel->switchedVirtualCallredirectReasonLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCalloriginallyCalledAddress);
		StorageDel->switchedVirtualCalloriginallyCalledAddressLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallcallingAddressExtension);
		StorageDel->switchedVirtualCallcallingAddressExtensionLen = 0;
		SNMP_FREE(StorageDel->switchedVirtualCallcalledAddressExtension);
		StorageDel->switchedVirtualCallcalledAddressExtensionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int switchedVirtualCallTable_add(struct switchedVirtualCallTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the switchedVirtualCallTable table data set.
 *
 * Adds a table row structure to the switchedVirtualCallTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
switchedVirtualCallTable_add(struct switchedVirtualCallTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "switchedVirtualCallTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		/* virtualCallId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCallId, thedata->virtualCallIdLen);
		header_complex_add_data(&switchedVirtualCallTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int switchedVirtualCallTable_del(struct switchedVirtualCallTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the switchedVirtualCallTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
switchedVirtualCallTable_del(struct switchedVirtualCallTable_data *thedata)
{
	struct switchedVirtualCallTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "switchedVirtualCallTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(switchedVirtualCallTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&switchedVirtualCallTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_switchedVirtualCallTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for switchedVirtualCallTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case switchedVirtualCallTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_switchedVirtualCallTable(const char *token, char *line)
{
	size_t tmpsize;
	struct switchedVirtualCallTable_data *StorageTmp = switchedVirtualCallTable_create();

	DEBUGMSGTL(("dlMIB", "parse_switchedVirtualCallTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCallId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
	if (StorageTmp->virtualCallId == NULL) {
		config_perror("invalid specification for virtualCallId");
		return;
	}
	SNMP_FREE(StorageTmp->switchedVirtualCalldirection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCalldirection, &StorageTmp->switchedVirtualCalldirectionLen);
	if (StorageTmp->switchedVirtualCalldirection == NULL) {
		config_perror("invalid specification for switchedVirtualCalldirection");
		return;
	}
	SNMP_FREE(StorageTmp->switchedVirtualCallremoteDTEAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallremoteDTEAddress, &StorageTmp->switchedVirtualCallremoteDTEAddressLen);
	if (StorageTmp->switchedVirtualCallremoteDTEAddress == NULL) {
		config_perror("invalid specification for switchedVirtualCallremoteDTEAddress");
		return;
	}
	SNMP_FREE(StorageTmp->switchedVirtualCallthroughputClass);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallthroughputClass, &StorageTmp->switchedVirtualCallthroughputClassLen);
	if (StorageTmp->switchedVirtualCallthroughputClass == NULL) {
		config_perror("invalid specification for switchedVirtualCallthroughputClass");
		return;
	}
	SNMP_FREE(StorageTmp->switchedVirtualCallredirectReason);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallredirectReason, &StorageTmp->switchedVirtualCallredirectReasonLen);
	if (StorageTmp->switchedVirtualCallredirectReason == NULL) {
		config_perror("invalid specification for switchedVirtualCallredirectReason");
		return;
	}
	SNMP_FREE(StorageTmp->switchedVirtualCalloriginallyCalledAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCalloriginallyCalledAddress, &StorageTmp->switchedVirtualCalloriginallyCalledAddressLen);
	if (StorageTmp->switchedVirtualCalloriginallyCalledAddress == NULL) {
		config_perror("invalid specification for switchedVirtualCalloriginallyCalledAddress");
		return;
	}
	SNMP_FREE(StorageTmp->switchedVirtualCallcallingAddressExtension);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallcallingAddressExtension, &StorageTmp->switchedVirtualCallcallingAddressExtensionLen);
	if (StorageTmp->switchedVirtualCallcallingAddressExtension == NULL) {
		config_perror("invalid specification for switchedVirtualCallcallingAddressExtension");
		return;
	}
	SNMP_FREE(StorageTmp->switchedVirtualCallcalledAddressExtension);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->switchedVirtualCallcalledAddressExtension, &StorageTmp->switchedVirtualCallcalledAddressExtensionLen);
	if (StorageTmp->switchedVirtualCallcalledAddressExtension == NULL) {
		config_perror("invalid specification for switchedVirtualCallcalledAddressExtension");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->switchedVirtualCallRowStatus, &tmpsize);
	switchedVirtualCallTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_switchedVirtualCallTable(): store configuraiton file for switchedVirtualCallTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_switchedVirtualCallTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct switchedVirtualCallTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_switchedVirtualCallTable: storing data...  "));
	refresh_switchedVirtualCallTable(1);
	(void) tmpsize;
	for (hcindex = switchedVirtualCallTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct switchedVirtualCallTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "switchedVirtualCallTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCallId, &StorageTmp->virtualCallIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCalldirection, &StorageTmp->switchedVirtualCalldirectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallremoteDTEAddress, &StorageTmp->switchedVirtualCallremoteDTEAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallthroughputClass, &StorageTmp->switchedVirtualCallthroughputClassLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallredirectReason, &StorageTmp->switchedVirtualCallredirectReasonLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCalloriginallyCalledAddress, &StorageTmp->switchedVirtualCalloriginallyCalledAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallcallingAddressExtension, &StorageTmp->switchedVirtualCallcallingAddressExtensionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->switchedVirtualCallcalledAddressExtension, &StorageTmp->switchedVirtualCallcalledAddressExtensionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->switchedVirtualCallRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCall_DTETable_data *virtualCall_DTETable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCall_DTETable table.
 *
 * Creates a new virtualCall_DTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCall_DTETable_data *
virtualCall_DTETable_create(void)
{
	struct virtualCall_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCall_DTETable_data);

	DEBUGMSGTL(("dlMIB", "virtualCall_DTETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		if ((StorageNew->virtualCircuitId = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitIdLen = strlen("");
		if ((StorageNew->virtualCall_DTEcallingAddressExtension = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DTEcallingAddressExtensionLen = strlen("");
		if ((StorageNew->virtualCall_DTEcalledAddressExtension = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DTEcalledAddressExtensionLen = strlen("");
		if ((StorageNew->virtualCall_DTEdirection = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DTEdirectionLen = strlen("");
		StorageNew->virtualCall_DTEfastSelect = 0;
		if ((StorageNew->virtualCall_DTEoriginallyCalledAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DTEoriginallyCalledAddressLen = strlen("");
		if ((StorageNew->virtualCall_DTEredirectReason = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DTEredirectReasonLen = strlen("");
		if ((StorageNew->virtualCall_DTEremoteDTEAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DTEremoteDTEAddressLen = strlen("");
		if ((StorageNew->virtualCall_DTEreverseCharging = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DTEreverseChargingLen = strlen("");
		StorageNew->virtualCall_DTERowStatus = 0;
		StorageNew->virtualCall_DTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct virtualCall_DTETable_data *virtualCall_DTETable_duplicate(struct virtualCall_DTETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct virtualCall_DTETable_data *
virtualCall_DTETable_duplicate(struct virtualCall_DTETable_data *thedata)
{
	struct virtualCall_DTETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCall_DTETable_data);

	DEBUGMSGTL(("dlMIB", "virtualCall_DTETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	virtualCall_DTETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int virtualCall_DTETable_destroy(struct virtualCall_DTETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCall_DTETable_destroy(struct virtualCall_DTETable_data **thedata)
{
	struct virtualCall_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCall_DTETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEcallingAddressExtension);
		StorageDel->virtualCall_DTEcallingAddressExtensionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEcalledAddressExtension);
		StorageDel->virtualCall_DTEcalledAddressExtensionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEdirection);
		StorageDel->virtualCall_DTEdirectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEoriginallyCalledAddress);
		StorageDel->virtualCall_DTEoriginallyCalledAddressLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEredirectReason);
		StorageDel->virtualCall_DTEredirectReasonLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEremoteDTEAddress);
		StorageDel->virtualCall_DTEremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DTEreverseCharging);
		StorageDel->virtualCall_DTEreverseChargingLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCall_DTETable_add(struct virtualCall_DTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCall_DTETable table data set.
 *
 * Adds a table row structure to the virtualCall_DTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCall_DTETable_add(struct virtualCall_DTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "virtualCall_DTETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		/* virtualCircuitId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
		header_complex_add_data(&virtualCall_DTETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCall_DTETable_del(struct virtualCall_DTETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the virtualCall_DTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCall_DTETable_del(struct virtualCall_DTETable_data *thedata)
{
	struct virtualCall_DTETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCall_DTETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCall_DTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCall_DTETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCall_DTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCall_DTETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCall_DTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCall_DTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCall_DTETable_data *StorageTmp = virtualCall_DTETable_create();

	DEBUGMSGTL(("dlMIB", "parse_virtualCall_DTETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCircuitId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DTEcallingAddressExtension);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEcallingAddressExtension, &StorageTmp->virtualCall_DTEcallingAddressExtensionLen);
	if (StorageTmp->virtualCall_DTEcallingAddressExtension == NULL) {
		config_perror("invalid specification for virtualCall_DTEcallingAddressExtension");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DTEcalledAddressExtension);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEcalledAddressExtension, &StorageTmp->virtualCall_DTEcalledAddressExtensionLen);
	if (StorageTmp->virtualCall_DTEcalledAddressExtension == NULL) {
		config_perror("invalid specification for virtualCall_DTEcalledAddressExtension");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DTEdirection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEdirection, &StorageTmp->virtualCall_DTEdirectionLen);
	if (StorageTmp->virtualCall_DTEdirection == NULL) {
		config_perror("invalid specification for virtualCall_DTEdirection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DTEfastSelect, &tmpsize);
	SNMP_FREE(StorageTmp->virtualCall_DTEoriginallyCalledAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEoriginallyCalledAddress, &StorageTmp->virtualCall_DTEoriginallyCalledAddressLen);
	if (StorageTmp->virtualCall_DTEoriginallyCalledAddress == NULL) {
		config_perror("invalid specification for virtualCall_DTEoriginallyCalledAddress");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DTEredirectReason);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEredirectReason, &StorageTmp->virtualCall_DTEredirectReasonLen);
	if (StorageTmp->virtualCall_DTEredirectReason == NULL) {
		config_perror("invalid specification for virtualCall_DTEredirectReason");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DTEremoteDTEAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEremoteDTEAddress, &StorageTmp->virtualCall_DTEremoteDTEAddressLen);
	if (StorageTmp->virtualCall_DTEremoteDTEAddress == NULL) {
		config_perror("invalid specification for virtualCall_DTEremoteDTEAddress");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DTEreverseCharging);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DTEreverseCharging, &StorageTmp->virtualCall_DTEreverseChargingLen);
	if (StorageTmp->virtualCall_DTEreverseCharging == NULL) {
		config_perror("invalid specification for virtualCall_DTEreverseCharging");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DTERowStatus, &tmpsize);
	virtualCall_DTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_virtualCall_DTETable(): store configuraiton file for virtualCall_DTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCall_DTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCall_DTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_virtualCall_DTETable: storing data...  "));
	refresh_virtualCall_DTETable(1);
	(void) tmpsize;
	for (hcindex = virtualCall_DTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCall_DTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCall_DTETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEcallingAddressExtension, &StorageTmp->virtualCall_DTEcallingAddressExtensionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEcalledAddressExtension, &StorageTmp->virtualCall_DTEcalledAddressExtensionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEdirection, &StorageTmp->virtualCall_DTEdirectionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DTEfastSelect, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEoriginallyCalledAddress, &StorageTmp->virtualCall_DTEoriginallyCalledAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEredirectReason, &StorageTmp->virtualCall_DTEredirectReasonLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEremoteDTEAddress, &StorageTmp->virtualCall_DTEremoteDTEAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DTEreverseCharging, &StorageTmp->virtualCall_DTEreverseChargingLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualCall_DCETable_data *virtualCall_DCETable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualCall_DCETable table.
 *
 * Creates a new virtualCall_DCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualCall_DCETable_data *
virtualCall_DCETable_create(void)
{
	struct virtualCall_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCall_DCETable_data);

	DEBUGMSGTL(("dlMIB", "virtualCall_DCETable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		if ((StorageNew->virtualCircuitId = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitIdLen = strlen("");
		if ((StorageNew->virtualCall_DCEchargingDirection = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCEchargingDirectionLen = strlen("");
		if ((StorageNew->virtualCall_DCEcUGSelection = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCEcUGSelectionLen = strlen("");
		if ((StorageNew->virtualCall_DCEdirection = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCEdirectionLen = strlen("");
		StorageNew->virtualCall_DCEfastSelect = 0;
		if ((StorageNew->virtualCall_DCEremoteDTEAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCEremoteDTEAddressLen = strlen("");
		if ((StorageNew->virtualCall_DCEtransitDelaySelectionAndIndication = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCEtransitDelaySelectionAndIndicationLen = strlen("");
		if ((StorageNew->virtualCall_DCEbilateralCUGSelection = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCEbilateralCUGSelectionLen = strlen("");
		StorageNew->virtualCall_DCEcallRedirectionDeflectionNotification = 0;
		StorageNew->virtualCall_DCEcalledLineAddressModifiedNotification = 0;
		if ((StorageNew->virtualCall_DCEcUGWithOutgoingAccessSelection = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCEcUGWithOutgoingAccessSelectionLen = strlen("");
		if ((StorageNew->virtualCall_DCEnUISelection = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCEnUISelectionLen = strlen("");
		if ((StorageNew->virtualCall_DCEreverseCharging = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCEreverseChargingLen = strlen("");
		if ((StorageNew->virtualCall_DCErOASelection = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCall_DCErOASelectionLen = strlen("");
		StorageNew->virtualCall_DCERowStatus = 0;
		StorageNew->virtualCall_DCERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct virtualCall_DCETable_data *virtualCall_DCETable_duplicate(struct virtualCall_DCETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct virtualCall_DCETable_data *
virtualCall_DCETable_duplicate(struct virtualCall_DCETable_data *thedata)
{
	struct virtualCall_DCETable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualCall_DCETable_data);

	DEBUGMSGTL(("dlMIB", "virtualCall_DCETable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	virtualCall_DCETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int virtualCall_DCETable_destroy(struct virtualCall_DCETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualCall_DCETable_destroy(struct virtualCall_DCETable_data **thedata)
{
	struct virtualCall_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCall_DCETable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEchargingDirection);
		StorageDel->virtualCall_DCEchargingDirectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEcUGSelection);
		StorageDel->virtualCall_DCEcUGSelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEdirection);
		StorageDel->virtualCall_DCEdirectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEremoteDTEAddress);
		StorageDel->virtualCall_DCEremoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEtransitDelaySelectionAndIndication);
		StorageDel->virtualCall_DCEtransitDelaySelectionAndIndicationLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEbilateralCUGSelection);
		StorageDel->virtualCall_DCEbilateralCUGSelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEcUGWithOutgoingAccessSelection);
		StorageDel->virtualCall_DCEcUGWithOutgoingAccessSelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEnUISelection);
		StorageDel->virtualCall_DCEnUISelectionLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCEreverseCharging);
		StorageDel->virtualCall_DCEreverseChargingLen = 0;
		SNMP_FREE(StorageDel->virtualCall_DCErOASelection);
		StorageDel->virtualCall_DCErOASelectionLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCall_DCETable_add(struct virtualCall_DCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualCall_DCETable table data set.
 *
 * Adds a table row structure to the virtualCall_DCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualCall_DCETable_add(struct virtualCall_DCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "virtualCall_DCETable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		/* virtualCircuitId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
		header_complex_add_data(&virtualCall_DCETableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualCall_DCETable_del(struct virtualCall_DCETable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the virtualCall_DCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualCall_DCETable_del(struct virtualCall_DCETable_data *thedata)
{
	struct virtualCall_DCETable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualCall_DCETable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualCall_DCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualCall_DCETableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualCall_DCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualCall_DCETable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualCall_DCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualCall_DCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualCall_DCETable_data *StorageTmp = virtualCall_DCETable_create();

	DEBUGMSGTL(("dlMIB", "parse_virtualCall_DCETable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCircuitId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DCEchargingDirection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEchargingDirection, &StorageTmp->virtualCall_DCEchargingDirectionLen);
	if (StorageTmp->virtualCall_DCEchargingDirection == NULL) {
		config_perror("invalid specification for virtualCall_DCEchargingDirection");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DCEcUGSelection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEcUGSelection, &StorageTmp->virtualCall_DCEcUGSelectionLen);
	if (StorageTmp->virtualCall_DCEcUGSelection == NULL) {
		config_perror("invalid specification for virtualCall_DCEcUGSelection");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DCEdirection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEdirection, &StorageTmp->virtualCall_DCEdirectionLen);
	if (StorageTmp->virtualCall_DCEdirection == NULL) {
		config_perror("invalid specification for virtualCall_DCEdirection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DCEfastSelect, &tmpsize);
	SNMP_FREE(StorageTmp->virtualCall_DCEremoteDTEAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEremoteDTEAddress, &StorageTmp->virtualCall_DCEremoteDTEAddressLen);
	if (StorageTmp->virtualCall_DCEremoteDTEAddress == NULL) {
		config_perror("invalid specification for virtualCall_DCEremoteDTEAddress");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndication);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndication, &StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndicationLen);
	if (StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndication == NULL) {
		config_perror("invalid specification for virtualCall_DCEtransitDelaySelectionAndIndication");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DCEbilateralCUGSelection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEbilateralCUGSelection, &StorageTmp->virtualCall_DCEbilateralCUGSelectionLen);
	if (StorageTmp->virtualCall_DCEbilateralCUGSelection == NULL) {
		config_perror("invalid specification for virtualCall_DCEbilateralCUGSelection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DCEcallRedirectionDeflectionNotification, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DCEcalledLineAddressModifiedNotification, &tmpsize);
	SNMP_FREE(StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelection, &StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelectionLen);
	if (StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelection == NULL) {
		config_perror("invalid specification for virtualCall_DCEcUGWithOutgoingAccessSelection");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DCEnUISelection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEnUISelection, &StorageTmp->virtualCall_DCEnUISelectionLen);
	if (StorageTmp->virtualCall_DCEnUISelection == NULL) {
		config_perror("invalid specification for virtualCall_DCEnUISelection");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DCEreverseCharging);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCEreverseCharging, &StorageTmp->virtualCall_DCEreverseChargingLen);
	if (StorageTmp->virtualCall_DCEreverseCharging == NULL) {
		config_perror("invalid specification for virtualCall_DCEreverseCharging");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCall_DCErOASelection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCall_DCErOASelection, &StorageTmp->virtualCall_DCErOASelectionLen);
	if (StorageTmp->virtualCall_DCErOASelection == NULL) {
		config_perror("invalid specification for virtualCall_DCErOASelection");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualCall_DCERowStatus, &tmpsize);
	virtualCall_DCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_virtualCall_DCETable(): store configuraiton file for virtualCall_DCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualCall_DCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualCall_DCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_virtualCall_DCETable: storing data...  "));
	refresh_virtualCall_DCETable(1);
	(void) tmpsize;
	for (hcindex = virtualCall_DCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualCall_DCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualCall_DCETable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEchargingDirection, &StorageTmp->virtualCall_DCEchargingDirectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEcUGSelection, &StorageTmp->virtualCall_DCEcUGSelectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEdirection, &StorageTmp->virtualCall_DCEdirectionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DCEfastSelect, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEremoteDTEAddress, &StorageTmp->virtualCall_DCEremoteDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndication,
						   &StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndicationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEbilateralCUGSelection, &StorageTmp->virtualCall_DCEbilateralCUGSelectionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DCEcallRedirectionDeflectionNotification, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DCEcalledLineAddressModifiedNotification, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelection, &StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEnUISelection, &StorageTmp->virtualCall_DCEnUISelectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCEreverseCharging, &StorageTmp->virtualCall_DCEreverseChargingLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCall_DCErOASelection, &StorageTmp->virtualCall_DCErOASelectionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualCall_DCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dSeriesCountsTable_data *dSeriesCountsTable_create(void)
 * @brief create a fresh data structure representing a new row in the dSeriesCountsTable table.
 *
 * Creates a new dSeriesCountsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dSeriesCountsTable_data *
dSeriesCountsTable_create(void)
{
	struct dSeriesCountsTable_data *StorageNew = SNMP_MALLOC_STRUCT(dSeriesCountsTable_data);

	DEBUGMSGTL(("dlMIB", "dSeriesCountsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->x25PLEId = (uint8_t *) strdup("")) != NULL)
			StorageNew->x25PLEIdLen = strlen("");
		if ((StorageNew->virtualCircuitId = (uint8_t *) strdup("")) != NULL)
			StorageNew->virtualCircuitIdLen = strlen("");
		StorageNew->dSeriesResetRequestIndicationPackets = 0;
		StorageNew->dSeriesSegmentsSent = 0;
		StorageNew->dSeriesSegmentsReceived = 0;
		StorageNew->dSeriesRowStatus = 0;
		StorageNew->dSeriesRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct dSeriesCountsTable_data *dSeriesCountsTable_duplicate(struct dSeriesCountsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dSeriesCountsTable_data *
dSeriesCountsTable_duplicate(struct dSeriesCountsTable_data *thedata)
{
	struct dSeriesCountsTable_data *StorageNew = SNMP_MALLOC_STRUCT(dSeriesCountsTable_data);

	DEBUGMSGTL(("dlMIB", "dSeriesCountsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dSeriesCountsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dSeriesCountsTable_destroy(struct dSeriesCountsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dSeriesCountsTable_destroy(struct dSeriesCountsTable_data **thedata)
{
	struct dSeriesCountsTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "dSeriesCountsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->virtualCircuitId);
		StorageDel->virtualCircuitIdLen = 0;
		SNMP_FREE(StorageDel->dSeriesId);
		StorageDel->dSeriesIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dSeriesCountsTable_add(struct dSeriesCountsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dSeriesCountsTable table data set.
 *
 * Adds a table row structure to the dSeriesCountsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dSeriesCountsTable_add(struct dSeriesCountsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "dSeriesCountsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* x25PLEId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId, thedata->x25PLEIdLen);
		/* virtualCircuitId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualCircuitId, thedata->virtualCircuitIdLen);
		/* dSeriesId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->dSeriesId, thedata->dSeriesIdLen);
		header_complex_add_data(&dSeriesCountsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dSeriesCountsTable_del(struct dSeriesCountsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dSeriesCountsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dSeriesCountsTable_del(struct dSeriesCountsTable_data *thedata)
{
	struct dSeriesCountsTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "dSeriesCountsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dSeriesCountsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dSeriesCountsTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dSeriesCountsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dSeriesCountsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case dSeriesCountsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dSeriesCountsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dSeriesCountsTable_data *StorageTmp = dSeriesCountsTable_create();

	DEBUGMSGTL(("dlMIB", "parse_dSeriesCountsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->x25PLEId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualCircuitId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
	if (StorageTmp->virtualCircuitId == NULL) {
		config_perror("invalid specification for virtualCircuitId");
		return;
	}
	SNMP_FREE(StorageTmp->dSeriesId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dSeriesId, &StorageTmp->dSeriesIdLen);
	if (StorageTmp->dSeriesId == NULL) {
		config_perror("invalid specification for dSeriesId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dSeriesResetRequestIndicationPackets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dSeriesSegmentsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dSeriesSegmentsReceived, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dSeriesRowStatus, &tmpsize);
	dSeriesCountsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_dSeriesCountsTable(): store configuraiton file for dSeriesCountsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dSeriesCountsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dSeriesCountsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_dSeriesCountsTable: storing data...  "));
	refresh_dSeriesCountsTable(1);
	(void) tmpsize;
	for (hcindex = dSeriesCountsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dSeriesCountsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dSeriesCountsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &StorageTmp->x25PLEIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualCircuitId, &StorageTmp->virtualCircuitIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dSeriesId, &StorageTmp->dSeriesIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dSeriesResetRequestIndicationPackets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dSeriesSegmentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dSeriesSegmentsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dSeriesRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct adjacencyTable_data *adjacencyTable_create(void)
 * @brief create a fresh data structure representing a new row in the adjacencyTable table.
 *
 * Creates a new adjacencyTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct adjacencyTable_data *
adjacencyTable_create(void)
{
	struct adjacencyTable_data *StorageNew = SNMP_MALLOC_STRUCT(adjacencyTable_data);

	DEBUGMSGTL(("dlMIB", "adjacencyTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->clProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->clProtocolMachineIdLen = strlen("");
		if ((StorageNew->linkageId = (uint8_t *) strdup("")) != NULL)
			StorageNew->linkageIdLen = strlen("");
		StorageNew->adjacencyState = 0;
		if ((StorageNew->neighbourSNPAAddress = (uint8_t *) strdup("")) != NULL)
			StorageNew->neighbourSNPAAddressLen = strlen("");
		StorageNew->neighbourSystemType = 0;
		if ((StorageNew->neighbourSystemIds = (uint8_t *) strdup("")) != NULL)
			StorageNew->neighbourSystemIdsLen = strlen("");
		StorageNew->adjacencyUsage = ADJACENCYUSAGE_UNDEFINED;
		if ((StorageNew->areaAddressesOfNeighbour = (uint8_t *) strdup("")) != NULL)
			StorageNew->areaAddressesOfNeighbourLen = strlen("");
		StorageNew->holdingTimer = 0;
		StorageNew->priorityOfNeighbour = 0;
		StorageNew->adjacencyRowStatus = 0;
		StorageNew->adjacencyRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct adjacencyTable_data *adjacencyTable_duplicate(struct adjacencyTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct adjacencyTable_data *
adjacencyTable_duplicate(struct adjacencyTable_data *thedata)
{
	struct adjacencyTable_data *StorageNew = SNMP_MALLOC_STRUCT(adjacencyTable_data);

	DEBUGMSGTL(("dlMIB", "adjacencyTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	adjacencyTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int adjacencyTable_destroy(struct adjacencyTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
adjacencyTable_destroy(struct adjacencyTable_data **thedata)
{
	struct adjacencyTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "adjacencyTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->linkageId);
		StorageDel->linkageIdLen = 0;
		SNMP_FREE(StorageDel->adjacencyId);
		StorageDel->adjacencyIdLen = 0;
		SNMP_FREE(StorageDel->neighbourSNPAAddress);
		StorageDel->neighbourSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->neighbourSystemIds);
		StorageDel->neighbourSystemIdsLen = 0;
		SNMP_FREE(StorageDel->areaAddressesOfNeighbour);
		StorageDel->areaAddressesOfNeighbourLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int adjacencyTable_add(struct adjacencyTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the adjacencyTable table data set.
 *
 * Adds a table row structure to the adjacencyTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
adjacencyTable_add(struct adjacencyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "adjacencyTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		/* linkageId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->linkageId, thedata->linkageIdLen);
		/* adjacencyId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->adjacencyId, thedata->adjacencyIdLen);
		header_complex_add_data(&adjacencyTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int adjacencyTable_del(struct adjacencyTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the adjacencyTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
adjacencyTable_del(struct adjacencyTable_data *thedata)
{
	struct adjacencyTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "adjacencyTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(adjacencyTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&adjacencyTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_adjacencyTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for adjacencyTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case adjacencyTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_adjacencyTable(const char *token, char *line)
{
	size_t tmpsize;
	struct adjacencyTable_data *StorageTmp = adjacencyTable_create();

	DEBUGMSGTL(("dlMIB", "parse_adjacencyTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->linkageId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->linkageId, &StorageTmp->linkageIdLen);
	if (StorageTmp->linkageId == NULL) {
		config_perror("invalid specification for linkageId");
		return;
	}
	SNMP_FREE(StorageTmp->adjacencyId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->adjacencyId, &StorageTmp->adjacencyIdLen);
	if (StorageTmp->adjacencyId == NULL) {
		config_perror("invalid specification for adjacencyId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->adjacencyState, &tmpsize);
	SNMP_FREE(StorageTmp->neighbourSNPAAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->neighbourSNPAAddress, &StorageTmp->neighbourSNPAAddressLen);
	if (StorageTmp->neighbourSNPAAddress == NULL) {
		config_perror("invalid specification for neighbourSNPAAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->neighbourSystemType, &tmpsize);
	SNMP_FREE(StorageTmp->neighbourSystemIds);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->neighbourSystemIds, &StorageTmp->neighbourSystemIdsLen);
	if (StorageTmp->neighbourSystemIds == NULL) {
		config_perror("invalid specification for neighbourSystemIds");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->adjacencyUsage, &tmpsize);
	SNMP_FREE(StorageTmp->areaAddressesOfNeighbour);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->areaAddressesOfNeighbour, &StorageTmp->areaAddressesOfNeighbourLen);
	if (StorageTmp->areaAddressesOfNeighbour == NULL) {
		config_perror("invalid specification for areaAddressesOfNeighbour");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->holdingTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->priorityOfNeighbour, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->adjacencyRowStatus, &tmpsize);
	adjacencyTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_adjacencyTable(): store configuraiton file for adjacencyTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_adjacencyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct adjacencyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_adjacencyTable: storing data...  "));
	refresh_adjacencyTable(1);
	(void) tmpsize;
	for (hcindex = adjacencyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct adjacencyTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "adjacencyTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->linkageId, &StorageTmp->linkageIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->adjacencyId, &StorageTmp->adjacencyIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->adjacencyState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->neighbourSNPAAddress, &StorageTmp->neighbourSNPAAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->neighbourSystemType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->neighbourSystemIds, &StorageTmp->neighbourSystemIdsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->adjacencyUsage, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->areaAddressesOfNeighbour, &StorageTmp->areaAddressesOfNeighbourLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->holdingTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->priorityOfNeighbour, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->adjacencyRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct virtualAdjacencyTable_data *virtualAdjacencyTable_create(void)
 * @brief create a fresh data structure representing a new row in the virtualAdjacencyTable table.
 *
 * Creates a new virtualAdjacencyTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct virtualAdjacencyTable_data *
virtualAdjacencyTable_create(void)
{
	struct virtualAdjacencyTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualAdjacencyTable_data);

	DEBUGMSGTL(("dlMIB", "virtualAdjacencyTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->clProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->clProtocolMachineIdLen = strlen("");
		StorageNew->virtualAdjacencyMetric = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct virtualAdjacencyTable_data *virtualAdjacencyTable_duplicate(struct virtualAdjacencyTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct virtualAdjacencyTable_data *
virtualAdjacencyTable_duplicate(struct virtualAdjacencyTable_data *thedata)
{
	struct virtualAdjacencyTable_data *StorageNew = SNMP_MALLOC_STRUCT(virtualAdjacencyTable_data);

	DEBUGMSGTL(("dlMIB", "virtualAdjacencyTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	virtualAdjacencyTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int virtualAdjacencyTable_destroy(struct virtualAdjacencyTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
virtualAdjacencyTable_destroy(struct virtualAdjacencyTable_data **thedata)
{
	struct virtualAdjacencyTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualAdjacencyTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->virtualAdjacencyNetworkEntityTitle);
		StorageDel->virtualAdjacencyNetworkEntityTitleLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualAdjacencyTable_add(struct virtualAdjacencyTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the virtualAdjacencyTable table data set.
 *
 * Adds a table row structure to the virtualAdjacencyTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
virtualAdjacencyTable_add(struct virtualAdjacencyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "virtualAdjacencyTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		/* virtualAdjacencyNetworkEntityTitle */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->virtualAdjacencyNetworkEntityTitle, thedata->virtualAdjacencyNetworkEntityTitleLen);
		header_complex_add_data(&virtualAdjacencyTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int virtualAdjacencyTable_del(struct virtualAdjacencyTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the virtualAdjacencyTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
virtualAdjacencyTable_del(struct virtualAdjacencyTable_data *thedata)
{
	struct virtualAdjacencyTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "virtualAdjacencyTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(virtualAdjacencyTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&virtualAdjacencyTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_virtualAdjacencyTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for virtualAdjacencyTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case virtualAdjacencyTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_virtualAdjacencyTable(const char *token, char *line)
{
	size_t tmpsize;
	struct virtualAdjacencyTable_data *StorageTmp = virtualAdjacencyTable_create();

	DEBUGMSGTL(("dlMIB", "parse_virtualAdjacencyTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->virtualAdjacencyNetworkEntityTitle);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->virtualAdjacencyNetworkEntityTitle, &StorageTmp->virtualAdjacencyNetworkEntityTitleLen);
	if (StorageTmp->virtualAdjacencyNetworkEntityTitle == NULL) {
		config_perror("invalid specification for virtualAdjacencyNetworkEntityTitle");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->virtualAdjacencyMetric, &tmpsize);
	virtualAdjacencyTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_virtualAdjacencyTable(): store configuraiton file for virtualAdjacencyTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_virtualAdjacencyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct virtualAdjacencyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_virtualAdjacencyTable: storing data...  "));
	refresh_virtualAdjacencyTable(1);
	(void) tmpsize;
	for (hcindex = virtualAdjacencyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct virtualAdjacencyTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "virtualAdjacencyTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->virtualAdjacencyNetworkEntityTitle, &StorageTmp->virtualAdjacencyNetworkEntityTitleLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->virtualAdjacencyMetric, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct destinationTable_data *destinationTable_create(void)
 * @brief create a fresh data structure representing a new row in the destinationTable table.
 *
 * Creates a new destinationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct destinationTable_data *
destinationTable_create(void)
{
	struct destinationTable_data *StorageNew = SNMP_MALLOC_STRUCT(destinationTable_data);

	DEBUGMSGTL(("dlMIB", "destinationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->clProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->clProtocolMachineIdLen = strlen("");
		StorageNew->destinationDefaultMetricPathCost = 0;
		if ((StorageNew->destinationDefaultMetricOutputAdjacencies = (uint8_t *) strdup("")) != NULL)
			StorageNew->destinationDefaultMetricOutputAdjacenciesLen = strlen("");
		StorageNew->destinationDelayMetricPathCost = 0;
		if ((StorageNew->destinationDelayMetricOutputAdjacencies = (uint8_t *) strdup("")) != NULL)
			StorageNew->destinationDelayMetricOutputAdjacenciesLen = strlen("");
		StorageNew->destinationExpenseMetricPathCost = 0;
		if ((StorageNew->destinationExpenseMetricOutputAdjacencies = (uint8_t *) strdup("")) != NULL)
			StorageNew->destinationExpenseMetricOutputAdjacenciesLen = strlen("");
		StorageNew->destinationErrorMetricPathCost = 0;
		if ((StorageNew->destinationErrorMetricOutputAdjacencies = (uint8_t *) strdup("")) != NULL)
			StorageNew->destinationErrorMetricOutputAdjacenciesLen = strlen("");

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct destinationTable_data *destinationTable_duplicate(struct destinationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct destinationTable_data *
destinationTable_duplicate(struct destinationTable_data *thedata)
{
	struct destinationTable_data *StorageNew = SNMP_MALLOC_STRUCT(destinationTable_data);

	DEBUGMSGTL(("dlMIB", "destinationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	destinationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int destinationTable_destroy(struct destinationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
destinationTable_destroy(struct destinationTable_data **thedata)
{
	struct destinationTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "destinationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->destinationAddressPrefix);
		StorageDel->destinationAddressPrefixLen = 0;
		SNMP_FREE(StorageDel->destinationDefaultMetricOutputAdjacencies);
		StorageDel->destinationDefaultMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel->destinationDelayMetricOutputAdjacencies);
		StorageDel->destinationDelayMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel->destinationExpenseMetricOutputAdjacencies);
		StorageDel->destinationExpenseMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel->destinationErrorMetricOutputAdjacencies);
		StorageDel->destinationErrorMetricOutputAdjacenciesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationTable_add(struct destinationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the destinationTable table data set.
 *
 * Adds a table row structure to the destinationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
destinationTable_add(struct destinationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "destinationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		/* destinationAddressPrefix */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->destinationAddressPrefix, thedata->destinationAddressPrefixLen);
		header_complex_add_data(&destinationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationTable_del(struct destinationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the destinationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
destinationTable_del(struct destinationTable_data *thedata)
{
	struct destinationTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "destinationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(destinationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&destinationTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_destinationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for destinationTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case destinationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_destinationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct destinationTable_data *StorageTmp = destinationTable_create();

	DEBUGMSGTL(("dlMIB", "parse_destinationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->destinationAddressPrefix);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationAddressPrefix, &StorageTmp->destinationAddressPrefixLen);
	if (StorageTmp->destinationAddressPrefix == NULL) {
		config_perror("invalid specification for destinationAddressPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationDefaultMetricPathCost, &tmpsize);
	SNMP_FREE(StorageTmp->destinationDefaultMetricOutputAdjacencies);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationDefaultMetricOutputAdjacencies, &StorageTmp->destinationDefaultMetricOutputAdjacenciesLen);
	if (StorageTmp->destinationDefaultMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationDefaultMetricOutputAdjacencies");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationDelayMetricPathCost, &tmpsize);
	SNMP_FREE(StorageTmp->destinationDelayMetricOutputAdjacencies);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationDelayMetricOutputAdjacencies, &StorageTmp->destinationDelayMetricOutputAdjacenciesLen);
	if (StorageTmp->destinationDelayMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationDelayMetricOutputAdjacencies");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationExpenseMetricPathCost, &tmpsize);
	SNMP_FREE(StorageTmp->destinationExpenseMetricOutputAdjacencies);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationExpenseMetricOutputAdjacencies, &StorageTmp->destinationExpenseMetricOutputAdjacenciesLen);
	if (StorageTmp->destinationExpenseMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationExpenseMetricOutputAdjacencies");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationErrorMetricPathCost, &tmpsize);
	SNMP_FREE(StorageTmp->destinationErrorMetricOutputAdjacencies);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationErrorMetricOutputAdjacencies, &StorageTmp->destinationErrorMetricOutputAdjacenciesLen);
	if (StorageTmp->destinationErrorMetricOutputAdjacencies == NULL) {
		config_perror("invalid specification for destinationErrorMetricOutputAdjacencies");
		return;
	}
	destinationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_destinationTable(): store configuraiton file for destinationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_destinationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct destinationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_destinationTable: storing data...  "));
	refresh_destinationTable(1);
	(void) tmpsize;
	for (hcindex = destinationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct destinationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "destinationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationAddressPrefix, &StorageTmp->destinationAddressPrefixLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationDefaultMetricPathCost, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationDefaultMetricOutputAdjacencies, &StorageTmp->destinationDefaultMetricOutputAdjacenciesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationDelayMetricPathCost, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationDelayMetricOutputAdjacencies, &StorageTmp->destinationDelayMetricOutputAdjacenciesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationExpenseMetricPathCost, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationExpenseMetricOutputAdjacencies, &StorageTmp->destinationExpenseMetricOutputAdjacenciesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationErrorMetricPathCost, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationErrorMetricOutputAdjacencies, &StorageTmp->destinationErrorMetricOutputAdjacenciesLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct destinationSystemTable_data *destinationSystemTable_create(void)
 * @brief create a fresh data structure representing a new row in the destinationSystemTable table.
 *
 * Creates a new destinationSystemTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct destinationSystemTable_data *
destinationSystemTable_create(void)
{
	struct destinationSystemTable_data *StorageNew = SNMP_MALLOC_STRUCT(destinationSystemTable_data);

	DEBUGMSGTL(("dlMIB", "destinationSystemTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->communicationsEntityId = (uint8_t *) strdup("")) != NULL)
			StorageNew->communicationsEntityIdLen = strlen("");
		if ((StorageNew->clProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->clProtocolMachineIdLen = strlen("");
		StorageNew->desintationSystemMetric = 0;

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct destinationSystemTable_data *destinationSystemTable_duplicate(struct destinationSystemTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct destinationSystemTable_data *
destinationSystemTable_duplicate(struct destinationSystemTable_data *thedata)
{
	struct destinationSystemTable_data *StorageNew = SNMP_MALLOC_STRUCT(destinationSystemTable_data);

	DEBUGMSGTL(("dlMIB", "destinationSystemTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	destinationSystemTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int destinationSystemTable_destroy(struct destinationSystemTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
destinationSystemTable_destroy(struct destinationSystemTable_data **thedata)
{
	struct destinationSystemTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "destinationSystemTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->communicationsEntityId);
		StorageDel->communicationsEntityIdLen = 0;
		SNMP_FREE(StorageDel->clProtocolMachineId);
		StorageDel->clProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->destinationSystemNetworkEntityTitle);
		StorageDel->destinationSystemNetworkEntityTitleLen = 0;
		SNMP_FREE(StorageDel->destinationSystemAdjacency);
		StorageDel->destinationSystemAdjacencyLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationSystemTable_add(struct destinationSystemTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the destinationSystemTable table data set.
 *
 * Adds a table row structure to the destinationSystemTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
destinationSystemTable_add(struct destinationSystemTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "destinationSystemTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* communicationsEntityId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->communicationsEntityId, thedata->communicationsEntityIdLen);
		/* clProtocolMachineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->clProtocolMachineId, thedata->clProtocolMachineIdLen);
		/* destinationSystemNetworkEntityTitle */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->destinationSystemNetworkEntityTitle, thedata->destinationSystemNetworkEntityTitleLen);
		/* destinationSystemMetricType */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->destinationSystemMetricType, sizeof(thedata->destinationSystemMetricType));
		/* destinationSystemAdjacency */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OBJECT_ID, (u_char *) thedata->destinationSystemAdjacency, thedata->destinationSystemAdjacencyLen * sizeof(oid));
		header_complex_add_data(&destinationSystemTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationSystemTable_del(struct destinationSystemTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the destinationSystemTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
destinationSystemTable_del(struct destinationSystemTable_data *thedata)
{
	struct destinationSystemTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "destinationSystemTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(destinationSystemTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&destinationSystemTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_destinationSystemTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for destinationSystemTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case destinationSystemTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_destinationSystemTable(const char *token, char *line)
{
	size_t tmpsize;
	struct destinationSystemTable_data *StorageTmp = destinationSystemTable_create();

	DEBUGMSGTL(("dlMIB", "parse_destinationSystemTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->communicationsEntityId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
	if (StorageTmp->communicationsEntityId == NULL) {
		config_perror("invalid specification for communicationsEntityId");
		return;
	}
	SNMP_FREE(StorageTmp->clProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
	if (StorageTmp->clProtocolMachineId == NULL) {
		config_perror("invalid specification for clProtocolMachineId");
		return;
	}
	SNMP_FREE(StorageTmp->destinationSystemNetworkEntityTitle);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationSystemNetworkEntityTitle, &StorageTmp->destinationSystemNetworkEntityTitleLen);
	if (StorageTmp->destinationSystemNetworkEntityTitle == NULL) {
		config_perror("invalid specification for destinationSystemNetworkEntityTitle");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->destinationSystemMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->desintationSystemMetric, &tmpsize);
	SNMP_FREE(StorageTmp->destinationSystemAdjacency);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->destinationSystemAdjacency, &StorageTmp->destinationSystemAdjacencyLen);
	if (StorageTmp->destinationSystemAdjacency == NULL) {
		config_perror("invalid specification for destinationSystemAdjacency");
		return;
	}
	destinationSystemTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_destinationSystemTable(): store configuraiton file for destinationSystemTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_destinationSystemTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct destinationSystemTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_destinationSystemTable: storing data...  "));
	refresh_destinationSystemTable(1);
	(void) tmpsize;
	for (hcindex = destinationSystemTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct destinationSystemTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "destinationSystemTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->communicationsEntityId, &StorageTmp->communicationsEntityIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->clProtocolMachineId, &StorageTmp->clProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationSystemNetworkEntityTitle, &StorageTmp->destinationSystemNetworkEntityTitleLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->destinationSystemMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->desintationSystemMetric, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->destinationSystemAdjacency, &StorageTmp->destinationSystemAdjacencyLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct destinationAreaTable_data *destinationAreaTable_create(void)
 * @brief create a fresh data structure representing a new row in the destinationAreaTable table.
 *
 * Creates a new destinationAreaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct destinationAreaTable_data *
destinationAreaTable_create(void)
{
	struct destinationAreaTable_data *StorageNew = SNMP_MALLOC_STRUCT(destinationAreaTable_data);

	DEBUGMSGTL(("dlMIB", "destinationAreaTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct destinationAreaTable_data *destinationAreaTable_duplicate(struct destinationAreaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct destinationAreaTable_data *
destinationAreaTable_duplicate(struct destinationAreaTable_data *thedata)
{
	struct destinationAreaTable_data *StorageNew = SNMP_MALLOC_STRUCT(destinationAreaTable_data);

	DEBUGMSGTL(("dlMIB", "destinationAreaTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	destinationAreaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int destinationAreaTable_destroy(struct destinationAreaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
destinationAreaTable_destroy(struct destinationAreaTable_data **thedata)
{
	struct destinationAreaTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "destinationAreaTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->destinationAreaId);
		StorageDel->destinationAreaIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationAreaTable_add(struct destinationAreaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the destinationAreaTable table data set.
 *
 * Adds a table row structure to the destinationAreaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
destinationAreaTable_add(struct destinationAreaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "destinationAreaTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* destinationAreaId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->destinationAreaId, thedata->destinationAreaIdLen);
		header_complex_add_data(&destinationAreaTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int destinationAreaTable_del(struct destinationAreaTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the destinationAreaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
destinationAreaTable_del(struct destinationAreaTable_data *thedata)
{
	struct destinationAreaTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "destinationAreaTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(destinationAreaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&destinationAreaTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_destinationAreaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for destinationAreaTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case destinationAreaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_destinationAreaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct destinationAreaTable_data *StorageTmp = destinationAreaTable_create();

	DEBUGMSGTL(("dlMIB", "parse_destinationAreaTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->destinationAreaId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->destinationAreaId, &StorageTmp->destinationAreaIdLen);
	if (StorageTmp->destinationAreaId == NULL) {
		config_perror("invalid specification for destinationAreaId");
		return;
	}
	destinationAreaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_destinationAreaTable(): store configuraiton file for destinationAreaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_destinationAreaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct destinationAreaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_destinationAreaTable: storing data...  "));
	refresh_destinationAreaTable(1);
	(void) tmpsize;
	for (hcindex = destinationAreaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct destinationAreaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "destinationAreaTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->destinationAreaId, &StorageTmp->destinationAreaIdLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct reachableAddressTable_data *reachableAddressTable_create(void)
 * @brief create a fresh data structure representing a new row in the reachableAddressTable table.
 *
 * Creates a new reachableAddressTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct reachableAddressTable_data *
reachableAddressTable_create(void)
{
	struct reachableAddressTable_data *StorageNew = SNMP_MALLOC_STRUCT(reachableAddressTable_data);

	DEBUGMSGTL(("dlMIB", "reachableAddressTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->reachableAddressPrefix = (uint8_t *) strdup("")) != NULL)
			StorageNew->reachableAddressPrefixLen = strlen("");
		StorageNew->reachableAddressMappingType = 0;
		StorageNew->reachableAddressDefaultMetric = 20;
		StorageNew->reachableAddressDelayMetric = 0;
		StorageNew->reachableAddressExpenseMetric = 0;
		StorageNew->reachableAddressErrorMetric = 0;
		StorageNew->reachableAddressDefaultMetricType = REACHABLEADDRESSDEFAULTMETRICTYPE_INTERNAL;
		StorageNew->reachableAddressDelayMetricType = REACHABLEADDRESSDELAYMETRICTYPE_INTERNAL;
		StorageNew->reachableAddressExpenseMetricType = REACHABLEADDRESSEXPENSEMETRICTYPE_INTERNAL;
		StorageNew->reachableAddressErrorMetricType = REACHABLEADDRESSERRORMETRICTYPE_INTERNAL;
		StorageNew->reachableAddressOperationalState = 0;
		StorageNew->reachableAddressAdministrativeState = 0;
		if ((StorageNew->reachableAddressSNPAAddresses = (uint8_t *) strdup("")) != NULL)
			StorageNew->reachableAddressSNPAAddressesLen = strlen("");
		if ((StorageNew->reachableAddressSNPAMask = (uint8_t *) strdup("")) != NULL)
			StorageNew->reachableAddressSNPAMaskLen = strlen("");
		if ((StorageNew->reachableAddressSNPAPrefix = (uint8_t *) strdup("")) != NULL)
			StorageNew->reachableAddressSNPAPrefixLen = strlen("");
		StorageNew->reachableAddressRowStatus = 0;
		StorageNew->reachableAddressRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct reachableAddressTable_data *reachableAddressTable_duplicate(struct reachableAddressTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct reachableAddressTable_data *
reachableAddressTable_duplicate(struct reachableAddressTable_data *thedata)
{
	struct reachableAddressTable_data *StorageNew = SNMP_MALLOC_STRUCT(reachableAddressTable_data);

	DEBUGMSGTL(("dlMIB", "reachableAddressTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	reachableAddressTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int reachableAddressTable_destroy(struct reachableAddressTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
reachableAddressTable_destroy(struct reachableAddressTable_data **thedata)
{
	struct reachableAddressTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "reachableAddressTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->reachableAddressId);
		StorageDel->reachableAddressIdLen = 0;
		SNMP_FREE(StorageDel->reachableAddressPrefix);
		StorageDel->reachableAddressPrefixLen = 0;
		SNMP_FREE(StorageDel->reachableAddressSNPAAddresses);
		StorageDel->reachableAddressSNPAAddressesLen = 0;
		SNMP_FREE(StorageDel->reachableAddressSNPAMask);
		StorageDel->reachableAddressSNPAMaskLen = 0;
		SNMP_FREE(StorageDel->reachableAddressSNPAPrefix);
		StorageDel->reachableAddressSNPAPrefixLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int reachableAddressTable_add(struct reachableAddressTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the reachableAddressTable table data set.
 *
 * Adds a table row structure to the reachableAddressTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
reachableAddressTable_add(struct reachableAddressTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("dlMIB", "reachableAddressTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* reachableAddressId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->reachableAddressId, thedata->reachableAddressIdLen);
		header_complex_add_data(&reachableAddressTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("dlMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int reachableAddressTable_del(struct reachableAddressTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the reachableAddressTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
reachableAddressTable_del(struct reachableAddressTable_data *thedata)
{
	struct reachableAddressTable_data *StorageDel;

	DEBUGMSGTL(("dlMIB", "reachableAddressTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(reachableAddressTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&reachableAddressTableStorage, hciptr);
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_reachableAddressTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for reachableAddressTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case reachableAddressTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_reachableAddressTable(const char *token, char *line)
{
	size_t tmpsize;
	struct reachableAddressTable_data *StorageTmp = reachableAddressTable_create();

	DEBUGMSGTL(("dlMIB", "parse_reachableAddressTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->reachableAddressId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressId, &StorageTmp->reachableAddressIdLen);
	if (StorageTmp->reachableAddressId == NULL) {
		config_perror("invalid specification for reachableAddressId");
		return;
	}
	SNMP_FREE(StorageTmp->reachableAddressPrefix);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressPrefix, &StorageTmp->reachableAddressPrefixLen);
	if (StorageTmp->reachableAddressPrefix == NULL) {
		config_perror("invalid specification for reachableAddressPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressMappingType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDefaultMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDelayMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressExpenseMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressErrorMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDefaultMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressDelayMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressExpenseMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressErrorMetricType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->reachableAddressSNPAAddresses);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressSNPAAddresses, &StorageTmp->reachableAddressSNPAAddressesLen);
	if (StorageTmp->reachableAddressSNPAAddresses == NULL) {
		config_perror("invalid specification for reachableAddressSNPAAddresses");
		return;
	}
	SNMP_FREE(StorageTmp->reachableAddressSNPAMask);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressSNPAMask, &StorageTmp->reachableAddressSNPAMaskLen);
	if (StorageTmp->reachableAddressSNPAMask == NULL) {
		config_perror("invalid specification for reachableAddressSNPAMask");
		return;
	}
	SNMP_FREE(StorageTmp->reachableAddressSNPAPrefix);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->reachableAddressSNPAPrefix, &StorageTmp->reachableAddressSNPAPrefixLen);
	if (StorageTmp->reachableAddressSNPAPrefix == NULL) {
		config_perror("invalid specification for reachableAddressSNPAPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->reachableAddressRowStatus, &tmpsize);
	reachableAddressTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/*
 * store_reachableAddressTable(): store configuraiton file for reachableAddressTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_reachableAddressTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct reachableAddressTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("dlMIB", "store_reachableAddressTable: storing data...  "));
	refresh_reachableAddressTable(1);
	(void) tmpsize;
	for (hcindex = reachableAddressTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct reachableAddressTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "reachableAddressTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressId, &StorageTmp->reachableAddressIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressPrefix, &StorageTmp->reachableAddressPrefixLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressMappingType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDefaultMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDelayMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressExpenseMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressErrorMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDefaultMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressDelayMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressExpenseMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressErrorMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressSNPAAddresses, &StorageTmp->reachableAddressSNPAAddressesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressSNPAMask, &StorageTmp->reachableAddressSNPAMaskLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->reachableAddressSNPAPrefix, &StorageTmp->reachableAddressSNPAPrefixLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->reachableAddressRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_communicationsEntityTable_row(struct communicationsEntityTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the communicationsEntityTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct communicationsEntityTable_data *
refresh_communicationsEntityTable_row(struct communicationsEntityTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->communicationsEntityTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->communicationsEntityTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_communicationsEntityTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the communicationsEntityTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_communicationsEntityTable(int force)
{
	if (!force && communicationsEntityTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	communicationsEntityTable_refresh = 0;
}

/**
 * @fn u_char *var_communicationsEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in communicationsEntityTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_communicationsEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct communicationsEntityTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_communicationsEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_communicationsEntityTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(communicationsEntityTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_communicationsEntityTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) COMMUNICATIONSENTITYLOCALSAPNAMES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->communicationsEntityLocalSapNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->communicationsEntityLocalSapNames;
		break;
	case (u_char) COMMUNICATIONSENTITYOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->communicationsEntityOperationalState);
		rval = (u_char *) &StorageTmp->communicationsEntityOperationalState;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sap1Table_row(struct sap1Table_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sap1Table row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct sap1Table_data *
refresh_sap1Table_row(struct sap1Table_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sap1Table_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->sap1Table_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_sap1Table(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sap1Table.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sap1Table(int force)
{
	if (!force && sap1Table_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	sap1Table_refresh = 0;
}

/**
 * @fn u_char *var_sap1Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sap1Table.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sap1Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sap1Table_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_sap1Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sap1Table(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(sap1TableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_sap1Table_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SAP1ADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sap1Address);
		rval = (u_char *) &StorageTmp->sap1Address;
		break;
	case (u_char) SAP1USERENTITYNAMES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sap1UserEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->sap1UserEntityNames;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sap2Table_row(struct sap2Table_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sap2Table row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct sap2Table_data *
refresh_sap2Table_row(struct sap2Table_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sap2Table_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->sap2Table_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_sap2Table(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sap2Table.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sap2Table(int force)
{
	if (!force && sap2Table_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	sap2Table_refresh = 0;
}

/**
 * @fn u_char *var_sap2Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sap2Table.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sap2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sap2Table_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_sap2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sap2Table(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(sap2TableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_sap2Table_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SAP2ADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sap2AddressLen;
		rval = (u_char *) StorageTmp->sap2Address;
		break;
	case (u_char) SAP2USERENTITYNAMES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sap2UserEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->sap2UserEntityNames;
		break;
	case (u_char) SAP2PROVIDERENTITYNAMES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sap2ProviderEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->sap2ProviderEntityNames;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_clProtocolMachineTable_row(struct clProtocolMachineTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the clProtocolMachineTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct clProtocolMachineTable_data *
refresh_clProtocolMachineTable_row(struct clProtocolMachineTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->clProtocolMachineTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->clProtocolMachineTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_clProtocolMachineTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the clProtocolMachineTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_clProtocolMachineTable(int force)
{
	if (!force && clProtocolMachineTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	clProtocolMachineTable_refresh = 0;
}

/**
 * @fn u_char *var_clProtocolMachineTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in clProtocolMachineTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_clProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct clProtocolMachineTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_clProtocolMachineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_clProtocolMachineTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(clProtocolMachineTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_clProtocolMachineTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) CLPROTOCOLMACHINEOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->clProtocolMachineOperationalState);
		rval = (u_char *) &StorageTmp->clProtocolMachineOperationalState;
		break;
	case (u_char) CLPROTOCOLMACHINETOTALREMOTESAPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->clProtocolMachineTotalRemoteSAPs);
		rval = (u_char *) &StorageTmp->clProtocolMachineTotalRemoteSAPs;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_coProtocolMachineTable_row(struct coProtocolMachineTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the coProtocolMachineTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct coProtocolMachineTable_data *
refresh_coProtocolMachineTable_row(struct coProtocolMachineTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->coProtocolMachineTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->coProtocolMachineTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_coProtocolMachineTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the coProtocolMachineTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_coProtocolMachineTable(int force)
{
	if (!force && coProtocolMachineTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	coProtocolMachineTable_refresh = 0;
}

/**
 * @fn u_char *var_coProtocolMachineTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in coProtocolMachineTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_coProtocolMachineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct coProtocolMachineTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_coProtocolMachineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_coProtocolMachineTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(coProtocolMachineTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_coProtocolMachineTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) COPROTOCOLMACHINEOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->coProtocolMachineOperationalState);
		rval = (u_char *) &StorageTmp->coProtocolMachineOperationalState;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_singlePeerConnectionTable_row(struct singlePeerConnectionTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the singlePeerConnectionTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct singlePeerConnectionTable_data *
refresh_singlePeerConnectionTable_row(struct singlePeerConnectionTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->singlePeerConnectionTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->singlePeerConnectionTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_singlePeerConnectionTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the singlePeerConnectionTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_singlePeerConnectionTable(int force)
{
	if (!force && singlePeerConnectionTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	singlePeerConnectionTable_refresh = 0;
}

/**
 * @fn u_char *var_singlePeerConnectionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in singlePeerConnectionTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_singlePeerConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct singlePeerConnectionTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_singlePeerConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_singlePeerConnectionTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(singlePeerConnectionTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_singlePeerConnectionTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) UNDERLYINGCONNECTIONNAMES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->underlyingConnectionNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->underlyingConnectionNames;
		break;
	case (u_char) SUPPPORTEDCONNECTIONNAMES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->suppportedConnectionNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->suppportedConnectionNames;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_physicalEntityTable_row(struct physicalEntityTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the physicalEntityTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct physicalEntityTable_data *
refresh_physicalEntityTable_row(struct physicalEntityTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->physicalEntityTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->physicalEntityTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_physicalEntityTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the physicalEntityTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_physicalEntityTable(int force)
{
	if (!force && physicalEntityTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	physicalEntityTable_refresh = 0;
}

/**
 * @fn u_char *var_physicalEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in physicalEntityTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_physicalEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct physicalEntityTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_physicalEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_physicalEntityTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(physicalEntityTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_physicalEntityTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) PHYSICALENTITYPHYSICALENTITYTITLES:	/* ReadWrite */
		*write_method = write_physicalEntityPhysicalEntityTitles;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->physicalEntityPhysicalEntityTitlesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->physicalEntityPhysicalEntityTitles;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_physicalSAPTable_row(struct physicalSAPTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the physicalSAPTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct physicalSAPTable_data *
refresh_physicalSAPTable_row(struct physicalSAPTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->physicalSAPTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->physicalSAPTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_physicalSAPTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the physicalSAPTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_physicalSAPTable(int force)
{
	if (!force && physicalSAPTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	physicalSAPTable_refresh = 0;
}

/**
 * @fn u_char *var_physicalSAPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in physicalSAPTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_physicalSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct physicalSAPTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_physicalSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_physicalSAPTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(physicalSAPTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_physicalSAPTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) PHYSICALSAPROWSTATUS:	/* Create */
		*write_method = write_physicalSAPRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->physicalSAPRowStatus);
		rval = (u_char *) &StorageTmp->physicalSAPRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_dataCircuitTable_row(struct dataCircuitTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dataCircuitTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dataCircuitTable_data *
refresh_dataCircuitTable_row(struct dataCircuitTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dataCircuitTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dataCircuitTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dataCircuitTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dataCircuitTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dataCircuitTable(int force)
{
	if (!force && dataCircuitTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dataCircuitTable_refresh = 0;
}

/**
 * @fn u_char *var_dataCircuitTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dataCircuitTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_dataCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dataCircuitTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_dataCircuitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dataCircuitTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dataCircuitTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dataCircuitTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DATACIRCUITBITERRORSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dataCircuitBitErrorsReceived);
		rval = (u_char *) &StorageTmp->dataCircuitBitErrorsReceived;
		break;
	case (u_char) DATACIRCUITBITERRORSTRANSMITTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dataCircuitBitErrorsTransmitted);
		rval = (u_char *) &StorageTmp->dataCircuitBitErrorsTransmitted;
		break;
	case (u_char) DATACIRCUITBITERRORSTHRESHOLD:	/* Create */
		*write_method = write_dataCircuitBitErrorsThreshold;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dataCircuitBitErrorsThresholdLen;
		rval = (u_char *) StorageTmp->dataCircuitBitErrorsThreshold;
		break;
	case (u_char) DATACIRCUITTYPE:	/* Create */
		*write_method = write_dataCircuitType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dataCircuitType);
		rval = (u_char *) &StorageTmp->dataCircuitType;
		break;
	case (u_char) DATACIRCUITPHYSICALMEDIANAMES:	/* Create */
		*write_method = write_dataCircuitPhysicalMediaNames;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dataCircuitPhysicalMediaNamesLen;
		rval = (u_char *) StorageTmp->dataCircuitPhysicalMediaNames;
		break;
	case (u_char) DATACIRCUITPHYSICALINTERFACETYPE:	/* Create */
		*write_method = write_dataCircuitPhysicalInterfaceType;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dataCircuitPhysicalInterfaceTypeLen;
		rval = (u_char *) StorageTmp->dataCircuitPhysicalInterfaceType;
		break;
	case (u_char) DATACIRCUITPHYSICALINTERFACESTANDARD:	/* Create */
		*write_method = write_dataCircuitPhysicalInterfaceStandard;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dataCircuitPhysicalInterfaceStandardLen;
		rval = (u_char *) StorageTmp->dataCircuitPhysicalInterfaceStandard;
		break;
	case (u_char) DATACIRCUITSYNCHRONIZATIONMODE:	/* Create */
		*write_method = write_dataCircuitSynchronizationMode;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dataCircuitSynchronizationMode);
		rval = (u_char *) &StorageTmp->dataCircuitSynchronizationMode;
		break;
	case (u_char) DATACIRCUITTRANSMISSIONCODING:	/* Create */
		*write_method = write_dataCircuitTransmissionCoding;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dataCircuitTransmissionCodingLen;
		rval = (u_char *) StorageTmp->dataCircuitTransmissionCoding;
		break;
	case (u_char) DATACIRCUITTRANSMISSIONMODE:	/* Create */
		*write_method = write_dataCircuitTransmissionMode;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dataCircuitTransmissionMode);
		rval = (u_char *) &StorageTmp->dataCircuitTransmissionMode;
		break;
	case (u_char) DATACIRCUITTRANSMISSIONRATE:	/* Create */
		*write_method = write_dataCircuitTransmissionRate;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dataCircuitTransmissionRateLen;
		rval = (u_char *) StorageTmp->dataCircuitTransmissionRate;
		break;
	case (u_char) DATACIRCUITROWSTATUS:	/* Create */
		*write_method = write_dataCircuitRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dataCircuitRowStatus);
		rval = (u_char *) &StorageTmp->dataCircuitRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_physicalConnectionTable_row(struct physicalConnectionTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the physicalConnectionTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct physicalConnectionTable_data *
refresh_physicalConnectionTable_row(struct physicalConnectionTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->physicalConnectionTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->physicalConnectionTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_physicalConnectionTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the physicalConnectionTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_physicalConnectionTable(int force)
{
	if (!force && physicalConnectionTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	physicalConnectionTable_refresh = 0;
}

/**
 * @fn u_char *var_physicalConnectionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in physicalConnectionTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_physicalConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct physicalConnectionTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_physicalConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_physicalConnectionTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(physicalConnectionTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_physicalConnectionTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) PHYSICALCONNECTIONENDPOINTIDENTIFIER:	/* Create */
		*write_method = write_physicalConnectionEndpointIdentifier;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->physicalConnectionEndpointIdentifierLen;
		rval = (u_char *) StorageTmp->physicalConnectionEndpointIdentifier;
		break;
	case (u_char) PHYSICALCONNECTIONPORTNUMBER:	/* Create */
		*write_method = write_physicalConnectionPortNumber;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->physicalConnectionPortNumber);
		rval = (u_char *) &StorageTmp->physicalConnectionPortNumber;
		break;
	case (u_char) PHYSICALCONNECTIONROWSTATUS:	/* Create */
		*write_method = write_physicalConnectionRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->physicalConnectionRowStatus);
		rval = (u_char *) &StorageTmp->physicalConnectionRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_datalinkEntityTable_row(struct datalinkEntityTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the datalinkEntityTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct datalinkEntityTable_data *
refresh_datalinkEntityTable_row(struct datalinkEntityTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->datalinkEntityTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->datalinkEntityTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_datalinkEntityTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the datalinkEntityTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_datalinkEntityTable(int force)
{
	if (!force && datalinkEntityTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	datalinkEntityTable_refresh = 0;
}

/**
 * @fn u_char *var_datalinkEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in datalinkEntityTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_datalinkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct datalinkEntityTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_datalinkEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_datalinkEntityTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(datalinkEntityTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_datalinkEntityTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DATALINKENTITYPROVIDERENTITYNAMES:	/* Create */
		*write_method = write_datalinkEntityProviderEntityNames;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->datalinkEntityProviderEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->datalinkEntityProviderEntityNames;
		break;
	case (u_char) DATALINKENTITYROWSTATUS:	/* Create */
		*write_method = write_datalinkEntityRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->datalinkEntityRowStatus);
		rval = (u_char *) &StorageTmp->datalinkEntityRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_dLSAPTable_row(struct dLSAPTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dLSAPTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dLSAPTable_data *
refresh_dLSAPTable_row(struct dLSAPTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dLSAPTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dLSAPTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dLSAPTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dLSAPTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dLSAPTable(int force)
{
	if (!force && dLSAPTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dLSAPTable_refresh = 0;
}

/**
 * @fn u_char *var_dLSAPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dLSAPTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_dLSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dLSAPTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_dLSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dLSAPTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dLSAPTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dLSAPTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DLSAPROWSTATUS:	/* Create */
		*write_method = write_dLSAPRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dLSAPRowStatus);
		rval = (u_char *) &StorageTmp->dLSAPRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lAPBDLETable_row(struct lAPBDLETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lAPBDLETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lAPBDLETable_data *
refresh_lAPBDLETable_row(struct lAPBDLETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lAPBDLETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lAPBDLETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lAPBDLETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lAPBDLETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lAPBDLETable(int force)
{
	if (!force && lAPBDLETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lAPBDLETable_refresh = 0;
}

/**
 * @fn u_char *var_lAPBDLETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lAPBDLETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lAPBDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lAPBDLETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lAPBDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lAPBDLETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lAPBDLETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lAPBDLETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LAPBDLEMT1TIMER:	/* Create */
		*write_method = write_lAPBDLEmT1Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEmT1Timer);
		rval = (u_char *) &StorageTmp->lAPBDLEmT1Timer;
		break;
	case (u_char) LAPBDLEMT3TIMER:	/* Create */
		*write_method = write_lAPBDLEmT3Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEmT3Timer);
		rval = (u_char *) &StorageTmp->lAPBDLEmT3Timer;
		break;
	case (u_char) LAPBDLEMW:	/* Create */
		*write_method = write_lAPBDLEmW;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEmW);
		rval = (u_char *) &StorageTmp->lAPBDLEmW;
		break;
	case (u_char) LAPBDLEMXSEND:	/* Create */
		*write_method = write_lAPBDLEmXSend;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEmXSend);
		rval = (u_char *) &StorageTmp->lAPBDLEmXSend;
		break;
	case (u_char) LAPBDLEMXRECEIVE:	/* Create */
		*write_method = write_lAPBDLEmXReceive;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEmXReceive);
		rval = (u_char *) &StorageTmp->lAPBDLEmXReceive;
		break;
	case (u_char) LAPBDLEMT2TIMER:	/* Create */
		*write_method = write_lAPBDLEmT2Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEmT2Timer);
		rval = (u_char *) &StorageTmp->lAPBDLEmT2Timer;
		break;
	case (u_char) LAPBDLERECEIVEDMLPRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEreceivedMlpResets);
		rval = (u_char *) &StorageTmp->lAPBDLEreceivedMlpResets;
		break;
	case (u_char) LAPBDLETIMESMT1EXPIRED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEtimesMT1Expired);
		rval = (u_char *) &StorageTmp->lAPBDLEtimesMT1Expired;
		break;
	case (u_char) LAPBDLEIFRAMESREASSIGNMENTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEIframesReassignments);
		rval = (u_char *) &StorageTmp->lAPBDLEIframesReassignments;
		break;
	case (u_char) LAPBDLEMLPFRAMESRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesReceived);
		rval = (u_char *) &StorageTmp->lAPBDLEmlpFramesReceived;
		break;
	case (u_char) LAPBDLEMLPFRAMESSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesSent);
		rval = (u_char *) &StorageTmp->lAPBDLEmlpFramesSent;
		break;
	case (u_char) LAPBDLEMLPFRAMESOUTSIDEWINDOWGUARD:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard);
		rval = (u_char *) &StorageTmp->lAPBDLEmlpFramesOutsideWindowGuard;
		break;
	case (u_char) LAPBDLERECEIVEDMLPFRAMESINGUARDREGION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion);
		rval = (u_char *) &StorageTmp->lAPBDLEreceivedMlpFramesInGuardRegion;
		break;
	case (u_char) LAPBDLEROWSTATUS:	/* Create */
		*write_method = write_lAPBDLERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lAPBDLERowStatus);
		rval = (u_char *) &StorageTmp->lAPBDLERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sLPPMTable_row(struct sLPPMTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sLPPMTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct sLPPMTable_data *
refresh_sLPPMTable_row(struct sLPPMTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sLPPMTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->sLPPMTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_sLPPMTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sLPPMTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sLPPMTable(int force)
{
	if (!force && sLPPMTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	sLPPMTable_refresh = 0;
}

/**
 * @fn u_char *var_sLPPMTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sLPPMTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sLPPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sLPPMTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_sLPPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sLPPMTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(sLPPMTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_sLPPMTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SLPPMADMINISTRATIVESTATE:	/* Create */
		*write_method = write_sLPPMadministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPPMadministrativeState);
		rval = (u_char *) &StorageTmp->sLPPMadministrativeState;
		break;
	case (u_char) SLPPMROWSTATUS:	/* Create */
		*write_method = write_sLPPMRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPPMRowStatus);
		rval = (u_char *) &StorageTmp->sLPPMRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sLPConnectionTable_row(struct sLPConnectionTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sLPConnectionTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct sLPConnectionTable_data *
refresh_sLPConnectionTable_row(struct sLPConnectionTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sLPConnectionTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->sLPConnectionTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_sLPConnectionTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sLPConnectionTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sLPConnectionTable(int force)
{
	if (!force && sLPConnectionTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	sLPConnectionTable_refresh = 0;
}

/**
 * @fn u_char *var_sLPConnectionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sLPConnectionTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sLPConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sLPConnectionTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_sLPConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sLPConnectionTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(sLPConnectionTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_sLPConnectionTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SLPCONNECTIONINTERFACETYPE:	/* Create */
		*write_method = write_sLPConnectionInterfaceType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionInterfaceType);
		rval = (u_char *) &StorageTmp->sLPConnectionInterfaceType;
		break;
	case (u_char) SLPCONNECTIONK:	/* Create */
		*write_method = write_sLPConnectionK;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionK);
		rval = (u_char *) &StorageTmp->sLPConnectionK;
		break;
	case (u_char) SLPCONNECTIONN1:	/* Create */
		*write_method = write_sLPConnectionN1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionN1);
		rval = (u_char *) &StorageTmp->sLPConnectionN1;
		break;
	case (u_char) SLPCONNECTIONN2:	/* Create */
		*write_method = write_sLPConnectionN2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionN2);
		rval = (u_char *) &StorageTmp->sLPConnectionN2;
		break;
	case (u_char) SLPCONNECTIONSEQUENCEMODULUS:	/* Create */
		*write_method = write_sLPConnectionSequenceModulus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionSequenceModulus);
		rval = (u_char *) &StorageTmp->sLPConnectionSequenceModulus;
		break;
	case (u_char) SLPCONNECTIONT1TIMER:	/* Create */
		*write_method = write_sLPConnectionT1Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionT1Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionT1Timer;
		break;
	case (u_char) SLPCONNECTIONT2TIMER:	/* Create */
		*write_method = write_sLPConnectionT2Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionT2Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionT2Timer;
		break;
	case (u_char) SLPCONNECTIONFCSERRORSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionFCSErrorsReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionFCSErrorsReceived;
		break;
	case (u_char) SLPCONNECTIONFRMRSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionFRMRsReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionFRMRsReceived;
		break;
	case (u_char) SLPCONNECTIONFRMRSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionFRMRsSent);
		rval = (u_char *) &StorageTmp->sLPConnectionFRMRsSent;
		break;
	case (u_char) SLPCONNECTIONIFRAMEDATAOCTETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIFrameDataOctetsReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionIFrameDataOctetsReceived;
		break;
	case (u_char) SLPCONNECTIONIFRAMEDATAOCTETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIFrameDataOctetsSent);
		rval = (u_char *) &StorageTmp->sLPConnectionIFrameDataOctetsSent;
		break;
	case (u_char) SLPCONNECTIONIFRAMESRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIFramesReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionIFramesReceived;
		break;
	case (u_char) SLPCONNECTIONIFRAMESSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIFramesSent);
		rval = (u_char *) &StorageTmp->sLPConnectionIFramesSent;
		break;
	case (u_char) SLPCONNECTIONPOLLSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionPollsReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionPollsReceived;
		break;
	case (u_char) SLPCONNECTIONREJSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionREJsReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionREJsReceived;
		break;
	case (u_char) SLPCONNECTIONREJSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionREJsSent);
		rval = (u_char *) &StorageTmp->sLPConnectionREJsSent;
		break;
	case (u_char) SLPCONNECTIONRNRSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionRNRsReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionRNRsReceived;
		break;
	case (u_char) SLPCONNECTIONRNRSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionRNRsSent);
		rval = (u_char *) &StorageTmp->sLPConnectionRNRsSent;
		break;
	case (u_char) SLPCONNECTIONSABMSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionSABMsReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionSABMsReceived;
		break;
	case (u_char) SLPCONNECTIONSABMSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionSABMsSent);
		rval = (u_char *) &StorageTmp->sLPConnectionSABMsSent;
		break;
	case (u_char) SLPCONNECTIONPROTOCOLSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionProtocolState);
		rval = (u_char *) &StorageTmp->sLPConnectionProtocolState;
		break;
	case (u_char) SLPCONNECTIONTIMEST1EXPIRED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT1Expired);
		rval = (u_char *) &StorageTmp->sLPConnectionTimesT1Expired;
		break;
	case (u_char) SLPCONNECTIONT3TIMER:	/* Create */
		*write_method = write_sLPConnectionT3Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionT3Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionT3Timer;
		break;
	case (u_char) SLPCONNECTIONTIMEST3EXPIRED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT3Expired);
		rval = (u_char *) &StorageTmp->sLPConnectionTimesT3Expired;
		break;
	case (u_char) SLPCONNECTIONT4TIMER:	/* Create */
		*write_method = write_sLPConnectionT4Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionT4Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionT4Timer;
		break;
	case (u_char) SLPCONNECTIONTIMEST4EXPIRED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionTimesT4Expired);
		rval = (u_char *) &StorageTmp->sLPConnectionTimesT4Expired;
		break;
	case (u_char) SLPCONNECTIONABNORMALLINKDISCONNECTSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionAbnormalLinkDisconnectsReceived;
		break;
	case (u_char) SLPCONNECTIONABNORMALLINKDISCONNECTSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent);
		rval = (u_char *) &StorageTmp->sLPConnectionAbnormalLinkDisconnectsSent;
		break;
	case (u_char) SLPCONNECTIONLINKRESETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionLinkResetsReceived);
		rval = (u_char *) &StorageTmp->sLPConnectionLinkResetsReceived;
		break;
	case (u_char) SLPCONNECTIONLINKRESETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionLinkResetsSent);
		rval = (u_char *) &StorageTmp->sLPConnectionLinkResetsSent;
		break;
	case (u_char) SLPCONNECTIONTIMESN2REACHED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionTimesN2Reached);
		rval = (u_char *) &StorageTmp->sLPConnectionTimesN2Reached;
		break;
	case (u_char) SLPCONNECTIONADMINISTRATIVESTATE:	/* Create */
		*write_method = write_sLPConnectionAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionAdministrativeState);
		rval = (u_char *) &StorageTmp->sLPConnectionAdministrativeState;
		break;
	case (u_char) SLPCONNECTIONOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionOperationalState);
		rval = (u_char *) &StorageTmp->sLPConnectionOperationalState;
		break;
	case (u_char) SLPCONNECTIONUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionUsageState);
		rval = (u_char *) &StorageTmp->sLPConnectionUsageState;
		break;
	case (u_char) SLPCONNECTIONPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sLPConnectionProceduralStatusLen;
		rval = (u_char *) StorageTmp->sLPConnectionProceduralStatus;
		break;
	case (u_char) SLPCONNECTIONALARMSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sLPConnectionAlarmStatusLen;
		rval = (u_char *) StorageTmp->sLPConnectionAlarmStatus;
		break;
	case (u_char) SLPCONNECTIONROWSTATUS:	/* Create */
		*write_method = write_sLPConnectionRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionRowStatus);
		rval = (u_char *) &StorageTmp->sLPConnectionRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sLPConnectionIVMOTable_row(struct sLPConnectionIVMOTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sLPConnectionIVMOTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct sLPConnectionIVMOTable_data *
refresh_sLPConnectionIVMOTable_row(struct sLPConnectionIVMOTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sLPConnectionIVMOTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->sLPConnectionIVMOTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_sLPConnectionIVMOTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sLPConnectionIVMOTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sLPConnectionIVMOTable(int force)
{
	if (!force && sLPConnectionIVMOTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	sLPConnectionIVMOTable_refresh = 0;
}

/**
 * @fn u_char *var_sLPConnectionIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sLPConnectionIVMOTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_sLPConnectionIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_sLPConnectionIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sLPConnectionIVMOTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(sLPConnectionIVMOTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_sLPConnectionIVMOTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SLPCONNECTIONIVMOID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sLPConnectionIVMOidLen;
		rval = (u_char *) StorageTmp->sLPConnectionIVMOid;
		break;
	case (u_char) SLPCONNECTIONIVMOINTERFACETYPE:	/* Create */
		*write_method = write_sLPConnectionIVMOinterfaceType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOinterfaceType);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMOinterfaceType;
		break;
	case (u_char) SLPCONNECTIONIVMOK:	/* Create */
		*write_method = write_sLPConnectionIVMOk;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOk);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMOk;
		break;
	case (u_char) SLPCONNECTIONIVMON1:	/* Create */
		*write_method = write_sLPConnectionIVMOn1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOn1);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMOn1;
		break;
	case (u_char) SLPCONNECTIONIVMON2:	/* Create */
		*write_method = write_sLPConnectionIVMOn2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOn2);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMOn2;
		break;
	case (u_char) SLPCONNECTIONIVMOSEQUENCEMODULUS:	/* Create */
		*write_method = write_sLPConnectionIVMOsequenceModulus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOsequenceModulus);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMOsequenceModulus;
		break;
	case (u_char) SLPCONNECTIONIVMOT1TIMER:	/* Create */
		*write_method = write_sLPConnectionIVMOt1Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt1Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMOt1Timer;
		break;
	case (u_char) SLPCONNECTIONIVMOT2TIMER:	/* Create */
		*write_method = write_sLPConnectionIVMOt2Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt2Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMOt2Timer;
		break;
	case (u_char) SLPCONNECTIONIVMOT3TIMER:	/* Create */
		*write_method = write_sLPConnectionIVMOt3Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt3Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMOt3Timer;
		break;
	case (u_char) SLPCONNECTIONIVMOT4TIMER:	/* Create */
		*write_method = write_sLPConnectionIVMOt4Timer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMOt4Timer);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMOt4Timer;
		break;
	case (u_char) SLPCONNECTIONIVMOROWSTATUS:	/* Create */
		*write_method = write_sLPConnectionIVMORowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sLPConnectionIVMORowStatus);
		rval = (u_char *) &StorageTmp->sLPConnectionIVMORowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mACDLETable_row(struct mACDLETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mACDLETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mACDLETable_data *
refresh_mACDLETable_row(struct mACDLETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mACDLETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mACDLETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mACDLETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mACDLETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mACDLETable(int force)
{
	if (!force && mACDLETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mACDLETable_refresh = 0;
}

/**
 * @fn u_char *var_mACDLETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mACDLETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_mACDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mACDLETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_mACDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mACDLETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mACDLETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mACDLETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MACDLEROWSTATUS:	/* Create */
		*write_method = write_mACDLERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mACDLERowStatus);
		rval = (u_char *) &StorageTmp->mACDLERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mACTable_row(struct mACTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mACTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mACTable_data *
refresh_mACTable_row(struct mACTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mACTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mACTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mACTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mACTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mACTable(int force)
{
	if (!force && mACTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mACTable_refresh = 0;
}

/**
 * @fn u_char *var_mACTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mACTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_mACTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mACTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_mACTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mACTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mACTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mACTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MACOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mACOperationalState);
		rval = (u_char *) &StorageTmp->mACOperationalState;
		break;
	case (u_char) MACROWSTATUS:	/* Create */
		*write_method = write_mACRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mACRowStatus);
		rval = (u_char *) &StorageTmp->mACRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCDLETable_row(struct lLCDLETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCDLETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCDLETable_data *
refresh_lLCDLETable_row(struct lLCDLETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCDLETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCDLETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCDLETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCDLETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCDLETable(int force)
{
	if (!force && lLCDLETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCDLETable_refresh = 0;
}

/**
 * @fn u_char *var_lLCDLETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCDLETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCDLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCDLETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCDLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCDLETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCDLETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCDLETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCDLEROWSTATUS:	/* Create */
		*write_method = write_lLCDLERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCDLERowStatus);
		rval = (u_char *) &StorageTmp->lLCDLERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCCLPMTable_row(struct lLCCLPMTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCCLPMTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCCLPMTable_data *
refresh_lLCCLPMTable_row(struct lLCCLPMTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCCLPMTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCCLPMTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCCLPMTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCCLPMTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCCLPMTable(int force)
{
	if (!force && lLCCLPMTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCCLPMTable_refresh = 0;
}

/**
 * @fn u_char *var_lLCCLPMTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCCLPMTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCCLPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCCLPMTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCCLPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCCLPMTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCCLPMTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCCLPMTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCCLPMROWSTATUS:	/* Create */
		*write_method = write_lLCCLPMRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCCLPMRowStatus);
		rval = (u_char *) &StorageTmp->lLCCLPMRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCCOPMTable_row(struct lLCCOPMTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCCOPMTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCCOPMTable_data *
refresh_lLCCOPMTable_row(struct lLCCOPMTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCCOPMTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCCOPMTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCCOPMTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCCOPMTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCCOPMTable(int force)
{
	if (!force && lLCCOPMTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCCOPMTable_refresh = 0;
}

/**
 * @fn u_char *var_lLCCOPMTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCCOPMTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCCOPMTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCCOPMTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCCOPMTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCCOPMTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCCOPMTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCCOPMTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCCOPMROWSTATUS:	/* Create */
		*write_method = write_lLCCOPMRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCCOPMRowStatus);
		rval = (u_char *) &StorageTmp->lLCCOPMRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_resourceTypeIdTable_row(struct resourceTypeIdTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the resourceTypeIdTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct resourceTypeIdTable_data *
refresh_resourceTypeIdTable_row(struct resourceTypeIdTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->resourceTypeIdTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->resourceTypeIdTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_resourceTypeIdTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the resourceTypeIdTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_resourceTypeIdTable(int force)
{
	if (!force && resourceTypeIdTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	resourceTypeIdTable_refresh = 0;
}

/**
 * @fn u_char *var_resourceTypeIdTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in resourceTypeIdTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_resourceTypeIdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct resourceTypeIdTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_resourceTypeIdTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_resourceTypeIdTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(resourceTypeIdTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_resourceTypeIdTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) RESOURCETYPEIDNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->resourceTypeIdNameLen;
		rval = (u_char *) StorageTmp->resourceTypeIdName;
		break;
	case (u_char) RESOURCEINFOMANUFACTUREROUI:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->resourceInfoManufacturerOUILen;
		rval = (u_char *) StorageTmp->resourceInfoManufacturerOUI;
		break;
	case (u_char) RESOURCEINFOMANUFACTURERNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->resourceInfoManufacturerNameLen;
		rval = (u_char *) StorageTmp->resourceInfoManufacturerName;
		break;
	case (u_char) RESOURCEINFOMANUFACTURERPRODUCTNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->resourceInfoManufacturerProductNameLen;
		rval = (u_char *) StorageTmp->resourceInfoManufacturerProductName;
		break;
	case (u_char) RESOURCEINFOMANUFACTURERPRODUCTVERSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->resourceInfoManufacturerProductVersionLen;
		rval = (u_char *) StorageTmp->resourceInfoManufacturerProductVersion;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCStationTable_row(struct lLCStationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCStationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCStationTable_data *
refresh_lLCStationTable_row(struct lLCStationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCStationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCStationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCStationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCStationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCStationTable(int force)
{
	if (!force && lLCStationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCStationTable_refresh = 0;
}

/**
 * @fn u_char *var_lLCStationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCStationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCStationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCStationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCStationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCStationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCStationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCStationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCSTATIONLLCNAME:	/* ReadWrite */
		*write_method = write_lLCStationLLCName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCStationLLCNameLen;
		rval = (u_char *) StorageTmp->lLCStationLLCName;
		break;
	case (u_char) LLCSTATIONMAXIMUMLSAPSCONFIGURED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationMaximumLSAPsConfigured);
		rval = (u_char *) &StorageTmp->lLCStationMaximumLSAPsConfigured;
		break;
	case (u_char) LLCSTATIONNUMBEROFACTIVELSAPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationNumberOfActiveLSAPs);
		rval = (u_char *) &StorageTmp->lLCStationNumberOfActiveLSAPs;
		break;
	case (u_char) LLCSTATIONSUPPORTEDSERVICESTYPES:	/* ReadWrite */
		*write_method = write_lLCStationSupportedServicesTypes;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCStationSupportedServicesTypesLen;
		rval = (u_char *) StorageTmp->lLCStationSupportedServicesTypes;
		break;
	case (u_char) LLCSTATIONSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationStatus);
		rval = (u_char *) &StorageTmp->lLCStationStatus;
		break;
	case (u_char) LLCSTATIONTYPE1ACKNOWLEDGETIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCStationType1AcknowledgeTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationType1AcknowledgeTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCStationType1AcknowledgeTimeoutValue;
		break;
	case (u_char) LLCSTATIONTYPE1MAXIMUMRETRYCOUNT:	/* ReadWrite */
		*write_method = write_lLCStationType1MaximumRetryCount;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationType1MaximumRetryCount);
		rval = (u_char *) &StorageTmp->lLCStationType1MaximumRetryCount;
		break;
	case (u_char) LLCSTATIONMAXIMUMPDUN3:	/* ReadWrite */
		*write_method = write_lLCStationMaximumPDUN3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationMaximumPDUN3);
		rval = (u_char *) &StorageTmp->lLCStationMaximumPDUN3;
		break;
	case (u_char) LLCSTATIONMAXIMUMRETRANSMISSIONS4:	/* ReadWrite */
		*write_method = write_lLCStationMaximumRetransmissions4;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationMaximumRetransmissions4);
		rval = (u_char *) &StorageTmp->lLCStationMaximumRetransmissions4;
		break;
	case (u_char) LLCSTATIONRECEIVEVARIABLELIFETIME:	/* ReadWrite */
		*write_method = write_lLCStationReceiveVariableLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationReceiveVariableLifetime);
		rval = (u_char *) &StorageTmp->lLCStationReceiveVariableLifetime;
		break;
	case (u_char) LLCSTATIONTRANSMITVARIABLELIFETIME:	/* ReadWrite */
		*write_method = write_lLCStationTransmitVariableLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationTransmitVariableLifetime);
		rval = (u_char *) &StorageTmp->lLCStationTransmitVariableLifetime;
		break;
	case (u_char) LLCSTATIONTYPE3ACKNOWLEDGETIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCStationType3AcknowledgeTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationType3AcknowledgeTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCStationType3AcknowledgeTimeoutValue;
		break;
	case (u_char) LLCSTATIONTYPE3RETRANSMISSIONS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationType3Retransmissions);
		rval = (u_char *) &StorageTmp->lLCStationType3Retransmissions;
		break;
	case (u_char) LLCSTATIONAVGBUFFERUSESIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationAvgBufferUseSize);
		rval = (u_char *) &StorageTmp->lLCStationAvgBufferUseSize;
		break;
	case (u_char) LLCSTATIONBUFFERPROBLEMS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationBufferProblems);
		rval = (u_char *) &StorageTmp->lLCStationBufferProblems;
		break;
	case (u_char) LLCSTATIONBUFFERSIZE:	/* ReadWrite */
		*write_method = write_lLCStationBufferSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationBufferSize);
		rval = (u_char *) &StorageTmp->lLCStationBufferSize;
		break;
	case (u_char) LLCSTATIONMAXBUFFERUSESIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationMaxBufferUseSize);
		rval = (u_char *) &StorageTmp->lLCStationMaxBufferUseSize;
		break;
	case (u_char) LLCSTATIONINACTIVELSAP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationInactiveLSAP);
		rval = (u_char *) &StorageTmp->lLCStationInactiveLSAP;
		break;
	case (u_char) LLCSTATIONPDUSDISCARD:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationPDUsDiscard);
		rval = (u_char *) &StorageTmp->lLCStationPDUsDiscard;
		break;
	case (u_char) LLCSTATIONSTRINDICATOR:	/* ReadWrite */
		*write_method = write_lLCStationSTRIndicator;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCStationSTRIndicatorLen;
		rval = (u_char *) StorageTmp->lLCStationSTRIndicator;
		break;
	case (u_char) LLCSTATIONVERSIONNUMBER:	/* ReadWrite */
		*write_method = write_lLCStationVersionNumber;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationVersionNumber);
		rval = (u_char *) &StorageTmp->lLCStationVersionNumber;
		break;
	case (u_char) LLCSTATIONTYPE1ACKNOWLEDGMENTTIMERTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts);
		rval = (u_char *) &StorageTmp->lLCStationType1AcknowledgmentTimerTimeouts;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCSAPTable_row(struct lLCSAPTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCSAPTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCSAPTable_data *
refresh_lLCSAPTable_row(struct lLCSAPTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCSAPTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCSAPTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCSAPTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCSAPTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCSAPTable(int force)
{
	if (!force && lLCSAPTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCSAPTable_refresh = 0;
}

/**
 * @fn u_char *var_lLCSAPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCSAPTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCSAPTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCSAPTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCSAPTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCSAPTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCSAPADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCSAPAddressLen;
		rval = (u_char *) StorageTmp->lLCSAPAddress;
		break;
	case (u_char) LLCSAPRDE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCSAPRDE);
		rval = (u_char *) &StorageTmp->lLCSAPRDE;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_rDESetupTable_row(struct rDESetupTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the rDESetupTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct rDESetupTable_data *
refresh_rDESetupTable_row(struct rDESetupTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->rDESetupTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->rDESetupTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_rDESetupTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the rDESetupTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_rDESetupTable(int force)
{
	if (!force && rDESetupTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	rDESetupTable_refresh = 0;
}

/**
 * @fn u_char *var_rDESetupTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in rDESetupTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_rDESetupTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct rDESetupTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_rDESetupTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_rDESetupTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(rDESetupTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_rDESetupTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) RDESETUPAGINGENABLED:	/* ReadWrite */
		*write_method = write_rDESetupAgingEnabled;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupAgingEnabled);
		rval = (u_char *) &StorageTmp->rDESetupAgingEnabled;
		break;
	case (u_char) RDESETUPAGINGVALUE:	/* ReadWrite */
		*write_method = write_rDESetupAgingValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupAgingValue);
		rval = (u_char *) &StorageTmp->rDESetupAgingValue;
		break;
	case (u_char) RDESETUPENABLETYPE2RESET:	/* ReadWrite */
		*write_method = write_rDESetupEnableType2Reset;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupEnableType2Reset);
		rval = (u_char *) &StorageTmp->rDESetupEnableType2Reset;
		break;
	case (u_char) RDESETUPMAXIMUMROUTEDESCRIPTORS:	/* ReadWrite */
		*write_method = write_rDESetupMaximumRouteDescriptors;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupMaximumRouteDescriptors);
		rval = (u_char *) &StorageTmp->rDESetupMaximumRouteDescriptors;
		break;
	case (u_char) RDESETUPMAXIMUMRESPONSETIME:	/* ReadWrite */
		*write_method = write_rDESetupMaximumResponseTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupMaximumResponseTime);
		rval = (u_char *) &StorageTmp->rDESetupMaximumResponseTime;
		break;
	case (u_char) RDESETUPMINIMUMPDUSIZE:	/* ReadWrite */
		*write_method = write_rDESetupMinimumPDUSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupMinimumPDUSize);
		rval = (u_char *) &StorageTmp->rDESetupMinimumPDUSize;
		break;
	case (u_char) RDESETUPRDEHOLD:	/* ReadWrite */
		*write_method = write_rDESetupRDEHold;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupRDEHold);
		rval = (u_char *) &StorageTmp->rDESetupRDEHold;
		break;
	case (u_char) RDESETUPRDEREPLACE:	/* ReadWrite */
		*write_method = write_rDESetupRDEReplace;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupRDEReplace);
		rval = (u_char *) &StorageTmp->rDESetupRDEReplace;
		break;
	case (u_char) RDESETUPNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupName);
		rval = (u_char *) &StorageTmp->rDESetupName;
		break;
	case (u_char) RDESETUPRESETONTESTENABLED:	/* ReadWrite */
		*write_method = write_rDESetupResetOnTestEnabled;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDESetupResetOnTestEnabled);
		rval = (u_char *) &StorageTmp->rDESetupResetOnTestEnabled;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_rDEPairTable_row(struct rDEPairTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the rDEPairTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct rDEPairTable_data *
refresh_rDEPairTable_row(struct rDEPairTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->rDEPairTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->rDEPairTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_rDEPairTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the rDEPairTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_rDEPairTable(int force)
{
	if (!force && rDEPairTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	rDEPairTable_refresh = 0;
}

/**
 * @fn u_char *var_rDEPairTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in rDEPairTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_rDEPairTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct rDEPairTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_rDEPairTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_rDEPairTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(rDEPairTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_rDEPairTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) RDEPAIRDISCARDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDEPairDiscardCounter);
		rval = (u_char *) &StorageTmp->rDEPairDiscardCounter;
		break;
	case (u_char) RDEPAIRNSRPDUCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDEPairNSRPDUCounter);
		rval = (u_char *) &StorageTmp->rDEPairNSRPDUCounter;
		break;
	case (u_char) RDEPAIRNSRSELECTEDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDEPairNSRSelectedCounter);
		rval = (u_char *) &StorageTmp->rDEPairNSRSelectedCounter;
		break;
	case (u_char) RDEPAIRRIF:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->rDEPairRIFLen;
		rval = (u_char *) StorageTmp->rDEPairRIF;
		break;
	case (u_char) RDEPAIRSRFPDUCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDEPairSRFPDUCounter);
		rval = (u_char *) &StorageTmp->rDEPairSRFPDUCounter;
		break;
	case (u_char) RDEPAIRQUERYCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->rDEPairQueryCounter);
		rval = (u_char *) &StorageTmp->rDEPairQueryCounter;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCConnectionLessTable_row(struct lLCConnectionLessTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCConnectionLessTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCConnectionLessTable_data *
refresh_lLCConnectionLessTable_row(struct lLCConnectionLessTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCConnectionLessTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCConnectionLessTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCConnectionLessTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCConnectionLessTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionLessTable(int force)
{
	if (!force && lLCConnectionLessTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCConnectionLessTable_refresh = 0;
}

/**
 * @fn u_char *var_lLCConnectionLessTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnectionLessTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnectionLessTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionLessTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCConnectionLessTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCConnectionLessTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCConnectionLessTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCConnectionLessTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCCONNECTIONLESSNAME:	/* ReadWrite */
		*write_method = write_lLCConnectionlessName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCConnectionlessNameLen;
		rval = (u_char *) StorageTmp->lLCConnectionlessName;
		break;
	case (u_char) LLCCONNECTIONLESSMAXIMUMLLCINFORMATIONFIELDSIZE:	/* ReadWrite */
		*write_method = write_lLCConnectionlessMaximumLLCInformationFieldSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize);
		rval = (u_char *) &StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize;
		break;
	case (u_char) LLCCONNECTIONLESSTESTRECEIVEDABBRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedABBResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedABBResponse;
		break;
	case (u_char) LLCCONNECTIONLESSTESTRECEIVEDCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedCommand;
		break;
	case (u_char) LLCCONNECTIONLESSTESTRECEIVEDRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTReceivedResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessTESTReceivedResponse;
		break;
	case (u_char) LLCCONNECTIONLESSTESTSENTABBRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentABBResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessTESTSentABBResponse;
		break;
	case (u_char) LLCCONNECTIONLESSTESTSENTCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessTESTSentCommand;
		break;
	case (u_char) LLCCONNECTIONLESSTESTSENTRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessTESTSentResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessTESTSentResponse;
		break;
	case (u_char) LLCCONNECTIONLESSUIRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessUIReceived);
		rval = (u_char *) &StorageTmp->lLCConnectionlessUIReceived;
		break;
	case (u_char) LLCCONNECTIONLESSUISENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessUISent);
		rval = (u_char *) &StorageTmp->lLCConnectionlessUISent;
		break;
	case (u_char) LLCCONNECTIONLESSXIDRECEIVEDCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDReceivedCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessXIDReceivedCommand;
		break;
	case (u_char) LLCCONNECTIONLESSXIDRECEIVEDRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDReceivedResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessXIDReceivedResponse;
		break;
	case (u_char) LLCCONNECTIONLESSXIDSENTCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDSentCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessXIDSentCommand;
		break;
	case (u_char) LLCCONNECTIONLESSXIDSENTRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessXIDSentResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessXIDSentResponse;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCConnection2Table_row(struct lLCConnection2Table_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCConnection2Table row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCConnection2Table_data *
refresh_lLCConnection2Table_row(struct lLCConnection2Table_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCConnection2Table_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCConnection2Table_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCConnection2Table(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCConnection2Table.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnection2Table(int force)
{
	if (!force && lLCConnection2Table_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCConnection2Table_refresh = 0;
}

/**
 * @fn u_char *var_lLCConnection2Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnection2Table.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnection2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnection2Table_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCConnection2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCConnection2Table(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCConnection2TableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCConnection2Table_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCCONNECTION2NAME:	/* ReadWrite */
		*write_method = write_lLCConnection2Name;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCConnection2NameLen;
		rval = (u_char *) StorageTmp->lLCConnection2Name;
		break;
	case (u_char) LLCCONNECTION2MAXIMUMRETRANSMISSIONS:	/* ReadWrite */
		*write_method = write_lLCConnection2MaximumRetransmissions;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2MaximumRetransmissions);
		rval = (u_char *) &StorageTmp->lLCConnection2MaximumRetransmissions;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDWINDOWSIZE:	/* ReadWrite */
		*write_method = write_lLCConnection2ReceivedWindowSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedWindowSize);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedWindowSize;
		break;
	case (u_char) LLCCONNECTION2SENDWINDOWSIZE:	/* ReadWrite */
		*write_method = write_lLCConnection2SendWindowSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SendWindowSize);
		rval = (u_char *) &StorageTmp->lLCConnection2SendWindowSize;
		break;
	case (u_char) LLCCONNECTION2ACKNOWLEDGETIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2AcknowledgeTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2AcknowledgeTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2AcknowledgeTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2BUSYSTATETIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2BusyStateTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2BusyStateTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2BusyStateTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2PBITTIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2PBitTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2PBitTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2PBitTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2REJECTTIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2RejectTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2RejectTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2RejectTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2LOCALBUSY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2LocalBusy);
		rval = (u_char *) &StorageTmp->lLCConnection2LocalBusy;
		break;
	case (u_char) LLCCONNECTION2REMOTEBUSY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2RemoteBusy);
		rval = (u_char *) &StorageTmp->lLCConnection2RemoteBusy;
		break;
	case (u_char) LLCCONNECTION2REMOTERESET:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2RemoteReset);
		rval = (u_char *) &StorageTmp->lLCConnection2RemoteReset;
		break;
	case (u_char) LLCCONNECTION2LOCALRESET:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2LocalReset);
		rval = (u_char *) &StorageTmp->lLCConnection2LocalReset;
		break;
	case (u_char) LLCCONNECTION2PROVIDERRESET:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ProviderReset);
		rval = (u_char *) &StorageTmp->lLCConnection2ProviderReset;
		break;
	case (u_char) LLCCONNECTION2ROUTE:	/* ReadWrite */
		*write_method = write_lLCConnection2Route;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCConnection2RouteLen;
		rval = (u_char *) StorageTmp->lLCConnection2Route;
		break;
	case (u_char) LLCCONNECTION2KSTEP:	/* ReadWrite */
		*write_method = write_lLCConnection2KStep;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2KStep);
		rval = (u_char *) &StorageTmp->lLCConnection2KStep;
		break;
	case (u_char) LLCCONNECTION2MAXSENDWINDOWSIZE:	/* ReadWrite */
		*write_method = write_lLCConnection2MaxSendWindowSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2MaxSendWindowSize);
		rval = (u_char *) &StorageTmp->lLCConnection2MaxSendWindowSize;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDI:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedI);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedI;
		break;
	case (u_char) LLCCONNECTION2SENTI:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentI);
		rval = (u_char *) &StorageTmp->lLCConnection2SentI;
		break;
	case (u_char) LLCCONNECTION2SENTACKS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentAcks);
		rval = (u_char *) &StorageTmp->lLCConnection2SentAcks;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDACKS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedAcks);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedAcks;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDFRMR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedFRMR);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedFRMR;
		break;
	case (u_char) LLCCONNECTION2SENTFRMR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentFRMR);
		rval = (u_char *) &StorageTmp->lLCConnection2SentFRMR;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDRR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedRR);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedRR;
		break;
	case (u_char) LLCCONNECTION2SENTRR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentRR);
		rval = (u_char *) &StorageTmp->lLCConnection2SentRR;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDRNR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedRNR);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedRNR;
		break;
	case (u_char) LLCCONNECTION2SENTRNR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentRNR);
		rval = (u_char *) &StorageTmp->lLCConnection2SentRNR;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDREJ:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedREJ);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedREJ;
		break;
	case (u_char) LLCCONNECTION2SENTREJ:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentREJ);
		rval = (u_char *) &StorageTmp->lLCConnection2SentREJ;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDSABME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedSABME);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedSABME;
		break;
	case (u_char) LLCCONNECTION2SENTSABME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentSABME);
		rval = (u_char *) &StorageTmp->lLCConnection2SentSABME;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDUA:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedUA);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedUA;
		break;
	case (u_char) LLCCONNECTION2SENTUA:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentUA);
		rval = (u_char *) &StorageTmp->lLCConnection2SentUA;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDDISC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedDISC);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedDISC;
		break;
	case (u_char) LLCCONNECTION2SENTDISC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentDISC);
		rval = (u_char *) &StorageTmp->lLCConnection2SentDISC;
		break;
	case (u_char) LLCCONNECTION2RECEIVEDDM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ReceivedDM);
		rval = (u_char *) &StorageTmp->lLCConnection2ReceivedDM;
		break;
	case (u_char) LLCCONNECTION2SENTDM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2SentDM);
		rval = (u_char *) &StorageTmp->lLCConnection2SentDM;
		break;
	case (u_char) LLCCONNECTION2PDUSDISCARDED1:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2PDUsDiscarded1);
		rval = (u_char *) &StorageTmp->lLCConnection2PDUsDiscarded1;
		break;
	case (u_char) LLCCONNECTION2PDUSDISCARDED2:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2PDUsDiscarded2);
		rval = (u_char *) &StorageTmp->lLCConnection2PDUsDiscarded2;
		break;
	case (u_char) LLCCONNECTION2PDURETRANSMISSIONS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2PDURetransmissions);
		rval = (u_char *) &StorageTmp->lLCConnection2PDURetransmissions;
		break;
	case (u_char) LLCCONNECTION2OPTIONALTOLERATIONIPDUS:	/* ReadWrite */
		*write_method = write_lLCConnection2OptionalTolerationIPDUs;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2OptionalTolerationIPDUs);
		rval = (u_char *) &StorageTmp->lLCConnection2OptionalTolerationIPDUs;
		break;
	case (u_char) LLCCONNECTION2DUPLICATEIPDUSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2DuplicateIPDUsReceived);
		rval = (u_char *) &StorageTmp->lLCConnection2DuplicateIPDUsReceived;
		break;
	case (u_char) LLCCONNECTION2VIOLATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2Violation);
		rval = (u_char *) &StorageTmp->lLCConnection2Violation;
		break;
	case (u_char) LLCCONNECTION2PROTOCOLSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2ProtocolState);
		rval = (u_char *) &StorageTmp->lLCConnection2ProtocolState;
		break;
	case (u_char) LLCCONNECTION2ADMINISTRATIVESTATE:	/* ReadWrite */
		*write_method = write_lLCConnection2AdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2AdministrativeState);
		rval = (u_char *) &StorageTmp->lLCConnection2AdministrativeState;
		break;
	case (u_char) LLCCONNECTION2OPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2OperationalState);
		rval = (u_char *) &StorageTmp->lLCConnection2OperationalState;
		break;
	case (u_char) LLCCONNECTION2USAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2UsageState);
		rval = (u_char *) &StorageTmp->lLCConnection2UsageState;
		break;
	case (u_char) LLCCONNECTION2PROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCConnection2ProceduralStatusLen;
		rval = (u_char *) StorageTmp->lLCConnection2ProceduralStatus;
		break;
	case (u_char) LLCCONNECTION2ALARMSTATUS:	/* ReadWrite */
		*write_method = write_lLCConnection2AlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lLCConnection2AlarmStatusLen;
		rval = (u_char *) StorageTmp->lLCConnection2AlarmStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCConnection2IVMOTable_row(struct lLCConnection2IVMOTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCConnection2IVMOTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCConnection2IVMOTable_data *
refresh_lLCConnection2IVMOTable_row(struct lLCConnection2IVMOTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCConnection2IVMOTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCConnection2IVMOTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCConnection2IVMOTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCConnection2IVMOTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnection2IVMOTable(int force)
{
	if (!force && lLCConnection2IVMOTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCConnection2IVMOTable_refresh = 0;
}

/**
 * @fn u_char *var_lLCConnection2IVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnection2IVMOTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnection2IVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCConnection2IVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCConnection2IVMOTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCConnection2IVMOTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCConnection2IVMOTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCCONNECTION2IVMOMAXIMUMRETRANSMISSIONS:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMOMaximumRetransmissions;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOMaximumRetransmissions);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMOMaximumRetransmissions;
		break;
	case (u_char) LLCCONNECTION2IVMORECEIVEDWINDOWSIZE:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMOReceivedWindowSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOReceivedWindowSize);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMOReceivedWindowSize;
		break;
	case (u_char) LLCCONNECTION2IVMOSENDWINDOWSIZE:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMOSendWindowSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOSendWindowSize);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMOSendWindowSize;
		break;
	case (u_char) LLCCONNECTION2IVMOACKNOWLEDGETIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMOAcknowledgeTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2IVMOBUSYSTATETIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMOBusyStateTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2IVMOBITTIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMOBitTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOBitTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMOBitTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2IVMOREJECTTIMEOUTVALUE:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMORejectTimeoutValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMORejectTimeoutValue);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMORejectTimeoutValue;
		break;
	case (u_char) LLCCONNECTION2IVMOROUTE:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMORoute;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMORoute);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMORoute;
		break;
	case (u_char) LLCCONNECTION2IVMOKSTEP:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMOKStep;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOKStep);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMOKStep;
		break;
	case (u_char) LLCCONNECTION2IVMOMAXSENDWINDOWSIZE:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMOMaxSendWindowSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOMaxSendWindowSize);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMOMaxSendWindowSize;
		break;
	case (u_char) LLCCONNECTION2IVMOOPTIONALTOLERATIONIPDUS:	/* ReadWrite */
		*write_method = write_lLCConnection2IVMOOptionalTolerationIPDUs;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs);
		rval = (u_char *) &StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCConnectionlessAckTable_row(struct lLCConnectionlessAckTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCConnectionlessAckTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCConnectionlessAckTable_data *
refresh_lLCConnectionlessAckTable_row(struct lLCConnectionlessAckTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCConnectionlessAckTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCConnectionlessAckTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCConnectionlessAckTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCConnectionlessAckTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionlessAckTable(int force)
{
	if (!force && lLCConnectionlessAckTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCConnectionlessAckTable_refresh = 0;
}

/**
 * @fn u_char *var_lLCConnectionlessAckTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnectionlessAckTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnectionlessAckTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCConnectionlessAckTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCConnectionlessAckTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCConnectionlessAckTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCConnectionlessAckTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCCONNECTIONLESSACKMAXIMUMLLCINFORMATIONFIELDSIZE:	/* ReadWrite */
		*write_method = write_lLCConnectionlessAckMaximumLLCInformationFieldSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize;
		break;
	case (u_char) LLCCONNECTIONLESSACKMAXIMUMRETRANSMISSIONS:	/* ReadWrite */
		*write_method = write_lLCConnectionlessAckMaximumRetransmissions;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckMaximumRetransmissions);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckMaximumRetransmissions;
		break;
	case (u_char) LLCCONNECTIONLESSACKTESTRECEIVEDABBRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedABBResponse;
		break;
	case (u_char) LLCCONNECTIONLESSACKTESTRECEIVEDCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedCommand;
		break;
	case (u_char) LLCCONNECTIONLESSACKTESTRECEIVEDRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTReceivedResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckTESTReceivedResponse;
		break;
	case (u_char) LLCCONNECTIONLESSACKTESTSENTABBRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentABBResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentABBResponse;
		break;
	case (u_char) LLCCONNECTIONLESSACKTESTSENTCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentCommand;
		break;
	case (u_char) LLCCONNECTIONLESSACKTESTSENTRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckTESTSentResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckTESTSentResponse;
		break;
	case (u_char) LLCCONNECTIONLESSACKRECEIVERESOURCES:	/* ReadWrite */
		*write_method = write_lLCConnectionlessAckReceiveResources;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckReceiveResources);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckReceiveResources;
		break;
	case (u_char) LLCCONNECTIONLESSACKUIRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckUIReceived);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckUIReceived;
		break;
	case (u_char) LLCCONNECTIONLESSACKUISENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckUISent);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckUISent;
		break;
	case (u_char) LLCCONNECTIONLESSACKXIDRECEIVEDCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDReceivedCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckXIDReceivedCommand;
		break;
	case (u_char) LLCCONNECTIONLESSACKXIDRECEIVEDRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDReceivedResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckXIDReceivedResponse;
		break;
	case (u_char) LLCCONNECTIONLESSACKXIDSENTCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDSentCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckXIDSentCommand;
		break;
	case (u_char) LLCCONNECTIONLESSACKXIDSENTRESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckXIDSentResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckXIDSentResponse;
		break;
	case (u_char) LLCCONNECTIONLESSACKRETRANSMISSIONS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckRetransmissions);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckRetransmissions;
		break;
	case (u_char) LLCCONNECTIONLESSACKNORESPONSE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckNoResponse);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckNoResponse;
		break;
	case (u_char) LLCCONNECTIONLESSACKCOMMANDIP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandIP);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckCommandIP;
		break;
	case (u_char) LLCCONNECTIONLESSACKCOMMANDIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandIT);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckCommandIT;
		break;
	case (u_char) LLCCONNECTIONLESSACKCOMMANDOK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandOK);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckCommandOK;
		break;
	case (u_char) LLCCONNECTIONLESSACKCOMMANDPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandPE);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckCommandPE;
		break;
	case (u_char) LLCCONNECTIONLESSACKCOMMANDRS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandRS);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckCommandRS;
		break;
	case (u_char) LLCCONNECTIONLESSACKCOMMANDUE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandUE);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckCommandUE;
		break;
	case (u_char) LLCCONNECTIONLESSACKCOMMANDUN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckCommandUN);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckCommandUN;
		break;
	case (u_char) LLCCONNECTIONLESSACKRECEIVEDACCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckReceivedACCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckReceivedACCommand;
		break;
	case (u_char) LLCCONNECTIONLESSACKSENTACCOMMAND:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckSentACCommand);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckSentACCommand;
		break;
	case (u_char) LLCCONNECTIONLESSACKRESPONSEIP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseIP);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckResponseIP;
		break;
	case (u_char) LLCCONNECTIONLESSACKRESPONSEIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseIT);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckResponseIT;
		break;
	case (u_char) LLCCONNECTIONLESSACKRESPONSENE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseNE);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckResponseNE;
		break;
	case (u_char) LLCCONNECTIONLESSACKRESPONSENR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseNR);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckResponseNR;
		break;
	case (u_char) LLCCONNECTIONLESSACKRESPONSEOK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseOK);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckResponseOK;
		break;
	case (u_char) LLCCONNECTIONLESSACKRESPONSERS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseRS);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckResponseRS;
		break;
	case (u_char) LLCCONNECTIONLESSACKRESPONSEUE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseUE);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckResponseUE;
		break;
	case (u_char) LLCCONNECTIONLESSACKRESPONSEUN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckResponseUN);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckResponseUN;
		break;
	case (u_char) LLCCONNECTIONLESSACKVIOLATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckViolation);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckViolation;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_lLCConnectionlessAckIVMOTable_row(struct lLCConnectionlessAckIVMOTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lLCConnectionlessAckIVMOTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lLCConnectionlessAckIVMOTable_data *
refresh_lLCConnectionlessAckIVMOTable_row(struct lLCConnectionlessAckIVMOTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lLCConnectionlessAckIVMOTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lLCConnectionlessAckIVMOTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lLCConnectionlessAckIVMOTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lLCConnectionlessAckIVMOTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lLCConnectionlessAckIVMOTable(int force)
{
	if (!force && lLCConnectionlessAckIVMOTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lLCConnectionlessAckIVMOTable_refresh = 0;
}

/**
 * @fn u_char *var_lLCConnectionlessAckIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lLCConnectionlessAckIVMOTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_lLCConnectionlessAckIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_lLCConnectionlessAckIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lLCConnectionlessAckIVMOTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lLCConnectionlessAckIVMOTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLCCONNECTIONLESSACKIVMOMAXIMUMLLCINFORMATIONFIELDSIZE:	/* Create */
		*write_method = write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		break;
	case (u_char) LLCCONNECTIONLESSACKIVMOMAXIMUMRETRANSMISSIONS:	/* Create */
		*write_method = write_lLCConnectionlessAckIVMOMaximumRetransmissions;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions;
		break;
	case (u_char) LLCCONNECTIONLESSACKIVMOROWSTATUS:	/* Create */
		*write_method = write_lLCConnectionlessAckIVMORowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lLCConnectionlessAckIVMORowStatus);
		rval = (u_char *) &StorageTmp->lLCConnectionlessAckIVMORowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_networkEntityTable_row(struct networkEntityTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the networkEntityTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct networkEntityTable_data *
refresh_networkEntityTable_row(struct networkEntityTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->networkEntityTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->networkEntityTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_networkEntityTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the networkEntityTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_networkEntityTable(int force)
{
	if (!force && networkEntityTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	networkEntityTable_refresh = 0;
}

/**
 * @fn u_char *var_networkEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in networkEntityTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_networkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct networkEntityTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_networkEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_networkEntityTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(networkEntityTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_networkEntityTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) NETWORKENTITYTITLES:	/* Create */
		*write_method = write_networkEntityTitles;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->networkEntityTitlesLen;
		rval = (u_char *) StorageTmp->networkEntityTitles;
		break;
	case (u_char) NETWORKENTITYSYSTEMTYPES:	/* Create */
		*write_method = write_networkEntitySystemTypes;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->networkEntitySystemTypesLen;
		rval = (u_char *) StorageTmp->networkEntitySystemTypes;
		break;
	case (u_char) NETWORKENTITYROWSTATUS:	/* Create */
		*write_method = write_networkEntityRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->networkEntityRowStatus);
		rval = (u_char *) &StorageTmp->networkEntityRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_nSAPTable_row(struct nSAPTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the nSAPTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct nSAPTable_data *
refresh_nSAPTable_row(struct nSAPTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->nSAPTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->nSAPTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_nSAPTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the nSAPTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_nSAPTable(int force)
{
	if (!force && nSAPTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	nSAPTable_refresh = 0;
}

/**
 * @fn u_char *var_nSAPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in nSAPTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_nSAPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct nSAPTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_nSAPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_nSAPTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(nSAPTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_nSAPTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) NSAPROWSTATUS:	/* Create */
		*write_method = write_nSAPRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->nSAPRowStatus);
		rval = (u_char *) &StorageTmp->nSAPRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_cLNSTable_row(struct cLNSTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the cLNSTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct cLNSTable_data *
refresh_cLNSTable_row(struct cLNSTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->cLNSTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->cLNSTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_cLNSTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the cLNSTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cLNSTable(int force)
{
	if (!force && cLNSTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	cLNSTable_refresh = 0;
}

/**
 * @fn u_char *var_cLNSTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in cLNSTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cLNSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cLNSTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_cLNSTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_cLNSTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(cLNSTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_cLNSTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) CLNSADMINISTRATIVESTATE:	/* Create */
		*write_method = write_cLNSAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSAdministrativeState);
		rval = (u_char *) &StorageTmp->cLNSAdministrativeState;
		break;
	case (u_char) CLNSSUPPORTEDPROTOCOLS:	/* Create */
		*write_method = write_cLNSSupportedProtocols;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSSupportedProtocolsLen;
		rval = (u_char *) StorageTmp->cLNSSupportedProtocols;
		break;
	case (u_char) CLNSOPERATIONALSYSTEMTYPE:	/* Create */
		*write_method = write_cLNSOperationalSystemType;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSOperationalSystemTypeLen;
		rval = (u_char *) StorageTmp->cLNSOperationalSystemType;
		break;
	case (u_char) CLNSOCTETSSENTCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSOctetsSentCounter);
		rval = (u_char *) &StorageTmp->cLNSOctetsSentCounter;
		break;
	case (u_char) CLNSOCTETSRECEIVEDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSOctetsReceivedCounter);
		rval = (u_char *) &StorageTmp->cLNSOctetsReceivedCounter;
		break;
	case (u_char) CLNSSEGMENTSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSSegmentsReceived);
		rval = (u_char *) &StorageTmp->cLNSSegmentsReceived;
		break;
	case (u_char) CLNSSEGMENTSDISCARDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSSegmentsDiscarded);
		rval = (u_char *) &StorageTmp->cLNSSegmentsDiscarded;
		break;
	case (u_char) CLNSASSEMBLINGSEGMENTSDISCARDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSAssemblingSegmentsDiscarded);
		rval = (u_char *) &StorageTmp->cLNSAssemblingSegmentsDiscarded;
		break;
	case (u_char) CLNSERRORREPORTSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSErrorReportsReceived);
		rval = (u_char *) &StorageTmp->cLNSErrorReportsReceived;
		break;
	case (u_char) CLNSPDUDISCARDS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSpDUDiscards);
		rval = (u_char *) &StorageTmp->cLNSpDUDiscards;
		break;
	case (u_char) CLNSCONGESTIONDISCARDS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSCongestionDiscards);
		rval = (u_char *) &StorageTmp->cLNSCongestionDiscards;
		break;
	case (u_char) CLNSMAXIMUMLIFETIME:	/* Create */
		*write_method = write_cLNSMaximumLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSMaximumLifetime);
		rval = (u_char *) &StorageTmp->cLNSMaximumLifetime;
		break;
	case (u_char) CLNSENABLECHECKSUM:	/* Create */
		*write_method = write_cLNSEnableChecksum;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSEnableChecksum);
		rval = (u_char *) &StorageTmp->cLNSEnableChecksum;
		break;
	case (u_char) CLNSROWSTATUS:	/* Create */
		*write_method = write_cLNSRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSRowStatus);
		rval = (u_char *) &StorageTmp->cLNSRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_cLNSISISTable_row(struct cLNSISISTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the cLNSISISTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct cLNSISISTable_data *
refresh_cLNSISISTable_row(struct cLNSISISTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->cLNSISISTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->cLNSISISTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_cLNSISISTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the cLNSISISTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cLNSISISTable(int force)
{
	if (!force && cLNSISISTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	cLNSISISTable_refresh = 0;
}

/**
 * @fn u_char *var_cLNSISISTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in cLNSISISTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cLNSISISTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cLNSISISTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_cLNSISISTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_cLNSISISTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(cLNSISISTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_cLNSISISTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) CLNSISISVERSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISversionLen;
		rval = (u_char *) StorageTmp->cLNSISISversion;
		break;
	case (u_char) CLNSISISISTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISiSType);
		rval = (u_char *) &StorageTmp->cLNSISISiSType;
		break;
	case (u_char) CLNSISISSYSTEMID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISsystemIdLen;
		rval = (u_char *) StorageTmp->cLNSISISsystemId;
		break;
	case (u_char) CLNSISISMAXIMUMPATHSPLITS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISmaximumPathSplits);
		rval = (u_char *) &StorageTmp->cLNSISISmaximumPathSplits;
		break;
	case (u_char) CLNSISISMINIMUMLSPTRANSMISSIONINTERVAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISminimumLSPTransmissionInterval);
		rval = (u_char *) &StorageTmp->cLNSISISminimumLSPTransmissionInterval;
		break;
	case (u_char) CLNSISISMAXIMUMLSPGENERATIONINTERVAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISmaximumLSPGenerationInterval);
		rval = (u_char *) &StorageTmp->cLNSISISmaximumLSPGenerationInterval;
		break;
	case (u_char) CLNSISISMINIMUMBROADCASTLSPTRANSMISSIONINTERVAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval);
		rval = (u_char *) &StorageTmp->cLNSISISminimumBroadcastLSPTransmissionInterval;
		break;
	case (u_char) CLNSISISCOMPLETESNPINTERVAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISIScompleteSNPInterval);
		rval = (u_char *) &StorageTmp->cLNSISIScompleteSNPInterval;
		break;
	case (u_char) CLNSISISORIGINATINGL1LSPBUFFERSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISoriginatingL1LSPBufferSize);
		rval = (u_char *) &StorageTmp->cLNSISISoriginatingL1LSPBufferSize;
		break;
	case (u_char) CLNSISISMANUALAREAADDRESSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISmanualAreaAddressesLen;
		rval = (u_char *) StorageTmp->cLNSISISmanualAreaAddresses;
		break;
	case (u_char) CLNSISISMAXIMUMAREAADDRESSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISmaximumAreaAddresses);
		rval = (u_char *) &StorageTmp->cLNSISISmaximumAreaAddresses;
		break;
	case (u_char) CLNSISISMINIMUMLSPGENERATIONINTERVAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISminimumLSPGenerationInterval);
		rval = (u_char *) &StorageTmp->cLNSISISminimumLSPGenerationInterval;
		break;
	case (u_char) CLNSISISPOLLESHELLORATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISpollESHelloRate);
		rval = (u_char *) &StorageTmp->cLNSISISpollESHelloRate;
		break;
	case (u_char) CLNSISISPARTIALSNPINTERVAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISpartialSNPInterval);
		rval = (u_char *) &StorageTmp->cLNSISISpartialSNPInterval;
		break;
	case (u_char) CLNSISISWAITINGTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISwaitingTime);
		rval = (u_char *) &StorageTmp->cLNSISISwaitingTime;
		break;
	case (u_char) CLNSISISDRISISHELLOTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISdRISISHelloTimer);
		rval = (u_char *) &StorageTmp->cLNSISISdRISISHelloTimer;
		break;
	case (u_char) CLNSISISL1STATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISl1State);
		rval = (u_char *) &StorageTmp->cLNSISISl1State;
		break;
	case (u_char) CLNSISISAREAADDRESSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISareaAddressesLen;
		rval = (u_char *) StorageTmp->cLNSISISareaAddresses;
		break;
	case (u_char) CLNSISISCORRUPTEDLSPSDETECTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISIScorruptedLSPsDetected);
		rval = (u_char *) &StorageTmp->cLNSISIScorruptedLSPsDetected;
		break;
	case (u_char) CLNSISISLSPL1DATABASEOVERLOADS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISlSPL1DatabaseOverloads);
		rval = (u_char *) &StorageTmp->cLNSISISlSPL1DatabaseOverloads;
		break;
	case (u_char) CLNSISISMANUALADDRESSESDROPPEDFROMAREAS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISmanualAddressesDroppedFromAreas);
		rval = (u_char *) &StorageTmp->cLNSISISmanualAddressesDroppedFromAreas;
		break;
	case (u_char) CLNSISISATTEMPTSTOEXCEEDMAXIMUMSEQUENCENUMBER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber);
		rval = (u_char *) &StorageTmp->cLNSISISattemptsToExceedMaximumSequenceNumber;
		break;
	case (u_char) CLNSISISSEQUENCENUMBERSKIPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISsequenceNumberSkips);
		rval = (u_char *) &StorageTmp->cLNSISISsequenceNumberSkips;
		break;
	case (u_char) CLNSISISOWNLSPPURGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISownLSPPurges);
		rval = (u_char *) &StorageTmp->cLNSISISownLSPPurges;
		break;
	case (u_char) CLNSISISIDFIELDLENGTHMISMATCHES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISiDFieldLengthMismatches);
		rval = (u_char *) &StorageTmp->cLNSISISiDFieldLengthMismatches;
		break;
	case (u_char) CLNSISISMAXIMUMAREAADDRESSESMISMATCHES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISmaximumAreaAddressesMismatches);
		rval = (u_char *) &StorageTmp->cLNSISISmaximumAreaAddressesMismatches;
		break;
	case (u_char) CLNSISISORIGINATINGLSPBUFFERSIZEMISMATCHES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches);
		rval = (u_char *) &StorageTmp->cLNSISISoriginatingLSPBufferSizeMismatches;
		break;
	case (u_char) CLNSISISLSPTOOLARGETOPROPAGATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISlSPTooLargeToPropagate);
		rval = (u_char *) &StorageTmp->cLNSISISlSPTooLargeToPropagate;
		break;
	case (u_char) CLNSISISAREATRANSMITPASSWORD:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISareaTransmitPasswordLen;
		rval = (u_char *) StorageTmp->cLNSISISareaTransmitPassword;
		break;
	case (u_char) CLNSISISAREARECEIVEPASSWORDS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISareaReceivePasswordsLen;
		rval = (u_char *) StorageTmp->cLNSISISareaReceivePasswords;
		break;
	case (u_char) CLNSISISAUTHENTICATIONFAILURES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISauthenticationFailures);
		rval = (u_char *) &StorageTmp->cLNSISISauthenticationFailures;
		break;
	case (u_char) CLNSISISROWSTATUS:	/* Create */
		*write_method = write_cLNSISISRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISRowStatus);
		rval = (u_char *) &StorageTmp->cLNSISISRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_cLNSISISLevel2Table_row(struct cLNSISISLevel2Table_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the cLNSISISLevel2Table row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct cLNSISISLevel2Table_data *
refresh_cLNSISISLevel2Table_row(struct cLNSISISLevel2Table_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->cLNSISISLevel2Table_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->cLNSISISLevel2Table_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_cLNSISISLevel2Table(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the cLNSISISLevel2Table.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cLNSISISLevel2Table(int force)
{
	if (!force && cLNSISISLevel2Table_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	cLNSISISLevel2Table_refresh = 0;
}

/**
 * @fn u_char *var_cLNSISISLevel2Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in cLNSISISLevel2Table.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cLNSISISLevel2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cLNSISISLevel2Table_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_cLNSISISLevel2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_cLNSISISLevel2Table(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(cLNSISISLevel2TableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_cLNSISISLevel2Table_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) CLNSISISLEVEL2MAXIMUMVIRTUALADJACENCIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies);
		rval = (u_char *) &StorageTmp->cLNSISISLevel2maximumVirtualAdjacencies;
		break;
	case (u_char) CLNSISISLEVEL2PARTITIONAREAADDRESSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISLevel2partitionAreaAddressesLen;
		rval = (u_char *) StorageTmp->cLNSISISLevel2partitionAreaAddresses;
		break;
	case (u_char) CLNSISISLEVEL2PARTITIONDESIGNATEDL2INTERMEDIATESYSTEM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystemLen;
		rval = (u_char *) StorageTmp->cLNSISISLevel2partitionDesignatedL2IntermediateSystem;
		break;
	case (u_char) CLNSISISLEVEL2PARTITIONVIRTUALLINKCHANGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges);
		rval = (u_char *) &StorageTmp->cLNSISISLevel2partitionVirtualLinkChanges;
		break;
	case (u_char) CLNSISISLEVEL2ORIGINATINGL2LSPBUFFERSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize);
		rval = (u_char *) &StorageTmp->cLNSISISLevel2originatingL2LSPBufferSize;
		break;
	case (u_char) CLNSISISLEVEL2L2STATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISLevel2l2State);
		rval = (u_char *) &StorageTmp->cLNSISISLevel2l2State;
		break;
	case (u_char) CLNSISISLEVEL2LSPL2DATABASEOVERLOADS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads);
		rval = (u_char *) &StorageTmp->cLNSISISLevel2lSPL2DatabaseOverloads;
		break;
	case (u_char) CLNSISISLEVEL2DOMAINTRANSMITPASSWORD:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISLevel2domainTransmitPasswordLen;
		rval = (u_char *) StorageTmp->cLNSISISLevel2domainTransmitPassword;
		break;
	case (u_char) CLNSISISLEVEL2DOMAINRECEIVEPASSWORDS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cLNSISISLevel2domainReceivePasswordsLen;
		rval = (u_char *) StorageTmp->cLNSISISLevel2domainReceivePasswords;
		break;
	case (u_char) CLNSISISLEVEL2ROWSTATUS:	/* Create */
		*write_method = write_cLNSISISLevel2RowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cLNSISISLevel2RowStatus);
		rval = (u_char *) &StorageTmp->cLNSISISLevel2RowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_linkageTable_row(struct linkageTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the linkageTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct linkageTable_data *
refresh_linkageTable_row(struct linkageTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->linkageTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->linkageTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_linkageTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the linkageTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_linkageTable(int force)
{
	if (!force && linkageTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	linkageTable_refresh = 0;
}

/**
 * @fn u_char *var_linkageTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in linkageTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_linkageTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct linkageTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_linkageTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_linkageTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(linkageTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_linkageTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LINKAGEOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageOperationalState);
		rval = (u_char *) &StorageTmp->linkageOperationalState;
		break;
	case (u_char) LINKAGEADMINISTRATIVESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageAdministrativeState);
		rval = (u_char *) &StorageTmp->linkageAdministrativeState;
		break;
	case (u_char) LINKAGESNSERVICEPROVIDER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageSnServiceProviderLen;
		rval = (u_char *) StorageTmp->linkageSnServiceProvider;
		break;
	case (u_char) LINKAGESNSAP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageSnSAPLen * sizeof(oid);
		rval = (u_char *) StorageTmp->linkageSnSAP;
		break;
	case (u_char) LINKAGEOPERATIONALPROTOCOLS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageOperationalProtocolsLen;
		rval = (u_char *) StorageTmp->linkageOperationalProtocols;
		break;
	case (u_char) LINKAGEISISO9542OPERATIONALSUBSETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISiSO9542OperationalSubsetsLen;
		rval = (u_char *) StorageTmp->linkageISiSO9542OperationalSubsets;
		break;
	case (u_char) LINKAGEISHOLDINGTIMERMULTIPLIER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISHoldingTimerMultiplierLen;
		rval = (u_char *) StorageTmp->linkageISHoldingTimerMultiplier;
		break;
	case (u_char) LINKAGEISISCONFIGURATIONTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISConfigurationTimerLen;
		rval = (u_char *) StorageTmp->linkageISISConfigurationTimer;
		break;
	case (u_char) LINKAGEISSUGGESTEDESCONFIGURATIONTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISSuggestedEsConfigurationTimerLen;
		rval = (u_char *) StorageTmp->linkageISSuggestedEsConfigurationTimer;
		break;
	case (u_char) LINKAGEISREDIRECTHOLDINGTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISRedirectHoldingTimeLen;
		rval = (u_char *) StorageTmp->linkageISRedirectHoldingTime;
		break;
	case (u_char) LINKAGEISESREACHABILITYCHANGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISESReachabilityChanges);
		rval = (u_char *) &StorageTmp->linkageISESReachabilityChanges;
		break;
	case (u_char) LINKAGEISINVALID9542PDUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISInvalid9542PDUs);
		rval = (u_char *) &StorageTmp->linkageISInvalid9542PDUs;
		break;
	case (u_char) LINKAGEESISO9542OPERATIONALSUBSETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageESiSO9542OperationalSubsetsLen;
		rval = (u_char *) StorageTmp->linkageESiSO9542OperationalSubsets;
		break;
	case (u_char) LINKAGEESHOLDINGTIMERMULTIPLIER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageESHoldingTimerMultiplierLen;
		rval = (u_char *) StorageTmp->linkageESHoldingTimerMultiplier;
		break;
	case (u_char) LINKAGEESMANUALISSNPAADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageESManualISSNPAAddressLen;
		rval = (u_char *) StorageTmp->linkageESManualISSNPAAddress;
		break;
	case (u_char) LINKAGEESDEFAULTESCONFIGTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageESDefaultESConfigTimerLen;
		rval = (u_char *) StorageTmp->linkageESDefaultESConfigTimer;
		break;
	case (u_char) LINKAGEESACTIVEESCONFIGTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageESActiveESConfigTimerLen;
		rval = (u_char *) StorageTmp->linkageESActiveESConfigTimer;
		break;
	case (u_char) LINKAGEESISREACHABILITYCHANGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageESISReachabilityChanges);
		rval = (u_char *) &StorageTmp->linkageESISReachabilityChanges;
		break;
	case (u_char) LINKAGEESINVALID9542PDUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageESInvalid9542PDUs);
		rval = (u_char *) &StorageTmp->linkageESInvalid9542PDUs;
		break;
	case (u_char) LINKAGEENABLECHECKSUM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageEnableChecksum);
		rval = (u_char *) &StorageTmp->linkageEnableChecksum;
		break;
	case (u_char) LINKAGEINITIALMINIMUMTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageInitialMinimumTimerLen;
		rval = (u_char *) StorageTmp->linkageInitialMinimumTimer;
		break;
	case (u_char) LINKAGERESERVETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageReserveTimerLen;
		rval = (u_char *) StorageTmp->linkageReserveTimer;
		break;
	case (u_char) LINKAGEIDLETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageIdleTimerLen;
		rval = (u_char *) StorageTmp->linkageIdleTimer;
		break;
	case (u_char) LINKAGESNDCFCALLSPLACED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageSNDCFCallsPlaced);
		rval = (u_char *) &StorageTmp->linkageSNDCFCallsPlaced;
		break;
	case (u_char) LINKAGESNDCFCALLSFAILED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageSNDCFCallsFailed);
		rval = (u_char *) &StorageTmp->linkageSNDCFCallsFailed;
		break;
	case (u_char) LINKAGECODLCALLSPLACED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageCODLCallsPlaced);
		rval = (u_char *) &StorageTmp->linkageCODLCallsPlaced;
		break;
	case (u_char) LINKAGECODLCALLSFAILED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageCODLCallsFailed);
		rval = (u_char *) &StorageTmp->linkageCODLCallsFailed;
		break;
	case (u_char) LINKAGEISISTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISTypeLen;
		rval = (u_char *) StorageTmp->linkageISISType;
		break;
	case (u_char) LINKAGEISISISISHELLOTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISiSISHelloTimerLen;
		rval = (u_char *) StorageTmp->linkageISISiSISHelloTimer;
		break;
	case (u_char) LINKAGEISISL1DEFAULTMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl1DefaultMetricLen;
		rval = (u_char *) StorageTmp->linkageISISl1DefaultMetric;
		break;
	case (u_char) LINKAGEISISL1DELAYMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl1DelayMetricLen;
		rval = (u_char *) StorageTmp->linkageISISl1DelayMetric;
		break;
	case (u_char) LINKAGEISISL1EXPENSEMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl1ExpenseMetricLen;
		rval = (u_char *) StorageTmp->linkageISISl1ExpenseMetric;
		break;
	case (u_char) LINKAGEISISL1ERRORMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl1ErrorMetricLen;
		rval = (u_char *) StorageTmp->linkageISISl1ErrorMetric;
		break;
	case (u_char) LINKAGEISISEXTERNALDOMAIN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISexternalDomainLen;
		rval = (u_char *) StorageTmp->linkageISISexternalDomain;
		break;
	case (u_char) LINKAGEISISCHANGEDINADJACENCYSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISchangedInAdjacencyState);
		rval = (u_char *) &StorageTmp->linkageISISchangedInAdjacencyState;
		break;
	case (u_char) LINKAGEISISINITIALISATIONFAILURES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISinitialisationFailures);
		rval = (u_char *) &StorageTmp->linkageISISinitialisationFailures;
		break;
	case (u_char) LINKAGEISISREJECTEDADJACENCIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISrejectedAdjacencies);
		rval = (u_char *) &StorageTmp->linkageISISrejectedAdjacencies;
		break;
	case (u_char) LINKAGEISISISISCONTROLPDUSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISiSISControlPDUsSent);
		rval = (u_char *) &StorageTmp->linkageISISiSISControlPDUsSent;
		break;
	case (u_char) LINKAGEISISISISCONTROLPDUSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISiSISControlPDUsReceived);
		rval = (u_char *) &StorageTmp->linkageISISiSISControlPDUsReceived;
		break;
	case (u_char) LINKAGEISISIDFIELDLENTHMISMATCHES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISiDFieldLenthMismatches);
		rval = (u_char *) &StorageTmp->linkageISISiDFieldLenthMismatches;
		break;
	case (u_char) LINKAGEISISMAXIMUMAREAADDRESSESMISMATCHES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISmaximumAreaAddressesMismatches);
		rval = (u_char *) &StorageTmp->linkageISISmaximumAreaAddressesMismatches;
		break;
	case (u_char) LINKAGEISISCIRCUITTRANSMITPASSWORD:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISIScircuitTransmitPasswordLen;
		rval = (u_char *) StorageTmp->linkageISIScircuitTransmitPassword;
		break;
	case (u_char) LINKAGEISISCIRCUITRECEIVEDPASSWORDS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISIScircuitReceivedPasswordsLen;
		rval = (u_char *) StorageTmp->linkageISIScircuitReceivedPasswords;
		break;
	case (u_char) LINKAGEISISAUTHENTICATIONFAILURES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISauthenticationFailures);
		rval = (u_char *) &StorageTmp->linkageISISauthenticationFailures;
		break;
	case (u_char) LINKAGEISISL1INTERMEDIATESYSTEMPRIORITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl1IntermediateSystemPriorityLen;
		rval = (u_char *) StorageTmp->linkageISISl1IntermediateSystemPriority;
		break;
	case (u_char) LINKAGEISISL1CIRCUITID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl1CircuitIDLen;
		rval = (u_char *) StorageTmp->linkageISISl1CircuitID;
		break;
	case (u_char) LINKAGEISISL1DESIGNATEDINTERMEDIATESYSTEM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl1DesignatedIntermediateSystemLen;
		rval = (u_char *) StorageTmp->linkageISISl1DesignatedIntermediateSystem;
		break;
	case (u_char) LINKAGEISISLANL1DESIGNATEDINTERMEDIATESYSTEMCHANGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges);
		rval = (u_char *) &StorageTmp->linkageISISlanL1DesignatedIntermediateSystemChanges;
		break;
	case (u_char) LINKAGEISISCALLESTABLISHMENTDEFAULTMETRICINCREMENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrementLen;
		rval = (u_char *) StorageTmp->linkageISIScallEstablishmentDefaultMetricIncrement;
		break;
	case (u_char) LINKAGEISISCALLESTABLISHMENTDELAYMETRICINCREMENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISIScallEstablishmentDelayMetricIncrementLen;
		rval = (u_char *) StorageTmp->linkageISIScallEstablishmentDelayMetricIncrement;
		break;
	case (u_char) LINKAGEISISCALLESTABLISHMENTEXPENSEMETRICINCREMENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrementLen;
		rval = (u_char *) StorageTmp->linkageISIScallEstablishmentExpenseMetricIncrement;
		break;
	case (u_char) LINKAGEISISCALLESTABLISHMENTERRORMETRICINCREMENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISIScallEstablishmentErrorMetricIncrementLen;
		rval = (u_char *) StorageTmp->linkageISIScallEstablishmentErrorMetricIncrement;
		break;
	case (u_char) LINKAGEISISPTPTCIRCUITID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISptPtCircuitIDLen;
		rval = (u_char *) StorageTmp->linkageISISptPtCircuitID;
		break;
	case (u_char) LINKAGEISISOUTGOINGCALLIVMO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISoutgoingCallIVMOLen;
		rval = (u_char *) StorageTmp->linkageISISoutgoingCallIVMO;
		break;
	case (u_char) LINKAGEISISNEIGHBORSNPAADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISneighborSNPAAddressLen;
		rval = (u_char *) StorageTmp->linkageISISneighborSNPAAddress;
		break;
	case (u_char) LINKAGEISISL2DEFAULTMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl2DefaultMetricLen;
		rval = (u_char *) StorageTmp->linkageISISl2DefaultMetric;
		break;
	case (u_char) LINKAGEISISL2DELAYMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl2DelayMetricLen;
		rval = (u_char *) StorageTmp->linkageISISl2DelayMetric;
		break;
	case (u_char) LINKAGEISISL2EXPENSEMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl2ExpenseMetricLen;
		rval = (u_char *) StorageTmp->linkageISISl2ExpenseMetric;
		break;
	case (u_char) LINKAGEISISL2ERRORMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl2ErrorMetricLen;
		rval = (u_char *) StorageTmp->linkageISISl2ErrorMetric;
		break;
	case (u_char) LINKAGEISISMANUALL2ONLYMODE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISmanualL2OnlyMode);
		rval = (u_char *) &StorageTmp->linkageISISmanualL2OnlyMode;
		break;
	case (u_char) LINKAGEISISL2INTERMEDIATESYSTEMPRIORITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl2IntermediateSystemPriorityLen;
		rval = (u_char *) StorageTmp->linkageISISl2IntermediateSystemPriority;
		break;
	case (u_char) LINKAGEISISL2CIRCUITID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl2CircuitIDLen;
		rval = (u_char *) StorageTmp->linkageISISl2CircuitID;
		break;
	case (u_char) LINKAGEISISL2DESIGNATEDINTERMEDIATESYSTEM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->linkageISISl2DesignatedIntermediateSystemLen;
		rval = (u_char *) StorageTmp->linkageISISl2DesignatedIntermediateSystem;
		break;
	case (u_char) LINKAGEISISLANL2DESIGNATEDINTERMEDITESYSTEMCHANGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges);
		rval = (u_char *) &StorageTmp->linkageISISlanL2DesignatedIntermediteSystemChanges;
		break;
	case (u_char) LINKAGEROWSTATUS:	/* Create */
		*write_method = write_linkageRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->linkageRowStatus);
		rval = (u_char *) &StorageTmp->linkageRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_cONSTable_row(struct cONSTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the cONSTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct cONSTable_data *
refresh_cONSTable_row(struct cONSTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->cONSTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->cONSTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_cONSTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the cONSTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_cONSTable(int force)
{
	if (!force && cONSTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	cONSTable_refresh = 0;
}

/**
 * @fn u_char *var_cONSTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in cONSTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_cONSTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct cONSTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_cONSTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_cONSTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(cONSTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_cONSTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) CONSADMINISTRATIVESTATE:	/* Create */
		*write_method = write_cONSAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cONSAdministrativeState);
		rval = (u_char *) &StorageTmp->cONSAdministrativeState;
		break;
	case (u_char) CONSOPERATIONALSYSTEMTYPE:	/* Create */
		*write_method = write_cONSOperationalSystemType;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->cONSOperationalSystemTypeLen;
		rval = (u_char *) StorageTmp->cONSOperationalSystemType;
		break;
	case (u_char) CONSROWSTATUS:	/* Create */
		*write_method = write_cONSRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->cONSRowStatus);
		rval = (u_char *) &StorageTmp->cONSRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_networkConnectionTable_row(struct networkConnectionTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the networkConnectionTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct networkConnectionTable_data *
refresh_networkConnectionTable_row(struct networkConnectionTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->networkConnectionTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->networkConnectionTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_networkConnectionTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the networkConnectionTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_networkConnectionTable(int force)
{
	if (!force && networkConnectionTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	networkConnectionTable_refresh = 0;
}

/**
 * @fn u_char *var_networkConnectionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in networkConnectionTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_networkConnectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct networkConnectionTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_networkConnectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_networkConnectionTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(networkConnectionTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_networkConnectionTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) NETWORKCONNECTIONLOCALNSAPMO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->networkConnectionLocalNSAPMOLen;
		rval = (u_char *) StorageTmp->networkConnectionLocalNSAPMO;
		break;
	case (u_char) NETWORKCONNECTIONREMOTENSAPADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->networkConnectionRemoteNSAPAddressLen;
		rval = (u_char *) StorageTmp->networkConnectionRemoteNSAPAddress;
		break;
	case (u_char) NETWORKCONNECTIONROWSTATUS:	/* Create */
		*write_method = write_networkConnectionRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->networkConnectionRowStatus);
		rval = (u_char *) &StorageTmp->networkConnectionRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_x25PLETable_row(struct x25PLETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the x25PLETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct x25PLETable_data *
refresh_x25PLETable_row(struct x25PLETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->x25PLETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->x25PLETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_x25PLETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the x25PLETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLETable(int force)
{
	if (!force && x25PLETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	x25PLETable_refresh = 0;
}

/**
 * @fn u_char *var_x25PLETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_x25PLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_x25PLETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(x25PLETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_x25PLETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) X25PLEOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEoperationalState);
		rval = (u_char *) &StorageTmp->x25PLEoperationalState;
		break;
	case (u_char) X25PLEADMINISTRATIVESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEadministrativeState);
		rval = (u_char *) &StorageTmp->x25PLEadministrativeState;
		break;
	case (u_char) X25PLEPROTOCOLVERSIONSUPPORTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEprotocolVersionSupportedLen;
		rval = (u_char *) StorageTmp->x25PLEprotocolVersionSupported;
		break;
	case (u_char) X25PLELOCALDTEADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLElocalDTEAddressLen;
		rval = (u_char *) StorageTmp->x25PLElocalDTEAddress;
		break;
	case (u_char) X25PLEMODE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEMode);
		rval = (u_char *) &StorageTmp->x25PLEMode;
		break;
	case (u_char) X25PLEDEFAULTTHROUGHPUTCLASSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEdefaultThroughputClassesLen;
		rval = (u_char *) StorageTmp->x25PLEdefaultThroughputClasses;
		break;
	case (u_char) X25PLEFLOWCONTROLPARAMETERNEGOTIATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEflowControlParameterNegotiationLen;
		rval = (u_char *) StorageTmp->x25PLEflowControlParameterNegotiation;
		break;
	case (u_char) X25PLEDEFAULTPACKAGESIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEdefaultPackageSizesLen;
		rval = (u_char *) StorageTmp->x25PLEdefaultPackageSizes;
		break;
	case (u_char) X25PLETHROUGHPUTCLASSNEGOTIATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEthroughputClassNegotiationLen;
		rval = (u_char *) StorageTmp->x25PLEthroughputClassNegotiation;
		break;
	case (u_char) X25PLESNSERVICEPROVIDER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEsNserviceProviderLen;
		rval = (u_char *) StorageTmp->x25PLEsNserviceProvider;
		break;
	case (u_char) X25PLESNSAP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEsNsAPLen;
		rval = (u_char *) StorageTmp->x25PLEsNsAP;
		break;
	case (u_char) X25PELOGICALCHANNELASSIGNMENTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PElogicalChannelAssignmentsLen;
		rval = (u_char *) StorageTmp->x25PElogicalChannelAssignments;
		break;
	case (u_char) X25PLEINTERFACEMODE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEinterfaceMode);
		rval = (u_char *) &StorageTmp->x25PLEinterfaceMode;
		break;
	case (u_char) X25PLEDEFAULTTHROUGHPUTCLASS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEdefaultThroughputClassLen;
		rval = (u_char *) StorageTmp->x25PLEdefaultThroughputClass;
		break;
	case (u_char) X25PLEFLOWCONTROLNEGOTIATIONPERMITTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEflowControlNegotiationPermittedLen;
		rval = (u_char *) StorageTmp->x25PLEflowControlNegotiationPermitted;
		break;
	case (u_char) X25PLECALLDEFLECTIONSUBSCRIPTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEcallDeflectionSubscription);
		rval = (u_char *) &StorageTmp->x25PLEcallDeflectionSubscription;
		break;
	case (u_char) X25PLEMAXACTIVECIRCUITS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEmaxActiveCircuitsLen;
		rval = (u_char *) StorageTmp->x25PLEmaxActiveCircuits;
		break;
	case (u_char) X25PLERESTARTTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLErestartTimeLen;
		rval = (u_char *) StorageTmp->x25PLErestartTime;
		break;
	case (u_char) X25PLEDEFAULTPACKETSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEdefaultPacketSizeLen;
		rval = (u_char *) StorageTmp->x25PLEdefaultPacketSize;
		break;
	case (u_char) X25PLEDEFAULTWINDOWSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEdefaultWindowSizeLen;
		rval = (u_char *) StorageTmp->x25PLEdefaultWindowSize;
		break;
	case (u_char) X25PLEMINIMUMRECALLTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEminimumRecallTimerLen;
		rval = (u_char *) StorageTmp->x25PLEminimumRecallTimer;
		break;
	case (u_char) X25PLERESTARTCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLErestartCountLen;
		rval = (u_char *) StorageTmp->x25PLErestartCount;
		break;
	case (u_char) X25PLESN_SERVICEPROVIDER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEsN_ServiceProviderLen;
		rval = (u_char *) StorageTmp->x25PLEsN_ServiceProvider;
		break;
	case (u_char) X25PLESN_SA_P:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEsN_SA_PLen;
		rval = (u_char *) StorageTmp->x25PLEsN_SA_P;
		break;
	case (u_char) X25PLELOGICALCHANNELASSIGNMENTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLElogicalChannelAssignmentsLen;
		rval = (u_char *) StorageTmp->x25PLElogicalChannelAssignments;
		break;
	case (u_char) X25PLEPACKETSEQUENCING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEpacketSequencingLen;
		rval = (u_char *) StorageTmp->x25PLEpacketSequencing;
		break;
	case (u_char) X25PLEOCTETSSENTCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEoctetsSentCounterLen;
		rval = (u_char *) StorageTmp->x25PLEoctetsSentCounter;
		break;
	case (u_char) X25PLEOCTETSRECEIVEDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEoctetsReceivedCounterLen;
		rval = (u_char *) StorageTmp->x25PLEoctetsReceivedCounter;
		break;
	case (u_char) X25PLEDATAPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEdataPacketsSentLen;
		rval = (u_char *) StorageTmp->x25PLEdataPacketsSent;
		break;
	case (u_char) X25PLEDATAPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEdataPacketsReceivedLen;
		rval = (u_char *) StorageTmp->x25PLEdataPacketsReceived;
		break;
	case (u_char) X25PLECALLATTEMPTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEcallAttemptsLen;
		rval = (u_char *) StorageTmp->x25PLEcallAttempts;
		break;
	case (u_char) X25PLECALLSCONNECTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEcallsConnectedLen;
		rval = (u_char *) StorageTmp->x25PLEcallsConnected;
		break;
	case (u_char) X25PLEPROVIDERINITIATEDDISCONNECTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEproviderInitiatedDisconnects);
		rval = (u_char *) &StorageTmp->x25PLEproviderInitiatedDisconnects;
		break;
	case (u_char) X25PLECALLTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEcallTimeoutsLen;
		rval = (u_char *) StorageTmp->x25PLEcallTimeouts;
		break;
	case (u_char) X25PLECLEARTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEclearTimeoutsLen;
		rval = (u_char *) StorageTmp->x25PLEclearTimeouts;
		break;
	case (u_char) X25PLEREMOTELYINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEremotelyInitiatedResetsLen;
		rval = (u_char *) StorageTmp->x25PLEremotelyInitiatedResets;
		break;
	case (u_char) X25PLEDATARETRANSMISSIONTIMEREXPIRIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEdataRetransmissionTimerExpiriesLen;
		rval = (u_char *) StorageTmp->x25PLEdataRetransmissionTimerExpiries;
		break;
	case (u_char) X25PLEPROVIDERINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEproviderInitiatedResetsLen;
		rval = (u_char *) StorageTmp->x25PLEproviderInitiatedResets;
		break;
	case (u_char) X25PLERESETTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEresetTimeoutsLen;
		rval = (u_char *) StorageTmp->x25PLEresetTimeouts;
		break;
	case (u_char) X25PLEREMOTELYINITIATEDRESTARTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEremotelyInitiatedRestartsLen;
		rval = (u_char *) StorageTmp->x25PLEremotelyInitiatedRestarts;
		break;
	case (u_char) X25PLERESTARTCOUNTSEXCEEDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLErestartCountsExceededLen;
		rval = (u_char *) StorageTmp->x25PLErestartCountsExceeded;
		break;
	case (u_char) X25PLEPROTOCOLERRORSDETECTEDLOCALLY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEprotocolErrorsDetectedLocallyLen;
		rval = (u_char *) StorageTmp->x25PLEprotocolErrorsDetectedLocally;
		break;
	case (u_char) X25PLEPROTOCOLERRORSACCUSEDOF:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEprotocolErrorsAccusedOfLen;
		rval = (u_char *) StorageTmp->x25PLEprotocolErrorsAccusedOf;
		break;
	case (u_char) X25PLECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEcallEstablishmentRetryCountsExceededLen;
		rval = (u_char *) StorageTmp->x25PLEcallEstablishmentRetryCountsExceeded;
		break;
	case (u_char) X25PLECLEARCOUNTSEXCEEDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEclearCountsExceededLen;
		rval = (u_char *) StorageTmp->x25PLEclearCountsExceeded;
		break;
	case (u_char) X25PLEPLECLIENTMONAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEpLEClientMONameLen;
		rval = (u_char *) StorageTmp->x25PLEpLEClientMOName;
		break;
	case (u_char) X25PLEREGISTRATIONREQUESTTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEregistrationRequestTimeLen;
		rval = (u_char *) StorageTmp->x25PLEregistrationRequestTime;
		break;
	case (u_char) X25PLEREGISTRATIONREQUESTCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEregistrationRequestCountLen;
		rval = (u_char *) StorageTmp->x25PLEregistrationRequestCount;
		break;
	case (u_char) X25PLEREGISTRATIONPERMITTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEregistrationPermitted);
		rval = (u_char *) &StorageTmp->x25PLEregistrationPermitted;
		break;
	case (u_char) X25PLEROWSTATUS:	/* Create */
		*write_method = write_x25PLERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLERowStatus);
		rval = (u_char *) &StorageTmp->x25PLERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_x25PLE_DTETable_row(struct x25PLE_DTETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the x25PLE_DTETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct x25PLE_DTETable_data *
refresh_x25PLE_DTETable_row(struct x25PLE_DTETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->x25PLE_DTETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->x25PLE_DTETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_x25PLE_DTETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the x25PLE_DTETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLE_DTETable(int force)
{
	if (!force && x25PLE_DTETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	x25PLE_DTETable_refresh = 0;
}

/**
 * @fn u_char *var_x25PLE_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLE_DTETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLE_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLE_DTETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_x25PLE_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_x25PLE_DTETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(x25PLE_DTETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_x25PLE_DTETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) X25PLE_DTECALLDEFLECTIONSUBSCRIPTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallDeflectionSubscription);
		rval = (u_char *) &StorageTmp->x25PLE_DTEcallDeflectionSubscription;
		break;
	case (u_char) X25PLE_DTECALLREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEcallRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEcallRequestResponseTimer;
		break;
	case (u_char) X25PLE_DTEEXTENDEDPACKETSEQUENCENUMBERING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEextendedPacketSequenceNumberingLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEextendedPacketSequenceNumbering;
		break;
	case (u_char) X25PLE_DTEMAXACTIVECIRCUITS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEmaxActiveCircuitsLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEmaxActiveCircuits;
		break;
	case (u_char) X25PLE_DTEMINIMUMRECALLTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEminimumRecallTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEminimumRecallTimer;
		break;
	case (u_char) X25PLE_DTERESETREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEresetRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEresetRequestResponseTimer;
		break;
	case (u_char) X25PLE_DTERESTARTREQUESTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTErestartRequestRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLE_DTErestartRequestRetransmissionCount;
		break;
	case (u_char) X25PLE_DTERESTARTREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTErestartRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTErestartRequestResponseTimer;
		break;
	case (u_char) X25PLE_DTECLEARREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEclearRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEclearRequestResponseTimer;
		break;
	case (u_char) X25PLE_DTEINTERRUPTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEinterruptResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEinterruptResponseTimer;
		break;
	case (u_char) X25PLE_DTERESETREQUESTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEresetRequestRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEresetRequestRetransmissionCount;
		break;
	case (u_char) X25PLE_DTECLEARREQUESTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEclearRequestRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEclearRequestRetransmissionCount;
		break;
	case (u_char) X25PLE_DTECALLATTEMPTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallAttempts);
		rval = (u_char *) &StorageTmp->x25PLE_DTEcallAttempts;
		break;
	case (u_char) X25PLE_DTEPROTOCOLERRORSDETECTEDLOCALLY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEprotocolErrorsDetectedLocally);
		rval = (u_char *) &StorageTmp->x25PLE_DTEprotocolErrorsDetectedLocally;
		break;
	case (u_char) X25PLE_DTEPROTOCOLERRORSACCUSEDOF:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEprotocolErrorsAccusedOf);
		rval = (u_char *) &StorageTmp->x25PLE_DTEprotocolErrorsAccusedOf;
		break;
	case (u_char) X25PLE_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallEstablishmentRetryCountsExceeded);
		rval = (u_char *) &StorageTmp->x25PLE_DTEcallEstablishmentRetryCountsExceeded;
		break;
	case (u_char) X25PLE_DTEOCTETSRECEIVEDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEoctetsReceivedCounter);
		rval = (u_char *) &StorageTmp->x25PLE_DTEoctetsReceivedCounter;
		break;
	case (u_char) X25PLE_DTEOCTETSSENTCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEoctetsSentCounter);
		rval = (u_char *) &StorageTmp->x25PLE_DTEoctetsSentCounter;
		break;
	case (u_char) X25PLE_DTECALLTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallTimeouts);
		rval = (u_char *) &StorageTmp->x25PLE_DTEcallTimeouts;
		break;
	case (u_char) X25PLE_DTECALLSCONNECTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEcallsConnected);
		rval = (u_char *) &StorageTmp->x25PLE_DTEcallsConnected;
		break;
	case (u_char) X25PLE_DTECLEARCOUNTSEXCEEDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEclearCountsExceeded);
		rval = (u_char *) &StorageTmp->x25PLE_DTEclearCountsExceeded;
		break;
	case (u_char) X25PLE_DTECLEARTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEclearTimeouts);
		rval = (u_char *) &StorageTmp->x25PLE_DTEclearTimeouts;
		break;
	case (u_char) X25PLE_DTEDATAPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEdataPacketsReceived);
		rval = (u_char *) &StorageTmp->x25PLE_DTEdataPacketsReceived;
		break;
	case (u_char) X25PLE_DTEDATAPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEdataPacketsSent);
		rval = (u_char *) &StorageTmp->x25PLE_DTEdataPacketsSent;
		break;
	case (u_char) X25PLE_DTEDATARETRANSMISSIONTIMEREXPIRIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEdataRetransmissionTimerExpiries);
		rval = (u_char *) &StorageTmp->x25PLE_DTEdataRetransmissionTimerExpiries;
		break;
	case (u_char) X25PLE_DTEPROVIDERINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEproviderInitiatedResets);
		rval = (u_char *) &StorageTmp->x25PLE_DTEproviderInitiatedResets;
		break;
	case (u_char) X25PLE_DTEPROVIDERINITIATEDDISCONNECTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEproviderInitiatedDisconnects);
		rval = (u_char *) &StorageTmp->x25PLE_DTEproviderInitiatedDisconnects;
		break;
	case (u_char) X25PLE_DTEREMOTELYINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEremotelyInitiatedResets);
		rval = (u_char *) &StorageTmp->x25PLE_DTEremotelyInitiatedResets;
		break;
	case (u_char) X25PLE_DTEREMOTELYINITIATEDRESTARTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEremotelyInitiatedRestarts);
		rval = (u_char *) &StorageTmp->x25PLE_DTEremotelyInitiatedRestarts;
		break;
	case (u_char) X25PLE_DTERESETTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEresetTimeouts);
		rval = (u_char *) &StorageTmp->x25PLE_DTEresetTimeouts;
		break;
	case (u_char) X25PLE_DTERESTARTCOUNTSEXCEEDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTErestartCountsExceeded);
		rval = (u_char *) &StorageTmp->x25PLE_DTErestartCountsExceeded;
		break;
	case (u_char) X25PLE_DTEWINDOWSTATUSTRANSMISSIONTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEwindowStatusTransmissionTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEwindowStatusTransmissionTimer;
		break;
	case (u_char) X25PLE_DTEWINDOWROTATIONTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEwindowRotationTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEwindowRotationTimer;
		break;
	case (u_char) X25PLE_DTEDATAPACKETRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEdataPacketRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEdataPacketRetransmissionCount;
		break;
	case (u_char) X25PLE_DTEREJECTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTErejectResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTErejectResponseTimer;
		break;
	case (u_char) X25PLE_DTEREJECTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTErejectRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLE_DTErejectRetransmissionCount;
		break;
	case (u_char) X25PLE_DTEREGISTRATIONREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEregistrationRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEregistrationRequestResponseTimer;
		break;
	case (u_char) X25PLE_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLE_DTEregistrationRequestRetransmissionCount;
		break;
	case (u_char) X25PLE_DTEREGISTRATIONPERMITTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DTEregistrationPermitted);
		rval = (u_char *) &StorageTmp->x25PLE_DTEregistrationPermitted;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_x25PLE_DCETable_row(struct x25PLE_DCETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the x25PLE_DCETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct x25PLE_DCETable_data *
refresh_x25PLE_DCETable_row(struct x25PLE_DCETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->x25PLE_DCETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->x25PLE_DCETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_x25PLE_DCETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the x25PLE_DCETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLE_DCETable(int force)
{
	if (!force && x25PLE_DCETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	x25PLE_DCETable_refresh = 0;
}

/**
 * @fn u_char *var_x25PLE_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLE_DCETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLE_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLE_DCETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_x25PLE_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_x25PLE_DCETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(x25PLE_DCETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_x25PLE_DCETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) X25PLE_DCECALLATTEMPTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEcallAttempts);
		rval = (u_char *) &StorageTmp->x25PLE_DCEcallAttempts;
		break;
	case (u_char) X25PLE_DCECALLSCONNECTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEcallsConnected);
		rval = (u_char *) &StorageTmp->x25PLE_DCEcallsConnected;
		break;
	case (u_char) X25PLE_DCECUG:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEcUG);
		rval = (u_char *) &StorageTmp->x25PLE_DCEcUG;
		break;
	case (u_char) X25PLE_DCEFASTSELECTACCEPTANCE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEfastSelectAcceptance);
		rval = (u_char *) &StorageTmp->x25PLE_DCEfastSelectAcceptance;
		break;
	case (u_char) X25PLE_DCEINCOMINGCALLSBARRED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEincomingCallsBarred);
		rval = (u_char *) &StorageTmp->x25PLE_DCEincomingCallsBarred;
		break;
	case (u_char) X25PLE_DCEONEWAYLOGICALCHANNELOUTGOING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEoneWayLogicalChannelOutgoing);
		rval = (u_char *) &StorageTmp->x25PLE_DCEoneWayLogicalChannelOutgoing;
		break;
	case (u_char) X25PLE_DCEOUTGOINGCALLSBARRED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEoutgoingCallsBarred);
		rval = (u_char *) &StorageTmp->x25PLE_DCEoutgoingCallsBarred;
		break;
	case (u_char) X25PLE_DCEDATAPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEdataPacketsReceived);
		rval = (u_char *) &StorageTmp->x25PLE_DCEdataPacketsReceived;
		break;
	case (u_char) X25PLE_DCEDATAPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEdataPacketsSent);
		rval = (u_char *) &StorageTmp->x25PLE_DCEdataPacketsSent;
		break;
	case (u_char) X25PLE_DCEINTERRUPTPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEinterruptPacketsReceived);
		rval = (u_char *) &StorageTmp->x25PLE_DCEinterruptPacketsReceived;
		break;
	case (u_char) X25PLE_DCEINTERRUPTPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEinterruptPacketsSent);
		rval = (u_char *) &StorageTmp->x25PLE_DCEinterruptPacketsSent;
		break;
	case (u_char) X25PLE_DCEINTERRUPTTIMEREXPIRIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEinterruptTimerExpiries);
		rval = (u_char *) &StorageTmp->x25PLE_DCEinterruptTimerExpiries;
		break;
	case (u_char) X25PLE_DCEOCTETSRECEIVEDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEoctetsReceivedCounter);
		rval = (u_char *) &StorageTmp->x25PLE_DCEoctetsReceivedCounter;
		break;
	case (u_char) X25PLE_DCEOCTETSSENTCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEoctetsSentCounter);
		rval = (u_char *) &StorageTmp->x25PLE_DCEoctetsSentCounter;
		break;
	case (u_char) X25PLE_DCEPROVIDERINITIATEDDISCONNECTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEproviderInitiatedDisconnects);
		rval = (u_char *) &StorageTmp->x25PLE_DCEproviderInitiatedDisconnects;
		break;
	case (u_char) X25PLE_DCEPROVIDERINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEproviderInitiatedResets);
		rval = (u_char *) &StorageTmp->x25PLE_DCEproviderInitiatedResets;
		break;
	case (u_char) X25PLE_DCEREMOTELYINITIATEDRESTARTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEremotelyInitiatedRestarts);
		rval = (u_char *) &StorageTmp->x25PLE_DCEremotelyInitiatedRestarts;
		break;
	case (u_char) X25PLE_DCEREMOTELYINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEremotelyInitiatedResets);
		rval = (u_char *) &StorageTmp->x25PLE_DCEremotelyInitiatedResets;
		break;
	case (u_char) X25PLE_DCERESETTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEresetTimeouts);
		rval = (u_char *) &StorageTmp->x25PLE_DCEresetTimeouts;
		break;
	case (u_char) X25PLE_DCEX25SEGMENTSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEx25SegmentsReceived);
		rval = (u_char *) &StorageTmp->x25PLE_DCEx25SegmentsReceived;
		break;
	case (u_char) X25PLE_DCEX25SEGMENTSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEx25SegmentsSent);
		rval = (u_char *) &StorageTmp->x25PLE_DCEx25SegmentsSent;
		break;
	case (u_char) X25PLE_DCEBILATERALCUG:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEbilateralCUG);
		rval = (u_char *) &StorageTmp->x25PLE_DCEbilateralCUG;
		break;
	case (u_char) X25PLE_DCEBILATERALCUGWITHOUTGOINGACCESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEbilateralCUGWithOutgoingAccess);
		rval = (u_char *) &StorageTmp->x25PLE_DCEbilateralCUGWithOutgoingAccess;
		break;
	case (u_char) X25PLE_DCECALLDEFLECTIONSUBSCRIPTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEcallDeflectionSubscription);
		rval = (u_char *) &StorageTmp->x25PLE_DCEcallDeflectionSubscription;
		break;
	case (u_char) X25PLE_DCECALLREDIRECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEcallRedirection);
		rval = (u_char *) &StorageTmp->x25PLE_DCEcallRedirection;
		break;
	case (u_char) X25PLE_DCECHARGINGINFORMATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEchargingInformation);
		rval = (u_char *) &StorageTmp->x25PLE_DCEchargingInformation;
		break;
	case (u_char) X25PLE_DCECUGWITHINCOMINGACCESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEcUGWithIncomingAccess);
		rval = (u_char *) &StorageTmp->x25PLE_DCEcUGWithIncomingAccess;
		break;
	case (u_char) X25PLE_DCECUGWITHOUTGOINGACCESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEcUGWithOutgoingAccess);
		rval = (u_char *) &StorageTmp->x25PLE_DCEcUGWithOutgoingAccess;
		break;
	case (u_char) X25PLE_DCEDBITMODIFICATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEdBitModification);
		rval = (u_char *) &StorageTmp->x25PLE_DCEdBitModification;
		break;
	case (u_char) X25PLE_DCEDEFAULTTHROUGHPUTCLASSESASSIGNMENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignmentLen;
		rval = (u_char *) StorageTmp->x25PLE_DCEdefaultThroughputClassesAssignment;
		break;
	case (u_char) X25PLE_DCEEXTENDEDPACKETSEQUENCENUMBERING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DCEextendedPacketSequenceNumberingLen;
		rval = (u_char *) StorageTmp->x25PLE_DCEextendedPacketSequenceNumbering;
		break;
	case (u_char) X25PLE_DCEHUNTGROUP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEhuntGroup);
		rval = (u_char *) &StorageTmp->x25PLE_DCEhuntGroup;
		break;
	case (u_char) X25PLE_DCEINCOMINGCALLBARREDWITHINCUG:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEincomingCallBarredWithinCUG);
		rval = (u_char *) &StorageTmp->x25PLE_DCEincomingCallBarredWithinCUG;
		break;
	case (u_char) X25PLE_DCELOCALCHARGINGPREVENTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCElocalChargingPrevention);
		rval = (u_char *) &StorageTmp->x25PLE_DCElocalChargingPrevention;
		break;
	case (u_char) X25PLE_DCENONSTANDARDDEFAULTPACKETSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizesLen;
		rval = (u_char *) StorageTmp->x25PLE_DCEnonStandardDefaultPacketSizes;
		break;
	case (u_char) X25PLE_DCENONSTANDARDDEFAULTWINDOWSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizesLen;
		rval = (u_char *) StorageTmp->x25PLE_DCEnonStandardDefaultWindowSizes;
		break;
	case (u_char) X25PLE_DCENUIOVERRIDE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEnUIOverride);
		rval = (u_char *) &StorageTmp->x25PLE_DCEnUIOverride;
		break;
	case (u_char) X25PLE_DCENUISUBSCRIPTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEnUISubscription);
		rval = (u_char *) &StorageTmp->x25PLE_DCEnUISubscription;
		break;
	case (u_char) X25PLE_DCEONEWAYLOGICALCHANNELINCOMING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEoneWayLogicalChannelIncoming);
		rval = (u_char *) &StorageTmp->x25PLE_DCEoneWayLogicalChannelIncoming;
		break;
	case (u_char) X25PLE_DCEONLINEFACILITYREGISTRATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEonlineFacilityRegistration);
		rval = (u_char *) &StorageTmp->x25PLE_DCEonlineFacilityRegistration;
		break;
	case (u_char) X25PLE_DCEOUTGOINGCALLBARREDWITHINCUG:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEoutgoingCallBarredWithinCUG);
		rval = (u_char *) &StorageTmp->x25PLE_DCEoutgoingCallBarredWithinCUG;
		break;
	case (u_char) X25PLE_DCEPACKETRETRANSMISSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEpacketRetransmission);
		rval = (u_char *) &StorageTmp->x25PLE_DCEpacketRetransmission;
		break;
	case (u_char) X25PLE_DCEREVERSECHARGINGACCEPTANCE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEreverseChargingAcceptance);
		rval = (u_char *) &StorageTmp->x25PLE_DCEreverseChargingAcceptance;
		break;
	case (u_char) X25PLE_DCEROASUBSCRIPTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCErOASubscription);
		rval = (u_char *) &StorageTmp->x25PLE_DCErOASubscription;
		break;
	case (u_char) X25PLE_DCECLEARINDICATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLE_DCEclearIndication);
		rval = (u_char *) &StorageTmp->x25PLE_DCEclearIndication;
		break;
	case (u_char) X25PLE_DCEINCOMINGCALL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DCEincomingCallLen;
		rval = (u_char *) StorageTmp->x25PLE_DCEincomingCall;
		break;
	case (u_char) X25PLE_DCERESETINDICATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DCEresetIndicationLen;
		rval = (u_char *) StorageTmp->x25PLE_DCEresetIndication;
		break;
	case (u_char) X25PLE_DCERESTARTINDICATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLE_DCErestartIndicationLen;
		rval = (u_char *) StorageTmp->x25PLE_DCErestartIndication;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_x25PLEIVMOTable_row(struct x25PLEIVMOTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the x25PLEIVMOTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct x25PLEIVMOTable_data *
refresh_x25PLEIVMOTable_row(struct x25PLEIVMOTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->x25PLEIVMOTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->x25PLEIVMOTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_x25PLEIVMOTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the x25PLEIVMOTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMOTable(int force)
{
	if (!force && x25PLEIVMOTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	x25PLEIVMOTable_refresh = 0;
}

/**
 * @fn u_char *var_x25PLEIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMOTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLEIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_x25PLEIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_x25PLEIVMOTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(x25PLEIVMOTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_x25PLEIVMOTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) X25PLEIVMOLOCALDTEADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOlocalDTEAddressLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOlocalDTEAddress;
		break;
	case (u_char) X25PLEIVMOLOGICALCHANNELASSIGNMENTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOlogicalChannelAssignmentsLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOlogicalChannelAssignments;
		break;
	case (u_char) X25PLEIVMOSN_SERVICEPROVIDER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOsN_ServiceProviderLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOsN_ServiceProvider;
		break;
	case (u_char) X25PLEIVMODEFAULTPACKETSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOdefaultPacketSizesLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOdefaultPacketSizes;
		break;
	case (u_char) X25PLEIVMODEFAULTTHROUGHPUTCLASSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOdefaultThroughputClassesLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOdefaultThroughputClasses;
		break;
	case (u_char) X25PLEIVMODEFAULTWINDOWSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOdefaultWindowSizesLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOdefaultWindowSizes;
		break;
	case (u_char) X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOflowControlParameterNegotiationLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOflowControlParameterNegotiation;
		break;
	case (u_char) X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOthroughputClassNegotiationLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOthroughputClassNegotiation;
		break;
	case (u_char) X25PLEIVMOX25PLEMODE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOx25PLEModeLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOx25PLEMode;
		break;
	case (u_char) X25PLEIVMOINTERFACEMODE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMOinterfaceMode);
		rval = (u_char *) &StorageTmp->x25PLEIVMOinterfaceMode;
		break;
	case (u_char) X25PLEIVMODEFAULTTHROUGHPUTCLASS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOdefaultThroughputClassLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOdefaultThroughputClass;
		break;
	case (u_char) X25PLEIVMOFLOWCONTROLNEGOTIATIONPERMITTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOflowControlNegotiationPermittedLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOflowControlNegotiationPermitted;
		break;
	case (u_char) X25PLEIVMOCALLDEFLECTIONSUBSCRIPTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMOcallDeflectionSubscription);
		rval = (u_char *) &StorageTmp->x25PLEIVMOcallDeflectionSubscription;
		break;
	case (u_char) X25PLEIVMOMAXACTIVECIRCUITS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOmaxActiveCircuitsLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOmaxActiveCircuits;
		break;
	case (u_char) X25PLEIVMORESTARTTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOrestartTimeLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOrestartTime;
		break;
	case (u_char) X25PLEIVMODEFAULTPACKETSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOdefaultPacketSizeLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOdefaultPacketSize;
		break;
	case (u_char) X25PLEIVMODEFAULTWINDOWSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOdefaultWindowSizeLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOdefaultWindowSize;
		break;
	case (u_char) X25PLEIVMOMINIMUMRECALLTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOminimumRecallTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOminimumRecallTimer;
		break;
	case (u_char) X25PLEIVMORESTARTCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOrestartCountLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOrestartCount;
		break;
	case (u_char) X25PLEIVMOPACKETSEQUENCING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOpacketSequencingLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOpacketSequencing;
		break;
	case (u_char) X25PLEIVMOREGISTRATIONREQUESTTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOregistrationRequestTimeLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOregistrationRequestTime;
		break;
	case (u_char) X25PLEIVMOREGISTRATIONREQUESTCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMOregistrationRequestCountLen;
		rval = (u_char *) StorageTmp->x25PLEIVMOregistrationRequestCount;
		break;
	case (u_char) X25PLEIVMOREGISTRATIONPERMITTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMOregistrationPermitted);
		rval = (u_char *) &StorageTmp->x25PLEIVMOregistrationPermitted;
		break;
	case (u_char) X25PLEIVMOROWSTATUS:	/* Create */
		*write_method = write_x25PLEIVMORowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMORowStatus);
		rval = (u_char *) &StorageTmp->x25PLEIVMORowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_x25PLEIVMO_DTETable_row(struct x25PLEIVMO_DTETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the x25PLEIVMO_DTETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct x25PLEIVMO_DTETable_data *
refresh_x25PLEIVMO_DTETable_row(struct x25PLEIVMO_DTETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->x25PLEIVMO_DTETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->x25PLEIVMO_DTETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_x25PLEIVMO_DTETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the x25PLEIVMO_DTETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMO_DTETable(int force)
{
	if (!force && x25PLEIVMO_DTETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	x25PLEIVMO_DTETable_refresh = 0;
}

/**
 * @fn u_char *var_x25PLEIVMO_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMO_DTETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLEIVMO_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLEIVMO_DTETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_x25PLEIVMO_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_x25PLEIVMO_DTETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(x25PLEIVMO_DTETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_x25PLEIVMO_DTETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) X25PLEIVMO_DTECALLDEFLECTIONSUBSCRIPTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEcallDeflectionSubscription);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEcallDeflectionSubscription;
		break;
	case (u_char) X25PLEIVMO_DTECALLREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEcallRequestResponseTimer;
		break;
	case (u_char) X25PLEIVMO_DTEEXTENDEDPACKETSEQUENCENUMBERING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumberingLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEextendedPacketSequenceNumbering;
		break;
	case (u_char) X25PLEIVMO_DTEMAXACTIVECIRCUITS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEmaxActiveCircuitsLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEmaxActiveCircuits;
		break;
	case (u_char) X25PLEIVMO_DTEMINIMUMRECALLTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEminimumRecallTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEminimumRecallTimer;
		break;
	case (u_char) X25PLEIVMO_DTERESETREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEresetRequestResponseTimer;
		break;
	case (u_char) X25PLEIVMO_DTERESTARTREQUESTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTErestartRequestRetransmissionCount;
		break;
	case (u_char) X25PLEIVMO_DTERESTARTREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTErestartRequestResponseTimer;
		break;
	case (u_char) X25PLEIVMO_DTECLEARREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEclearRequestResponseTimer;
		break;
	case (u_char) X25PLEIVMO_DTEINTERRUPTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEinterruptResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEinterruptResponseTimer;
		break;
	case (u_char) X25PLEIVMO_DTERESETREQUESTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEresetRequestRetransmissionCount;
		break;
	case (u_char) X25PLEIVMO_DTECLEARREQUESTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEclearRequestRetransmissionCount;
		break;
	case (u_char) X25PLEIVMO_DTECALLATTEMPTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEcallAttemptsLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEcallAttempts;
		break;
	case (u_char) X25PLEIVMO_DTEPROTOCOLERRORSDETECTEDLOCALLY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocallyLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEprotocolErrorsDetectedLocally;
		break;
	case (u_char) X25PLEIVMO_DTEPROTOCOLERRORSACCUSEDOF:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOfLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEprotocolErrorsAccusedOf;
		break;
	case (u_char) X25PLEIVMO_DTECALLESTABLISHMENTRETRYCOUNTSEXCEEDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceededLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEcallEstablishmentRetryCountsExceeded;
		break;
	case (u_char) X25PLEIVMO_DTEOCTETSRECEIVEDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEoctetsReceivedCounter);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEoctetsReceivedCounter;
		break;
	case (u_char) X25PLEIVMO_DTEOCTETSSENTCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEoctetsSentCounter);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEoctetsSentCounter;
		break;
	case (u_char) X25PLEIVMO_DTECALLTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEcallTimeouts);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEcallTimeouts;
		break;
	case (u_char) X25PLEIVMO_DTECALLSCONNECTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEcallsConnected);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEcallsConnected;
		break;
	case (u_char) X25PLEIVMO_DTECLEARCOUNTSEXCEEDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEclearCountsExceeded);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEclearCountsExceeded;
		break;
	case (u_char) X25PLEIVMO_DTECLEARTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEclearTimeouts);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEclearTimeouts;
		break;
	case (u_char) X25PLEIVMO_DTEDATAPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEdataPacketsReceived);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEdataPacketsReceived;
		break;
	case (u_char) X25PLEIVMO_DTEDATAPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEdataPacketsSent);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEdataPacketsSent;
		break;
	case (u_char) X25PLEIVMO_DTEDATARETRANSMISSIONTIMEREXPIRIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEdataRetransmissionTimerExpiries);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEdataRetransmissionTimerExpiries;
		break;
	case (u_char) X25PLEIVMO_DTEPROVIDERINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEproviderInitiatedResets);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEproviderInitiatedResets;
		break;
	case (u_char) X25PLEIVMO_DTEPROVIDERINITIATEDDISCONNECTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEproviderInitiatedDisconnects);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEproviderInitiatedDisconnects;
		break;
	case (u_char) X25PLEIVMO_DTEREMOTELYINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEremotelyInitiatedResets);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedResets;
		break;
	case (u_char) X25PLEIVMO_DTEREMOTELYINITIATEDRESTARTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEremotelyInitiatedRestarts);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEremotelyInitiatedRestarts;
		break;
	case (u_char) X25PLEIVMO_DTERESETTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEresetTimeouts);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEresetTimeouts;
		break;
	case (u_char) X25PLEIVMO_DTERESTARTCOUNTSEXCEEDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTErestartCountsExceeded);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTErestartCountsExceeded;
		break;
	case (u_char) X25PLEIVMO_DTEWINDOWSTATUSTRANSMISSIONTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEwindowStatusTransmissionTimer;
		break;
	case (u_char) X25PLEIVMO_DTEWINDOWROTATIONTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEwindowRotationTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEwindowRotationTimer;
		break;
	case (u_char) X25PLEIVMO_DTEDATAPACKETRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEdataPacketRetransmissionCount;
		break;
	case (u_char) X25PLEIVMO_DTEREJECTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTErejectResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTErejectResponseTimer;
		break;
	case (u_char) X25PLEIVMO_DTEREJECTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTErejectRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTErejectRetransmissionCount;
		break;
	case (u_char) X25PLEIVMO_DTEREGISTRATIONREQUESTRESPONSETIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimerLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEregistrationRequestResponseTimer;
		break;
	case (u_char) X25PLEIVMO_DTEREGISTRATIONREQUESTRETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCountLen;
		rval = (u_char *) StorageTmp->x25PLEIVMO_DTEregistrationRequestRetransmissionCount;
		break;
	case (u_char) X25PLEIVMO_DTEREGISTRATIONPERMITTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTEregistrationPermitted);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTEregistrationPermitted;
		break;
	case (u_char) X25PLEIVMO_DTEROWSTATUS:	/* Create */
		*write_method = write_x25PLEIVMO_DTERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DTERowStatus);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DTERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_x25PLEIVMO_DCETable_row(struct x25PLEIVMO_DCETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the x25PLEIVMO_DCETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct x25PLEIVMO_DCETable_data *
refresh_x25PLEIVMO_DCETable_row(struct x25PLEIVMO_DCETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->x25PLEIVMO_DCETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->x25PLEIVMO_DCETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_x25PLEIVMO_DCETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the x25PLEIVMO_DCETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMO_DCETable(int force)
{
	if (!force && x25PLEIVMO_DCETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	x25PLEIVMO_DCETable_refresh = 0;
}

/**
 * @fn u_char *var_x25PLEIVMO_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMO_DCETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_x25PLEIVMO_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct x25PLEIVMO_DCETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_x25PLEIVMO_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_x25PLEIVMO_DCETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(x25PLEIVMO_DCETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_x25PLEIVMO_DCETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) X25PLEIVMO_DCEROWSTATUS:	/* Create */
		*write_method = write_x25PLEIVMO_DCERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->x25PLEIVMO_DCERowStatus);
		rval = (u_char *) &StorageTmp->x25PLEIVMO_DCERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_virtualCallTable_row(struct virtualCallTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the virtualCallTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct virtualCallTable_data *
refresh_virtualCallTable_row(struct virtualCallTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->virtualCallTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->virtualCallTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_virtualCallTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the virtualCallTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCallTable(int force)
{
	if (!force && virtualCallTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	virtualCallTable_refresh = 0;
}

/**
 * @fn u_char *var_virtualCallTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCallTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCallTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_virtualCallTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_virtualCallTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(virtualCallTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_virtualCallTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) VIRTUALCALLCHANNEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallChannelLen;
		rval = (u_char *) StorageTmp->virtualCallChannel;
		break;
	case (u_char) VIRTUALCALLPACKETSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallPacketSizeLen;
		rval = (u_char *) StorageTmp->virtualCallPacketSize;
		break;
	case (u_char) VIRTUALCALLWINDOWSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallWindowSizeLen;
		rval = (u_char *) StorageTmp->virtualCallWindowSize;
		break;
	case (u_char) VIRTUALCALLOCTETSSENTCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallOctetsSentCounterLen;
		rval = (u_char *) StorageTmp->virtualCallOctetsSentCounter;
		break;
	case (u_char) VIRTUALCALLOCTETSRECEIVEDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallOctetsReceivedCounterLen;
		rval = (u_char *) StorageTmp->virtualCallOctetsReceivedCounter;
		break;
	case (u_char) VIRTUALCALLDATAPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallDataPacketsSentLen;
		rval = (u_char *) StorageTmp->virtualCallDataPacketsSent;
		break;
	case (u_char) VIRTUALCALLDATAPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallDataPacketsReceivedLen;
		rval = (u_char *) StorageTmp->virtualCallDataPacketsReceived;
		break;
	case (u_char) VIRTUALCALLREMOTELYINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallRemotelyInitiatedResetsLen;
		rval = (u_char *) StorageTmp->virtualCallRemotelyInitiatedResets;
		break;
	case (u_char) VIRTUALCALLDATARETRANSMISSIONTIMEREXPIRIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallDataRetransmissionTimerExpiriesLen;
		rval = (u_char *) StorageTmp->virtualCallDataRetransmissionTimerExpiries;
		break;
	case (u_char) VIRTUALCALLPROVIDERINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallProviderInitiatedResetsLen;
		rval = (u_char *) StorageTmp->virtualCallProviderInitiatedResets;
		break;
	case (u_char) VIRTUALCALLRESETTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallResetTimeoutsLen;
		rval = (u_char *) StorageTmp->virtualCallResetTimeouts;
		break;
	case (u_char) VIRTUALCALLINTERRUPTPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallInterruptPacketsSentLen;
		rval = (u_char *) StorageTmp->virtualCallInterruptPacketsSent;
		break;
	case (u_char) VIRTUALCALLINTERRUPTPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallInterruptPacketsReceivedLen;
		rval = (u_char *) StorageTmp->virtualCallInterruptPacketsReceived;
		break;
	case (u_char) VIRTUALCALLINTERRUPTTIMEREXPIRIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallInterruptTimerExpiriesLen;
		rval = (u_char *) StorageTmp->virtualCallInterruptTimerExpiries;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_virtualCircuitTable_row(struct virtualCircuitTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the virtualCircuitTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct virtualCircuitTable_data *
refresh_virtualCircuitTable_row(struct virtualCircuitTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->virtualCircuitTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->virtualCircuitTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_virtualCircuitTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the virtualCircuitTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCircuitTable(int force)
{
	if (!force && virtualCircuitTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	virtualCircuitTable_refresh = 0;
}

/**
 * @fn u_char *var_virtualCircuitTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCircuitTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCircuitTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_virtualCircuitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_virtualCircuitTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(virtualCircuitTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_virtualCircuitTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) VIRTUALCIRCUITLOGICALCHANNEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCircuitLogicalChannelLen;
		rval = (u_char *) StorageTmp->virtualCircuitLogicalChannel;
		break;
	case (u_char) VIRTUALCIRCUITPACKETSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCircuitPacketSizesLen;
		rval = (u_char *) StorageTmp->virtualCircuitPacketSizes;
		break;
	case (u_char) VIRTUALCIRCUITTHROUGHPUTCLASSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCircuitThroughputClassesLen;
		rval = (u_char *) StorageTmp->virtualCircuitThroughputClasses;
		break;
	case (u_char) VIRTUALCIRCUITWINDOWSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCircuitWindowSizesLen;
		rval = (u_char *) StorageTmp->virtualCircuitWindowSizes;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_virtualCircuit_DTETable_row(struct virtualCircuit_DTETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the virtualCircuit_DTETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct virtualCircuit_DTETable_data *
refresh_virtualCircuit_DTETable_row(struct virtualCircuit_DTETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->virtualCircuit_DTETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->virtualCircuit_DTETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_virtualCircuit_DTETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the virtualCircuit_DTETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCircuit_DTETable(int force)
{
	if (!force && virtualCircuit_DTETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	virtualCircuit_DTETable_refresh = 0;
}

/**
 * @fn u_char *var_virtualCircuit_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCircuit_DTETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCircuit_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCircuit_DTETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_virtualCircuit_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_virtualCircuit_DTETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(virtualCircuit_DTETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_virtualCircuit_DTETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) VIRTUALCIRCUIT_DTEOCTETSSENTCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEoctetsSentCounter);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEoctetsSentCounter;
		break;
	case (u_char) VIRTUALCIRCUIT_DTEOCTETSRECEIVEDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEoctetsReceivedCounter);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEoctetsReceivedCounter;
		break;
	case (u_char) VIRTUALCIRCUIT_DTEDATAPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEdataPacketsReceived);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEdataPacketsReceived;
		break;
	case (u_char) VIRTUALCIRCUIT_DTEDATAPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEdataPacketsSent);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEdataPacketsSent;
		break;
	case (u_char) VIRTUALCIRCUIT_DTEDATARETRANSMISSIONTIMEREXPIRIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEdataRetransmissionTimerExpiries);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEdataRetransmissionTimerExpiries;
		break;
	case (u_char) VIRTUALCIRCUIT_DTEINTERRUPTPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEinterruptPacketsReceived);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEinterruptPacketsReceived;
		break;
	case (u_char) VIRTUALCIRCUIT_DTEINTERRUPTPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEinterruptPacketsSent);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEinterruptPacketsSent;
		break;
	case (u_char) VIRTUALCIRCUIT_DTEINTERRUPTTIMEREXPIRIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEinterruptTimerExpiries);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEinterruptTimerExpiries;
		break;
	case (u_char) VIRTUALCIRCUIT_DTEPROVIDERINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEproviderInitiatedResets);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEproviderInitiatedResets;
		break;
	case (u_char) VIRTUALCIRCUIT_DTEREMOTELYINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEremotelyInitiatedResets);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEremotelyInitiatedResets;
		break;
	case (u_char) VIRTUALCIRCUIT_DTERESETTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DTEresetTimeouts);
		rval = (u_char *) &StorageTmp->virtualCircuit_DTEresetTimeouts;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_virtualCircuit_DCETable_row(struct virtualCircuit_DCETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the virtualCircuit_DCETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct virtualCircuit_DCETable_data *
refresh_virtualCircuit_DCETable_row(struct virtualCircuit_DCETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->virtualCircuit_DCETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->virtualCircuit_DCETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_virtualCircuit_DCETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the virtualCircuit_DCETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCircuit_DCETable(int force)
{
	if (!force && virtualCircuit_DCETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	virtualCircuit_DCETable_refresh = 0;
}

/**
 * @fn u_char *var_virtualCircuit_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCircuit_DCETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCircuit_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCircuit_DCETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_virtualCircuit_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_virtualCircuit_DCETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(virtualCircuit_DCETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_virtualCircuit_DCETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) VIRTUALCIRCUIT_DCEDATAPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEdataPacketsReceived);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEdataPacketsReceived;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEDATAPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEdataPacketsSent);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEdataPacketsSent;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEINTERRUPTPACKETSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEinterruptPacketsReceived);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEinterruptPacketsReceived;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEINTERRUPTPACKETSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEinterruptPacketsSent);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEinterruptPacketsSent;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEINTERRUPTTIMEREXPIRIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEinterruptTimerExpiries);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEinterruptTimerExpiries;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEOCTETSRECEIVEDCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEoctetsReceivedCounter);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEoctetsReceivedCounter;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEOCTETSSENTCOUNTER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEoctetsSentCounter);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEoctetsSentCounter;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEPROVIDERINITIATEDDISCONNECTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEproviderInitiatedDisconnects);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEproviderInitiatedDisconnects;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEPROVIDERINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEproviderInitiatedResets);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEproviderInitiatedResets;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESTARTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEremotelyInitiatedRestarts);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEremotelyInitiatedRestarts;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEREMOTELYINITIATEDRESETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEremotelyInitiatedResets);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEremotelyInitiatedResets;
		break;
	case (u_char) VIRTUALCIRCUIT_DCERESETTIMEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEresetTimeouts);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEresetTimeouts;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEX25SEGMENTSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEx25SegmentsReceived);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEx25SegmentsReceived;
		break;
	case (u_char) VIRTUALCIRCUIT_DCEX25SEGMENTSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCircuit_DCEx25SegmentsSent);
		rval = (u_char *) &StorageTmp->virtualCircuit_DCEx25SegmentsSent;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_permanentVirtualCircuitTable_row(struct permanentVirtualCircuitTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the permanentVirtualCircuitTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct permanentVirtualCircuitTable_data *
refresh_permanentVirtualCircuitTable_row(struct permanentVirtualCircuitTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->permanentVirtualCircuitTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->permanentVirtualCircuitTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_permanentVirtualCircuitTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the permanentVirtualCircuitTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_permanentVirtualCircuitTable(int force)
{
	if (!force && permanentVirtualCircuitTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	permanentVirtualCircuitTable_refresh = 0;
}

/**
 * @fn u_char *var_permanentVirtualCircuitTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in permanentVirtualCircuitTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_permanentVirtualCircuitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct permanentVirtualCircuitTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_permanentVirtualCircuitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_permanentVirtualCircuitTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(permanentVirtualCircuitTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_permanentVirtualCircuitTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) PERMANENTVIRTUALCIRCUITCHANNEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuitChannelLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuitChannel;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUITROWSTATUS:	/* Create */
		*write_method = write_permanentVirtualCircuitRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->permanentVirtualCircuitRowStatus);
		rval = (u_char *) &StorageTmp->permanentVirtualCircuitRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_permanentVirtualCircuit_DTETable_row(struct permanentVirtualCircuit_DTETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the permanentVirtualCircuit_DTETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct permanentVirtualCircuit_DTETable_data *
refresh_permanentVirtualCircuit_DTETable_row(struct permanentVirtualCircuit_DTETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->permanentVirtualCircuit_DTETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->permanentVirtualCircuit_DTETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_permanentVirtualCircuit_DTETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the permanentVirtualCircuit_DTETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_permanentVirtualCircuit_DTETable(int force)
{
	if (!force && permanentVirtualCircuit_DTETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	permanentVirtualCircuit_DTETable_refresh = 0;
}

/**
 * @fn u_char *var_permanentVirtualCircuit_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in permanentVirtualCircuit_DTETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_permanentVirtualCircuit_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct permanentVirtualCircuit_DTETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_permanentVirtualCircuit_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_permanentVirtualCircuit_DTETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(permanentVirtualCircuit_DTETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_permanentVirtualCircuit_DTETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) PERMANENTVIRTUALCIRCUIT_DTELOGICALCHANNEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DTElogicalChannelLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DTElogicalChannel;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DTEPACKETSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DTEpacketSizesLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DTEpacketSizes;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DTETHROUGHPUTCLASSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DTEthroughputClassesLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DTEthroughputClasses;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DTEWINDOWSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DTEwindowSizesLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DTEwindowSizes;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DTEROWSTATUS:	/* Create */
		*write_method = write_permanentVirtualCircuit_DTERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->permanentVirtualCircuit_DTERowStatus);
		rval = (u_char *) &StorageTmp->permanentVirtualCircuit_DTERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_permanentVirtualCircuit_DCETable_row(struct permanentVirtualCircuit_DCETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the permanentVirtualCircuit_DCETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct permanentVirtualCircuit_DCETable_data *
refresh_permanentVirtualCircuit_DCETable_row(struct permanentVirtualCircuit_DCETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->permanentVirtualCircuit_DCETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->permanentVirtualCircuit_DCETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_permanentVirtualCircuit_DCETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the permanentVirtualCircuit_DCETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_permanentVirtualCircuit_DCETable(int force)
{
	if (!force && permanentVirtualCircuit_DCETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	permanentVirtualCircuit_DCETable_refresh = 0;
}

/**
 * @fn u_char *var_permanentVirtualCircuit_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in permanentVirtualCircuit_DCETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_permanentVirtualCircuit_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct permanentVirtualCircuit_DCETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_permanentVirtualCircuit_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_permanentVirtualCircuit_DCETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(permanentVirtualCircuit_DCETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_permanentVirtualCircuit_DCETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) PERMANENTVIRTUALCIRCUIT_DCECHARGINGDIRECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DCEchargingDirectionLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DCEchargingDirection;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DCELOGICALCHANNEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DCElogicalChannelLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DCElogicalChannel;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DCEPACKETSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DCEpacketSizesLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DCEpacketSizes;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DCETHROUGHPUTCLASSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DCEthroughputClassesLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DCEthroughputClasses;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DCEWINDOWSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DCEwindowSizesLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DCEwindowSizes;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DCEOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->permanentVirtualCircuit_DCEoperationalState);
		rval = (u_char *) &StorageTmp->permanentVirtualCircuit_DCEoperationalState;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DCEREMOTEDTEADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddressLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DCEremoteDTEAddress;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DCEREMOTELOGICALCHANNEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannelLen;
		rval = (u_char *) StorageTmp->permanentVirtualCircuit_DCEremoteLogicalChannel;
		break;
	case (u_char) PERMANENTVIRTUALCIRCUIT_DCEROWSTATUS:	/* Create */
		*write_method = write_permanentVirtualCircuit_DCERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->permanentVirtualCircuit_DCERowStatus);
		rval = (u_char *) &StorageTmp->permanentVirtualCircuit_DCERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_virtualCallIVMOTable_row(struct virtualCallIVMOTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the virtualCallIVMOTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct virtualCallIVMOTable_data *
refresh_virtualCallIVMOTable_row(struct virtualCallIVMOTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->virtualCallIVMOTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->virtualCallIVMOTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_virtualCallIVMOTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the virtualCallIVMOTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCallIVMOTable(int force)
{
	if (!force && virtualCallIVMOTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	virtualCallIVMOTable_refresh = 0;
}

/**
 * @fn u_char *var_virtualCallIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCallIVMOTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCallIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCallIVMOTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_virtualCallIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_virtualCallIVMOTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(virtualCallIVMOTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_virtualCallIVMOTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) VIRTUALCALLIVMOFASTSELECT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCallIVMOfastSelect);
		rval = (u_char *) &StorageTmp->virtualCallIVMOfastSelect;
		break;
	case (u_char) VIRTUALCALLIVMOPACKETSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOpacketSizesLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOpacketSizes;
		break;
	case (u_char) VIRTUALCALLIVMOREVERSECHARGING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOreverseChargingLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOreverseCharging;
		break;
	case (u_char) VIRTUALCALLIVMOTHROUGHPUTCLASSES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOthroughputClassesLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOthroughputClasses;
		break;
	case (u_char) VIRTUALCALLIVMOWINDOWSIZES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOwindowSizesLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOwindowSizes;
		break;
	case (u_char) VIRTUALCALLIVMOPROPOSEDPACKETSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOproposedPacketSizeLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOproposedPacketSize;
		break;
	case (u_char) VIRTUALCALLIVMOPROPOSEDWINDOWSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOproposedWindowSizeLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOproposedWindowSize;
		break;
	case (u_char) VIRTUALCALLIVMOACCEPTREVERSECHARGING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOacceptReverseChargingLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOacceptReverseCharging;
		break;
	case (u_char) VIRTUALCALLIVMOPROPOSEREVERSECHARGING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOproposeReverseChargingLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOproposeReverseCharging;
		break;
	case (u_char) VIRTUALCALLIVMOCALLTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOcallTimeLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOcallTime;
		break;
	case (u_char) VIRTUALCALLIVMORESETTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOresetTimeLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOresetTime;
		break;
	case (u_char) VIRTUALCALLIVMOCLEARTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOclearTimeLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOclearTime;
		break;
	case (u_char) VIRTUALCALLIVMOINTERRUPTTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOinterruptTimeLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOinterruptTime;
		break;
	case (u_char) VIRTUALCALLIVMORESETCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOresetCountLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOresetCount;
		break;
	case (u_char) VIRTUALCALLIVMOCLEARCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOclearCountLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOclearCount;
		break;
	case (u_char) VIRTUALCALLIVMOWINDOWTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOwindowTimeLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOwindowTime;
		break;
	case (u_char) VIRTUALCALLIVMODATARETRANSMISSIONTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOdataRetransmissionTimeLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOdataRetransmissionTime;
		break;
	case (u_char) VIRTUALCALLIVMODATARETRANSMISSIONCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOdataRetransmissionCountLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOdataRetransmissionCount;
		break;
	case (u_char) VIRTUALCALLIVMOREJECTTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOrejectTimeLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOrejectTime;
		break;
	case (u_char) VIRTUALCALLIVMOREJECTCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCallIVMOrejectCountLen;
		rval = (u_char *) StorageTmp->virtualCallIVMOrejectCount;
		break;
	case (u_char) VIRTUALCALLIVMOROWSTATUS:	/* Create */
		*write_method = write_virtualCallIVMORowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCallIVMORowStatus);
		rval = (u_char *) &StorageTmp->virtualCallIVMORowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_switchedVirtualCallTable_row(struct switchedVirtualCallTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the switchedVirtualCallTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct switchedVirtualCallTable_data *
refresh_switchedVirtualCallTable_row(struct switchedVirtualCallTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->switchedVirtualCallTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->switchedVirtualCallTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_switchedVirtualCallTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the switchedVirtualCallTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_switchedVirtualCallTable(int force)
{
	if (!force && switchedVirtualCallTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	switchedVirtualCallTable_refresh = 0;
}

/**
 * @fn u_char *var_switchedVirtualCallTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in switchedVirtualCallTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_switchedVirtualCallTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct switchedVirtualCallTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_switchedVirtualCallTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_switchedVirtualCallTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(switchedVirtualCallTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_switchedVirtualCallTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SWITCHEDVIRTUALCALLDIRECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->switchedVirtualCalldirectionLen;
		rval = (u_char *) StorageTmp->switchedVirtualCalldirection;
		break;
	case (u_char) SWITCHEDVIRTUALCALLREMOTEDTEADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->switchedVirtualCallremoteDTEAddressLen;
		rval = (u_char *) StorageTmp->switchedVirtualCallremoteDTEAddress;
		break;
	case (u_char) SWITCHEDVIRTUALCALLTHROUGHPUTCLASS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->switchedVirtualCallthroughputClassLen;
		rval = (u_char *) StorageTmp->switchedVirtualCallthroughputClass;
		break;
	case (u_char) SWITCHEDVIRTUALCALLREDIRECTREASON:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->switchedVirtualCallredirectReasonLen;
		rval = (u_char *) StorageTmp->switchedVirtualCallredirectReason;
		break;
	case (u_char) SWITCHEDVIRTUALCALLORIGINALLYCALLEDADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->switchedVirtualCalloriginallyCalledAddressLen;
		rval = (u_char *) StorageTmp->switchedVirtualCalloriginallyCalledAddress;
		break;
	case (u_char) SWITCHEDVIRTUALCALLCALLINGADDRESSEXTENSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->switchedVirtualCallcallingAddressExtensionLen;
		rval = (u_char *) StorageTmp->switchedVirtualCallcallingAddressExtension;
		break;
	case (u_char) SWITCHEDVIRTUALCALLCALLEDADDRESSEXTENSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->switchedVirtualCallcalledAddressExtensionLen;
		rval = (u_char *) StorageTmp->switchedVirtualCallcalledAddressExtension;
		break;
	case (u_char) SWITCHEDVIRTUALCALLROWSTATUS:	/* Create */
		*write_method = write_switchedVirtualCallRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->switchedVirtualCallRowStatus);
		rval = (u_char *) &StorageTmp->switchedVirtualCallRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_virtualCall_DTETable_row(struct virtualCall_DTETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the virtualCall_DTETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct virtualCall_DTETable_data *
refresh_virtualCall_DTETable_row(struct virtualCall_DTETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->virtualCall_DTETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->virtualCall_DTETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_virtualCall_DTETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the virtualCall_DTETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCall_DTETable(int force)
{
	if (!force && virtualCall_DTETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	virtualCall_DTETable_refresh = 0;
}

/**
 * @fn u_char *var_virtualCall_DTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCall_DTETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCall_DTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCall_DTETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_virtualCall_DTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_virtualCall_DTETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(virtualCall_DTETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_virtualCall_DTETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) VIRTUALCALL_DTECALLINGADDRESSEXTENSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DTEcallingAddressExtensionLen;
		rval = (u_char *) StorageTmp->virtualCall_DTEcallingAddressExtension;
		break;
	case (u_char) VIRTUALCALL_DTECALLEDADDRESSEXTENSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DTEcalledAddressExtensionLen;
		rval = (u_char *) StorageTmp->virtualCall_DTEcalledAddressExtension;
		break;
	case (u_char) VIRTUALCALL_DTEDIRECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DTEdirectionLen;
		rval = (u_char *) StorageTmp->virtualCall_DTEdirection;
		break;
	case (u_char) VIRTUALCALL_DTEFASTSELECT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCall_DTEfastSelect);
		rval = (u_char *) &StorageTmp->virtualCall_DTEfastSelect;
		break;
	case (u_char) VIRTUALCALL_DTEORIGINALLYCALLEDADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DTEoriginallyCalledAddressLen;
		rval = (u_char *) StorageTmp->virtualCall_DTEoriginallyCalledAddress;
		break;
	case (u_char) VIRTUALCALL_DTEREDIRECTREASON:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DTEredirectReasonLen;
		rval = (u_char *) StorageTmp->virtualCall_DTEredirectReason;
		break;
	case (u_char) VIRTUALCALL_DTEREMOTEDTEADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DTEremoteDTEAddressLen;
		rval = (u_char *) StorageTmp->virtualCall_DTEremoteDTEAddress;
		break;
	case (u_char) VIRTUALCALL_DTEREVERSECHARGING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DTEreverseChargingLen;
		rval = (u_char *) StorageTmp->virtualCall_DTEreverseCharging;
		break;
	case (u_char) VIRTUALCALL_DTEROWSTATUS:	/* Create */
		*write_method = write_virtualCall_DTERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCall_DTERowStatus);
		rval = (u_char *) &StorageTmp->virtualCall_DTERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_virtualCall_DCETable_row(struct virtualCall_DCETable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the virtualCall_DCETable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct virtualCall_DCETable_data *
refresh_virtualCall_DCETable_row(struct virtualCall_DCETable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->virtualCall_DCETable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->virtualCall_DCETable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_virtualCall_DCETable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the virtualCall_DCETable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualCall_DCETable(int force)
{
	if (!force && virtualCall_DCETable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	virtualCall_DCETable_refresh = 0;
}

/**
 * @fn u_char *var_virtualCall_DCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualCall_DCETable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualCall_DCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualCall_DCETable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_virtualCall_DCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_virtualCall_DCETable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(virtualCall_DCETableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_virtualCall_DCETable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) VIRTUALCALL_DCECHARGINGDIRECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCEchargingDirectionLen;
		rval = (u_char *) StorageTmp->virtualCall_DCEchargingDirection;
		break;
	case (u_char) VIRTUALCALL_DCECUGSELECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCEcUGSelectionLen;
		rval = (u_char *) StorageTmp->virtualCall_DCEcUGSelection;
		break;
	case (u_char) VIRTUALCALL_DCEDIRECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCEdirectionLen;
		rval = (u_char *) StorageTmp->virtualCall_DCEdirection;
		break;
	case (u_char) VIRTUALCALL_DCEFASTSELECT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCall_DCEfastSelect);
		rval = (u_char *) &StorageTmp->virtualCall_DCEfastSelect;
		break;
	case (u_char) VIRTUALCALL_DCEREMOTEDTEADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCEremoteDTEAddressLen;
		rval = (u_char *) StorageTmp->virtualCall_DCEremoteDTEAddress;
		break;
	case (u_char) VIRTUALCALL_DCETRANSITDELAYSELECTIONANDINDICATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndicationLen;
		rval = (u_char *) StorageTmp->virtualCall_DCEtransitDelaySelectionAndIndication;
		break;
	case (u_char) VIRTUALCALL_DCEBILATERALCUGSELECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCEbilateralCUGSelectionLen;
		rval = (u_char *) StorageTmp->virtualCall_DCEbilateralCUGSelection;
		break;
	case (u_char) VIRTUALCALL_DCECALLREDIRECTIONDEFLECTIONNOTIFICATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCall_DCEcallRedirectionDeflectionNotification);
		rval = (u_char *) &StorageTmp->virtualCall_DCEcallRedirectionDeflectionNotification;
		break;
	case (u_char) VIRTUALCALL_DCECALLEDLINEADDRESSMODIFIEDNOTIFICATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCall_DCEcalledLineAddressModifiedNotification);
		rval = (u_char *) &StorageTmp->virtualCall_DCEcalledLineAddressModifiedNotification;
		break;
	case (u_char) VIRTUALCALL_DCECUGWITHOUTGOINGACCESSSELECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelectionLen;
		rval = (u_char *) StorageTmp->virtualCall_DCEcUGWithOutgoingAccessSelection;
		break;
	case (u_char) VIRTUALCALL_DCENUISELECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCEnUISelectionLen;
		rval = (u_char *) StorageTmp->virtualCall_DCEnUISelection;
		break;
	case (u_char) VIRTUALCALL_DCEREVERSECHARGING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCEreverseChargingLen;
		rval = (u_char *) StorageTmp->virtualCall_DCEreverseCharging;
		break;
	case (u_char) VIRTUALCALL_DCEROASELECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->virtualCall_DCErOASelectionLen;
		rval = (u_char *) StorageTmp->virtualCall_DCErOASelection;
		break;
	case (u_char) VIRTUALCALL_DCEROWSTATUS:	/* Create */
		*write_method = write_virtualCall_DCERowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualCall_DCERowStatus);
		rval = (u_char *) &StorageTmp->virtualCall_DCERowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_dSeriesCountsTable_row(struct dSeriesCountsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dSeriesCountsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dSeriesCountsTable_data *
refresh_dSeriesCountsTable_row(struct dSeriesCountsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dSeriesCountsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dSeriesCountsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dSeriesCountsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dSeriesCountsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dSeriesCountsTable(int force)
{
	if (!force && dSeriesCountsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dSeriesCountsTable_refresh = 0;
}

/**
 * @fn u_char *var_dSeriesCountsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dSeriesCountsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_dSeriesCountsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dSeriesCountsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_dSeriesCountsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dSeriesCountsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dSeriesCountsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dSeriesCountsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DSERIESRESETREQUESTINDICATIONPACKETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dSeriesResetRequestIndicationPackets);
		rval = (u_char *) &StorageTmp->dSeriesResetRequestIndicationPackets;
		break;
	case (u_char) DSERIESSEGMENTSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dSeriesSegmentsSent);
		rval = (u_char *) &StorageTmp->dSeriesSegmentsSent;
		break;
	case (u_char) DSERIESSEGMENTSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dSeriesSegmentsReceived);
		rval = (u_char *) &StorageTmp->dSeriesSegmentsReceived;
		break;
	case (u_char) DSERIESROWSTATUS:	/* Create */
		*write_method = write_dSeriesRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dSeriesRowStatus);
		rval = (u_char *) &StorageTmp->dSeriesRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_adjacencyTable_row(struct adjacencyTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the adjacencyTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct adjacencyTable_data *
refresh_adjacencyTable_row(struct adjacencyTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->adjacencyTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->adjacencyTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_adjacencyTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the adjacencyTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_adjacencyTable(int force)
{
	if (!force && adjacencyTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	adjacencyTable_refresh = 0;
}

/**
 * @fn u_char *var_adjacencyTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in adjacencyTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_adjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct adjacencyTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_adjacencyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_adjacencyTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(adjacencyTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_adjacencyTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ADJACENCYSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->adjacencyState);
		rval = (u_char *) &StorageTmp->adjacencyState;
		break;
	case (u_char) NEIGHBOURSNPAADDRESS:	/* Create */
		*write_method = write_neighbourSNPAAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->neighbourSNPAAddressLen;
		rval = (u_char *) StorageTmp->neighbourSNPAAddress;
		break;
	case (u_char) NEIGHBOURSYSTEMTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->neighbourSystemType);
		rval = (u_char *) &StorageTmp->neighbourSystemType;
		break;
	case (u_char) NEIGHBOURSYSTEMIDS:	/* Create */
		*write_method = write_neighbourSystemIds;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->neighbourSystemIdsLen;
		rval = (u_char *) StorageTmp->neighbourSystemIds;
		break;
	case (u_char) ADJACENCYUSAGE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->adjacencyUsage);
		rval = (u_char *) &StorageTmp->adjacencyUsage;
		break;
	case (u_char) AREAADDRESSESOFNEIGHBOUR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->areaAddressesOfNeighbourLen;
		rval = (u_char *) StorageTmp->areaAddressesOfNeighbour;
		break;
	case (u_char) HOLDINGTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->holdingTimer);
		rval = (u_char *) &StorageTmp->holdingTimer;
		break;
	case (u_char) PRIORITYOFNEIGHBOUR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->priorityOfNeighbour);
		rval = (u_char *) &StorageTmp->priorityOfNeighbour;
		break;
	case (u_char) ADJACENCYROWSTATUS:	/* Create */
		*write_method = write_adjacencyRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->adjacencyRowStatus);
		rval = (u_char *) &StorageTmp->adjacencyRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_virtualAdjacencyTable_row(struct virtualAdjacencyTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the virtualAdjacencyTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct virtualAdjacencyTable_data *
refresh_virtualAdjacencyTable_row(struct virtualAdjacencyTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->virtualAdjacencyTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->virtualAdjacencyTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_virtualAdjacencyTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the virtualAdjacencyTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_virtualAdjacencyTable(int force)
{
	if (!force && virtualAdjacencyTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	virtualAdjacencyTable_refresh = 0;
}

/**
 * @fn u_char *var_virtualAdjacencyTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in virtualAdjacencyTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_virtualAdjacencyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct virtualAdjacencyTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_virtualAdjacencyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_virtualAdjacencyTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(virtualAdjacencyTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_virtualAdjacencyTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) VIRTUALADJACENCYMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->virtualAdjacencyMetric);
		rval = (u_char *) &StorageTmp->virtualAdjacencyMetric;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_destinationTable_row(struct destinationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the destinationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct destinationTable_data *
refresh_destinationTable_row(struct destinationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->destinationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->destinationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_destinationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the destinationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_destinationTable(int force)
{
	if (!force && destinationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	destinationTable_refresh = 0;
}

/**
 * @fn u_char *var_destinationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in destinationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_destinationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct destinationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_destinationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_destinationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(destinationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_destinationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DESTINATIONDEFAULTMETRICPATHCOST:	/* ReadWrite */
		*write_method = write_destinationDefaultMetricPathCost;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->destinationDefaultMetricPathCost);
		rval = (u_char *) &StorageTmp->destinationDefaultMetricPathCost;
		break;
	case (u_char) DESTINATIONDEFAULTMETRICOUTPUTADJACENCIES:	/* ReadWrite */
		*write_method = write_destinationDefaultMetricOutputAdjacencies;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->destinationDefaultMetricOutputAdjacenciesLen;
		rval = (u_char *) StorageTmp->destinationDefaultMetricOutputAdjacencies;
		break;
	case (u_char) DESTINATIONDELAYMETRICPATHCOST:	/* ReadWrite */
		*write_method = write_destinationDelayMetricPathCost;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->destinationDelayMetricPathCost);
		rval = (u_char *) &StorageTmp->destinationDelayMetricPathCost;
		break;
	case (u_char) DESTINATIONDELAYMETRICOUTPUTADJACENCIES:	/* ReadWrite */
		*write_method = write_destinationDelayMetricOutputAdjacencies;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->destinationDelayMetricOutputAdjacenciesLen;
		rval = (u_char *) StorageTmp->destinationDelayMetricOutputAdjacencies;
		break;
	case (u_char) DESTINATIONEXPENSEMETRICPATHCOST:	/* ReadWrite */
		*write_method = write_destinationExpenseMetricPathCost;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->destinationExpenseMetricPathCost);
		rval = (u_char *) &StorageTmp->destinationExpenseMetricPathCost;
		break;
	case (u_char) DESTINATIONEXPENSEMETRICOUTPUTADJACENCIES:	/* ReadWrite */
		*write_method = write_destinationExpenseMetricOutputAdjacencies;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->destinationExpenseMetricOutputAdjacenciesLen;
		rval = (u_char *) StorageTmp->destinationExpenseMetricOutputAdjacencies;
		break;
	case (u_char) DESTINATIONERRORMETRICPATHCOST:	/* ReadWrite */
		*write_method = write_destinationErrorMetricPathCost;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->destinationErrorMetricPathCost);
		rval = (u_char *) &StorageTmp->destinationErrorMetricPathCost;
		break;
	case (u_char) DESTINATIONERRORMETRICOUTPUTADJACENCIES:	/* ReadWrite */
		*write_method = write_destinationErrorMetricOutputAdjacencies;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->destinationErrorMetricOutputAdjacenciesLen;
		rval = (u_char *) StorageTmp->destinationErrorMetricOutputAdjacencies;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_destinationSystemTable_row(struct destinationSystemTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the destinationSystemTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct destinationSystemTable_data *
refresh_destinationSystemTable_row(struct destinationSystemTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->destinationSystemTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->destinationSystemTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_destinationSystemTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the destinationSystemTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_destinationSystemTable(int force)
{
	if (!force && destinationSystemTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	destinationSystemTable_refresh = 0;
}

/**
 * @fn u_char *var_destinationSystemTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in destinationSystemTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_destinationSystemTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct destinationSystemTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_destinationSystemTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_destinationSystemTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(destinationSystemTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_destinationSystemTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DESINTATIONSYSTEMMETRIC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->desintationSystemMetric);
		rval = (u_char *) &StorageTmp->desintationSystemMetric;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_destinationAreaTable_row(struct destinationAreaTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the destinationAreaTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct destinationAreaTable_data *
refresh_destinationAreaTable_row(struct destinationAreaTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->destinationAreaTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->destinationAreaTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_destinationAreaTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the destinationAreaTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_destinationAreaTable(int force)
{
	if (!force && destinationAreaTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	destinationAreaTable_refresh = 0;
}

/**
 * @fn u_char *var_destinationAreaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in destinationAreaTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_destinationAreaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct destinationAreaTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_destinationAreaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_destinationAreaTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(destinationAreaTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_destinationAreaTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_reachableAddressTable_row(struct reachableAddressTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the reachableAddressTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct reachableAddressTable_data *
refresh_reachableAddressTable_row(struct reachableAddressTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->reachableAddressTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->reachableAddressTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_reachableAddressTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the reachableAddressTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_reachableAddressTable(int force)
{
	if (!force && reachableAddressTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	reachableAddressTable_refresh = 0;
}

/**
 * @fn u_char *var_reachableAddressTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in reachableAddressTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_dlMIB above.
 */
u_char *
var_reachableAddressTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct reachableAddressTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("dlMIB", "var_reachableAddressTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_reachableAddressTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(reachableAddressTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_reachableAddressTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) REACHABLEADDRESSPREFIX:	/* Create */
		*write_method = write_reachableAddressPrefix;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->reachableAddressPrefixLen;
		rval = (u_char *) StorageTmp->reachableAddressPrefix;
		break;
	case (u_char) REACHABLEADDRESSMAPPINGTYPE:	/* Create */
		*write_method = write_reachableAddressMappingType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressMappingType);
		rval = (u_char *) &StorageTmp->reachableAddressMappingType;
		break;
	case (u_char) REACHABLEADDRESSDEFAULTMETRIC:	/* Create */
		*write_method = write_reachableAddressDefaultMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressDefaultMetric);
		rval = (u_char *) &StorageTmp->reachableAddressDefaultMetric;
		break;
	case (u_char) REACHABLEADDRESSDELAYMETRIC:	/* Create */
		*write_method = write_reachableAddressDelayMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressDelayMetric);
		rval = (u_char *) &StorageTmp->reachableAddressDelayMetric;
		break;
	case (u_char) REACHABLEADDRESSEXPENSEMETRIC:	/* Create */
		*write_method = write_reachableAddressExpenseMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressExpenseMetric);
		rval = (u_char *) &StorageTmp->reachableAddressExpenseMetric;
		break;
	case (u_char) REACHABLEADDRESSERRORMETRIC:	/* Create */
		*write_method = write_reachableAddressErrorMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressErrorMetric);
		rval = (u_char *) &StorageTmp->reachableAddressErrorMetric;
		break;
	case (u_char) REACHABLEADDRESSDEFAULTMETRICTYPE:	/* Create */
		*write_method = write_reachableAddressDefaultMetricType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressDefaultMetricType);
		rval = (u_char *) &StorageTmp->reachableAddressDefaultMetricType;
		break;
	case (u_char) REACHABLEADDRESSDELAYMETRICTYPE:	/* Create */
		*write_method = write_reachableAddressDelayMetricType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressDelayMetricType);
		rval = (u_char *) &StorageTmp->reachableAddressDelayMetricType;
		break;
	case (u_char) REACHABLEADDRESSEXPENSEMETRICTYPE:	/* Create */
		*write_method = write_reachableAddressExpenseMetricType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressExpenseMetricType);
		rval = (u_char *) &StorageTmp->reachableAddressExpenseMetricType;
		break;
	case (u_char) REACHABLEADDRESSERRORMETRICTYPE:	/* Create */
		*write_method = write_reachableAddressErrorMetricType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressErrorMetricType);
		rval = (u_char *) &StorageTmp->reachableAddressErrorMetricType;
		break;
	case (u_char) REACHABLEADDRESSOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressOperationalState);
		rval = (u_char *) &StorageTmp->reachableAddressOperationalState;
		break;
	case (u_char) REACHABLEADDRESSADMINISTRATIVESTATE:	/* Create */
		*write_method = write_reachableAddressAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressAdministrativeState);
		rval = (u_char *) &StorageTmp->reachableAddressAdministrativeState;
		break;
	case (u_char) REACHABLEADDRESSSNPAADDRESSES:	/* Create */
		*write_method = write_reachableAddressSNPAAddresses;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->reachableAddressSNPAAddressesLen;
		rval = (u_char *) StorageTmp->reachableAddressSNPAAddresses;
		break;
	case (u_char) REACHABLEADDRESSSNPAMASK:	/* Create */
		*write_method = write_reachableAddressSNPAMask;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->reachableAddressSNPAMaskLen;
		rval = (u_char *) StorageTmp->reachableAddressSNPAMask;
		break;
	case (u_char) REACHABLEADDRESSSNPAPREFIX:	/* Create */
		*write_method = write_reachableAddressSNPAPrefix;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->reachableAddressSNPAPrefixLen;
		rval = (u_char *) StorageTmp->reachableAddressSNPAPrefix;
		break;
	case (u_char) REACHABLEADDRESSROWSTATUS:	/* Create */
		*write_method = write_reachableAddressRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->reachableAddressRowStatus);
		rval = (u_char *) &StorageTmp->reachableAddressRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_physicalEntityPhysicalEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_physicalEntityPhysicalEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct physicalEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("dlMIB", "write_physicalEntityPhysicalEntityTitles entering action=%d...  \n", action));
	StorageTmp = header_complex(physicalEntityTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		objid = NULL;
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalEntityPhysicalEntityTitles not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalEntityPhysicalEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->physicalEntityPhysicalEntityTitles for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->physicalEntityPhysicalEntityTitles;
		old_length = StorageTmp->physicalEntityPhysicalEntityTitlesLen;
		StorageTmp->physicalEntityPhysicalEntityTitles = objid;
		StorageTmp->physicalEntityPhysicalEntityTitlesLen = var_val_len / sizeof(oid);
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->physicalEntityPhysicalEntityTitles = old_value;
		StorageTmp->physicalEntityPhysicalEntityTitlesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitBitErrorsThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitBitErrorsThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitBitErrorsThreshold entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OPAQUE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 7..7 */
		if (string != 7) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitBitErrorsThreshold: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dataCircuitBitErrorsThreshold for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->dataCircuitBitErrorsThreshold;
		old_length = StorageTmp->dataCircuitBitErrorsThresholdLen;
		StorageTmp->dataCircuitBitErrorsThreshold = string;
		StorageTmp->dataCircuitBitErrorsThresholdLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitBitErrorsThreshold = old_value;
		StorageTmp->dataCircuitBitErrorsThresholdLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_dataCircuitType entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DATACIRCUITTYPE_ENDSYSTEM:
		case DATACIRCUITTYPE_RELAYSYSTEM:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dataCircuitType for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->dataCircuitType;
		StorageTmp->dataCircuitType = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitType = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitPhysicalMediaNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitPhysicalMediaNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitPhysicalMediaNames entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalMediaNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalMediaNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalMediaNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dataCircuitPhysicalMediaNames for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->dataCircuitPhysicalMediaNames;
		old_length = StorageTmp->dataCircuitPhysicalMediaNamesLen;
		StorageTmp->dataCircuitPhysicalMediaNames = string;
		StorageTmp->dataCircuitPhysicalMediaNamesLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitPhysicalMediaNames = old_value;
		StorageTmp->dataCircuitPhysicalMediaNamesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitPhysicalInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitPhysicalInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitPhysicalInterfaceType entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dataCircuitPhysicalInterfaceType for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->dataCircuitPhysicalInterfaceType;
		old_length = StorageTmp->dataCircuitPhysicalInterfaceTypeLen;
		StorageTmp->dataCircuitPhysicalInterfaceType = string;
		StorageTmp->dataCircuitPhysicalInterfaceTypeLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitPhysicalInterfaceType = old_value;
		StorageTmp->dataCircuitPhysicalInterfaceTypeLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitPhysicalInterfaceStandard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitPhysicalInterfaceStandard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitPhysicalInterfaceStandard entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceStandard: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceStandard not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitPhysicalInterfaceStandard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dataCircuitPhysicalInterfaceStandard for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->dataCircuitPhysicalInterfaceStandard;
		old_length = StorageTmp->dataCircuitPhysicalInterfaceStandardLen;
		StorageTmp->dataCircuitPhysicalInterfaceStandard = string;
		StorageTmp->dataCircuitPhysicalInterfaceStandardLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitPhysicalInterfaceStandard = old_value;
		StorageTmp->dataCircuitPhysicalInterfaceStandardLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitSynchronizationMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitSynchronizationMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_dataCircuitSynchronizationMode entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DATACIRCUITSYNCHRONIZATIONMODE_SYNCHRONOUS:
		case DATACIRCUITSYNCHRONIZATIONMODE_ASYNCHRONOUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitSynchronizationMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dataCircuitSynchronizationMode for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->dataCircuitSynchronizationMode;
		StorageTmp->dataCircuitSynchronizationMode = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitSynchronizationMode = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitTransmissionCoding(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitTransmissionCoding(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitTransmissionCoding entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionCoding: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionCoding not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionCoding: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dataCircuitTransmissionCoding for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->dataCircuitTransmissionCoding;
		old_length = StorageTmp->dataCircuitTransmissionCodingLen;
		StorageTmp->dataCircuitTransmissionCoding = string;
		StorageTmp->dataCircuitTransmissionCodingLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitTransmissionCoding = old_value;
		StorageTmp->dataCircuitTransmissionCodingLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitTransmissionMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitTransmissionMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_dataCircuitTransmissionMode entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DATACIRCUITTRANSMISSIONMODE_SIMPLEX:
		case DATACIRCUITTRANSMISSIONMODE_DUPLEX:
		case DATACIRCUITTRANSMISSIONMODE_HALFDUPLEX:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dataCircuitTransmissionMode for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->dataCircuitTransmissionMode;
		StorageTmp->dataCircuitTransmissionMode = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitTransmissionMode = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dataCircuitTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dataCircuitTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitTransmissionRate entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dataCircuitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OPAQUE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate not ASN_OPAQUE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 7..7 */
		if (string != 7) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dataCircuitTransmissionRate for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->dataCircuitTransmissionRate;
		old_length = StorageTmp->dataCircuitTransmissionRateLen;
		StorageTmp->dataCircuitTransmissionRate = string;
		StorageTmp->dataCircuitTransmissionRateLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->dataCircuitTransmissionRate = old_value;
		StorageTmp->dataCircuitTransmissionRateLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_physicalConnectionEndpointIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_physicalConnectionEndpointIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct physicalConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_physicalConnectionEndpointIdentifier entering action=%d...  \n", action));
	StorageTmp = header_complex(physicalConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->physicalConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionEndpointIdentifier: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionEndpointIdentifier not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionEndpointIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->physicalConnectionEndpointIdentifier for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->physicalConnectionEndpointIdentifier;
		old_length = StorageTmp->physicalConnectionEndpointIdentifierLen;
		StorageTmp->physicalConnectionEndpointIdentifier = string;
		StorageTmp->physicalConnectionEndpointIdentifierLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->physicalConnectionEndpointIdentifier = old_value;
		StorageTmp->physicalConnectionEndpointIdentifierLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_physicalConnectionPortNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_physicalConnectionPortNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct physicalConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_physicalConnectionPortNumber entering action=%d...  \n", action));
	StorageTmp = header_complex(physicalConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->physicalConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionPortNumber: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionPortNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionPortNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->physicalConnectionPortNumber for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->physicalConnectionPortNumber;
		StorageTmp->physicalConnectionPortNumber = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->physicalConnectionPortNumber = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_datalinkEntityProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_datalinkEntityProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct datalinkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("dlMIB", "write_datalinkEntityProviderEntityNames entering action=%d...  \n", action));
	StorageTmp = header_complex(datalinkEntityTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		objid = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->datalinkEntityRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityProviderEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->datalinkEntityProviderEntityNames for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->datalinkEntityProviderEntityNames;
		old_length = StorageTmp->datalinkEntityProviderEntityNamesLen;
		StorageTmp->datalinkEntityProviderEntityNames = objid;
		StorageTmp->datalinkEntityProviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->datalinkEntityProviderEntityNames = old_value;
		StorageTmp->datalinkEntityProviderEntityNamesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmT1Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lAPBDLEmT1Timer for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->lAPBDLEmT1Timer;
		StorageTmp->lAPBDLEmT1Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT1Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmT3Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lAPBDLEmT3Timer for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->lAPBDLEmT3Timer;
		StorageTmp->lAPBDLEmT3Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT3Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmW(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmW(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmW entering action=%d...  \n", action));
	StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmW: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmW not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmW: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lAPBDLEmW for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->lAPBDLEmW;
		StorageTmp->lAPBDLEmW = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmW = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmXSend(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmXSend(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmXSend entering action=%d...  \n", action));
	StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXSend: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXSend not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXSend: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lAPBDLEmXSend for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->lAPBDLEmXSend;
		StorageTmp->lAPBDLEmXSend = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmXSend = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmXReceive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmXReceive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmXReceive entering action=%d...  \n", action));
	StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXReceive: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXReceive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmXReceive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lAPBDLEmXReceive for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->lAPBDLEmXReceive;
		StorageTmp->lAPBDLEmXReceive = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmXReceive = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLEmT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lAPBDLEmT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lAPBDLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lAPBDLEmT2Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lAPBDLERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLEmT2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lAPBDLEmT2Timer for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->lAPBDLEmT2Timer;
		StorageTmp->lAPBDLEmT2Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lAPBDLEmT2Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPPMadministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPPMadministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPPMTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPPMadministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPPMTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPPMRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPPMADMINISTRATIVESTATE_LOCKED:
		case SLPPMADMINISTRATIVESTATE_UNLOCKED:
		case SLPPMADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMadministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPPMadministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPPMadministrativeState;
		StorageTmp->sLPPMadministrativeState = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPPMadministrativeState = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionInterfaceType entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPCONNECTIONINTERFACETYPE_DTE:
		case SLPCONNECTIONINTERFACETYPE_DCE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionInterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionInterfaceType for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionInterfaceType;
		StorageTmp->sLPConnectionInterfaceType = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionInterfaceType = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionK entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionK: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionK for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionK;
		StorageTmp->sLPConnectionK = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionK = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionN1 entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionN1 for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionN1;
		StorageTmp->sLPConnectionN1 = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionN1 = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionN2 entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionN2 for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionN2;
		StorageTmp->sLPConnectionN2 = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionN2 = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionSequenceModulus entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 128..128 */
		if (set_value != 8 && set_value != 128) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionSequenceModulus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionSequenceModulus for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionSequenceModulus;
		StorageTmp->sLPConnectionSequenceModulus = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionSequenceModulus = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT1Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionT1Timer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionT1Timer;
		StorageTmp->sLPConnectionT1Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT1Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT2Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionT2Timer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionT2Timer;
		StorageTmp->sLPConnectionT2Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT2Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT3Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionT3Timer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionT3Timer;
		StorageTmp->sLPConnectionT3Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT3Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionT4Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionT4Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionT4Timer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionT4Timer;
		StorageTmp->sLPConnectionT4Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionT4Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPCONNECTIONADMINISTRATIVESTATE_LOCKED:
		case SLPCONNECTIONADMINISTRATIVESTATE_UNLOCKED:
		case SLPCONNECTIONADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionAdministrativeState for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionAdministrativeState;
		StorageTmp->sLPConnectionAdministrativeState = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionAdministrativeState = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOinterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOinterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOinterfaceType entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SLPCONNECTIONIVMOINTERFACETYPE_DTE:
		case SLPCONNECTIONIVMOINTERFACETYPE_DCE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOinterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionIVMOinterfaceType for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionIVMOinterfaceType;
		StorageTmp->sLPConnectionIVMOinterfaceType = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOinterfaceType = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOk(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOk(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOk entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOk: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOk not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOk: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionIVMOk for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionIVMOk;
		StorageTmp->sLPConnectionIVMOk = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOk = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOn1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOn1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOn1 entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionIVMOn1 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionIVMOn1;
		StorageTmp->sLPConnectionIVMOn1 = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOn1 = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOn2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOn2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOn2 entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOn2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionIVMOn2 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionIVMOn2;
		StorageTmp->sLPConnectionIVMOn2 = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOn2 = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOsequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOsequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOsequenceModulus entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 128..128 */
		if (set_value != 8 && set_value != 128) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOsequenceModulus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionIVMOsequenceModulus for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionIVMOsequenceModulus;
		StorageTmp->sLPConnectionIVMOsequenceModulus = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOsequenceModulus = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOt1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOt1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt1Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionIVMOt1Timer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionIVMOt1Timer;
		StorageTmp->sLPConnectionIVMOt1Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt1Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOt2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOt2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt2Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionIVMOt2Timer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionIVMOt2Timer;
		StorageTmp->sLPConnectionIVMOt2Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt2Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOt3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOt3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt3Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionIVMOt3Timer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionIVMOt3Timer;
		StorageTmp->sLPConnectionIVMOt3Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt3Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMOt4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sLPConnectionIVMOt4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMOt4Timer entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sLPConnectionIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMOt4Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sLPConnectionIVMOt4Timer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->sLPConnectionIVMOt4Timer;
		StorageTmp->sLPConnectionIVMOt4Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionIVMOt4Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationLLCName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationLLCName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCStationLLCName entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationLLCName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationLLCName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationLLCName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationLLCName;
		old_length = StorageTmp->lLCStationLLCNameLen;
		StorageTmp->lLCStationLLCName = string;
		StorageTmp->lLCStationLLCNameLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationLLCName = old_value;
		StorageTmp->lLCStationLLCNameLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationSupportedServicesTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationSupportedServicesTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCStationSupportedServicesTypes entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSupportedServicesTypes: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationSupportedServicesTypes for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationSupportedServicesTypes;
		old_length = StorageTmp->lLCStationSupportedServicesTypesLen;
		StorageTmp->lLCStationSupportedServicesTypes = string;
		StorageTmp->lLCStationSupportedServicesTypesLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationSupportedServicesTypes = old_value;
		StorageTmp->lLCStationSupportedServicesTypesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationType1AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationType1AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationType1AcknowledgeTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationType1AcknowledgeTimeoutValue for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType1AcknowledgeTimeoutValue;
		StorageTmp->lLCStationType1AcknowledgeTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType1AcknowledgeTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationType1MaximumRetryCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationType1MaximumRetryCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationType1MaximumRetryCount entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1MaximumRetryCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType1MaximumRetryCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationType1MaximumRetryCount for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType1MaximumRetryCount;
		StorageTmp->lLCStationType1MaximumRetryCount = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType1MaximumRetryCount = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationMaximumPDUN3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationMaximumPDUN3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationMaximumPDUN3 entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumPDUN3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumPDUN3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationMaximumPDUN3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationMaximumPDUN3;
		StorageTmp->lLCStationMaximumPDUN3 = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationMaximumPDUN3 = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationMaximumRetransmissions4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationMaximumRetransmissions4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationMaximumRetransmissions4 entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumRetransmissions4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationMaximumRetransmissions4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationMaximumRetransmissions4 for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationMaximumRetransmissions4;
		StorageTmp->lLCStationMaximumRetransmissions4 = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationMaximumRetransmissions4 = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationReceiveVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationReceiveVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationReceiveVariableLifetime entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationReceiveVariableLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationReceiveVariableLifetime for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationReceiveVariableLifetime;
		StorageTmp->lLCStationReceiveVariableLifetime = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationReceiveVariableLifetime = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationTransmitVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationTransmitVariableLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationTransmitVariableLifetime entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationTransmitVariableLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationTransmitVariableLifetime for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationTransmitVariableLifetime;
		StorageTmp->lLCStationTransmitVariableLifetime = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationTransmitVariableLifetime = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationType3AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationType3AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationType3AcknowledgeTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationType3AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationType3AcknowledgeTimeoutValue for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationType3AcknowledgeTimeoutValue;
		StorageTmp->lLCStationType3AcknowledgeTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationType3AcknowledgeTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationBufferSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationBufferSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationBufferSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationBufferSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationBufferSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationBufferSize for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationBufferSize;
		StorageTmp->lLCStationBufferSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationBufferSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationSTRIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationSTRIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCStationSTRIndicator entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationSTRIndicator: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationSTRIndicator for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationSTRIndicator;
		old_length = StorageTmp->lLCStationSTRIndicatorLen;
		StorageTmp->lLCStationSTRIndicator = string;
		StorageTmp->lLCStationSTRIndicatorLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationSTRIndicator = old_value;
		StorageTmp->lLCStationSTRIndicatorLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCStationVersionNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCStationVersionNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCStationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCStationVersionNumber entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCStationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationVersionNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCStationVersionNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCStationVersionNumber for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCStationVersionNumber;
		StorageTmp->lLCStationVersionNumber = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCStationVersionNumber = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupAgingEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupAgingEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupAgingEnabled entering action=%d...  \n", action));
	StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->rDESetupAgingEnabled for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupAgingEnabled;
		StorageTmp->rDESetupAgingEnabled = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupAgingEnabled = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupAgingValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupAgingValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupAgingValue entering action=%d...  \n", action));
	StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupAgingValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->rDESetupAgingValue for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupAgingValue;
		StorageTmp->rDESetupAgingValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupAgingValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupEnableType2Reset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupEnableType2Reset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupEnableType2Reset entering action=%d...  \n", action));
	StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupEnableType2Reset not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupEnableType2Reset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->rDESetupEnableType2Reset for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupEnableType2Reset;
		StorageTmp->rDESetupEnableType2Reset = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupEnableType2Reset = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupMaximumRouteDescriptors(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupMaximumRouteDescriptors(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupMaximumRouteDescriptors entering action=%d...  \n", action));
	StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumRouteDescriptors not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumRouteDescriptors: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->rDESetupMaximumRouteDescriptors for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMaximumRouteDescriptors;
		StorageTmp->rDESetupMaximumRouteDescriptors = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMaximumRouteDescriptors = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupMaximumResponseTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupMaximumResponseTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupMaximumResponseTime entering action=%d...  \n", action));
	StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMaximumResponseTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->rDESetupMaximumResponseTime for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMaximumResponseTime;
		StorageTmp->rDESetupMaximumResponseTime = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMaximumResponseTime = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupMinimumPDUSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupMinimumPDUSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupMinimumPDUSize entering action=%d...  \n", action));
	StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMinimumPDUSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupMinimumPDUSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->rDESetupMinimumPDUSize for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupMinimumPDUSize;
		StorageTmp->rDESetupMinimumPDUSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupMinimumPDUSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupRDEHold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupRDEHold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupRDEHold entering action=%d...  \n", action));
	StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEHold: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->rDESetupRDEHold for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupRDEHold;
		StorageTmp->rDESetupRDEHold = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupRDEHold = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupRDEReplace(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupRDEReplace(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupRDEReplace entering action=%d...  \n", action));
	StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupRDEReplace: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->rDESetupRDEReplace for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupRDEReplace;
		StorageTmp->rDESetupRDEReplace = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupRDEReplace = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_rDESetupResetOnTestEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_rDESetupResetOnTestEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct rDESetupTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_rDESetupResetOnTestEnabled entering action=%d...  \n", action));
	StorageTmp = header_complex(rDESetupTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to rDESetupResetOnTestEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->rDESetupResetOnTestEnabled for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->rDESetupResetOnTestEnabled;
		StorageTmp->rDESetupResetOnTestEnabled = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->rDESetupResetOnTestEnabled = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnectionLessTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessName entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnectionLessTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnectionlessName for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessName;
		old_length = StorageTmp->lLCConnectionlessNameLen;
		StorageTmp->lLCConnectionlessName = string;
		StorageTmp->lLCConnectionlessNameLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessName = old_value;
		StorageTmp->lLCConnectionlessNameLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionLessTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnectionLessTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize for you to use, and you have just been asked to do something with it.
				   Note that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessMaximumLLCInformationFieldSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2Name entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2Name for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2Name;
		old_length = StorageTmp->lLCConnection2NameLen;
		StorageTmp->lLCConnection2Name = string;
		StorageTmp->lLCConnection2NameLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2Name = old_value;
		StorageTmp->lLCConnection2NameLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2MaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2MaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2MaximumRetransmissions entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2MaximumRetransmissions for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2MaximumRetransmissions;
		StorageTmp->lLCConnection2MaximumRetransmissions = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2MaximumRetransmissions = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2ReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2ReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2ReceivedWindowSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2ReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2ReceivedWindowSize for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2ReceivedWindowSize;
		StorageTmp->lLCConnection2ReceivedWindowSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2ReceivedWindowSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2SendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2SendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2SendWindowSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2SendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2SendWindowSize for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2SendWindowSize;
		StorageTmp->lLCConnection2SendWindowSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2SendWindowSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2AcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2AcknowledgeTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2AcknowledgeTimeoutValue for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2AcknowledgeTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AcknowledgeTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2BusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2BusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2BusyStateTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2BusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2BusyStateTimeoutValue for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2BusyStateTimeoutValue;
		StorageTmp->lLCConnection2BusyStateTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2BusyStateTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2PBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2PBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2PBitTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2PBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2PBitTimeoutValue for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2PBitTimeoutValue;
		StorageTmp->lLCConnection2PBitTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2PBitTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2RejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2RejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2RejectTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2RejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2RejectTimeoutValue for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2RejectTimeoutValue;
		StorageTmp->lLCConnection2RejectTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2RejectTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2Route(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2Route(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2Route entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Route not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2Route: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2Route for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2Route;
		old_length = StorageTmp->lLCConnection2RouteLen;
		StorageTmp->lLCConnection2Route = string;
		StorageTmp->lLCConnection2RouteLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2Route = old_value;
		StorageTmp->lLCConnection2RouteLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2KStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2KStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2KStep entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2KStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2KStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2KStep for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2KStep;
		StorageTmp->lLCConnection2KStep = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2KStep = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2MaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2MaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2MaxSendWindowSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2MaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2MaxSendWindowSize for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2MaxSendWindowSize;
		StorageTmp->lLCConnection2MaxSendWindowSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2MaxSendWindowSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2OptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2OptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2OptionalTolerationIPDUs entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2OptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2OptionalTolerationIPDUs for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2OptionalTolerationIPDUs;
		StorageTmp->lLCConnection2OptionalTolerationIPDUs = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2OptionalTolerationIPDUs = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2AdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case LLCCONNECTION2ADMINISTRATIVESTATE_LOCKED:
		case LLCCONNECTION2ADMINISTRATIVESTATE_UNLOCKED:
		case LLCCONNECTION2ADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2AdministrativeState for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AdministrativeState;
		StorageTmp->lLCConnection2AdministrativeState = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AdministrativeState = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2AlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2AlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct lLCConnection2Table_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2AlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2AlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2AlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2AlarmStatus;
		old_length = StorageTmp->lLCConnection2AlarmStatusLen;
		StorageTmp->lLCConnection2AlarmStatus = string;
		StorageTmp->lLCConnection2AlarmStatusLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2AlarmStatus = old_value;
		StorageTmp->lLCConnection2AlarmStatusLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOMaximumRetransmissions entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaximumRetransmissions not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMOMaximumRetransmissions for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOMaximumRetransmissions;
		StorageTmp->lLCConnection2IVMOMaximumRetransmissions = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOMaximumRetransmissions = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOReceivedWindowSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOReceivedWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMOReceivedWindowSize for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOReceivedWindowSize;
		StorageTmp->lLCConnection2IVMOReceivedWindowSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOReceivedWindowSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOSendWindowSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMOSendWindowSize for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOSendWindowSize;
		StorageTmp->lLCConnection2IVMOSendWindowSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOSendWindowSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOAcknowledgeTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOAcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOAcknowledgeTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOBusyStateTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue for you to use, and you have just been asked to do something with it.  Note that 
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue;
		StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOBusyStateTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOBitTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMOBitTimeoutValue for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOBitTimeoutValue;
		StorageTmp->lLCConnection2IVMOBitTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOBitTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMORejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMORejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMORejectTimeoutValue entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMORejectTimeoutValue for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMORejectTimeoutValue;
		StorageTmp->lLCConnection2IVMORejectTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMORejectTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMORoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMORoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMORoute entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORoute not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMORoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMORoute for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMORoute;
		StorageTmp->lLCConnection2IVMORoute = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMORoute = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOKStep entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOKStep not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMOKStep for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOKStep;
		StorageTmp->lLCConnection2IVMOKStep = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOKStep = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOMaxSendWindowSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaxSendWindowSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMOMaxSendWindowSize for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOMaxSendWindowSize;
		StorageTmp->lLCConnection2IVMOMaxSendWindowSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOMaxSendWindowSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2IVMOOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnection2IVMOOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnection2IVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2IVMOOptionalTolerationIPDUs entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnection2IVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2IVMOOptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs;
		StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2IVMOOptionalTolerationIPDUs = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize for you to use, and you have just been asked to do something with it. 
				   Note that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckMaximumLLCInformationFieldSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckMaximumRetransmissions entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnectionlessAckMaximumRetransmissions for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckMaximumRetransmissions = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckMaximumRetransmissions = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckReceiveResources(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckReceiveResources(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckReceiveResources entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnectionlessAckTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckReceiveResources: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnectionlessAckReceiveResources for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckReceiveResources;
		StorageTmp->lLCConnectionlessAckReceiveResources = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckReceiveResources = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lLCConnectionlessAckIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize for you to use, and you have just been asked to do something with 
				   it.  Note that anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckIVMOMaximumLLCInformationFieldSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckIVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lLCConnectionlessAckIVMOMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckIVMOMaximumRetransmissions entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->lLCConnectionlessAckIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMOMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions for you to use, and you have just been asked to do something with it.
				   Note that anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckIVMOMaximumRetransmissions = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_networkEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_networkEntityTitles(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct networkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_networkEntityTitles entering action=%d...  \n", action));
	StorageTmp = header_complex(networkEntityTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->networkEntityRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityTitles: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityTitles not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityTitles: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->networkEntityTitles for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->networkEntityTitles;
		old_length = StorageTmp->networkEntityTitlesLen;
		StorageTmp->networkEntityTitles = string;
		StorageTmp->networkEntityTitlesLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->networkEntityTitles = old_value;
		StorageTmp->networkEntityTitlesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_networkEntitySystemTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_networkEntitySystemTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct networkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_networkEntitySystemTypes entering action=%d...  \n", action));
	StorageTmp = header_complex(networkEntityTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->networkEntityRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntitySystemTypes: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->networkEntitySystemTypes for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->networkEntitySystemTypes;
		old_length = StorageTmp->networkEntitySystemTypesLen;
		StorageTmp->networkEntitySystemTypes = string;
		StorageTmp->networkEntitySystemTypesLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->networkEntitySystemTypes = old_value;
		StorageTmp->networkEntitySystemTypesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cLNSAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(cLNSTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case CLNSADMINISTRATIVESTATE_LOCKED:
		case CLNSADMINISTRATIVESTATE_UNLOCKED:
		case CLNSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->cLNSAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->cLNSAdministrativeState;
		StorageTmp->cLNSAdministrativeState = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSAdministrativeState = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSSupportedProtocols(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSSupportedProtocols(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_cLNSSupportedProtocols entering action=%d...  \n", action));
	StorageTmp = header_complex(cLNSTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSSupportedProtocols: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSSupportedProtocols not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSSupportedProtocols: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->cLNSSupportedProtocols for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->cLNSSupportedProtocols;
		old_length = StorageTmp->cLNSSupportedProtocolsLen;
		StorageTmp->cLNSSupportedProtocols = string;
		StorageTmp->cLNSSupportedProtocolsLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSSupportedProtocols = old_value;
		StorageTmp->cLNSSupportedProtocolsLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_cLNSOperationalSystemType entering action=%d...  \n", action));
	StorageTmp = header_complex(cLNSTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSOperationalSystemType: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->cLNSOperationalSystemType for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->cLNSOperationalSystemType;
		old_length = StorageTmp->cLNSOperationalSystemTypeLen;
		StorageTmp->cLNSOperationalSystemType = string;
		StorageTmp->cLNSOperationalSystemTypeLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSOperationalSystemType = old_value;
		StorageTmp->cLNSOperationalSystemTypeLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSMaximumLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSMaximumLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cLNSMaximumLifetime entering action=%d...  \n", action));
	StorageTmp = header_complex(cLNSTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..255 */
		if ((1 > set_value || set_value > 255)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSMaximumLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->cLNSMaximumLifetime for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->cLNSMaximumLifetime;
		StorageTmp->cLNSMaximumLifetime = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSMaximumLifetime = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSEnableChecksum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cLNSEnableChecksum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct cLNSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cLNSEnableChecksum entering action=%d...  \n", action));
	StorageTmp = header_complex(cLNSTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cLNSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSEnableChecksum: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->cLNSEnableChecksum for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->cLNSEnableChecksum;
		StorageTmp->cLNSEnableChecksum = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cLNSEnableChecksum = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cONSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cONSAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct cONSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_cONSAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(cONSTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cONSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case CONSADMINISTRATIVESTATE_LOCKED:
		case CONSADMINISTRATIVESTATE_UNLOCKED:
		case CONSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->cONSAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->cONSAdministrativeState;
		StorageTmp->cONSAdministrativeState = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cONSAdministrativeState = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cONSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_cONSOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct cONSTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_cONSOperationalSystemType entering action=%d...  \n", action));
	StorageTmp = header_complex(cONSTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->cONSRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSOperationalSystemType: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->cONSOperationalSystemType for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->cONSOperationalSystemType;
		old_length = StorageTmp->cONSOperationalSystemTypeLen;
		StorageTmp->cONSOperationalSystemType = string;
		StorageTmp->cONSOperationalSystemTypeLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->cONSOperationalSystemType = old_value;
		StorageTmp->cONSOperationalSystemTypeLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_neighbourSNPAAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_neighbourSNPAAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct adjacencyTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_neighbourSNPAAddress entering action=%d...  \n", action));
	StorageTmp = header_complex(adjacencyTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->adjacencyRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSNPAAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSNPAAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSNPAAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->neighbourSNPAAddress for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->neighbourSNPAAddress;
		old_length = StorageTmp->neighbourSNPAAddressLen;
		StorageTmp->neighbourSNPAAddress = string;
		StorageTmp->neighbourSNPAAddressLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->neighbourSNPAAddress = old_value;
		StorageTmp->neighbourSNPAAddressLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_neighbourSystemIds(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_neighbourSystemIds(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct adjacencyTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_neighbourSystemIds entering action=%d...  \n", action));
	StorageTmp = header_complex(adjacencyTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->adjacencyRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSystemIds: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSystemIds not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to neighbourSystemIds: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->neighbourSystemIds for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->neighbourSystemIds;
		old_length = StorageTmp->neighbourSystemIdsLen;
		StorageTmp->neighbourSystemIds = string;
		StorageTmp->neighbourSystemIdsLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->neighbourSystemIds = old_value;
		StorageTmp->neighbourSystemIdsLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationDefaultMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationDefaultMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationDefaultMetricPathCost entering action=%d...  \n", action));
	StorageTmp = header_complex(destinationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->destinationDefaultMetricPathCost for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDefaultMetricPathCost;
		StorageTmp->destinationDefaultMetricPathCost = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDefaultMetricPathCost = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationDefaultMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationDefaultMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationDefaultMetricOutputAdjacencies entering action=%d...  \n", action));
	StorageTmp = header_complex(destinationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDefaultMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->destinationDefaultMetricOutputAdjacencies for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDefaultMetricOutputAdjacencies;
		old_length = StorageTmp->destinationDefaultMetricOutputAdjacenciesLen;
		StorageTmp->destinationDefaultMetricOutputAdjacencies = string;
		StorageTmp->destinationDefaultMetricOutputAdjacenciesLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDefaultMetricOutputAdjacencies = old_value;
		StorageTmp->destinationDefaultMetricOutputAdjacenciesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationDelayMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationDelayMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationDelayMetricPathCost entering action=%d...  \n", action));
	StorageTmp = header_complex(destinationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->destinationDelayMetricPathCost for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDelayMetricPathCost;
		StorageTmp->destinationDelayMetricPathCost = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDelayMetricPathCost = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationDelayMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationDelayMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationDelayMetricOutputAdjacencies entering action=%d...  \n", action));
	StorageTmp = header_complex(destinationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationDelayMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->destinationDelayMetricOutputAdjacencies for you to use, and you have just been asked to do something with it.  Note that 
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationDelayMetricOutputAdjacencies;
		old_length = StorageTmp->destinationDelayMetricOutputAdjacenciesLen;
		StorageTmp->destinationDelayMetricOutputAdjacencies = string;
		StorageTmp->destinationDelayMetricOutputAdjacenciesLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationDelayMetricOutputAdjacencies = old_value;
		StorageTmp->destinationDelayMetricOutputAdjacenciesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationExpenseMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationExpenseMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationExpenseMetricPathCost entering action=%d...  \n", action));
	StorageTmp = header_complex(destinationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->destinationExpenseMetricPathCost for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationExpenseMetricPathCost;
		StorageTmp->destinationExpenseMetricPathCost = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationExpenseMetricPathCost = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationExpenseMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationExpenseMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationExpenseMetricOutputAdjacencies entering action=%d...  \n", action));
	StorageTmp = header_complex(destinationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationExpenseMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->destinationExpenseMetricOutputAdjacencies for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationExpenseMetricOutputAdjacencies;
		old_length = StorageTmp->destinationExpenseMetricOutputAdjacenciesLen;
		StorageTmp->destinationExpenseMetricOutputAdjacencies = string;
		StorageTmp->destinationExpenseMetricOutputAdjacenciesLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationExpenseMetricOutputAdjacencies = old_value;
		StorageTmp->destinationExpenseMetricOutputAdjacenciesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationErrorMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationErrorMetricPathCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_destinationErrorMetricPathCost entering action=%d...  \n", action));
	StorageTmp = header_complex(destinationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricPathCost not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricPathCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1023 */
		if ((0 > set_value || set_value > 1023)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricPathCost: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->destinationErrorMetricPathCost for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationErrorMetricPathCost;
		StorageTmp->destinationErrorMetricPathCost = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationErrorMetricPathCost = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_destinationErrorMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_destinationErrorMetricOutputAdjacencies(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct destinationTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_destinationErrorMetricOutputAdjacencies entering action=%d...  \n", action));
	StorageTmp = header_complex(destinationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricOutputAdjacencies not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to destinationErrorMetricOutputAdjacencies: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->destinationErrorMetricOutputAdjacencies for you to use, and you have just been asked to do something with it.  Note that 
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->destinationErrorMetricOutputAdjacencies;
		old_length = StorageTmp->destinationErrorMetricOutputAdjacenciesLen;
		StorageTmp->destinationErrorMetricOutputAdjacencies = string;
		StorageTmp->destinationErrorMetricOutputAdjacenciesLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->destinationErrorMetricOutputAdjacencies = old_value;
		StorageTmp->destinationErrorMetricOutputAdjacenciesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressPrefix entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressPrefix: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..21 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 21))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressPrefix for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressPrefix;
		old_length = StorageTmp->reachableAddressPrefixLen;
		StorageTmp->reachableAddressPrefix = string;
		StorageTmp->reachableAddressPrefixLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressPrefix = old_value;
		StorageTmp->reachableAddressPrefixLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressMappingType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressMappingType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressMappingType entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case REACHABLEADDRESSMAPPINGTYPE_NONE:
		case REACHABLEADDRESSMAPPINGTYPE_EXPLICIT:
		case REACHABLEADDRESSMAPPINGTYPE_EXTRACTIDI:
		case REACHABLEADDRESSMAPPINGTYPE_EXTRACTDSP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressMappingType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressMappingType for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressMappingType;
		StorageTmp->reachableAddressMappingType = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressMappingType = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressDefaultMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressDefaultMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDefaultMetric entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 1..63 */
		if ((1 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressDefaultMetric for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressDefaultMetric;
		StorageTmp->reachableAddressDefaultMetric = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDefaultMetric = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressDelayMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressDelayMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDelayMetric entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressDelayMetric for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressDelayMetric;
		StorageTmp->reachableAddressDelayMetric = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDelayMetric = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressExpenseMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressExpenseMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressExpenseMetric entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressExpenseMetric for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressExpenseMetric;
		StorageTmp->reachableAddressExpenseMetric = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressExpenseMetric = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressErrorMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressErrorMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressErrorMetric entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressErrorMetric for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressErrorMetric;
		StorageTmp->reachableAddressErrorMetric = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressErrorMetric = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressDefaultMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressDefaultMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDefaultMetricType entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSDEFAULTMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSDEFAULTMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDefaultMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressDefaultMetricType for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressDefaultMetricType;
		StorageTmp->reachableAddressDefaultMetricType = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDefaultMetricType = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressDelayMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressDelayMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressDelayMetricType entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSDELAYMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSDELAYMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressDelayMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressDelayMetricType for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressDelayMetricType;
		StorageTmp->reachableAddressDelayMetricType = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressDelayMetricType = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressExpenseMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressExpenseMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressExpenseMetricType entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSEXPENSEMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSEXPENSEMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressExpenseMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressExpenseMetricType for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressExpenseMetricType;
		StorageTmp->reachableAddressExpenseMetricType = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressExpenseMetricType = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressErrorMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressErrorMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressErrorMetricType entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case REACHABLEADDRESSERRORMETRICTYPE_INTERNAL:
		case REACHABLEADDRESSERRORMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressErrorMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressErrorMetricType for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressErrorMetricType;
		StorageTmp->reachableAddressErrorMetricType = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressErrorMetricType = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_reachableAddressAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case REACHABLEADDRESSADMINISTRATIVESTATE_LOCKED:
		case REACHABLEADDRESSADMINISTRATIVESTATE_UNLOCKED:
		case REACHABLEADDRESSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressAdministrativeState for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressAdministrativeState;
		StorageTmp->reachableAddressAdministrativeState = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressAdministrativeState = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressSNPAAddresses(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressSNPAAddresses(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressSNPAAddresses entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAAddresses: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAAddresses not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAAddresses: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressSNPAAddresses for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressSNPAAddresses;
		old_length = StorageTmp->reachableAddressSNPAAddressesLen;
		StorageTmp->reachableAddressSNPAAddresses = string;
		StorageTmp->reachableAddressSNPAAddressesLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressSNPAAddresses = old_value;
		StorageTmp->reachableAddressSNPAAddressesLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressSNPAMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressSNPAMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressSNPAMask entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAMask: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAMask not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressSNPAMask for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressSNPAMask;
		old_length = StorageTmp->reachableAddressSNPAMaskLen;
		StorageTmp->reachableAddressSNPAMask = string;
		StorageTmp->reachableAddressSNPAMaskLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressSNPAMask = old_value;
		StorageTmp->reachableAddressSNPAMaskLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressSNPAPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_reachableAddressSNPAPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct reachableAddressTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 15;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressSNPAPrefix entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->reachableAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAPrefix: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..21 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 21))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressSNPAPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->reachableAddressSNPAPrefix for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->reachableAddressSNPAPrefix;
		old_length = StorageTmp->reachableAddressSNPAPrefixLen;
		StorageTmp->reachableAddressSNPAPrefix = string;
		StorageTmp->reachableAddressSNPAPrefixLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->reachableAddressSNPAPrefix = old_value;
		StorageTmp->reachableAddressSNPAPrefixLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultInterfaceType entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value dTE */
		switch (set_value) {
		case SLPCONNECTIONDEFAULTINTERFACETYPE_DTE:
		case SLPCONNECTIONDEFAULTINTERFACETYPE_DCE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultInterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultInterfaceType;
		StorageTmp->sLPConnectionDefaultInterfaceType = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultInterfaceType = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultK entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultK not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultK;
		StorageTmp->sLPConnectionDefaultK = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultK = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultN1 entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultN1;
		StorageTmp->sLPConnectionDefaultN1 = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultN1 = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultN2 entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultN2;
		StorageTmp->sLPConnectionDefaultN2 = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultN2 = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultSequenceModulus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultSequenceModulus entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultSequenceModulus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultSequenceModulus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 8..8 128..128 */
		if (set_value != 8 && set_value != 128) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultSequenceModulus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultSequenceModulus;
		StorageTmp->sLPConnectionDefaultSequenceModulus = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultSequenceModulus = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultT1Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT1Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT1Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT1Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT1Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT1Timer;
		StorageTmp->sLPConnectionDefaultT1Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT1Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultT2Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT2Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT2Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT2Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT2Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT2Timer;
		StorageTmp->sLPConnectionDefaultT2Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT2Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultT3Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT3Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT3Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT3Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT3Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT3Timer;
		StorageTmp->sLPConnectionDefaultT3Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT3Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionDefaultT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_sLPConnectionDefaultT4Timer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionDefaultT4Timer entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT4Timer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT4Timer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionDefaultT4Timer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sLPConnectionDefaultT4Timer;
		StorageTmp->sLPConnectionDefaultT4Timer = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sLPConnectionDefaultT4Timer = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultMaximumRetransmissions;
		StorageTmp->lLCConnection2DefaultMaximumRetransmissions = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultMaximumRetransmissions = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultReceivedWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultReceivedWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultReceivedWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultReceivedWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultReceivedWindowSize;
		StorageTmp->lLCConnection2DefaultReceivedWindowSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultReceivedWindowSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultSendWindowSize;
		StorageTmp->lLCConnection2DefaultSendWindowSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultSendWindowSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultAcknowledgeTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultAcknowledgeTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultAcknowledgeTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue;
		StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultAcknowledgeTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultBusyStateTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultBusyStateTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultBusyStateTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue;
		StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultBusyStateTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultPBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultPBitTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultPBitTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultPBitTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultPBitTimeoutValue;
		StorageTmp->lLCConnection2DefaultPBitTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultPBitTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultRejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultRejectTimeoutValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultRejectTimeoutValue entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRejectTimeoutValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultRejectTimeoutValue;
		StorageTmp->lLCConnection2DefaultRejectTimeoutValue = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultRejectTimeoutValue = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultRoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultRoute(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct dlMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultRoute entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		string = NULL;
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRoute not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultRoute: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultRoute;
		old_length = StorageTmp->lLCConnection2DefaultRouteLen;
		StorageTmp->lLCConnection2DefaultRoute = string;
		StorageTmp->lLCConnection2DefaultRouteLen = var_val_len;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultRoute = old_value;
		StorageTmp->lLCConnection2DefaultRouteLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultKStep(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultKStep entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultKStep not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultKStep: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultKStep;
		StorageTmp->lLCConnection2DefaultKStep = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultKStep = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultMaxSendWindowSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultMaxSendWindowSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaxSendWindowSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultMaxSendWindowSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultMaxSendWindowSize;
		StorageTmp->lLCConnection2DefaultMaxSendWindowSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultMaxSendWindowSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnection2DefaultOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnection2DefaultOptionalTolerationIPDUs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnection2DefaultOptionalTolerationIPDUs entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnection2DefaultOptionalTolerationIPDUs: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs;
		StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnection2DefaultOptionalTolerationIPDUs = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize;
		StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckDefaultMaximumLLCInformationFieldSize = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckDefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lLCConnectionlessAckDefaultMaximumRetransmissions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct dlMIB_data *StorageTmp = NULL;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckDefaultMaximumRetransmissions entering action=%d...  \n", action));
	if ((StorageTmp = dlMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumRetransmissions not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckDefaultMaximumRetransmissions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions;
		StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->lLCConnectionlessAckDefaultMaximumRetransmissions = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int communicationsEntityTable_consistent(struct communicationsEntityTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the communicationsEntityTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
communicationsEntityTable_consistent(struct communicationsEntityTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int sap1Table_consistent(struct sap1Table_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sap1Table table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
sap1Table_consistent(struct sap1Table_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int sap2Table_consistent(struct sap2Table_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sap2Table table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
sap2Table_consistent(struct sap2Table_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int clProtocolMachineTable_consistent(struct clProtocolMachineTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the clProtocolMachineTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
clProtocolMachineTable_consistent(struct clProtocolMachineTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int coProtocolMachineTable_consistent(struct coProtocolMachineTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the coProtocolMachineTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
coProtocolMachineTable_consistent(struct coProtocolMachineTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int singlePeerConnectionTable_consistent(struct singlePeerConnectionTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the singlePeerConnectionTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
singlePeerConnectionTable_consistent(struct singlePeerConnectionTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int physicalEntityTable_consistent(struct physicalEntityTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the physicalEntityTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
physicalEntityTable_consistent(struct physicalEntityTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int physicalSAPTable_consistent(struct physicalSAPTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the physicalSAPTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
physicalSAPTable_consistent(struct physicalSAPTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int dataCircuitTable_consistent(struct dataCircuitTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the dataCircuitTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
dataCircuitTable_consistent(struct dataCircuitTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int physicalConnectionTable_consistent(struct physicalConnectionTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the physicalConnectionTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
physicalConnectionTable_consistent(struct physicalConnectionTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int datalinkEntityTable_consistent(struct datalinkEntityTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the datalinkEntityTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
datalinkEntityTable_consistent(struct datalinkEntityTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int dLSAPTable_consistent(struct dLSAPTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the dLSAPTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
dLSAPTable_consistent(struct dLSAPTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lAPBDLETable_consistent(struct lAPBDLETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lAPBDLETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lAPBDLETable_consistent(struct lAPBDLETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int sLPPMTable_consistent(struct sLPPMTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sLPPMTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
sLPPMTable_consistent(struct sLPPMTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int sLPConnectionTable_consistent(struct sLPConnectionTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sLPConnectionTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
sLPConnectionTable_consistent(struct sLPConnectionTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int sLPConnectionIVMOTable_consistent(struct sLPConnectionIVMOTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sLPConnectionIVMOTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
sLPConnectionIVMOTable_consistent(struct sLPConnectionIVMOTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mACDLETable_consistent(struct mACDLETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mACDLETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mACDLETable_consistent(struct mACDLETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mACTable_consistent(struct mACTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mACTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mACTable_consistent(struct mACTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCDLETable_consistent(struct lLCDLETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCDLETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCDLETable_consistent(struct lLCDLETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCCLPMTable_consistent(struct lLCCLPMTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCCLPMTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCCLPMTable_consistent(struct lLCCLPMTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCCOPMTable_consistent(struct lLCCOPMTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCCOPMTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCCOPMTable_consistent(struct lLCCOPMTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int resourceTypeIdTable_consistent(struct resourceTypeIdTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the resourceTypeIdTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
resourceTypeIdTable_consistent(struct resourceTypeIdTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCStationTable_consistent(struct lLCStationTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCStationTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCStationTable_consistent(struct lLCStationTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCSAPTable_consistent(struct lLCSAPTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCSAPTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCSAPTable_consistent(struct lLCSAPTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int rDESetupTable_consistent(struct rDESetupTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the rDESetupTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
rDESetupTable_consistent(struct rDESetupTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int rDEPairTable_consistent(struct rDEPairTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the rDEPairTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
rDEPairTable_consistent(struct rDEPairTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCConnectionLessTable_consistent(struct lLCConnectionLessTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCConnectionLessTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCConnectionLessTable_consistent(struct lLCConnectionLessTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCConnection2Table_consistent(struct lLCConnection2Table_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCConnection2Table table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCConnection2Table_consistent(struct lLCConnection2Table_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCConnection2IVMOTable_consistent(struct lLCConnection2IVMOTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCConnection2IVMOTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCConnection2IVMOTable_consistent(struct lLCConnection2IVMOTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCConnectionlessAckTable_consistent(struct lLCConnectionlessAckTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCConnectionlessAckTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCConnectionlessAckTable_consistent(struct lLCConnectionlessAckTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int lLCConnectionlessAckIVMOTable_consistent(struct lLCConnectionlessAckIVMOTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the lLCConnectionlessAckIVMOTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
lLCConnectionlessAckIVMOTable_consistent(struct lLCConnectionlessAckIVMOTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int networkEntityTable_consistent(struct networkEntityTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the networkEntityTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
networkEntityTable_consistent(struct networkEntityTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int nSAPTable_consistent(struct nSAPTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the nSAPTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
nSAPTable_consistent(struct nSAPTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int cLNSTable_consistent(struct cLNSTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the cLNSTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
cLNSTable_consistent(struct cLNSTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int cLNSISISTable_consistent(struct cLNSISISTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the cLNSISISTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
cLNSISISTable_consistent(struct cLNSISISTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int cLNSISISLevel2Table_consistent(struct cLNSISISLevel2Table_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the cLNSISISLevel2Table table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
cLNSISISLevel2Table_consistent(struct cLNSISISLevel2Table_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int linkageTable_consistent(struct linkageTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the linkageTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
linkageTable_consistent(struct linkageTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int cONSTable_consistent(struct cONSTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the cONSTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
cONSTable_consistent(struct cONSTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int networkConnectionTable_consistent(struct networkConnectionTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the networkConnectionTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
networkConnectionTable_consistent(struct networkConnectionTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int x25PLETable_consistent(struct x25PLETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the x25PLETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
x25PLETable_consistent(struct x25PLETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int x25PLE_DTETable_consistent(struct x25PLE_DTETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the x25PLE_DTETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
x25PLE_DTETable_consistent(struct x25PLE_DTETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int x25PLE_DCETable_consistent(struct x25PLE_DCETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the x25PLE_DCETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
x25PLE_DCETable_consistent(struct x25PLE_DCETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int x25PLEIVMOTable_consistent(struct x25PLEIVMOTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the x25PLEIVMOTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
x25PLEIVMOTable_consistent(struct x25PLEIVMOTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int x25PLEIVMO_DTETable_consistent(struct x25PLEIVMO_DTETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the x25PLEIVMO_DTETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
x25PLEIVMO_DTETable_consistent(struct x25PLEIVMO_DTETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int x25PLEIVMO_DCETable_consistent(struct x25PLEIVMO_DCETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the x25PLEIVMO_DCETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
x25PLEIVMO_DCETable_consistent(struct x25PLEIVMO_DCETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int virtualCallTable_consistent(struct virtualCallTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the virtualCallTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
virtualCallTable_consistent(struct virtualCallTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int virtualCircuitTable_consistent(struct virtualCircuitTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the virtualCircuitTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
virtualCircuitTable_consistent(struct virtualCircuitTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int virtualCircuit_DTETable_consistent(struct virtualCircuit_DTETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the virtualCircuit_DTETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
virtualCircuit_DTETable_consistent(struct virtualCircuit_DTETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int virtualCircuit_DCETable_consistent(struct virtualCircuit_DCETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the virtualCircuit_DCETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
virtualCircuit_DCETable_consistent(struct virtualCircuit_DCETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int permanentVirtualCircuitTable_consistent(struct permanentVirtualCircuitTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the permanentVirtualCircuitTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
permanentVirtualCircuitTable_consistent(struct permanentVirtualCircuitTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int permanentVirtualCircuit_DTETable_consistent(struct permanentVirtualCircuit_DTETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the permanentVirtualCircuit_DTETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
permanentVirtualCircuit_DTETable_consistent(struct permanentVirtualCircuit_DTETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int permanentVirtualCircuit_DCETable_consistent(struct permanentVirtualCircuit_DCETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the permanentVirtualCircuit_DCETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
permanentVirtualCircuit_DCETable_consistent(struct permanentVirtualCircuit_DCETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int virtualCallIVMOTable_consistent(struct virtualCallIVMOTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the virtualCallIVMOTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
virtualCallIVMOTable_consistent(struct virtualCallIVMOTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int switchedVirtualCallTable_consistent(struct switchedVirtualCallTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the switchedVirtualCallTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
switchedVirtualCallTable_consistent(struct switchedVirtualCallTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int virtualCall_DTETable_consistent(struct virtualCall_DTETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the virtualCall_DTETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
virtualCall_DTETable_consistent(struct virtualCall_DTETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int virtualCall_DCETable_consistent(struct virtualCall_DCETable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the virtualCall_DCETable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
virtualCall_DCETable_consistent(struct virtualCall_DCETable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int dSeriesCountsTable_consistent(struct dSeriesCountsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the dSeriesCountsTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
dSeriesCountsTable_consistent(struct dSeriesCountsTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int adjacencyTable_consistent(struct adjacencyTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the adjacencyTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
adjacencyTable_consistent(struct adjacencyTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int virtualAdjacencyTable_consistent(struct virtualAdjacencyTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the virtualAdjacencyTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
virtualAdjacencyTable_consistent(struct virtualAdjacencyTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int destinationTable_consistent(struct destinationTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the destinationTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
destinationTable_consistent(struct destinationTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int destinationSystemTable_consistent(struct destinationSystemTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the destinationSystemTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
destinationSystemTable_consistent(struct destinationSystemTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int destinationAreaTable_consistent(struct destinationAreaTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the destinationAreaTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
destinationAreaTable_consistent(struct destinationAreaTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int reachableAddressTable_consistent(struct reachableAddressTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the reachableAddressTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
reachableAddressTable_consistent(struct reachableAddressTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int write_physicalSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_physicalSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct physicalSAPTable_data *StorageTmp = NULL;
	static struct physicalSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_physicalSAPRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(physicalSAPTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalSAPRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->physicalSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->physicalSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->physicalSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sapId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* sapId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index sapId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = physicalSAPTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sapId, vp->val.string, vp->val_len);
			StorageNew->sapIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&physicalSAPTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				physicalSAPTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = physicalSAPTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->physicalSAPRowStatus;
			StorageTmp->physicalSAPRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = physicalSAPTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->physicalSAPRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->physicalSAPRowStatus;
			StorageTmp->physicalSAPRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->physicalSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->physicalSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			physicalSAPTable_destroy(&StorageDel);
			/* physicalSAPTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->physicalSAPRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				physicalSAPTable_del(StorageNew);
				physicalSAPTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				physicalSAPTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dataCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dataCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dataCircuitTable_data *StorageTmp = NULL;
	static struct dataCircuitTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_dataCircuitRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(dataCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dataCircuitRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dataCircuitRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dataCircuitTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dataCircuitTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = dataCircuitTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&dataCircuitTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dataCircuitTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = dataCircuitTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->dataCircuitRowStatus;
			StorageTmp->dataCircuitRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = dataCircuitTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->dataCircuitRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dataCircuitRowStatus;
			StorageTmp->dataCircuitRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->dataCircuitRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->dataCircuitRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dataCircuitTable_destroy(&StorageDel);
			/* dataCircuitTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dataCircuitRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				dataCircuitTable_del(StorageNew);
				dataCircuitTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				dataCircuitTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_physicalConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_physicalConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct physicalConnectionTable_data *StorageTmp = NULL;
	static struct physicalConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_physicalConnectionRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(physicalConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to physicalConnectionRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->physicalConnectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->physicalConnectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->physicalConnectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* connectionId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* connectionId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index connectionId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = physicalConnectionTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&physicalConnectionTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				physicalConnectionTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = physicalConnectionTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->physicalConnectionRowStatus;
			StorageTmp->physicalConnectionRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = physicalConnectionTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->physicalConnectionRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->physicalConnectionRowStatus;
			StorageTmp->physicalConnectionRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->physicalConnectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->physicalConnectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			physicalConnectionTable_destroy(&StorageDel);
			/* physicalConnectionTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->physicalConnectionRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				physicalConnectionTable_del(StorageNew);
				physicalConnectionTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				physicalConnectionTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_datalinkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_datalinkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct datalinkEntityTable_data *StorageTmp = NULL;
	static struct datalinkEntityTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_datalinkEntityRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(datalinkEntityTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to datalinkEntityRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->datalinkEntityRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->datalinkEntityTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->datalinkEntityTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = datalinkEntityTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&datalinkEntityTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				datalinkEntityTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = datalinkEntityTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->datalinkEntityRowStatus;
			StorageTmp->datalinkEntityRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = datalinkEntityTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->datalinkEntityRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->datalinkEntityRowStatus;
			StorageTmp->datalinkEntityRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->datalinkEntityRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->datalinkEntityRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			datalinkEntityTable_destroy(&StorageDel);
			/* datalinkEntityTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->datalinkEntityRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				datalinkEntityTable_del(StorageNew);
				datalinkEntityTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				datalinkEntityTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dLSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dLSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dLSAPTable_data *StorageTmp = NULL;
	static struct dLSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_dLSAPRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(dLSAPTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dLSAPRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dLSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dLSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dLSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sapId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* sapId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index sapId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = dLSAPTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sapId, vp->val.string, vp->val_len);
			StorageNew->sapIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&dLSAPTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dLSAPTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = dLSAPTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->dLSAPRowStatus;
			StorageTmp->dLSAPRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = dLSAPTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->dLSAPRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dLSAPRowStatus;
			StorageTmp->dLSAPRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->dLSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->dLSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dLSAPTable_destroy(&StorageDel);
			/* dLSAPTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dLSAPRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				dLSAPTable_del(StorageNew);
				dLSAPTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				dLSAPTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lAPBDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lAPBDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lAPBDLETable_data *StorageTmp = NULL;
	static struct lAPBDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_lAPBDLERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(lAPBDLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lAPBDLERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lAPBDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lAPBDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lAPBDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = lAPBDLETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&lAPBDLETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lAPBDLETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = lAPBDLETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->lAPBDLERowStatus;
			StorageTmp->lAPBDLERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = lAPBDLETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->lAPBDLERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lAPBDLERowStatus;
			StorageTmp->lAPBDLERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->lAPBDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->lAPBDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lAPBDLETable_destroy(&StorageDel);
			/* lAPBDLETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lAPBDLERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				lAPBDLETable_del(StorageNew);
				lAPBDLETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				lAPBDLETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sLPPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sLPPMTable_data *StorageTmp = NULL;
	static struct sLPPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_sLPPMRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPPMTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPPMRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sLPPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sLPPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sLPPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = sLPPMTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sLPPMTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sLPPMTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = sLPPMTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->sLPPMRowStatus;
			StorageTmp->sLPPMRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = sLPPMTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->sLPPMRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sLPPMRowStatus;
			StorageTmp->sLPPMRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->sLPPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->sLPPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sLPPMTable_destroy(&StorageDel);
			/* sLPPMTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sLPPMRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				sLPPMTable_del(StorageNew);
				sLPPMTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				sLPPMTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sLPConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sLPConnectionTable_data *StorageTmp = NULL;
	static struct sLPConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sLPConnectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sLPConnectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sLPConnectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* connectionId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* connectionId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index connectionId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = sLPConnectionTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sLPConnectionTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sLPConnectionTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = sLPConnectionTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->sLPConnectionRowStatus;
			StorageTmp->sLPConnectionRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = sLPConnectionTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->sLPConnectionRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sLPConnectionRowStatus;
			StorageTmp->sLPConnectionRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->sLPConnectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->sLPConnectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sLPConnectionTable_destroy(&StorageDel);
			/* sLPConnectionTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sLPConnectionRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				sLPConnectionTable_del(StorageNew);
				sLPConnectionTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				sLPConnectionTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sLPConnectionIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sLPConnectionIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sLPConnectionIVMOTable_data *StorageTmp = NULL;
	static struct sLPConnectionIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_sLPConnectionIVMORowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(sLPConnectionIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sLPConnectionIVMORowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sLPConnectionIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sLPConnectionIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sLPConnectionIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* connectionId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* connectionId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index connectionId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = sLPConnectionIVMOTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sLPConnectionIVMOTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sLPConnectionIVMOTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = sLPConnectionIVMOTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->sLPConnectionIVMORowStatus;
			StorageTmp->sLPConnectionIVMORowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = sLPConnectionIVMOTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->sLPConnectionIVMORowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sLPConnectionIVMORowStatus;
			StorageTmp->sLPConnectionIVMORowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->sLPConnectionIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->sLPConnectionIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sLPConnectionIVMOTable_destroy(&StorageDel);
			/* sLPConnectionIVMOTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sLPConnectionIVMORowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				sLPConnectionIVMOTable_del(StorageNew);
				sLPConnectionIVMOTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				sLPConnectionIVMOTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mACDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mACDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mACDLETable_data *StorageTmp = NULL;
	static struct mACDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_mACDLERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mACDLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACDLERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mACDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mACDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mACDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mACDLETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mACDLETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mACDLETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = mACDLETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->mACDLERowStatus;
			StorageTmp->mACDLERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = mACDLETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->mACDLERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mACDLERowStatus;
			StorageTmp->mACDLERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->mACDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->mACDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mACDLETable_destroy(&StorageDel);
			/* mACDLETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mACDLERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mACDLETable_del(StorageNew);
				mACDLETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mACDLETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mACRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mACRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mACTable_data *StorageTmp = NULL;
	static struct mACTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_mACRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mACTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mACRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mACRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mACTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mACTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mACId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mACId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mACId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mACTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mACId, vp->val.string, vp->val_len);
			StorageNew->mACIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mACTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mACTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = mACTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->mACRowStatus;
			StorageTmp->mACRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = mACTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->mACRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mACRowStatus;
			StorageTmp->mACRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->mACRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->mACRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mACTable_destroy(&StorageDel);
			/* mACTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mACRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mACTable_del(StorageNew);
				mACTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mACTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lLCDLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCDLETable_data *StorageTmp = NULL;
	static struct lLCDLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_lLCDLERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCDLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCDLERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCDLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCDLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCDLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = lLCDLETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&lLCDLETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lLCDLETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = lLCDLETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->lLCDLERowStatus;
			StorageTmp->lLCDLERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = lLCDLETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->lLCDLERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCDLERowStatus;
			StorageTmp->lLCDLERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->lLCDLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->lLCDLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCDLETable_destroy(&StorageDel);
			/* lLCDLETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCDLERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				lLCDLETable_del(StorageNew);
				lLCDLETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				lLCDLETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCCLPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lLCCLPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCCLPMTable_data *StorageTmp = NULL;
	static struct lLCCLPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_lLCCLPMRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCCLPMTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCLPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCLPMRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCCLPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCCLPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCCLPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* clProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* clProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index clProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = lLCCLPMTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&lLCCLPMTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lLCCLPMTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = lLCCLPMTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->lLCCLPMRowStatus;
			StorageTmp->lLCCLPMRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = lLCCLPMTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->lLCCLPMRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCCLPMRowStatus;
			StorageTmp->lLCCLPMRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->lLCCLPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->lLCCLPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCCLPMTable_destroy(&StorageDel);
			/* lLCCLPMTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCCLPMRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				lLCCLPMTable_del(StorageNew);
				lLCCLPMTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				lLCCLPMTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCCOPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lLCCOPMRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCCOPMTable_data *StorageTmp = NULL;
	static struct lLCCOPMTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_lLCCOPMRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCCOPMTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCOPMRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCCOPMRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCCOPMRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCCOPMTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCCOPMTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = lLCCOPMTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&lLCCOPMTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lLCCOPMTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = lLCCOPMTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->lLCCOPMRowStatus;
			StorageTmp->lLCCOPMRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = lLCCOPMTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->lLCCOPMRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCCOPMRowStatus;
			StorageTmp->lLCCOPMRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->lLCCOPMRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->lLCCOPMRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCCOPMTable_destroy(&StorageDel);
			/* lLCCOPMTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCCOPMRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				lLCCOPMTable_del(StorageNew);
				lLCCOPMTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				lLCCOPMTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lLCConnectionlessAckIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_lLCConnectionlessAckIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lLCConnectionlessAckIVMOTable_data *StorageTmp = NULL;
	static struct lLCConnectionlessAckIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_lLCConnectionlessAckIVMORowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(lLCConnectionlessAckIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to lLCConnectionlessAckIVMORowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->lLCConnectionlessAckIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->lLCConnectionlessAckIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->lLCConnectionlessAckIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* lLCConnectionlessAckIVMOName */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* lLCConnectionlessAckIVMOName */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index lLCConnectionlessAckIVMOName: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = lLCConnectionlessAckIVMOTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->lLCConnectionlessAckIVMOName, vp->val.string, vp->val_len);
			StorageNew->lLCConnectionlessAckIVMONameLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&lLCConnectionlessAckIVMOTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				lLCConnectionlessAckIVMOTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = lLCConnectionlessAckIVMOTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->lLCConnectionlessAckIVMORowStatus;
			StorageTmp->lLCConnectionlessAckIVMORowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = lLCConnectionlessAckIVMOTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->lLCConnectionlessAckIVMORowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->lLCConnectionlessAckIVMORowStatus;
			StorageTmp->lLCConnectionlessAckIVMORowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->lLCConnectionlessAckIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->lLCConnectionlessAckIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			lLCConnectionlessAckIVMOTable_destroy(&StorageDel);
			/* lLCConnectionlessAckIVMOTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->lLCConnectionlessAckIVMORowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				lLCConnectionlessAckIVMOTable_del(StorageNew);
				lLCConnectionlessAckIVMOTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				lLCConnectionlessAckIVMOTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_networkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_networkEntityRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct networkEntityTable_data *StorageTmp = NULL;
	static struct networkEntityTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_networkEntityRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(networkEntityTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkEntityRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->networkEntityRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->networkEntityTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->networkEntityTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = networkEntityTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&networkEntityTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				networkEntityTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = networkEntityTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->networkEntityRowStatus;
			StorageTmp->networkEntityRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = networkEntityTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->networkEntityRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->networkEntityRowStatus;
			StorageTmp->networkEntityRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->networkEntityRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->networkEntityRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			networkEntityTable_destroy(&StorageDel);
			/* networkEntityTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->networkEntityRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				networkEntityTable_del(StorageNew);
				networkEntityTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				networkEntityTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_nSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_nSAPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct nSAPTable_data *StorageTmp = NULL;
	static struct nSAPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_nSAPRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(nSAPTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to nSAPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to nSAPRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->nSAPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->nSAPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->nSAPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sapId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* sapId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index sapId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = nSAPTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->sapId, vp->val.string, vp->val_len);
			StorageNew->sapIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&nSAPTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				nSAPTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = nSAPTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->nSAPRowStatus;
			StorageTmp->nSAPRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = nSAPTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->nSAPRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->nSAPRowStatus;
			StorageTmp->nSAPRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->nSAPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->nSAPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			nSAPTable_destroy(&StorageDel);
			/* nSAPTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->nSAPRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				nSAPTable_del(StorageNew);
				nSAPTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				nSAPTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_cLNSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cLNSTable_data *StorageTmp = NULL;
	static struct cLNSTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_cLNSRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(cLNSTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cLNSRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cLNSTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cLNSTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* clProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* clProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index clProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = cLNSTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&cLNSTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				cLNSTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = cLNSTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->cLNSRowStatus;
			StorageTmp->cLNSRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = cLNSTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->cLNSRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cLNSRowStatus;
			StorageTmp->cLNSRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->cLNSRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->cLNSRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cLNSTable_destroy(&StorageDel);
			/* cLNSTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cLNSRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				cLNSTable_del(StorageNew);
				cLNSTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				cLNSTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSISISRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_cLNSISISRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cLNSISISTable_data *StorageTmp = NULL;
	static struct cLNSISISTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_cLNSISISRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(cLNSISISTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cLNSISISRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cLNSISISTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cLNSISISTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* clProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* clProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index clProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = cLNSISISTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&cLNSISISTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				cLNSISISTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = cLNSISISTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->cLNSISISRowStatus;
			StorageTmp->cLNSISISRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = cLNSISISTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->cLNSISISRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cLNSISISRowStatus;
			StorageTmp->cLNSISISRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->cLNSISISRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->cLNSISISRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cLNSISISTable_destroy(&StorageDel);
			/* cLNSISISTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cLNSISISRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				cLNSISISTable_del(StorageNew);
				cLNSISISTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				cLNSISISTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cLNSISISLevel2RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_cLNSISISLevel2RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cLNSISISLevel2Table_data *StorageTmp = NULL;
	static struct cLNSISISLevel2Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_cLNSISISLevel2RowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(cLNSISISLevel2TableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISLevel2RowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cLNSISISLevel2RowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cLNSISISLevel2RowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cLNSISISLevel2Table_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cLNSISISLevel2Table_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = cLNSISISLevel2Table_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&cLNSISISLevel2TableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				cLNSISISLevel2Table_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = cLNSISISLevel2Table_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->cLNSISISLevel2RowStatus;
			StorageTmp->cLNSISISLevel2RowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = cLNSISISLevel2Table_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->cLNSISISLevel2RowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cLNSISISLevel2RowStatus;
			StorageTmp->cLNSISISLevel2RowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->cLNSISISLevel2RowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->cLNSISISLevel2RowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cLNSISISLevel2Table_destroy(&StorageDel);
			/* cLNSISISLevel2Table_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cLNSISISLevel2RowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				cLNSISISLevel2Table_del(StorageNew);
				cLNSISISLevel2Table_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				cLNSISISLevel2Table_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_linkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_linkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct linkageTable_data *StorageTmp = NULL;
	static struct linkageTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_linkageRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(linkageTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to linkageRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to linkageRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->linkageRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->linkageTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->linkageTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* protocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* linkageId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* protocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index protocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* linkageId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index linkageId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = linkageTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->protocolMachineId, vp->val.string, vp->val_len);
			StorageNew->protocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->linkageId, vp->val.string, vp->val_len);
			StorageNew->linkageIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&linkageTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				linkageTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = linkageTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->linkageRowStatus;
			StorageTmp->linkageRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = linkageTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->linkageRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->linkageRowStatus;
			StorageTmp->linkageRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->linkageRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->linkageRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			linkageTable_destroy(&StorageDel);
			/* linkageTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->linkageRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				linkageTable_del(StorageNew);
				linkageTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				linkageTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_cONSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_cONSRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct cONSTable_data *StorageTmp = NULL;
	static struct cONSTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_cONSRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(cONSTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to cONSRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->cONSRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->cONSTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->cONSTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = cONSTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&cONSTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				cONSTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = cONSTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->cONSRowStatus;
			StorageTmp->cONSRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = cONSTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->cONSRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->cONSRowStatus;
			StorageTmp->cONSRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->cONSRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->cONSRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			cONSTable_destroy(&StorageDel);
			/* cONSTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->cONSRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				cONSTable_del(StorageNew);
				cONSTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				cONSTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_networkConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_networkConnectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct networkConnectionTable_data *StorageTmp = NULL;
	static struct networkConnectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_networkConnectionRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(networkConnectionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkConnectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to networkConnectionRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->networkConnectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->networkConnectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->networkConnectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* coProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* connectionId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* coProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index coProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* connectionId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index connectionId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = networkConnectionTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->coProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->coProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->connectionId, vp->val.string, vp->val_len);
			StorageNew->connectionIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&networkConnectionTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				networkConnectionTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = networkConnectionTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->networkConnectionRowStatus;
			StorageTmp->networkConnectionRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = networkConnectionTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->networkConnectionRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->networkConnectionRowStatus;
			StorageTmp->networkConnectionRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->networkConnectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->networkConnectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			networkConnectionTable_destroy(&StorageDel);
			/* networkConnectionTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->networkConnectionRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				networkConnectionTable_del(StorageNew);
				networkConnectionTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				networkConnectionTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLETable_data *StorageTmp = NULL;
	static struct x25PLETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_x25PLERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(x25PLETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = x25PLETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&x25PLETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = x25PLETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->x25PLERowStatus;
			StorageTmp->x25PLERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = x25PLETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->x25PLERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLERowStatus;
			StorageTmp->x25PLERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->x25PLERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->x25PLERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLETable_destroy(&StorageDel);
			/* x25PLETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				x25PLETable_del(StorageNew);
				x25PLETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				x25PLETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static struct x25PLEIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_x25PLEIVMORowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(x25PLEIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMORowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEIVMOId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEIVMOId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEIVMOId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = x25PLEIVMOTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&x25PLEIVMOTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEIVMOTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = x25PLEIVMOTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->x25PLEIVMORowStatus;
			StorageTmp->x25PLEIVMORowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = x25PLEIVMOTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->x25PLEIVMORowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMORowStatus;
			StorageTmp->x25PLEIVMORowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->x25PLEIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->x25PLEIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMOTable_destroy(&StorageDel);
			/* x25PLEIVMOTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMORowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				x25PLEIVMOTable_del(StorageNew);
				x25PLEIVMOTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				x25PLEIVMOTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMO_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEIVMO_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMO_DTETable_data *StorageTmp = NULL;
	static struct x25PLEIVMO_DTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_x25PLEIVMO_DTERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(x25PLEIVMO_DTETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO_DTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO_DTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMO_DTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMO_DTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMO_DTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEIVMOId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEIVMOId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEIVMOId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = x25PLEIVMO_DTETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&x25PLEIVMO_DTETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEIVMO_DTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = x25PLEIVMO_DTETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->x25PLEIVMO_DTERowStatus;
			StorageTmp->x25PLEIVMO_DTERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = x25PLEIVMO_DTETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->x25PLEIVMO_DTERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMO_DTERowStatus;
			StorageTmp->x25PLEIVMO_DTERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->x25PLEIVMO_DTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->x25PLEIVMO_DTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMO_DTETable_destroy(&StorageDel);
			/* x25PLEIVMO_DTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMO_DTERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				x25PLEIVMO_DTETable_del(StorageNew);
				x25PLEIVMO_DTETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				x25PLEIVMO_DTETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMO_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEIVMO_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMO_DCETable_data *StorageTmp = NULL;
	static struct x25PLEIVMO_DCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_x25PLEIVMO_DCERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(x25PLEIVMO_DCETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO_DCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMO_DCERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMO_DCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMO_DCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMO_DCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEIVMOId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEIVMOId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEIVMOId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = x25PLEIVMO_DCETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&x25PLEIVMO_DCETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEIVMO_DCETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = x25PLEIVMO_DCETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->x25PLEIVMO_DCERowStatus;
			StorageTmp->x25PLEIVMO_DCERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = x25PLEIVMO_DCETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->x25PLEIVMO_DCERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMO_DCERowStatus;
			StorageTmp->x25PLEIVMO_DCERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->x25PLEIVMO_DCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->x25PLEIVMO_DCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMO_DCETable_destroy(&StorageDel);
			/* x25PLEIVMO_DCETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMO_DCERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				x25PLEIVMO_DCETable_del(StorageNew);
				x25PLEIVMO_DCETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				x25PLEIVMO_DCETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_permanentVirtualCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_permanentVirtualCircuitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct permanentVirtualCircuitTable_data *StorageTmp = NULL;
	static struct permanentVirtualCircuitTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_permanentVirtualCircuitRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(permanentVirtualCircuitTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuitRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuitRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->permanentVirtualCircuitRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->permanentVirtualCircuitTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->permanentVirtualCircuitTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* virtualCallId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* virtualCallId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index virtualCallId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = permanentVirtualCircuitTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCallId, vp->val.string, vp->val_len);
			StorageNew->virtualCallIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&permanentVirtualCircuitTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				permanentVirtualCircuitTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = permanentVirtualCircuitTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->permanentVirtualCircuitRowStatus;
			StorageTmp->permanentVirtualCircuitRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = permanentVirtualCircuitTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->permanentVirtualCircuitRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->permanentVirtualCircuitRowStatus;
			StorageTmp->permanentVirtualCircuitRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->permanentVirtualCircuitRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->permanentVirtualCircuitRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			permanentVirtualCircuitTable_destroy(&StorageDel);
			/* permanentVirtualCircuitTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->permanentVirtualCircuitRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				permanentVirtualCircuitTable_del(StorageNew);
				permanentVirtualCircuitTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				permanentVirtualCircuitTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_permanentVirtualCircuit_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_permanentVirtualCircuit_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct permanentVirtualCircuit_DTETable_data *StorageTmp = NULL;
	static struct permanentVirtualCircuit_DTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_permanentVirtualCircuit_DTERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(permanentVirtualCircuit_DTETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit_DTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit_DTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->permanentVirtualCircuit_DTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->permanentVirtualCircuit_DTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->permanentVirtualCircuit_DTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* virtualCircuitId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* virtualCircuitId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index virtualCircuitId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = permanentVirtualCircuit_DTETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&permanentVirtualCircuit_DTETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				permanentVirtualCircuit_DTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = permanentVirtualCircuit_DTETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->permanentVirtualCircuit_DTERowStatus;
			StorageTmp->permanentVirtualCircuit_DTERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = permanentVirtualCircuit_DTETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->permanentVirtualCircuit_DTERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->permanentVirtualCircuit_DTERowStatus;
			StorageTmp->permanentVirtualCircuit_DTERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->permanentVirtualCircuit_DTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->permanentVirtualCircuit_DTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			permanentVirtualCircuit_DTETable_destroy(&StorageDel);
			/* permanentVirtualCircuit_DTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->permanentVirtualCircuit_DTERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				permanentVirtualCircuit_DTETable_del(StorageNew);
				permanentVirtualCircuit_DTETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				permanentVirtualCircuit_DTETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_permanentVirtualCircuit_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_permanentVirtualCircuit_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct permanentVirtualCircuit_DCETable_data *StorageTmp = NULL;
	static struct permanentVirtualCircuit_DCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_permanentVirtualCircuit_DCERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(permanentVirtualCircuit_DCETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit_DCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to permanentVirtualCircuit_DCERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->permanentVirtualCircuit_DCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->permanentVirtualCircuit_DCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->permanentVirtualCircuit_DCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* virtualCircuitId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* virtualCircuitId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index virtualCircuitId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = permanentVirtualCircuit_DCETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&permanentVirtualCircuit_DCETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				permanentVirtualCircuit_DCETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = permanentVirtualCircuit_DCETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->permanentVirtualCircuit_DCERowStatus;
			StorageTmp->permanentVirtualCircuit_DCERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = permanentVirtualCircuit_DCETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->permanentVirtualCircuit_DCERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->permanentVirtualCircuit_DCERowStatus;
			StorageTmp->permanentVirtualCircuit_DCERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->permanentVirtualCircuit_DCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->permanentVirtualCircuit_DCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			permanentVirtualCircuit_DCETable_destroy(&StorageDel);
			/* permanentVirtualCircuit_DCETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->permanentVirtualCircuit_DCERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				permanentVirtualCircuit_DCETable_del(StorageNew);
				permanentVirtualCircuit_DCETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				permanentVirtualCircuit_DCETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_virtualCallIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_virtualCallIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct virtualCallIVMOTable_data *StorageTmp = NULL;
	static struct virtualCallIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_virtualCallIVMORowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(virtualCallIVMOTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCallIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCallIVMORowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->virtualCallIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->virtualCallIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->virtualCallIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* virtualCallIVMOId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* virtualCallIVMOId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index virtualCallIVMOId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = virtualCallIVMOTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCallIVMOId, vp->val.string, vp->val_len);
			StorageNew->virtualCallIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&virtualCallIVMOTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				virtualCallIVMOTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = virtualCallIVMOTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->virtualCallIVMORowStatus;
			StorageTmp->virtualCallIVMORowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = virtualCallIVMOTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->virtualCallIVMORowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->virtualCallIVMORowStatus;
			StorageTmp->virtualCallIVMORowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->virtualCallIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->virtualCallIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			virtualCallIVMOTable_destroy(&StorageDel);
			/* virtualCallIVMOTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->virtualCallIVMORowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				virtualCallIVMOTable_del(StorageNew);
				virtualCallIVMOTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				virtualCallIVMOTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_switchedVirtualCallRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_switchedVirtualCallRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct switchedVirtualCallTable_data *StorageTmp = NULL;
	static struct switchedVirtualCallTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_switchedVirtualCallRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(switchedVirtualCallTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to switchedVirtualCallRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to switchedVirtualCallRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->switchedVirtualCallRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->switchedVirtualCallTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->switchedVirtualCallTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* virtualCallId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* virtualCallId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index virtualCallId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = switchedVirtualCallTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCallId, vp->val.string, vp->val_len);
			StorageNew->virtualCallIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&switchedVirtualCallTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				switchedVirtualCallTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = switchedVirtualCallTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->switchedVirtualCallRowStatus;
			StorageTmp->switchedVirtualCallRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = switchedVirtualCallTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->switchedVirtualCallRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->switchedVirtualCallRowStatus;
			StorageTmp->switchedVirtualCallRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->switchedVirtualCallRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->switchedVirtualCallRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			switchedVirtualCallTable_destroy(&StorageDel);
			/* switchedVirtualCallTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->switchedVirtualCallRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				switchedVirtualCallTable_del(StorageNew);
				switchedVirtualCallTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				switchedVirtualCallTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_virtualCall_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_virtualCall_DTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct virtualCall_DTETable_data *StorageTmp = NULL;
	static struct virtualCall_DTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_virtualCall_DTERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(virtualCall_DTETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall_DTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall_DTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->virtualCall_DTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->virtualCall_DTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->virtualCall_DTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* virtualCircuitId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* virtualCircuitId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index virtualCircuitId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = virtualCall_DTETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&virtualCall_DTETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				virtualCall_DTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = virtualCall_DTETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->virtualCall_DTERowStatus;
			StorageTmp->virtualCall_DTERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = virtualCall_DTETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->virtualCall_DTERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->virtualCall_DTERowStatus;
			StorageTmp->virtualCall_DTERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->virtualCall_DTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->virtualCall_DTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			virtualCall_DTETable_destroy(&StorageDel);
			/* virtualCall_DTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->virtualCall_DTERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				virtualCall_DTETable_del(StorageNew);
				virtualCall_DTETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				virtualCall_DTETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_virtualCall_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_virtualCall_DCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct virtualCall_DCETable_data *StorageTmp = NULL;
	static struct virtualCall_DCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_virtualCall_DCERowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(virtualCall_DCETableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall_DCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to virtualCall_DCERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->virtualCall_DCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->virtualCall_DCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->virtualCall_DCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* virtualCircuitId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* virtualCircuitId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index virtualCircuitId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = virtualCall_DCETable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&virtualCall_DCETableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				virtualCall_DCETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = virtualCall_DCETable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->virtualCall_DCERowStatus;
			StorageTmp->virtualCall_DCERowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = virtualCall_DCETable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->virtualCall_DCERowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->virtualCall_DCERowStatus;
			StorageTmp->virtualCall_DCERowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->virtualCall_DCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->virtualCall_DCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			virtualCall_DCETable_destroy(&StorageDel);
			/* virtualCall_DCETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->virtualCall_DCERowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				virtualCall_DCETable_del(StorageNew);
				virtualCall_DCETable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				virtualCall_DCETable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dSeriesRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dSeriesRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dSeriesCountsTable_data *StorageTmp = NULL;
	static struct dSeriesCountsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_dSeriesRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(dSeriesCountsTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dSeriesRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dSeriesRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dSeriesRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dSeriesCountsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dSeriesCountsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* virtualCircuitId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* dSeriesId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* x25PLEId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index x25PLEId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* virtualCircuitId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index virtualCircuitId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* dSeriesId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dSeriesId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = dSeriesCountsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->virtualCircuitId, vp->val.string, vp->val_len);
			StorageNew->virtualCircuitIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->dSeriesId, vp->val.string, vp->val_len);
			StorageNew->dSeriesIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&dSeriesCountsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dSeriesCountsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = dSeriesCountsTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->dSeriesRowStatus;
			StorageTmp->dSeriesRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = dSeriesCountsTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->dSeriesRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->dSeriesRowStatus;
			StorageTmp->dSeriesRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->dSeriesRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->dSeriesRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			dSeriesCountsTable_destroy(&StorageDel);
			/* dSeriesCountsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->dSeriesRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				dSeriesCountsTable_del(StorageNew);
				dSeriesCountsTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				dSeriesCountsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_adjacencyRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_adjacencyRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct adjacencyTable_data *StorageTmp = NULL;
	static struct adjacencyTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_adjacencyRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(adjacencyTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to adjacencyRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to adjacencyRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->adjacencyRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->adjacencyTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->adjacencyTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* communicationsEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* clProtocolMachineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* linkageId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* adjacencyId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* communicationsEntityId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index communicationsEntityId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* clProtocolMachineId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index clProtocolMachineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* linkageId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index linkageId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* adjacencyId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index adjacencyId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = adjacencyTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->communicationsEntityId, vp->val.string, vp->val_len);
			StorageNew->communicationsEntityIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->clProtocolMachineId, vp->val.string, vp->val_len);
			StorageNew->clProtocolMachineIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->linkageId, vp->val.string, vp->val_len);
			StorageNew->linkageIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->adjacencyId, vp->val.string, vp->val_len);
			StorageNew->adjacencyIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&adjacencyTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				adjacencyTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = adjacencyTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->adjacencyRowStatus;
			StorageTmp->adjacencyRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = adjacencyTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->adjacencyRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->adjacencyRowStatus;
			StorageTmp->adjacencyRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->adjacencyRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->adjacencyRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			adjacencyTable_destroy(&StorageDel);
			/* adjacencyTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->adjacencyRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				adjacencyTable_del(StorageNew);
				adjacencyTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				adjacencyTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_reachableAddressRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_reachableAddressRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct reachableAddressTable_data *StorageTmp = NULL;
	static struct reachableAddressTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("dlMIB", "write_reachableAddressRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(reachableAddressTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to reachableAddressRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->reachableAddressRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->reachableAddressTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->reachableAddressTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* reachableAddressId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* reachableAddressId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index reachableAddressId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = reachableAddressTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			memdup((void *) &StorageNew->reachableAddressId, vp->val.string, vp->val_len);
			StorageNew->reachableAddressIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&reachableAddressTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				reachableAddressTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = reachableAddressTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->reachableAddressRowStatus;
			StorageTmp->reachableAddressRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = reachableAddressTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->reachableAddressRowStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->reachableAddressRowStatus;
			StorageTmp->reachableAddressRowStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->reachableAddressRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->reachableAddressRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			reachableAddressTable_destroy(&StorageDel);
			/* reachableAddressTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->reachableAddressRowStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				reachableAddressTable_del(StorageNew);
				reachableAddressTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				reachableAddressTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

void
send_lLCConnection2Event_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("dlMIB", "send_lLCConnection2Event_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lLCConnection2Event_oid;
	trap.val_len = sizeof(lLCConnection2Event_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

void
send_lLCClessACKEvent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("dlMIB", "send_lLCClessACKEvent_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lLCClessACKEvent_oid;
	trap.val_len = sizeof(lLCClessACKEvent_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

void
send_lLCStationEvent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("dlMIB", "send_lLCStationEvent_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lLCStationEvent_oid;
	trap.val_len = sizeof(lLCStationEvent_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/**
 * @fn void dlMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
dlMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("dlMIB", "dlMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (dlMIBold_signal_handler != NULL)
		(*dlMIBold_signal_handler) (sig);
	DEBUGMSGTL(("dlMIB", "done.\n"));
}

/**
 * @fn void dlMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
dlMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("dlMIB", "dlMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("dlMIB", "done.\n"));
	return;
}
