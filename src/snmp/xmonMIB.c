/*****************************************************************************

 @(#) src/snmp/xmonMIB.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] = "src/snmp/xmonMIB.c (" PACKAGE_ENVR ") " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NETSNMP_MEMDUP
#include "ucd_memdup.h"
#endif
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "xmonMIB.h"
#define MASTER 1
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "xmonMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int xmonMIB_refresh = 1;
volatile int xmonSourceTable_refresh = 1;
volatile int xmonSourceStatsTable_refresh = 1;
volatile int xmonSourceHistTable_refresh = 1;
volatile int xmonSourceTotalTable_refresh = 1;
volatile int xmonInterfaceTable_refresh = 1;
volatile int xmonRmonTable_refresh = 1;
volatile int xmonArchiveTable_refresh = 1;
volatile int xmonFeedListenTable_refresh = 1;
volatile int xmonFeedTable_refresh = 1;
volatile int xmonFeedStatsTable_refresh = 1;
volatile int xmonPushListenTable_refresh = 1;
volatile int xmonPushTable_refresh = 1;
volatile int xmonPullListenTable_refresh = 1;
volatile int xmonPullTable_refresh = 1;
volatile int xmonUploadTable_refresh = 1;
volatile int xmonDownloadTable_refresh = 1;
volatile int xmonSctpTable_refresh = 1;

/*
 * xmonMIB_variables_oid: object identifier for xmonMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid xmonMIB_variables_oid[9] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83 };
oid xmonInterfaceTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 3, 1, 1 };
oid xmonRmonTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 4, 1, 1 };
oid xmonFeedListenTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 8, 3, 1 };
oid xmonFeedTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 8, 5, 1 };
oid xmonPushListenTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 9, 2, 1 };
oid xmonPushTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 9, 3, 1 };
oid xmonPullListenTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 10, 2, 1 };
oid xmonPullTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 10, 5, 1 };
oid xmonUploadTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 12, 1, 1 };
oid xmonDownloadTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 13, 1, 1 };
oid xmonSctpTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 14, 16, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */

/*
 * Oids accessible only for notify defined in this MIB.
 */

/*
 * Other oids defined in this MIB.
 */
oid xmonProbe_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 1 };
oid xmonSource_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 2 };
oid xmonInterface_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 3 };
oid xmonRmon_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 4 };
oid xmonBuffer_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 5 };
oid xmonCapture_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 6 };
oid xmonArchive_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 7 };
oid xmonFeed_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 8 };
oid xmonPush_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 9 };
oid xmonPull_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 10 };
oid xmonCollector_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 11 };
oid xmonUpload_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 12 };
oid xmonDownload_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 13 };
oid xmonProfile_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 2, 14 };
oid xmonProbeGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 1 };
oid xmonSourceGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 2 };
oid xmonInterfaceGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 3 };
oid xmonRmonGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 4 };
oid xmonBufferGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 5 };
oid xmonCaptureGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 6 };
oid xmonArchiveGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 7 };
oid xmonFeedGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 8 };
oid xmonPushGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 9 };
oid xmonPullGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 10 };
oid xmonCollectorGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 11 };
oid xmonProfileGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 12 };
oid xmonUploadGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 13 };
oid xmonDownloadGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 14 };
oid xmonSourceStatsGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 16 };
oid xmonBufferStatsGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 17 };
oid xmonCaptureStatsGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 18 };
oid xmonArchiveStatsGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 19 };
oid xmonFeedStatsGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 20 };
oid xmonSourceHistGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 3, 22 };
oid xmonBasicCompliance_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 4, 1 };
oid xmonProbeCompliance_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 4, 2 };
oid xmonCollectorCompliance_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 4, 3 };
oid xmonRepositoryCompliance_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 4, 4 };
oid xmonNmsCompliance_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 4, 5 };
oid xmonFullCompliance_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 83, 4, 6 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 xmonMIB_variables: tree for xmonMIB
 * This variable defines function callbacks and type return information for the xmonMIB mib section
 */
struct variable7 xmonMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   XMONPROBENAME         1
	{(u_char) XMONPROBENAME, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 1, 1}},
#define   XMONPROBEUUID         2
	{(u_char) XMONPROBEUUID, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 1, 2}},
#define   XMONPROBEHARDWARE     3
	{(u_char) XMONPROBEHARDWARE, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 1, 3}},
#define   XMONPROBEOS           4
	{(u_char) XMONPROBEOS, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 1, 4}},
#define   XMONPROBEUSERAPPL     5
	{(u_char) XMONPROBEUSERAPPL, ASN_OCTET_STR, RONLY, var_xmonMIB, 3, {2, 1, 5}},
#define   XMONSOURCETYPE        6
	{(u_char) XMONSOURCETYPE, ASN_INTEGER, RONLY, var_xmonSourceTable, 5, {2, 2, 1, 1, 2}},
#define   XMONSOURCENAME        7
	{(u_char) XMONSOURCENAME, ASN_OCTET_STR, RWRITE, var_xmonSourceTable, 5, {2, 2, 1, 1, 3}},
#define   XMONSOURCEIFINDEX     8
	{(u_char) XMONSOURCEIFINDEX, ASN_INTEGER, RONLY, var_xmonSourceTable, 5, {2, 2, 1, 1, 4}},
#define   XMONSOURCEADMINSTATE  9
	{(u_char) XMONSOURCEADMINSTATE, ASN_INTEGER, RWRITE, var_xmonSourceTable, 5, {2, 2, 1, 1, 5}},
#define   XMONSOURCEOPSTATE     10
	{(u_char) XMONSOURCEOPSTATE, ASN_INTEGER, RONLY, var_xmonSourceTable, 5, {2, 2, 1, 1, 6}},
#define   XMONSOURCEAVAILSTATUS  11
	{(u_char) XMONSOURCEAVAILSTATUS, ASN_OCTET_STR, RONLY, var_xmonSourceTable, 5, {2, 2, 1, 1, 7}},
#define   XMONSOURCEPROCSTATUS  12
	{(u_char) XMONSOURCEPROCSTATUS, ASN_OCTET_STR, RONLY, var_xmonSourceTable, 5, {2, 2, 1, 1, 8}},
#define   XMONSOURCEUSAGESTATE  13
	{(u_char) XMONSOURCEUSAGESTATE, ASN_INTEGER, RONLY, var_xmonSourceTable, 5, {2, 2, 1, 1, 9}},
#define   XMONSOURCESTATSTIMEELAPSED  14
	{(u_char) XMONSOURCESTATSTIMEELAPSED, ASN_INTEGER, RONLY, var_xmonSourceStatsTable, 5, {2, 2, 2, 1, 1}},
#define   XMONSOURCESTATSTIMESTAMP  15
	{(u_char) XMONSOURCESTATSTIMESTAMP, ASN_TIMETICKS, RONLY, var_xmonSourceStatsTable, 5, {2, 2, 2, 1, 2}},
#define   XMONSOURCESTATSSTARTTIME  16
	{(u_char) XMONSOURCESTATSSTARTTIME, ASN_TIMETICKS, RONLY, var_xmonSourceStatsTable, 5, {2, 2, 2, 1, 3}},
#define   XMONSOURCESTATSENDTIME  17
	{(u_char) XMONSOURCESTATSENDTIME, ASN_TIMETICKS, RONLY, var_xmonSourceStatsTable, 5, {2, 2, 2, 1, 4}},
#define   XMONSOURCESTATSIFRECV  18
	{(u_char) XMONSOURCESTATSIFRECV, ASN_COUNTER64, RONLY, var_xmonSourceStatsTable, 5, {2, 2, 2, 1, 5}},
#define   XMONSOURCESTATSIFDROP  19
	{(u_char) XMONSOURCESTATSIFDROP, ASN_COUNTER64, RONLY, var_xmonSourceStatsTable, 5, {2, 2, 2, 1, 6}},
#define   XMONSOURCESTATSFILTERACCEPT  20
	{(u_char) XMONSOURCESTATSFILTERACCEPT, ASN_COUNTER64, RONLY, var_xmonSourceStatsTable, 5, {2, 2, 2, 1, 7}},
#define   XMONSOURCESTATSOSDROP  21
	{(u_char) XMONSOURCESTATSOSDROP, ASN_COUNTER64, RONLY, var_xmonSourceStatsTable, 5, {2, 2, 2, 1, 8}},
#define   XMONSOURCESTATSUSERDELIV  22
	{(u_char) XMONSOURCESTATSUSERDELIV, ASN_COUNTER64, RONLY, var_xmonSourceStatsTable, 5, {2, 2, 2, 1, 9}},
#define   XMONSOURCEHISTIFRECV  23
	{(u_char) XMONSOURCEHISTIFRECV, ASN_COUNTER64, RONLY, var_xmonSourceHistTable, 5, {2, 2, 3, 1, 2}},
#define   XMONSOURCEHISTIFDROP  24
	{(u_char) XMONSOURCEHISTIFDROP, ASN_COUNTER64, RONLY, var_xmonSourceHistTable, 5, {2, 2, 3, 1, 3}},
#define   XMONSOURCEHISTFILTERACCEPT  25
	{(u_char) XMONSOURCEHISTFILTERACCEPT, ASN_COUNTER64, RONLY, var_xmonSourceHistTable, 5, {2, 2, 3, 1, 4}},
#define   XMONSOURCEHISTOSDROP  26
	{(u_char) XMONSOURCEHISTOSDROP, ASN_COUNTER64, RONLY, var_xmonSourceHistTable, 5, {2, 2, 3, 1, 5}},
#define   XMONSOURCEHISTUSERDELIV  27
	{(u_char) XMONSOURCEHISTUSERDELIV, ASN_COUNTER64, RONLY, var_xmonSourceHistTable, 5, {2, 2, 3, 1, 6}},
#define   XMONSOURCETOTALVALIDINTERVALS  28
	{(u_char) XMONSOURCETOTALVALIDINTERVALS, ASN_INTEGER, RONLY, var_xmonSourceTotalTable, 5, {2, 2, 4, 1, 1}},
#define   XMONSOURCETOTALIFRECV  29
	{(u_char) XMONSOURCETOTALIFRECV, ASN_COUNTER64, RONLY, var_xmonSourceTotalTable, 5, {2, 2, 4, 1, 3}},
#define   XMONSOURCETOTALIFDROP  30
	{(u_char) XMONSOURCETOTALIFDROP, ASN_COUNTER64, RONLY, var_xmonSourceTotalTable, 5, {2, 2, 4, 1, 4}},
#define   XMONSOURCETOTALFILTERACCEPT  31
	{(u_char) XMONSOURCETOTALFILTERACCEPT, ASN_COUNTER64, RONLY, var_xmonSourceTotalTable, 5, {2, 2, 4, 1, 5}},
#define   XMONSOURCETOTALOSDROP  32
	{(u_char) XMONSOURCETOTALOSDROP, ASN_COUNTER64, RONLY, var_xmonSourceTotalTable, 5, {2, 2, 4, 1, 6}},
#define   XMONSOURCETOTALUSERDELIV  33
	{(u_char) XMONSOURCETOTALUSERDELIV, ASN_COUNTER64, RONLY, var_xmonSourceTotalTable, 5, {2, 2, 4, 1, 7}},
#define   XMONINTERFACELINKTYPE  34
	{(u_char) XMONINTERFACELINKTYPE, ASN_INTEGER, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 1}},
#define   XMONINTERFACESNAPLEN  35
	{(u_char) XMONINTERFACESNAPLEN, ASN_UNSIGNED, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 2}},
#define   XMONINTERFACEPROMISCUOUS  36
	{(u_char) XMONINTERFACEPROMISCUOUS, ASN_INTEGER, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 3}},
#define   XMONINTERFACEMONITOR  37
	{(u_char) XMONINTERFACEMONITOR, ASN_INTEGER, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 4}},
#define   XMONINTERFACEDIRECTION  38
	{(u_char) XMONINTERFACEDIRECTION, ASN_INTEGER, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 5}},
#define   XMONINTERFACEDESCRIPTION  39
	{(u_char) XMONINTERFACEDESCRIPTION, ASN_OCTET_STR, RONLY, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 6}},
#define   XMONINTERFACEPHYSADDR  40
	{(u_char) XMONINTERFACEPHYSADDR, ASN_OCTET_STR, RONLY, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 7}},
#define   XMONINTERFACESPEED    41
	{(u_char) XMONINTERFACESPEED, ASN_COUNTER64, RONLY, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 8}},
#define   XMONINTERFACETSRES    42
	{(u_char) XMONINTERFACETSRES, ASN_INTEGER, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 9}},
#define   XMONINTERFACETZONE    43
	{(u_char) XMONINTERFACETZONE, ASN_INTEGER, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 10}},
#define   XMONINTERFACEFILTERTYPE  44
	{(u_char) XMONINTERFACEFILTERTYPE, ASN_OCTET_STR, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 11}},
#define   XMONINTERFACEFILTER   45
	{(u_char) XMONINTERFACEFILTER, ASN_OCTET_STR, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 12}},
#define   XMONINTERFACEFILTERBPF  46
	{(u_char) XMONINTERFACEFILTERBPF, ASN_OCTET_STR, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 13}},
#define   XMONINTERFACEFILTERSTATUS  47
	{(u_char) XMONINTERFACEFILTERSTATUS, ASN_INTEGER, RONLY, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 14}},
#define   XMONINTERFACEOS       48
	{(u_char) XMONINTERFACEOS, ASN_OCTET_STR, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 15}},
#define   XMONINTERFACEFCSLEN   49
	{(u_char) XMONINTERFACEFCSLEN, ASN_UNSIGNED, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 16}},
#define   XMONINTERFACETSOFFSET  50
	{(u_char) XMONINTERFACETSOFFSET, ASN_COUNTER64, RONLY, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 17}},
#define   XMONINTERFACESTORAGETYPE  51
	{(u_char) XMONINTERFACESTORAGETYPE, ASN_INTEGER, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 18}},
#define   XMONINTERFACEROWSTATUS  52
	{(u_char) XMONINTERFACEROWSTATUS, ASN_INTEGER, RWRITE, var_xmonInterfaceTable, 5, {2, 3, 1, 1, 19}},
#define   XMONRMONADDRTYPE      53
	{(u_char) XMONRMONADDRTYPE, ASN_INTEGER, RWRITE, var_xmonRmonTable, 5, {2, 4, 1, 1, 2}},
#define   XMONRMONADDR          54
	{(u_char) XMONRMONADDR, ASN_OCTET_STR, RWRITE, var_xmonRmonTable, 5, {2, 4, 1, 1, 3}},
#define   XMONRMONSNMPVERSION   55
	{(u_char) XMONRMONSNMPVERSION, ASN_INTEGER, RWRITE, var_xmonRmonTable, 5, {2, 4, 1, 1, 4}},
#define   XMONRMONCOMMUNITY     56
	{(u_char) XMONRMONCOMMUNITY, ASN_OCTET_STR, RWRITE, var_xmonRmonTable, 5, {2, 4, 1, 1, 5}},
#define   XMONRMONUSERNAME      57
	{(u_char) XMONRMONUSERNAME, ASN_OCTET_STR, RWRITE, var_xmonRmonTable, 5, {2, 4, 1, 1, 6}},
#define   XMONRMONPASSWORD      58
	{(u_char) XMONRMONPASSWORD, ASN_OCTET_STR, RWRITE, var_xmonRmonTable, 5, {2, 4, 1, 1, 7}},
#define   XMONRMONBUFFCTRLINDEX  59
	{(u_char) XMONRMONBUFFCTRLINDEX, ASN_INTEGER, RWRITE, var_xmonRmonTable, 5, {2, 4, 1, 1, 8}},
#define   XMONRMONBUFFINDEX     60
	{(u_char) XMONRMONBUFFINDEX, ASN_INTEGER, RONLY, var_xmonRmonTable, 5, {2, 4, 1, 1, 9}},
#define   XMONRMONSTORAGETYPE   61
	{(u_char) XMONRMONSTORAGETYPE, ASN_INTEGER, RWRITE, var_xmonRmonTable, 5, {2, 4, 1, 1, 10}},
#define   XMONRMONROWSTATUS     62
	{(u_char) XMONRMONROWSTATUS, ASN_INTEGER, RWRITE, var_xmonRmonTable, 5, {2, 4, 1, 1, 11}},
#define   XMONBUFFERADMINSTATE  63
	{(u_char) XMONBUFFERADMINSTATE, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 5, 1}},
#define   XMONBUFFEROPSTATE     64
	{(u_char) XMONBUFFEROPSTATE, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 5, 2}},
#define   XMONBUFFERAVAILSTATUS  65
	{(u_char) XMONBUFFERAVAILSTATUS, ASN_OCTET_STR, RONLY, var_xmonMIB, 3, {2, 5, 3}},
#define   XMONBUFFERFULLACTION  66
	{(u_char) XMONBUFFERFULLACTION, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 5, 4}},
#define   XMONBUFFERMAXSIZE     67
	{(u_char) XMONBUFFERMAXSIZE, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 5, 5}},
#define   XMONBUFFERMAXPACKETS  68
	{(u_char) XMONBUFFERMAXPACKETS, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 5, 6}},
#define   XMONBUFFERMAXTIME     69
	{(u_char) XMONBUFFERMAXTIME, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 5, 7}},
#define   XMONBUFFERCURRENTSIZE  70
	{(u_char) XMONBUFFERCURRENTSIZE, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 8}},
#define   XMONBUFFERNUMBEROFPACKETS  71
	{(u_char) XMONBUFFERNUMBEROFPACKETS, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 9}},
#define   XMONBUFFERCURRENTINTERVAL  72
	{(u_char) XMONBUFFERCURRENTINTERVAL, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 5, 10}},
#define   XMONBUFFERALARMTHRESHOLD  73
	{(u_char) XMONBUFFERALARMTHRESHOLD, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 5, 11}},
#define   XMONBUFFEROCTETHIWATERMARK  74
	{(u_char) XMONBUFFEROCTETHIWATERMARK, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 12}},
#define   XMONBUFFEROCTETLOWATERMARK  75
	{(u_char) XMONBUFFEROCTETLOWATERMARK, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 13}},
#define   XMONBUFFERPKTSHIWATERMARK  76
	{(u_char) XMONBUFFERPKTSHIWATERMARK, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 14}},
#define   XMONBUFFERPKTSLOWATERMARK  77
	{(u_char) XMONBUFFERPKTSLOWATERMARK, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 15}},
#define   XMONBUFFERTIMEHIWATERMARK  78
	{(u_char) XMONBUFFERTIMEHIWATERMARK, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 5, 16}},
#define   XMONBUFFERTIMELOWATERMARK  79
	{(u_char) XMONBUFFERTIMELOWATERMARK, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 5, 17}},
#define   XMONBUFFERDROPS       80
	{(u_char) XMONBUFFERDROPS, ASN_GAUGE, RONLY, var_xmonMIB, 3, {2, 5, 18}},
#define   XMONBUFFERRESET       81
	{(u_char) XMONBUFFERRESET, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 5, 19}},
#define   XMONBUFFERTIMEELAPSED  82
	{(u_char) XMONBUFFERTIMEELAPSED, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 5, 20}},
#define   XMONBUFFERBEGTIME     83
	{(u_char) XMONBUFFERBEGTIME, ASN_TIMETICKS, RONLY, var_xmonMIB, 3, {2, 5, 21}},
#define   XMONBUFFERENDTIME     84
	{(u_char) XMONBUFFERENDTIME, ASN_TIMETICKS, RONLY, var_xmonMIB, 3, {2, 5, 22}},
#define   XMONBUFFERIFRECV      85
	{(u_char) XMONBUFFERIFRECV, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 23}},
#define   XMONBUFFERIFDROP      86
	{(u_char) XMONBUFFERIFDROP, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 24}},
#define   XMONBUFFERFILTERACCEPT  87
	{(u_char) XMONBUFFERFILTERACCEPT, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 25}},
#define   XMONBUFFEROSDROP      88
	{(u_char) XMONBUFFEROSDROP, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 26}},
#define   XMONBUFFERUSERDELIV   89
	{(u_char) XMONBUFFERUSERDELIV, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 27}},
#define   XMONBUFFERIFCOMPRESS  90
	{(u_char) XMONBUFFERIFCOMPRESS, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 28}},
#define   XMONBUFFERUSEROCTETS  91
	{(u_char) XMONBUFFERUSEROCTETS, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 5, 29}},
#define   XMONBUFFERACTIONRESULT  92
	{(u_char) XMONBUFFERACTIONRESULT, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 5, 30}},
#define   XMONCAPTUREPATH       93
	{(u_char) XMONCAPTUREPATH, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 6, 1}},
#define   XMONCAPTUREFILENAME   94
	{(u_char) XMONCAPTUREFILENAME, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 6, 2}},
#define   XMONCAPTUREADMINSTATE  95
	{(u_char) XMONCAPTUREADMINSTATE, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 6, 3}},
#define   XMONCAPTUREOPSTATE    96
	{(u_char) XMONCAPTUREOPSTATE, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 6, 4}},
#define   XMONCAPTUREAVAILSTATUS  97
	{(u_char) XMONCAPTUREAVAILSTATUS, ASN_OCTET_STR, RONLY, var_xmonMIB, 3, {2, 6, 5}},
#define   XMONCAPTUREFULLACTION  98
	{(u_char) XMONCAPTUREFULLACTION, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 6, 6}},
#define   XMONCAPTUREMAXSIZE    99
	{(u_char) XMONCAPTUREMAXSIZE, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 6, 7}},
#define   XMONCAPTUREMAXPACKETS  100
	{(u_char) XMONCAPTUREMAXPACKETS, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 6, 8}},
#define   XMONCAPTUREMAXTIME    101
	{(u_char) XMONCAPTUREMAXTIME, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 6, 9}},
#define   XMONCAPTURECURRENTSIZE  102
	{(u_char) XMONCAPTURECURRENTSIZE, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 6, 10}},
#define   XMONCAPTURENUMBEROFPACKETS  103
	{(u_char) XMONCAPTURENUMBEROFPACKETS, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 6, 11}},
#define   XMONCAPTURECURRENTINTERVAL  104
	{(u_char) XMONCAPTURECURRENTINTERVAL, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 6, 12}},
#define   XMONCAPTUREALARMTHRESHOLD  105
	{(u_char) XMONCAPTUREALARMTHRESHOLD, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 6, 13}},
#define   XMONCAPTUREOCTETHIWATERMARK  106
	{(u_char) XMONCAPTUREOCTETHIWATERMARK, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 6, 14}},
#define   XMONCAPTUREOCTETLOWATERMARK  107
	{(u_char) XMONCAPTUREOCTETLOWATERMARK, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 6, 15}},
#define   XMONCAPTUREPKTSHIWATERMARK  108
	{(u_char) XMONCAPTUREPKTSHIWATERMARK, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 6, 16}},
#define   XMONCAPTUREPKTSLOWATERMARK  109
	{(u_char) XMONCAPTUREPKTSLOWATERMARK, ASN_COUNTER64, RONLY, var_xmonMIB, 3, {2, 6, 17}},
#define   XMONCAPTURETIMEHIWATERMARK  110
	{(u_char) XMONCAPTURETIMEHIWATERMARK, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 6, 18}},
#define   XMONCAPTURETIMELOWATERMARK  111
	{(u_char) XMONCAPTURETIMELOWATERMARK, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 6, 19}},
#define   XMONARCHIVEPATH       112
	{(u_char) XMONARCHIVEPATH, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 7, 1}},
#define   XMONARCHIVENAME       113
	{(u_char) XMONARCHIVENAME, ASN_OCTET_STR, RWRITE, var_xmonArchiveTable, 5, {2, 7, 2, 1, 2}},
#define   XMONARCHIVEFILEFORMAT  114
	{(u_char) XMONARCHIVEFILEFORMAT, ASN_INTEGER, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 3}},
#define   XMONARCHIVECOMPRESSED  115
	{(u_char) XMONARCHIVECOMPRESSED, ASN_INTEGER, RWRITE, var_xmonArchiveTable, 5, {2, 7, 2, 1, 4}},
#define   XMONARCHIVESTATE      116
	{(u_char) XMONARCHIVESTATE, ASN_INTEGER, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 5}},
#define   XMONARCHIVESIZE       117
	{(u_char) XMONARCHIVESIZE, ASN_COUNTER64, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 6}},
#define   XMONARCHIVECOMPSIZE   118
	{(u_char) XMONARCHIVECOMPSIZE, ASN_COUNTER64, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 7}},
#define   XMONARCHIVETIMEELAPSED  119
	{(u_char) XMONARCHIVETIMEELAPSED, ASN_INTEGER, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 8}},
#define   XMONARCHIVEBEGTIME    120
	{(u_char) XMONARCHIVEBEGTIME, ASN_TIMETICKS, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 9}},
#define   XMONARCHIVEENDTIME    121
	{(u_char) XMONARCHIVEENDTIME, ASN_TIMETICKS, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 10}},
#define   XMONARCHIVEIFRECV     122
	{(u_char) XMONARCHIVEIFRECV, ASN_COUNTER64, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 11}},
#define   XMONARCHIVEIFDROP     123
	{(u_char) XMONARCHIVEIFDROP, ASN_COUNTER64, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 12}},
#define   XMONARCHIVEFILTERACCEPT  124
	{(u_char) XMONARCHIVEFILTERACCEPT, ASN_COUNTER64, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 13}},
#define   XMONARCHIVEOSDROP     125
	{(u_char) XMONARCHIVEOSDROP, ASN_COUNTER64, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 14}},
#define   XMONARCHIVEUSERDELIV  126
	{(u_char) XMONARCHIVEUSERDELIV, ASN_COUNTER64, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 15}},
#define   XMONARCHIVEIFCOMPRESS  127
	{(u_char) XMONARCHIVEIFCOMPRESS, ASN_COUNTER64, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 16}},
#define   XMONARCHIVEUSEROCTETS  128
	{(u_char) XMONARCHIVEUSEROCTETS, ASN_COUNTER64, RONLY, var_xmonArchiveTable, 5, {2, 7, 2, 1, 17}},
#define   XMONARCHIVEACTIONRESULT  129
	{(u_char) XMONARCHIVEACTIONRESULT, ASN_INTEGER, RWRITE, var_xmonArchiveTable, 5, {2, 7, 2, 1, 18}},
#define   XMONFEEDTYPES         130
	{(u_char) XMONFEEDTYPES, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 8, 1}},
#define   XMONFEEDPORT          131
	{(u_char) XMONFEEDPORT, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 8, 2}},
#define   XMONFEEDLISTENADDRTYPE  132
	{(u_char) XMONFEEDLISTENADDRTYPE, ASN_INTEGER, RWRITE, var_xmonFeedListenTable, 5, {2, 8, 3, 1, 2}},
#define   XMONFEEDLISTENADDR    133
	{(u_char) XMONFEEDLISTENADDR, ASN_OCTET_STR, RWRITE, var_xmonFeedListenTable, 5, {2, 8, 3, 1, 3}},
#define   XMONFEEDLISTENROWSTATUS  134
	{(u_char) XMONFEEDLISTENROWSTATUS, ASN_INTEGER, RWRITE, var_xmonFeedListenTable, 5, {2, 8, 3, 1, 4}},
#define   XMONFEEDROLE          135
	{(u_char) XMONFEEDROLE, ASN_INTEGER, RONLY, var_xmonFeedTable, 5, {2, 8, 5, 1, 2}},
#define   XMONFEEDNAME          136
	{(u_char) XMONFEEDNAME, ASN_OCTET_STR, RWRITE, var_xmonFeedTable, 5, {2, 8, 5, 1, 3}},
#define   XMONFEEDADDRTYPE      137
	{(u_char) XMONFEEDADDRTYPE, ASN_INTEGER, RWRITE, var_xmonFeedTable, 5, {2, 8, 5, 1, 4}},
#define   XMONFEEDADDR          138
	{(u_char) XMONFEEDADDR, ASN_OCTET_STR, RWRITE, var_xmonFeedTable, 5, {2, 8, 5, 1, 5}},
#define   XMONFEEDCONNINTERVAL  139
	{(u_char) XMONFEEDCONNINTERVAL, ASN_INTEGER, RWRITE, var_xmonFeedTable, 5, {2, 8, 5, 1, 6}},
#define   XMONFEEDCONNATTEMPTS  140
	{(u_char) XMONFEEDCONNATTEMPTS, ASN_UNSIGNED, RWRITE, var_xmonFeedTable, 5, {2, 8, 5, 1, 7}},
#define   XMONFEEDPROFILE       141
	{(u_char) XMONFEEDPROFILE, ASN_OCTET_STR, RWRITE, var_xmonFeedTable, 5, {2, 8, 5, 1, 8}},
#define   XMONFEEDADMINSTATE    142
	{(u_char) XMONFEEDADMINSTATE, ASN_INTEGER, RWRITE, var_xmonFeedTable, 5, {2, 8, 5, 1, 9}},
#define   XMONFEEDOPSTATE       143
	{(u_char) XMONFEEDOPSTATE, ASN_INTEGER, RONLY, var_xmonFeedTable, 5, {2, 8, 5, 1, 10}},
#define   XMONFEEDPROCSTATUS    144
	{(u_char) XMONFEEDPROCSTATUS, ASN_OCTET_STR, RONLY, var_xmonFeedTable, 5, {2, 8, 5, 1, 11}},
#define   XMONFEEDUSAGESTATE    145
	{(u_char) XMONFEEDUSAGESTATE, ASN_INTEGER, RONLY, var_xmonFeedTable, 5, {2, 8, 5, 1, 12}},
#define   XMONFEEDCONNSTATE     146
	{(u_char) XMONFEEDCONNSTATE, ASN_INTEGER, RONLY, var_xmonFeedTable, 5, {2, 8, 5, 1, 13}},
#define   XMONFEEDSTORAGETYPE   147
	{(u_char) XMONFEEDSTORAGETYPE, ASN_INTEGER, RWRITE, var_xmonFeedTable, 5, {2, 8, 5, 1, 14}},
#define   XMONFEEDROWSTATUS     148
	{(u_char) XMONFEEDROWSTATUS, ASN_INTEGER, RWRITE, var_xmonFeedTable, 5, {2, 8, 5, 1, 15}},
#define   XMONFEEDTIMEELAPSED   149
	{(u_char) XMONFEEDTIMEELAPSED, ASN_INTEGER, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 2}},
#define   XMONFEEDBEGTIME       150
	{(u_char) XMONFEEDBEGTIME, ASN_TIMETICKS, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 3}},
#define   XMONFEEDENDTIME       151
	{(u_char) XMONFEEDENDTIME, ASN_TIMETICKS, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 4}},
#define   XMONFEEDIFRECV        152
	{(u_char) XMONFEEDIFRECV, ASN_COUNTER64, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 5}},
#define   XMONFEEDIFDROP        153
	{(u_char) XMONFEEDIFDROP, ASN_COUNTER64, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 6}},
#define   XMONFEEDFILTERACCEPT  154
	{(u_char) XMONFEEDFILTERACCEPT, ASN_COUNTER64, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 7}},
#define   XMONFEEDOSDROP        155
	{(u_char) XMONFEEDOSDROP, ASN_COUNTER64, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 8}},
#define   XMONFEEDUSERDELIV     156
	{(u_char) XMONFEEDUSERDELIV, ASN_COUNTER64, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 9}},
#define   XMONFEEDIFCOMPRESS    157
	{(u_char) XMONFEEDIFCOMPRESS, ASN_COUNTER64, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 10}},
#define   XMONFEEDUSEROCTETS    158
	{(u_char) XMONFEEDUSEROCTETS, ASN_COUNTER64, RONLY, var_xmonFeedStatsTable, 5, {2, 8, 6, 1, 11}},
#define   XMONPUSHPORT          159
	{(u_char) XMONPUSHPORT, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 9, 1}},
#define   XMONPUSHLISTENADDRTYPE  160
	{(u_char) XMONPUSHLISTENADDRTYPE, ASN_INTEGER, RWRITE, var_xmonPushListenTable, 5, {2, 9, 2, 1, 2}},
#define   XMONPUSHLISTENADDR    161
	{(u_char) XMONPUSHLISTENADDR, ASN_OCTET_STR, RWRITE, var_xmonPushListenTable, 5, {2, 9, 2, 1, 3}},
#define   XMONPUSHLISTENROWSTATUS  162
	{(u_char) XMONPUSHLISTENROWSTATUS, ASN_INTEGER, RWRITE, var_xmonPushListenTable, 5, {2, 9, 2, 1, 4}},
#define   XMONPUSHROLE          163
	{(u_char) XMONPUSHROLE, ASN_INTEGER, RONLY, var_xmonPushTable, 5, {2, 9, 3, 1, 2}},
#define   XMONPUSHNAME          164
	{(u_char) XMONPUSHNAME, ASN_OCTET_STR, RWRITE, var_xmonPushTable, 5, {2, 9, 3, 1, 3}},
#define   XMONPUSHADDRTYPE      165
	{(u_char) XMONPUSHADDRTYPE, ASN_INTEGER, RWRITE, var_xmonPushTable, 5, {2, 9, 3, 1, 4}},
#define   XMONPUSHADDR          166
	{(u_char) XMONPUSHADDR, ASN_OCTET_STR, RWRITE, var_xmonPushTable, 5, {2, 9, 3, 1, 5}},
#define   XMONPUSHCONNINTERVAL  167
	{(u_char) XMONPUSHCONNINTERVAL, ASN_INTEGER, RWRITE, var_xmonPushTable, 5, {2, 9, 3, 1, 6}},
#define   XMONPUSHCONNATTEMPTS  168
	{(u_char) XMONPUSHCONNATTEMPTS, ASN_UNSIGNED, RWRITE, var_xmonPushTable, 5, {2, 9, 3, 1, 7}},
#define   XMONPUSHPROFILE       169
	{(u_char) XMONPUSHPROFILE, ASN_OCTET_STR, RWRITE, var_xmonPushTable, 5, {2, 9, 3, 1, 8}},
#define   XMONPUSHADMINSTATE    170
	{(u_char) XMONPUSHADMINSTATE, ASN_INTEGER, RWRITE, var_xmonPushTable, 5, {2, 9, 3, 1, 9}},
#define   XMONPUSHOPSTATE       171
	{(u_char) XMONPUSHOPSTATE, ASN_INTEGER, RONLY, var_xmonPushTable, 5, {2, 9, 3, 1, 10}},
#define   XMONPUSHPROCSTATUS    172
	{(u_char) XMONPUSHPROCSTATUS, ASN_OCTET_STR, RONLY, var_xmonPushTable, 5, {2, 9, 3, 1, 11}},
#define   XMONPUSHUSAGESTATE    173
	{(u_char) XMONPUSHUSAGESTATE, ASN_INTEGER, RONLY, var_xmonPushTable, 5, {2, 9, 3, 1, 12}},
#define   XMONPUSHCONNSTATE     174
	{(u_char) XMONPUSHCONNSTATE, ASN_INTEGER, RONLY, var_xmonPushTable, 5, {2, 9, 3, 1, 13}},
#define   XMONPUSHSTORAGETYPE   175
	{(u_char) XMONPUSHSTORAGETYPE, ASN_INTEGER, RWRITE, var_xmonPushTable, 5, {2, 9, 3, 1, 14}},
#define   XMONPUSHROWSTATUS     176
	{(u_char) XMONPUSHROWSTATUS, ASN_INTEGER, RWRITE, var_xmonPushTable, 5, {2, 9, 3, 1, 15}},
#define   XMONPULLPORT          177
	{(u_char) XMONPULLPORT, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 10, 1}},
#define   XMONPULLLISTENADDRTYPE  178
	{(u_char) XMONPULLLISTENADDRTYPE, ASN_INTEGER, RWRITE, var_xmonPullListenTable, 5, {2, 10, 2, 1, 2}},
#define   XMONPULLLISTENADDR    179
	{(u_char) XMONPULLLISTENADDR, ASN_OCTET_STR, RWRITE, var_xmonPullListenTable, 5, {2, 10, 2, 1, 3}},
#define   XMONPULLLISTENROWSTATUS  180
	{(u_char) XMONPULLLISTENROWSTATUS, ASN_INTEGER, RWRITE, var_xmonPullListenTable, 5, {2, 10, 2, 1, 4}},
#define   XMONPULLSPOOLPATH     181
	{(u_char) XMONPULLSPOOLPATH, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 10, 3}},
#define   XMONPULLARCHIVEPATH   182
	{(u_char) XMONPULLARCHIVEPATH, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 10, 4}},
#define   XMONPULLROLE          183
	{(u_char) XMONPULLROLE, ASN_INTEGER, RONLY, var_xmonPullTable, 5, {2, 10, 5, 1, 2}},
#define   XMONPULLNAME          184
	{(u_char) XMONPULLNAME, ASN_OCTET_STR, RWRITE, var_xmonPullTable, 5, {2, 10, 5, 1, 3}},
#define   XMONPULLADDRTYPE      185
	{(u_char) XMONPULLADDRTYPE, ASN_INTEGER, RWRITE, var_xmonPullTable, 5, {2, 10, 5, 1, 4}},
#define   XMONPULLADDR          186
	{(u_char) XMONPULLADDR, ASN_OCTET_STR, RWRITE, var_xmonPullTable, 5, {2, 10, 5, 1, 5}},
#define   XMONPULLCONNINTERVAL  187
	{(u_char) XMONPULLCONNINTERVAL, ASN_INTEGER, RWRITE, var_xmonPullTable, 5, {2, 10, 5, 1, 6}},
#define   XMONPULLCONNATTEMPTS  188
	{(u_char) XMONPULLCONNATTEMPTS, ASN_UNSIGNED, RWRITE, var_xmonPullTable, 5, {2, 10, 5, 1, 7}},
#define   XMONPULLPROFILE       189
	{(u_char) XMONPULLPROFILE, ASN_OCTET_STR, RWRITE, var_xmonPullTable, 5, {2, 10, 5, 1, 8}},
#define   XMONPULLADMINSTATE    190
	{(u_char) XMONPULLADMINSTATE, ASN_INTEGER, RWRITE, var_xmonPullTable, 5, {2, 10, 5, 1, 9}},
#define   XMONPULLOPSTATE       191
	{(u_char) XMONPULLOPSTATE, ASN_INTEGER, RONLY, var_xmonPullTable, 5, {2, 10, 5, 1, 10}},
#define   XMONPULLPROCSTATUS    192
	{(u_char) XMONPULLPROCSTATUS, ASN_OCTET_STR, RONLY, var_xmonPullTable, 5, {2, 10, 5, 1, 11}},
#define   XMONPULLUSAGESTATE    193
	{(u_char) XMONPULLUSAGESTATE, ASN_INTEGER, RONLY, var_xmonPullTable, 5, {2, 10, 5, 1, 12}},
#define   XMONPULLCONNSTATE     194
	{(u_char) XMONPULLCONNSTATE, ASN_INTEGER, RONLY, var_xmonPullTable, 5, {2, 10, 5, 1, 13}},
#define   XMONPULLSTORAGETYPE   195
	{(u_char) XMONPULLSTORAGETYPE, ASN_INTEGER, RWRITE, var_xmonPullTable, 5, {2, 10, 5, 1, 14}},
#define   XMONPULLROWSTATUS     196
	{(u_char) XMONPULLROWSTATUS, ASN_INTEGER, RWRITE, var_xmonPullTable, 5, {2, 10, 5, 1, 15}},
#define   XMONCOLLECTOREXTENSIONS  197
	{(u_char) XMONCOLLECTOREXTENSIONS, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 11, 1}},
#define   XMONCOLLECTORADMINSTATE  198
	{(u_char) XMONCOLLECTORADMINSTATE, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 11, 2}},
#define   XMONCOLLECTOROPSTATE  199
	{(u_char) XMONCOLLECTOROPSTATE, ASN_INTEGER, RONLY, var_xmonMIB, 3, {2, 11, 3}},
#define   XMONCOLLECTORAVAILSTATUS  200
	{(u_char) XMONCOLLECTORAVAILSTATUS, ASN_OCTET_STR, RONLY, var_xmonMIB, 3, {2, 11, 4}},
#define   XMONCOLLECTORFULLACTION  201
	{(u_char) XMONCOLLECTORFULLACTION, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 11, 5}},
#define   XMONCOLLECTORALARMTHRESHOLD  202
	{(u_char) XMONCOLLECTORALARMTHRESHOLD, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 11, 6}},
#define   XMONCOLLECTORCACHEPATH  203
	{(u_char) XMONCOLLECTORCACHEPATH, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 11, 7}},
#define   XMONCOLLECTORSPOOLPATH  204
	{(u_char) XMONCOLLECTORSPOOLPATH, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 11, 8}},
#define   XMONCOLLECTORARCHIVEPATH  205
	{(u_char) XMONCOLLECTORARCHIVEPATH, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 11, 9}},
#define   XMONCOLLECTORARCHIVESUBDIRS  206
	{(u_char) XMONCOLLECTORARCHIVESUBDIRS, ASN_OCTET_STR, RWRITE, var_xmonMIB, 3, {2, 11, 10}},
#define   XMONCOLLECTORCOMPRESSION  207
	{(u_char) XMONCOLLECTORCOMPRESSION, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 11, 11}},
#define   XMONCOLLECTORFILESYSTEMALLOC  208
	{(u_char) XMONCOLLECTORFILESYSTEMALLOC, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 11, 12}},
#define   XMONCOLLECTORMAXDISKUSAGE  209
	{(u_char) XMONCOLLECTORMAXDISKUSAGE, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 11, 13}},
#define   XMONCOLLECTORDISCARDPOLICY  210
	{(u_char) XMONCOLLECTORDISCARDPOLICY, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 11, 14}},
#define   XMONUPLOADSPEC        211
	{(u_char) XMONUPLOADSPEC, ASN_OCTET_STR, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 2}},
#define   XMONUPLOADUSERNAME    212
	{(u_char) XMONUPLOADUSERNAME, ASN_OCTET_STR, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 3}},
#define   XMONUPLOADPASSWORD    213
	{(u_char) XMONUPLOADPASSWORD, ASN_OCTET_STR, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 4}},
#define   XMONUPLOADPERIOD      214
	{(u_char) XMONUPLOADPERIOD, ASN_INTEGER, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 5}},
#define   XMONUPLOADSTARTTIME   215
	{(u_char) XMONUPLOADSTARTTIME, ASN_TIMETICKS, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 6}},
#define   XMONUPLOADSTOPTIME    216
	{(u_char) XMONUPLOADSTOPTIME, ASN_TIMETICKS, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 7}},
#define   XMONUPLOADINTERVALSOFDAY  217
	{(u_char) XMONUPLOADINTERVALSOFDAY, ASN_OCTET_STR, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 8}},
#define   XMONUPLOADWEEKMASK    218
	{(u_char) XMONUPLOADWEEKMASK, ASN_OCTET_STR, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 9}},
#define   XMONUPLOADONROTATION  219
	{(u_char) XMONUPLOADONROTATION, ASN_INTEGER, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 10}},
#define   XMONUPLOADSELECTION   220
	{(u_char) XMONUPLOADSELECTION, ASN_INTEGER, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 11}},
#define   XMONUPLOADADMINSTATE  221
	{(u_char) XMONUPLOADADMINSTATE, ASN_INTEGER, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 12}},
#define   XMONUPLOADUSAGESTATE  222
	{(u_char) XMONUPLOADUSAGESTATE, ASN_INTEGER, RONLY, var_xmonUploadTable, 5, {2, 12, 1, 1, 13}},
#define   XMONUPLOADPROCSTATUS  223
	{(u_char) XMONUPLOADPROCSTATUS, ASN_OCTET_STR, RONLY, var_xmonUploadTable, 5, {2, 12, 1, 1, 14}},
#define   XMONUPLOADSTORAGETYPE  224
	{(u_char) XMONUPLOADSTORAGETYPE, ASN_INTEGER, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 15}},
#define   XMONUPLOADROWSTATUS   225
	{(u_char) XMONUPLOADROWSTATUS, ASN_INTEGER, RWRITE, var_xmonUploadTable, 5, {2, 12, 1, 1, 16}},
#define   XMONDOWNLOADSPEC      226
	{(u_char) XMONDOWNLOADSPEC, ASN_OCTET_STR, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 2}},
#define   XMONDOWNLOADUSERNAME  227
	{(u_char) XMONDOWNLOADUSERNAME, ASN_OCTET_STR, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 3}},
#define   XMONDOWNLOADPASSWORD  228
	{(u_char) XMONDOWNLOADPASSWORD, ASN_OCTET_STR, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 4}},
#define   XMONDOWNLOADPERIOD    229
	{(u_char) XMONDOWNLOADPERIOD, ASN_INTEGER, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 5}},
#define   XMONDOWNLOADSTARTTIME  230
	{(u_char) XMONDOWNLOADSTARTTIME, ASN_TIMETICKS, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 6}},
#define   XMONDOWNLOADSTOPTIME  231
	{(u_char) XMONDOWNLOADSTOPTIME, ASN_TIMETICKS, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 7}},
#define   XMONDOWNLOADINTERVALSOFDAY  232
	{(u_char) XMONDOWNLOADINTERVALSOFDAY, ASN_OCTET_STR, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 8}},
#define   XMONDOWNLOADWEEKMASK  233
	{(u_char) XMONDOWNLOADWEEKMASK, ASN_OCTET_STR, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 9}},
#define   XMONDOWNLOADONROTATION  234
	{(u_char) XMONDOWNLOADONROTATION, ASN_INTEGER, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 10}},
#define   XMONDOWNLOADSELECTION  235
	{(u_char) XMONDOWNLOADSELECTION, ASN_INTEGER, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 11}},
#define   XMONDOWNLOADADMINSTATE  236
	{(u_char) XMONDOWNLOADADMINSTATE, ASN_INTEGER, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 12}},
#define   XMONDOWNLOADUSAGESTATE  237
	{(u_char) XMONDOWNLOADUSAGESTATE, ASN_INTEGER, RONLY, var_xmonDownloadTable, 5, {2, 13, 1, 1, 13}},
#define   XMONDOWNLOADPROCSTATUS  238
	{(u_char) XMONDOWNLOADPROCSTATUS, ASN_OCTET_STR, RONLY, var_xmonDownloadTable, 5, {2, 13, 1, 1, 14}},
#define   XMONDOWNLOADSTORAGETYPE  239
	{(u_char) XMONDOWNLOADSTORAGETYPE, ASN_INTEGER, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 15}},
#define   XMONDOWNLOADROWSTATUS  240
	{(u_char) XMONDOWNLOADROWSTATUS, ASN_INTEGER, RWRITE, var_xmonDownloadTable, 5, {2, 13, 1, 1, 16}},
#define   XMONSCTPDEFAULTNODELAY  241
	{(u_char) XMONSCTPDEFAULTNODELAY, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 14, 1}},
#define   XMONSCTPDEFAULTMAXSEG  242
	{(u_char) XMONSCTPDEFAULTMAXSEG, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 2}},
#define   XMONSCTPDEFAULTHEARTBEATITVL  243
	{(u_char) XMONSCTPDEFAULTHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 3}},
#define   XMONSCTPDEFAULTHEARTBEAT  244
	{(u_char) XMONSCTPDEFAULTHEARTBEAT, ASN_INTEGER, RWRITE, var_xmonMIB, 3, {2, 14, 4}},
#define   XMONSCTPDEFAULTRTOINITIAL  245
	{(u_char) XMONSCTPDEFAULTRTOINITIAL, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 5}},
#define   XMONSCTPDEFAULTRTOMIN  246
	{(u_char) XMONSCTPDEFAULTRTOMIN, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 6}},
#define   XMONSCTPDEFAULTRTOMAX  247
	{(u_char) XMONSCTPDEFAULTRTOMAX, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 7}},
#define   XMONSCTPDEFAULTPATHMAXRETRANS  248
	{(u_char) XMONSCTPDEFAULTPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 8}},
#define   XMONSCTPDEFAULTCOOKIELIFE  249
	{(u_char) XMONSCTPDEFAULTCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 9}},
#define   XMONSCTPDEFAULTCOOKIEINC  250
	{(u_char) XMONSCTPDEFAULTCOOKIEINC, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 10}},
#define   XMONSCTPDEFAULTMAXINITRETRIES  251
	{(u_char) XMONSCTPDEFAULTMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 11}},
#define   XMONSCTPDEFAULTMAXBURST  252
	{(u_char) XMONSCTPDEFAULTMAXBURST, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 12}},
#define   XMONSCTPDEFAULTASSOCMAXRETRANS  253
	{(u_char) XMONSCTPDEFAULTASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 13}},
#define   XMONSCTPDEFAULTSACKDELAY  254
	{(u_char) XMONSCTPDEFAULTSACKDELAY, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 14}},
#define   XMONSCTPDEFAULTLIFETIME  255
	{(u_char) XMONSCTPDEFAULTLIFETIME, ASN_UNSIGNED, RWRITE, var_xmonMIB, 3, {2, 14, 15}},
#define   XMONSCTPNODELAY       256
	{(u_char) XMONSCTPNODELAY, ASN_INTEGER, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 2}},
#define   XMONSCTPMAXSEG        257
	{(u_char) XMONSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 3}},
#define   XMONSCTPHEARTBEATITVL  258
	{(u_char) XMONSCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 4}},
#define   XMONSCTPHEARTBEAT     259
	{(u_char) XMONSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 5}},
#define   XMONSCTPRTOINITIAL    260
	{(u_char) XMONSCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 6}},
#define   XMONSCTPRTOMIN        261
	{(u_char) XMONSCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 7}},
#define   XMONSCTPRTOMAX        262
	{(u_char) XMONSCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 8}},
#define   XMONSCTPPATHMAXRETRANS  263
	{(u_char) XMONSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 9}},
#define   XMONSCTPCOOKIELIFE    264
	{(u_char) XMONSCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 10}},
#define   XMONSCTPCOOKIEINC     265
	{(u_char) XMONSCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 11}},
#define   XMONSCTPMAXINITRETRIES  266
	{(u_char) XMONSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 12}},
#define   XMONSCTPMAXBURST      267
	{(u_char) XMONSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 13}},
#define   XMONSCTPASSOCMAXRETRANS  268
	{(u_char) XMONSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 14}},
#define   XMONSCTPSACKDELAY     269
	{(u_char) XMONSCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 15}},
#define   XMONSCTPLIFETIME      270
	{(u_char) XMONSCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 16}},
#define   XMONSCTPROWSTATUS     271
	{(u_char) XMONSCTPROWSTATUS, ASN_INTEGER, RWRITE, var_xmonSctpTable, 5, {2, 14, 16, 1, 17}},
};

/* (L = length of the oidsuffix) */
struct xmonMIB_data *xmonMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *xmonSourceTableStorage = NULL;
struct header_complex_index *xmonSourceStatsTableStorage = NULL;
struct header_complex_index *xmonSourceHistTableStorage = NULL;
struct header_complex_index *xmonSourceTotalTableStorage = NULL;
struct header_complex_index *xmonInterfaceTableStorage = NULL;
struct header_complex_index *xmonRmonTableStorage = NULL;
struct header_complex_index *xmonArchiveTableStorage = NULL;
struct header_complex_index *xmonFeedListenTableStorage = NULL;
struct header_complex_index *xmonFeedTableStorage = NULL;
struct header_complex_index *xmonFeedStatsTableStorage = NULL;
struct header_complex_index *xmonPushListenTableStorage = NULL;
struct header_complex_index *xmonPushTableStorage = NULL;
struct header_complex_index *xmonPullListenTableStorage = NULL;
struct header_complex_index *xmonPullTableStorage = NULL;
struct header_complex_index *xmonUploadTableStorage = NULL;
struct header_complex_index *xmonDownloadTableStorage = NULL;
struct header_complex_index *xmonSctpTableStorage = NULL;

void (*xmonMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void xmonMIB_loop_handler(int);
void xmonMIB_fd_handler(int, void *);

/**
 * @fn void init_xmonMIB(void)
 * @brief xmonMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (xmonMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_xmonMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("xmonMIB", "init_xmonMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("xmonMIB", xmonMIB_variables, variable7, xmonMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_xmonMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("xmonMIB", parse_xmonMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonSourceTable", parse_xmonSourceTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonSourceStatsTable", parse_xmonSourceStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonSourceHistTable", parse_xmonSourceHistTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonSourceTotalTable", parse_xmonSourceTotalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonInterfaceTable", parse_xmonInterfaceTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonRmonTable", parse_xmonRmonTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonArchiveTable", parse_xmonArchiveTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonFeedListenTable", parse_xmonFeedListenTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonFeedTable", parse_xmonFeedTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonFeedStatsTable", parse_xmonFeedStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonPushListenTable", parse_xmonPushListenTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonPushTable", parse_xmonPushTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonPullListenTable", parse_xmonPullListenTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonPullTable", parse_xmonPullTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonUploadTable", parse_xmonUploadTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonDownloadTable", parse_xmonDownloadTable, NULL, "HELP STRING");
	snmpd_register_config_handler("xmonSctpTable", parse_xmonSctpTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonSourceTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonSourceStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonSourceHistTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonSourceTotalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonInterfaceTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonRmonTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonArchiveTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonFeedListenTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonFeedTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonFeedStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonPushListenTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonPushTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonPullListenTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonPullTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonUploadTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonDownloadTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_xmonSctpTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, xmonMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, xmonMIB_fd_handler, (void *) 1);
	}
	xmonMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &xmonMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/**
 * @fn void deinit_xmonMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (xmonMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_xmonMIB(void)
{
	DEBUGMSGTL(("xmonMIB", "deinit_xmonMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = xmonMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(xmonMIB_variables_oid, sizeof(xmonMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("xmonMIB");
	snmpd_unregister_config_handler("xmonSourceTable");
	snmpd_unregister_config_handler("xmonSourceStatsTable");
	snmpd_unregister_config_handler("xmonSourceHistTable");
	snmpd_unregister_config_handler("xmonSourceTotalTable");
	snmpd_unregister_config_handler("xmonInterfaceTable");
	snmpd_unregister_config_handler("xmonRmonTable");
	snmpd_unregister_config_handler("xmonArchiveTable");
	snmpd_unregister_config_handler("xmonFeedListenTable");
	snmpd_unregister_config_handler("xmonFeedTable");
	snmpd_unregister_config_handler("xmonFeedStatsTable");
	snmpd_unregister_config_handler("xmonPushListenTable");
	snmpd_unregister_config_handler("xmonPushTable");
	snmpd_unregister_config_handler("xmonPullListenTable");
	snmpd_unregister_config_handler("xmonPullTable");
	snmpd_unregister_config_handler("xmonUploadTable");
	snmpd_unregister_config_handler("xmonDownloadTable");
	snmpd_unregister_config_handler("xmonSctpTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

int
term_xmonMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("xmonMIB", "term_xmonMIB: terminating...  "));
	deinit_xmonMIB();
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct xmonMIB_data *xmonMIB_create(void)
 * @brief create a fresh data structure representing scalars in xmonMIB.
 *
 * Creates a new xmonMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in xmonMIB.
 */
struct xmonMIB_data *
xmonMIB_create(void)
{
	struct xmonMIB_data *StorageNew = SNMP_MALLOC_STRUCT(xmonMIB_data);

	DEBUGMSGTL(("xmonMIB", "xmonMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		if ((StorageNew->xmonProbeName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonProbeNameLen = 0;
		StorageNew->xmonProbeName[StorageNew->xmonProbeNameLen] = 0;
		if ((StorageNew->xmonProbeUuid = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonProbeUuidLen = 0;
		StorageNew->xmonProbeUuid[StorageNew->xmonProbeUuidLen] = 0;
		if ((StorageNew->xmonProbeHardware = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonProbeHardwareLen = 0;
		StorageNew->xmonProbeHardware[StorageNew->xmonProbeHardwareLen] = 0;
		if ((StorageNew->xmonProbeOs = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonProbeOsLen = 0;
		StorageNew->xmonProbeOs[StorageNew->xmonProbeOsLen] = 0;
		if ((StorageNew->xmonProbeUserAppl = (uint8_t *) strdup("ss7mon 1.1.2")) == NULL)
			goto nomem;
		StorageNew->xmonProbeUserApplLen = strlen("ss7mon 1.1.2");
		StorageNew->xmonBufferAdminState = 0;
		StorageNew->xmonBufferOpState = 0;
		if (memdup((u_char **) &StorageNew->xmonBufferAvailStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonBufferAvailStatusLen = 2;
		StorageNew->xmonBufferFullAction = XMONBUFFERFULLACTION_WRAP;
		StorageNew->xmonBufferMaxSize = 0;
		StorageNew->xmonBufferMaxPackets = 0;
		StorageNew->xmonBufferMaxTime = 0;
		StorageNew->xmonBufferCurrentSize = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferNumberOfPackets = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferCurrentInterval = 0;
		if (memdup((u_char **) &StorageNew->xmonBufferAlarmThreshold, (u_char *) "\x64", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonBufferAlarmThresholdLen = 1;
		StorageNew->xmonBufferOctetHiWaterMark = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferOctetLoWaterMark = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferPktsHiWaterMark = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferPktsLoWaterMark = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferTimeHiWaterMark = 0;
		StorageNew->xmonBufferTimeLoWaterMark = 0;
		StorageNew->xmonBufferDrops = 0;
		StorageNew->xmonBufferReset = XMONBUFFERRESET_RESET;
		StorageNew->xmonBufferTimeElapsed = 0;
		StorageNew->xmonBufferBegTime = 0;
		StorageNew->xmonBufferEndTime = 0;
		StorageNew->xmonBufferIfRecv = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferIfDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferFilterAccept = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferOsDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferUserDeliv = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferIfCompress = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferUserOctets = (struct counter64) {
		0, 0};
		StorageNew->xmonBufferActionResult = 0;
		if ((StorageNew->xmonCapturePath = (uint8_t *) strdup("/var/local/openss7/xmon/spool/%P")) == NULL)
			goto nomem;
		StorageNew->xmonCapturePathLen = strlen("/var/local/openss7/xmon/spool/%P");
		if ((StorageNew->xmonCaptureFilename = (uint8_t *) strdup("xmon-%I-%Y-%M-%D-%h:%m:%s")) == NULL)
			goto nomem;
		StorageNew->xmonCaptureFilenameLen = strlen("xmon-%I-%Y-%M-%D-%h:%m:%s");
		StorageNew->xmonCaptureAdminState = 0;
		StorageNew->xmonCaptureOpState = 0;
		if (memdup((u_char **) &StorageNew->xmonCaptureAvailStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonCaptureAvailStatusLen = 2;
		StorageNew->xmonCaptureFullAction = XMONCAPTUREFULLACTION_WRAP;
		StorageNew->xmonCaptureMaxSize = 0;
		StorageNew->xmonCaptureMaxPackets = 0;
		StorageNew->xmonCaptureMaxTime = 0;
		StorageNew->xmonCaptureCurrentSize = (struct counter64) {
		0, 0};
		StorageNew->xmonCaptureNumberOfPackets = (struct counter64) {
		0, 0};
		StorageNew->xmonCaptureCurrentInterval = 0;
		if (memdup((u_char **) &StorageNew->xmonCaptureAlarmThreshold, (u_char *) "\x64", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonCaptureAlarmThresholdLen = 1;
		StorageNew->xmonCaptureOctetHiWaterMark = (struct counter64) {
		0, 0};
		StorageNew->xmonCaptureOctetLoWaterMark = (struct counter64) {
		0, 0};
		StorageNew->xmonCapturePktsHiWaterMark = (struct counter64) {
		0, 0};
		StorageNew->xmonCapturePktsLoWaterMark = (struct counter64) {
		0, 0};
		StorageNew->xmonCaptureTimeHiWaterMark = 0;
		StorageNew->xmonCaptureTimeLoWaterMark = 0;
		if ((StorageNew->xmonArchivePath = (uint8_t *) strdup("/var/local/openss7/xmon/spool/%P")) == NULL)
			goto nomem;
		StorageNew->xmonArchivePathLen = strlen("/var/local/openss7/xmon/spool/%P");
		if (memdup((u_char **) &StorageNew->xmonFeedTypes, (u_char *) "\xC0", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonFeedTypesLen = 1;
		StorageNew->xmonFeedPort = 5572;
		StorageNew->xmonPushPort = 5573;
		StorageNew->xmonPullPort = 0;
		if ((StorageNew->xmonPullSpoolPath = (uint8_t *) strdup("/var/local/openss7/xmon/spool/%U")) == NULL)
			goto nomem;
		StorageNew->xmonPullSpoolPathLen = strlen("/var/local/openss7/xmon/spool/%U");
		if ((StorageNew->xmonPullArchivePath = (uint8_t *) strdup("/var/local/openss7/xmon/archive/%U")) == NULL)
			goto nomem;
		StorageNew->xmonPullArchivePathLen = strlen("/var/local/openss7/xmon/archive/%U");
		if (memdup((u_char **) &StorageNew->xmonCollectorExtensions, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonCollectorExtensionsLen = 1;
		StorageNew->xmonCollectorAdminState = XMONCOLLECTORADMINSTATE_UNLOCKED;
		StorageNew->xmonCollectorOpState = XMONCOLLECTOROPSTATE_ENABLED;
		if (memdup((u_char **) &StorageNew->xmonCollectorAvailStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonCollectorAvailStatusLen = 2;
		StorageNew->xmonCollectorFullAction = 0;
		if (memdup((u_char **) &StorageNew->xmonCollectorAlarmThreshold, (u_char *) "\x64", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonCollectorAlarmThresholdLen = 1;
		if ((StorageNew->xmonCollectorCachePath = (uint8_t *) strdup("/var/local/openss7/xmon/cache/%U")) == NULL)
			goto nomem;
		StorageNew->xmonCollectorCachePathLen = strlen("/var/local/openss7/xmon/cache/%U");
		if ((StorageNew->xmonCollectorSpoolPath = (uint8_t *) strdup("/var/local/openss7/xmon/spool/%U")) == NULL)
			goto nomem;
		StorageNew->xmonCollectorSpoolPathLen = strlen("/var/local/openss7/xmon/spool/%U");
		if ((StorageNew->xmonCollectorArchivePath = (uint8_t *) strdup("/var/local/openss7/xmon/spool/%U")) == NULL)
			goto nomem;
		StorageNew->xmonCollectorArchivePathLen = strlen("/var/local/openss7/xmon/spool/%U");
		if (memdup((u_char **) &StorageNew->xmonCollectorArchiveSubdirs, (u_char *) "\xA0", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonCollectorArchiveSubdirsLen = 1;
		StorageNew->xmonCollectorCompression = XMONCOLLECTORCOMPRESSION_XZ;
		StorageNew->xmonCollectorFileSystemAlloc = 90;
		StorageNew->xmonCollectorMaxDiskUsage = 80;
		StorageNew->xmonCollectorDiscardPolicy = XMONCOLLECTORDISCARDPOLICY_IGNORE;
		StorageNew->xmonSctpDefaultNoDelay = TV_FALSE;
		StorageNew->xmonSctpDefaultMaxseg = 536;
		StorageNew->xmonSctpDefaultHeartbeatItvl = 60000;
		StorageNew->xmonSctpDefaultHeartbeat = TV_TRUE;
		StorageNew->xmonSctpDefaultRtoInitial = 3000;
		StorageNew->xmonSctpDefaultRtoMin = 1000;
		StorageNew->xmonSctpDefaultRtoMax = 60000;
		StorageNew->xmonSctpDefaultPathMaxRetrans = 5;
		StorageNew->xmonSctpDefaultCookieLife = 0;
		StorageNew->xmonSctpDefaultCookieInc = 5000;
		StorageNew->xmonSctpDefaultMaxInitRetries = 8;
		StorageNew->xmonSctpDefaultMaxBurst = 3;
		StorageNew->xmonSctpDefaultAssocMaxRetrans = 10;
		StorageNew->xmonSctpDefaultSackDelay = 200;
		StorageNew->xmonSctpDefaultLifetime = 0;

	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonMIB_data *xmonMIB_duplicate(struct xmonMIB_data *thedata)
 * @param thedata the mib structure to duplicate
 * @brief duplicate a mib structure for the mib
 *
 * Duplicates the specified mib structure @param thedata and returns a pointer to the newly
 * allocated mib structure on success, or NULL on failure.
 */
struct xmonMIB_data *
xmonMIB_duplicate(struct xmonMIB_data *thedata)
{
	struct xmonMIB_data *StorageNew = SNMP_MALLOC_STRUCT(xmonMIB_data);

	DEBUGMSGTL(("xmonMIB", "xmonMIB_duplicate: duplicating mib... "));
	if (StorageNew != NULL) {
		if (!(StorageNew->xmonProbeName = malloc(thedata->xmonProbeNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonProbeName, thedata->xmonProbeName, thedata->xmonProbeNameLen);
		StorageNew->xmonProbeNameLen = thedata->xmonProbeNameLen;
		StorageNew->xmonProbeName[StorageNew->xmonProbeNameLen] = 0;
		if (!(StorageNew->xmonProbeUuid = malloc(thedata->xmonProbeUuidLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonProbeUuid, thedata->xmonProbeUuid, thedata->xmonProbeUuidLen);
		StorageNew->xmonProbeUuidLen = thedata->xmonProbeUuidLen;
		StorageNew->xmonProbeUuid[StorageNew->xmonProbeUuidLen] = 0;
		if (!(StorageNew->xmonProbeHardware = malloc(thedata->xmonProbeHardwareLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonProbeHardware, thedata->xmonProbeHardware, thedata->xmonProbeHardwareLen);
		StorageNew->xmonProbeHardwareLen = thedata->xmonProbeHardwareLen;
		StorageNew->xmonProbeHardware[StorageNew->xmonProbeHardwareLen] = 0;
		if (!(StorageNew->xmonProbeOs = malloc(thedata->xmonProbeOsLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonProbeOs, thedata->xmonProbeOs, thedata->xmonProbeOsLen);
		StorageNew->xmonProbeOsLen = thedata->xmonProbeOsLen;
		StorageNew->xmonProbeOs[StorageNew->xmonProbeOsLen] = 0;
		if (!(StorageNew->xmonProbeUserAppl = malloc(thedata->xmonProbeUserApplLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonProbeUserAppl, thedata->xmonProbeUserAppl, thedata->xmonProbeUserApplLen);
		StorageNew->xmonProbeUserApplLen = thedata->xmonProbeUserApplLen;
		StorageNew->xmonProbeUserAppl[StorageNew->xmonProbeUserApplLen] = 0;
		StorageNew->xmonBufferAdminState = thedata->xmonBufferAdminState;
		StorageNew->xmonBufferOpState = thedata->xmonBufferOpState;
		if (!(StorageNew->xmonBufferAvailStatus = malloc(thedata->xmonBufferAvailStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonBufferAvailStatus, thedata->xmonBufferAvailStatus, thedata->xmonBufferAvailStatusLen);
		StorageNew->xmonBufferAvailStatusLen = thedata->xmonBufferAvailStatusLen;
		StorageNew->xmonBufferAvailStatus[StorageNew->xmonBufferAvailStatusLen] = 0;
		StorageNew->xmonBufferFullAction = thedata->xmonBufferFullAction;
		StorageNew->xmonBufferMaxSize = thedata->xmonBufferMaxSize;
		StorageNew->xmonBufferMaxPackets = thedata->xmonBufferMaxPackets;
		StorageNew->xmonBufferMaxTime = thedata->xmonBufferMaxTime;
		StorageNew->xmonBufferCurrentSize = thedata->xmonBufferCurrentSize;
		StorageNew->xmonBufferNumberOfPackets = thedata->xmonBufferNumberOfPackets;
		StorageNew->xmonBufferCurrentInterval = thedata->xmonBufferCurrentInterval;
		if (!(StorageNew->xmonBufferAlarmThreshold = malloc(thedata->xmonBufferAlarmThresholdLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonBufferAlarmThreshold, thedata->xmonBufferAlarmThreshold, thedata->xmonBufferAlarmThresholdLen);
		StorageNew->xmonBufferAlarmThresholdLen = thedata->xmonBufferAlarmThresholdLen;
		StorageNew->xmonBufferAlarmThreshold[StorageNew->xmonBufferAlarmThresholdLen] = 0;
		StorageNew->xmonBufferOctetHiWaterMark = thedata->xmonBufferOctetHiWaterMark;
		StorageNew->xmonBufferOctetLoWaterMark = thedata->xmonBufferOctetLoWaterMark;
		StorageNew->xmonBufferPktsHiWaterMark = thedata->xmonBufferPktsHiWaterMark;
		StorageNew->xmonBufferPktsLoWaterMark = thedata->xmonBufferPktsLoWaterMark;
		StorageNew->xmonBufferTimeHiWaterMark = thedata->xmonBufferTimeHiWaterMark;
		StorageNew->xmonBufferTimeLoWaterMark = thedata->xmonBufferTimeLoWaterMark;
		StorageNew->xmonBufferDrops = thedata->xmonBufferDrops;
		StorageNew->xmonBufferReset = thedata->xmonBufferReset;
		StorageNew->xmonBufferTimeElapsed = thedata->xmonBufferTimeElapsed;
		StorageNew->xmonBufferBegTime = thedata->xmonBufferBegTime;
		StorageNew->xmonBufferEndTime = thedata->xmonBufferEndTime;
		StorageNew->xmonBufferIfRecv = thedata->xmonBufferIfRecv;
		StorageNew->xmonBufferIfDrop = thedata->xmonBufferIfDrop;
		StorageNew->xmonBufferFilterAccept = thedata->xmonBufferFilterAccept;
		StorageNew->xmonBufferOsDrop = thedata->xmonBufferOsDrop;
		StorageNew->xmonBufferUserDeliv = thedata->xmonBufferUserDeliv;
		StorageNew->xmonBufferIfCompress = thedata->xmonBufferIfCompress;
		StorageNew->xmonBufferUserOctets = thedata->xmonBufferUserOctets;
		StorageNew->xmonBufferActionResult = thedata->xmonBufferActionResult;
		if (!(StorageNew->xmonCapturePath = malloc(thedata->xmonCapturePathLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCapturePath, thedata->xmonCapturePath, thedata->xmonCapturePathLen);
		StorageNew->xmonCapturePathLen = thedata->xmonCapturePathLen;
		StorageNew->xmonCapturePath[StorageNew->xmonCapturePathLen] = 0;
		if (!(StorageNew->xmonCaptureFilename = malloc(thedata->xmonCaptureFilenameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCaptureFilename, thedata->xmonCaptureFilename, thedata->xmonCaptureFilenameLen);
		StorageNew->xmonCaptureFilenameLen = thedata->xmonCaptureFilenameLen;
		StorageNew->xmonCaptureFilename[StorageNew->xmonCaptureFilenameLen] = 0;
		StorageNew->xmonCaptureAdminState = thedata->xmonCaptureAdminState;
		StorageNew->xmonCaptureOpState = thedata->xmonCaptureOpState;
		if (!(StorageNew->xmonCaptureAvailStatus = malloc(thedata->xmonCaptureAvailStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCaptureAvailStatus, thedata->xmonCaptureAvailStatus, thedata->xmonCaptureAvailStatusLen);
		StorageNew->xmonCaptureAvailStatusLen = thedata->xmonCaptureAvailStatusLen;
		StorageNew->xmonCaptureAvailStatus[StorageNew->xmonCaptureAvailStatusLen] = 0;
		StorageNew->xmonCaptureFullAction = thedata->xmonCaptureFullAction;
		StorageNew->xmonCaptureMaxSize = thedata->xmonCaptureMaxSize;
		StorageNew->xmonCaptureMaxPackets = thedata->xmonCaptureMaxPackets;
		StorageNew->xmonCaptureMaxTime = thedata->xmonCaptureMaxTime;
		StorageNew->xmonCaptureCurrentSize = thedata->xmonCaptureCurrentSize;
		StorageNew->xmonCaptureNumberOfPackets = thedata->xmonCaptureNumberOfPackets;
		StorageNew->xmonCaptureCurrentInterval = thedata->xmonCaptureCurrentInterval;
		if (!(StorageNew->xmonCaptureAlarmThreshold = malloc(thedata->xmonCaptureAlarmThresholdLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCaptureAlarmThreshold, thedata->xmonCaptureAlarmThreshold, thedata->xmonCaptureAlarmThresholdLen);
		StorageNew->xmonCaptureAlarmThresholdLen = thedata->xmonCaptureAlarmThresholdLen;
		StorageNew->xmonCaptureAlarmThreshold[StorageNew->xmonCaptureAlarmThresholdLen] = 0;
		StorageNew->xmonCaptureOctetHiWaterMark = thedata->xmonCaptureOctetHiWaterMark;
		StorageNew->xmonCaptureOctetLoWaterMark = thedata->xmonCaptureOctetLoWaterMark;
		StorageNew->xmonCapturePktsHiWaterMark = thedata->xmonCapturePktsHiWaterMark;
		StorageNew->xmonCapturePktsLoWaterMark = thedata->xmonCapturePktsLoWaterMark;
		StorageNew->xmonCaptureTimeHiWaterMark = thedata->xmonCaptureTimeHiWaterMark;
		StorageNew->xmonCaptureTimeLoWaterMark = thedata->xmonCaptureTimeLoWaterMark;
		if (!(StorageNew->xmonArchivePath = malloc(thedata->xmonArchivePathLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonArchivePath, thedata->xmonArchivePath, thedata->xmonArchivePathLen);
		StorageNew->xmonArchivePathLen = thedata->xmonArchivePathLen;
		StorageNew->xmonArchivePath[StorageNew->xmonArchivePathLen] = 0;
		if (!(StorageNew->xmonFeedTypes = malloc(thedata->xmonFeedTypesLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonFeedTypes, thedata->xmonFeedTypes, thedata->xmonFeedTypesLen);
		StorageNew->xmonFeedTypesLen = thedata->xmonFeedTypesLen;
		StorageNew->xmonFeedTypes[StorageNew->xmonFeedTypesLen] = 0;
		StorageNew->xmonFeedPort = thedata->xmonFeedPort;
		StorageNew->xmonPushPort = thedata->xmonPushPort;
		StorageNew->xmonPullPort = thedata->xmonPullPort;
		if (!(StorageNew->xmonPullSpoolPath = malloc(thedata->xmonPullSpoolPathLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPullSpoolPath, thedata->xmonPullSpoolPath, thedata->xmonPullSpoolPathLen);
		StorageNew->xmonPullSpoolPathLen = thedata->xmonPullSpoolPathLen;
		StorageNew->xmonPullSpoolPath[StorageNew->xmonPullSpoolPathLen] = 0;
		if (!(StorageNew->xmonPullArchivePath = malloc(thedata->xmonPullArchivePathLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPullArchivePath, thedata->xmonPullArchivePath, thedata->xmonPullArchivePathLen);
		StorageNew->xmonPullArchivePathLen = thedata->xmonPullArchivePathLen;
		StorageNew->xmonPullArchivePath[StorageNew->xmonPullArchivePathLen] = 0;
		if (!(StorageNew->xmonCollectorExtensions = malloc(thedata->xmonCollectorExtensionsLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCollectorExtensions, thedata->xmonCollectorExtensions, thedata->xmonCollectorExtensionsLen);
		StorageNew->xmonCollectorExtensionsLen = thedata->xmonCollectorExtensionsLen;
		StorageNew->xmonCollectorExtensions[StorageNew->xmonCollectorExtensionsLen] = 0;
		StorageNew->xmonCollectorAdminState = thedata->xmonCollectorAdminState;
		StorageNew->xmonCollectorOpState = thedata->xmonCollectorOpState;
		if (!(StorageNew->xmonCollectorAvailStatus = malloc(thedata->xmonCollectorAvailStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCollectorAvailStatus, thedata->xmonCollectorAvailStatus, thedata->xmonCollectorAvailStatusLen);
		StorageNew->xmonCollectorAvailStatusLen = thedata->xmonCollectorAvailStatusLen;
		StorageNew->xmonCollectorAvailStatus[StorageNew->xmonCollectorAvailStatusLen] = 0;
		StorageNew->xmonCollectorFullAction = thedata->xmonCollectorFullAction;
		if (!(StorageNew->xmonCollectorAlarmThreshold = malloc(thedata->xmonCollectorAlarmThresholdLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCollectorAlarmThreshold, thedata->xmonCollectorAlarmThreshold, thedata->xmonCollectorAlarmThresholdLen);
		StorageNew->xmonCollectorAlarmThresholdLen = thedata->xmonCollectorAlarmThresholdLen;
		StorageNew->xmonCollectorAlarmThreshold[StorageNew->xmonCollectorAlarmThresholdLen] = 0;
		if (!(StorageNew->xmonCollectorCachePath = malloc(thedata->xmonCollectorCachePathLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCollectorCachePath, thedata->xmonCollectorCachePath, thedata->xmonCollectorCachePathLen);
		StorageNew->xmonCollectorCachePathLen = thedata->xmonCollectorCachePathLen;
		StorageNew->xmonCollectorCachePath[StorageNew->xmonCollectorCachePathLen] = 0;
		if (!(StorageNew->xmonCollectorSpoolPath = malloc(thedata->xmonCollectorSpoolPathLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCollectorSpoolPath, thedata->xmonCollectorSpoolPath, thedata->xmonCollectorSpoolPathLen);
		StorageNew->xmonCollectorSpoolPathLen = thedata->xmonCollectorSpoolPathLen;
		StorageNew->xmonCollectorSpoolPath[StorageNew->xmonCollectorSpoolPathLen] = 0;
		if (!(StorageNew->xmonCollectorArchivePath = malloc(thedata->xmonCollectorArchivePathLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCollectorArchivePath, thedata->xmonCollectorArchivePath, thedata->xmonCollectorArchivePathLen);
		StorageNew->xmonCollectorArchivePathLen = thedata->xmonCollectorArchivePathLen;
		StorageNew->xmonCollectorArchivePath[StorageNew->xmonCollectorArchivePathLen] = 0;
		if (!(StorageNew->xmonCollectorArchiveSubdirs = malloc(thedata->xmonCollectorArchiveSubdirsLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonCollectorArchiveSubdirs, thedata->xmonCollectorArchiveSubdirs, thedata->xmonCollectorArchiveSubdirsLen);
		StorageNew->xmonCollectorArchiveSubdirsLen = thedata->xmonCollectorArchiveSubdirsLen;
		StorageNew->xmonCollectorArchiveSubdirs[StorageNew->xmonCollectorArchiveSubdirsLen] = 0;
		StorageNew->xmonCollectorCompression = thedata->xmonCollectorCompression;
		StorageNew->xmonCollectorFileSystemAlloc = thedata->xmonCollectorFileSystemAlloc;
		StorageNew->xmonCollectorMaxDiskUsage = thedata->xmonCollectorMaxDiskUsage;
		StorageNew->xmonCollectorDiscardPolicy = thedata->xmonCollectorDiscardPolicy;
		StorageNew->xmonSctpDefaultNoDelay = thedata->xmonSctpDefaultNoDelay;
		StorageNew->xmonSctpDefaultMaxseg = thedata->xmonSctpDefaultMaxseg;
		StorageNew->xmonSctpDefaultHeartbeatItvl = thedata->xmonSctpDefaultHeartbeatItvl;
		StorageNew->xmonSctpDefaultHeartbeat = thedata->xmonSctpDefaultHeartbeat;
		StorageNew->xmonSctpDefaultRtoInitial = thedata->xmonSctpDefaultRtoInitial;
		StorageNew->xmonSctpDefaultRtoMin = thedata->xmonSctpDefaultRtoMin;
		StorageNew->xmonSctpDefaultRtoMax = thedata->xmonSctpDefaultRtoMax;
		StorageNew->xmonSctpDefaultPathMaxRetrans = thedata->xmonSctpDefaultPathMaxRetrans;
		StorageNew->xmonSctpDefaultCookieLife = thedata->xmonSctpDefaultCookieLife;
		StorageNew->xmonSctpDefaultCookieInc = thedata->xmonSctpDefaultCookieInc;
		StorageNew->xmonSctpDefaultMaxInitRetries = thedata->xmonSctpDefaultMaxInitRetries;
		StorageNew->xmonSctpDefaultMaxBurst = thedata->xmonSctpDefaultMaxBurst;
		StorageNew->xmonSctpDefaultAssocMaxRetrans = thedata->xmonSctpDefaultAssocMaxRetrans;
		StorageNew->xmonSctpDefaultSackDelay = thedata->xmonSctpDefaultSackDelay;
		StorageNew->xmonSctpDefaultLifetime = thedata->xmonSctpDefaultLifetime;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonMIB_destroy(struct xmonMIB_data **thedata)
 * @param thedata pointer to the data structure in xmonMIB.
 * @brief delete a scalars structure from xmonMIB.
 *
 * Frees scalars that were previously removed from xmonMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonMIB_destroy(struct xmonMIB_data **thedata)
{
	struct xmonMIB_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonProbeName);
		StorageDel->xmonProbeNameLen = 0;
		SNMP_FREE(StorageDel->xmonProbeUuid);
		StorageDel->xmonProbeUuidLen = 0;
		SNMP_FREE(StorageDel->xmonProbeHardware);
		StorageDel->xmonProbeHardwareLen = 0;
		SNMP_FREE(StorageDel->xmonProbeOs);
		StorageDel->xmonProbeOsLen = 0;
		SNMP_FREE(StorageDel->xmonProbeUserAppl);
		StorageDel->xmonProbeUserApplLen = 0;
		SNMP_FREE(StorageDel->xmonBufferAvailStatus);
		StorageDel->xmonBufferAvailStatusLen = 0;
		SNMP_FREE(StorageDel->xmonBufferAlarmThreshold);
		StorageDel->xmonBufferAlarmThresholdLen = 0;
		SNMP_FREE(StorageDel->xmonCapturePath);
		StorageDel->xmonCapturePathLen = 0;
		SNMP_FREE(StorageDel->xmonCaptureFilename);
		StorageDel->xmonCaptureFilenameLen = 0;
		SNMP_FREE(StorageDel->xmonCaptureAvailStatus);
		StorageDel->xmonCaptureAvailStatusLen = 0;
		SNMP_FREE(StorageDel->xmonCaptureAlarmThreshold);
		StorageDel->xmonCaptureAlarmThresholdLen = 0;
		SNMP_FREE(StorageDel->xmonArchivePath);
		StorageDel->xmonArchivePathLen = 0;
		SNMP_FREE(StorageDel->xmonFeedTypes);
		StorageDel->xmonFeedTypesLen = 0;
		SNMP_FREE(StorageDel->xmonPullSpoolPath);
		StorageDel->xmonPullSpoolPathLen = 0;
		SNMP_FREE(StorageDel->xmonPullArchivePath);
		StorageDel->xmonPullArchivePathLen = 0;
		SNMP_FREE(StorageDel->xmonCollectorExtensions);
		StorageDel->xmonCollectorExtensionsLen = 0;
		SNMP_FREE(StorageDel->xmonCollectorAvailStatus);
		StorageDel->xmonCollectorAvailStatusLen = 0;
		SNMP_FREE(StorageDel->xmonCollectorAlarmThreshold);
		StorageDel->xmonCollectorAlarmThresholdLen = 0;
		SNMP_FREE(StorageDel->xmonCollectorCachePath);
		StorageDel->xmonCollectorCachePathLen = 0;
		SNMP_FREE(StorageDel->xmonCollectorSpoolPath);
		StorageDel->xmonCollectorSpoolPathLen = 0;
		SNMP_FREE(StorageDel->xmonCollectorArchivePath);
		StorageDel->xmonCollectorArchivePathLen = 0;
		SNMP_FREE(StorageDel->xmonCollectorArchiveSubdirs);
		StorageDel->xmonCollectorArchiveSubdirsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonMIB_add(struct xmonMIB_data *thedata)
 * @param thedata the structure representing xmonMIB scalars.
 * @brief adds node to the xmonMIB scalar data set.
 *
 * Adds a scalar structure to the xmonMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
xmonMIB_add(struct xmonMIB_data *thedata)
{
	DEBUGMSGTL(("xmonMIB", "xmonMIB_add: adding data...  "));
	if (thedata)
		xmonMIBStorage = thedata;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonMIB entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_xmonMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonMIB_data *StorageTmp = xmonMIB_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	SNMP_FREE(StorageTmp->xmonProbeName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonProbeName, &StorageTmp->xmonProbeNameLen);
	if (StorageTmp->xmonProbeName == NULL) {
		config_perror("invalid specification for xmonProbeName");
		return;
	}
	SNMP_FREE(StorageTmp->xmonProbeUuid);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonProbeUuid, &StorageTmp->xmonProbeUuidLen);
	if (StorageTmp->xmonProbeUuid == NULL) {
		config_perror("invalid specification for xmonProbeUuid");
		return;
	}
	SNMP_FREE(StorageTmp->xmonProbeHardware);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonProbeHardware, &StorageTmp->xmonProbeHardwareLen);
	if (StorageTmp->xmonProbeHardware == NULL) {
		config_perror("invalid specification for xmonProbeHardware");
		return;
	}
	SNMP_FREE(StorageTmp->xmonProbeOs);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonProbeOs, &StorageTmp->xmonProbeOsLen);
	if (StorageTmp->xmonProbeOs == NULL) {
		config_perror("invalid specification for xmonProbeOs");
		return;
	}
	SNMP_FREE(StorageTmp->xmonProbeUserAppl);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonProbeUserAppl, &StorageTmp->xmonProbeUserApplLen);
	if (StorageTmp->xmonProbeUserAppl == NULL) {
		config_perror("invalid specification for xmonProbeUserAppl");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferOpState, &tmpsize);
	SNMP_FREE(StorageTmp->xmonBufferAvailStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonBufferAvailStatus, &StorageTmp->xmonBufferAvailStatusLen);
	if (StorageTmp->xmonBufferAvailStatus == NULL) {
		config_perror("invalid specification for xmonBufferAvailStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferFullAction, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonBufferMaxSize, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonBufferMaxPackets, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferMaxTime, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferCurrentSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferNumberOfPackets, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferCurrentInterval, &tmpsize);
	SNMP_FREE(StorageTmp->xmonBufferAlarmThreshold);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonBufferAlarmThreshold, &StorageTmp->xmonBufferAlarmThresholdLen);
	if (StorageTmp->xmonBufferAlarmThreshold == NULL) {
		config_perror("invalid specification for xmonBufferAlarmThreshold");
		return;
	}
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferOctetHiWaterMark, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferOctetLoWaterMark, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferPktsHiWaterMark, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferPktsLoWaterMark, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferTimeHiWaterMark, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferTimeLoWaterMark, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->xmonBufferDrops, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferReset, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferTimeElapsed, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonBufferBegTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonBufferEndTime, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferIfRecv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferIfDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferFilterAccept, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferOsDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferUserDeliv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferIfCompress, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonBufferUserOctets, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonBufferActionResult, &tmpsize);
	SNMP_FREE(StorageTmp->xmonCapturePath);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCapturePath, &StorageTmp->xmonCapturePathLen);
	if (StorageTmp->xmonCapturePath == NULL) {
		config_perror("invalid specification for xmonCapturePath");
		return;
	}
	SNMP_FREE(StorageTmp->xmonCaptureFilename);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCaptureFilename, &StorageTmp->xmonCaptureFilenameLen);
	if (StorageTmp->xmonCaptureFilename == NULL) {
		config_perror("invalid specification for xmonCaptureFilename");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCaptureAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCaptureOpState, &tmpsize);
	SNMP_FREE(StorageTmp->xmonCaptureAvailStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCaptureAvailStatus, &StorageTmp->xmonCaptureAvailStatusLen);
	if (StorageTmp->xmonCaptureAvailStatus == NULL) {
		config_perror("invalid specification for xmonCaptureAvailStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCaptureFullAction, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonCaptureMaxSize, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonCaptureMaxPackets, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCaptureMaxTime, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonCaptureCurrentSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonCaptureNumberOfPackets, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCaptureCurrentInterval, &tmpsize);
	SNMP_FREE(StorageTmp->xmonCaptureAlarmThreshold);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCaptureAlarmThreshold, &StorageTmp->xmonCaptureAlarmThresholdLen);
	if (StorageTmp->xmonCaptureAlarmThreshold == NULL) {
		config_perror("invalid specification for xmonCaptureAlarmThreshold");
		return;
	}
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonCaptureOctetHiWaterMark, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonCaptureOctetLoWaterMark, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonCapturePktsHiWaterMark, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonCapturePktsLoWaterMark, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCaptureTimeHiWaterMark, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCaptureTimeLoWaterMark, &tmpsize);
	SNMP_FREE(StorageTmp->xmonArchivePath);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonArchivePath, &StorageTmp->xmonArchivePathLen);
	if (StorageTmp->xmonArchivePath == NULL) {
		config_perror("invalid specification for xmonArchivePath");
		return;
	}
	SNMP_FREE(StorageTmp->xmonFeedTypes);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonFeedTypes, &StorageTmp->xmonFeedTypesLen);
	if (StorageTmp->xmonFeedTypes == NULL) {
		config_perror("invalid specification for xmonFeedTypes");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedPort, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushPort, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullPort, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPullSpoolPath);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPullSpoolPath, &StorageTmp->xmonPullSpoolPathLen);
	if (StorageTmp->xmonPullSpoolPath == NULL) {
		config_perror("invalid specification for xmonPullSpoolPath");
		return;
	}
	SNMP_FREE(StorageTmp->xmonPullArchivePath);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPullArchivePath, &StorageTmp->xmonPullArchivePathLen);
	if (StorageTmp->xmonPullArchivePath == NULL) {
		config_perror("invalid specification for xmonPullArchivePath");
		return;
	}
	SNMP_FREE(StorageTmp->xmonCollectorExtensions);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCollectorExtensions, &StorageTmp->xmonCollectorExtensionsLen);
	if (StorageTmp->xmonCollectorExtensions == NULL) {
		config_perror("invalid specification for xmonCollectorExtensions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCollectorAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCollectorOpState, &tmpsize);
	SNMP_FREE(StorageTmp->xmonCollectorAvailStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCollectorAvailStatus, &StorageTmp->xmonCollectorAvailStatusLen);
	if (StorageTmp->xmonCollectorAvailStatus == NULL) {
		config_perror("invalid specification for xmonCollectorAvailStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCollectorFullAction, &tmpsize);
	SNMP_FREE(StorageTmp->xmonCollectorAlarmThreshold);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCollectorAlarmThreshold, &StorageTmp->xmonCollectorAlarmThresholdLen);
	if (StorageTmp->xmonCollectorAlarmThreshold == NULL) {
		config_perror("invalid specification for xmonCollectorAlarmThreshold");
		return;
	}
	SNMP_FREE(StorageTmp->xmonCollectorCachePath);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCollectorCachePath, &StorageTmp->xmonCollectorCachePathLen);
	if (StorageTmp->xmonCollectorCachePath == NULL) {
		config_perror("invalid specification for xmonCollectorCachePath");
		return;
	}
	SNMP_FREE(StorageTmp->xmonCollectorSpoolPath);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCollectorSpoolPath, &StorageTmp->xmonCollectorSpoolPathLen);
	if (StorageTmp->xmonCollectorSpoolPath == NULL) {
		config_perror("invalid specification for xmonCollectorSpoolPath");
		return;
	}
	SNMP_FREE(StorageTmp->xmonCollectorArchivePath);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCollectorArchivePath, &StorageTmp->xmonCollectorArchivePathLen);
	if (StorageTmp->xmonCollectorArchivePath == NULL) {
		config_perror("invalid specification for xmonCollectorArchivePath");
		return;
	}
	SNMP_FREE(StorageTmp->xmonCollectorArchiveSubdirs);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonCollectorArchiveSubdirs, &StorageTmp->xmonCollectorArchiveSubdirsLen);
	if (StorageTmp->xmonCollectorArchiveSubdirs == NULL) {
		config_perror("invalid specification for xmonCollectorArchiveSubdirs");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCollectorCompression, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonCollectorFileSystemAlloc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonCollectorMaxDiskUsage, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonCollectorDiscardPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSctpDefaultNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSctpDefaultHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpDefaultLifetime, &tmpsize);
	xmonMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_xmonMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonMIB_data *StorageTmp;

	DEBUGMSGTL(("xmonMIB", "store_xmonMIB: storing data...  "));
	refresh_xmonMIB(1);
	if ((StorageTmp = xmonMIBStorage) == NULL) {
		DEBUGMSGTL(("xmonMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "xmonMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonProbeName, &StorageTmp->xmonProbeNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonProbeUuid, &StorageTmp->xmonProbeUuidLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonProbeHardware, &StorageTmp->xmonProbeHardwareLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonProbeOs, &StorageTmp->xmonProbeOsLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonProbeUserAppl, &StorageTmp->xmonProbeUserApplLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferAdminState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferOpState, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonBufferAvailStatus, &StorageTmp->xmonBufferAvailStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferFullAction, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonBufferMaxSize, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonBufferMaxPackets, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferMaxTime, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferCurrentSize, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferNumberOfPackets, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferCurrentInterval, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonBufferAlarmThreshold, &StorageTmp->xmonBufferAlarmThresholdLen);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferOctetHiWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferOctetLoWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferPktsHiWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferPktsLoWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferTimeHiWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferTimeLoWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->xmonBufferDrops, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferReset, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferTimeElapsed, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonBufferBegTime, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonBufferEndTime, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferIfRecv, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferIfDrop, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferFilterAccept, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferOsDrop, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferUserDeliv, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferIfCompress, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonBufferUserOctets, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonBufferActionResult, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCapturePath, &StorageTmp->xmonCapturePathLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCaptureFilename, &StorageTmp->xmonCaptureFilenameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCaptureAdminState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCaptureOpState, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCaptureAvailStatus, &StorageTmp->xmonCaptureAvailStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCaptureFullAction, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonCaptureMaxSize, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonCaptureMaxPackets, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCaptureMaxTime, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonCaptureCurrentSize, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonCaptureNumberOfPackets, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCaptureCurrentInterval, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCaptureAlarmThreshold, &StorageTmp->xmonCaptureAlarmThresholdLen);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonCaptureOctetHiWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonCaptureOctetLoWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonCapturePktsHiWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonCapturePktsLoWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCaptureTimeHiWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCaptureTimeLoWaterMark, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonArchivePath, &StorageTmp->xmonArchivePathLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonFeedTypes, &StorageTmp->xmonFeedTypesLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedPort, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushPort, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullPort, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPullSpoolPath, &StorageTmp->xmonPullSpoolPathLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPullArchivePath, &StorageTmp->xmonPullArchivePathLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCollectorExtensions, &StorageTmp->xmonCollectorExtensionsLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCollectorAdminState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCollectorOpState, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCollectorAvailStatus, &StorageTmp->xmonCollectorAvailStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCollectorFullAction, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCollectorAlarmThreshold, &StorageTmp->xmonCollectorAlarmThresholdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCollectorCachePath, &StorageTmp->xmonCollectorCachePathLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCollectorSpoolPath, &StorageTmp->xmonCollectorSpoolPathLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCollectorArchivePath, &StorageTmp->xmonCollectorArchivePathLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonCollectorArchiveSubdirs, &StorageTmp->xmonCollectorArchiveSubdirsLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCollectorCompression, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonCollectorFileSystemAlloc, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonCollectorMaxDiskUsage, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonCollectorDiscardPolicy, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSctpDefaultNoDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultMaxseg, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultHeartbeatItvl, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSctpDefaultHeartbeat, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultRtoInitial, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultRtoMin, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultRtoMax, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultPathMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultCookieLife, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultCookieInc, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultMaxInitRetries, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultMaxBurst, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultAssocMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultSackDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpDefaultLifetime, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_xmonMIB(struct xmonMIB_data *StorageTmp, struct xmonMIB_data *StorageOld)
 * @param StorageTmp the data as updated
 * @param StorageOld the data previous to update
 *
 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
 * made for setting values that were not in the varbinds.
 */
int
check_xmonMIB(struct xmonMIB_data *StorageTmp, struct xmonMIB_data *StorageOld)
{
	/* XXX: provide code to check the scalars for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonMIB(struct xmonMIB_data *StorageTmp, struct xmonMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase)
 *
 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
 * consistency already checked (see check_xmonMIB()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the mib were applied: the values in StorageTmp are the new values.
 */
int
update_xmonMIB(struct xmonMIB_data *StorageTmp, struct xmonMIB_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonMIB_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn revert_xmonMIB(struct 
 * @fn void revert_xmonMIB(struct xmonMIB_data *StorageTmp, struct xmonMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase)
 */
void
revert_xmonMIB(struct xmonMIB_data *StorageTmp, struct xmonMIB_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonMIB(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of xmonMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_xmonMIB(int force)
{
	if (xmonMIBStorage == NULL) {
		struct xmonMIB_data *StorageNew;

		if ((StorageNew = xmonMIB_create()) == NULL)
			return;
		xmonMIBStorage = StorageNew;
		xmonMIB_refresh = 1;
	}
	if (!force && xmonMIB_refresh == 0)
		return;
	DEBUGMSGTL(("xmonMIB", "refresh_xmonMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	xmonMIB_refresh = 0;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/**
 * @fn u_char * var_xmonMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in xmonMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_xmonMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_xmonMIB(0);
	if ((StorageTmp = xmonMIBStorage) == NULL) {
		DEBUGMSGTL(("xmonMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONPROBENAME:	/* ReadWrite */
		*write_method = write_xmonProbeName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonProbeNameLen;
		rval = (u_char *) StorageTmp->xmonProbeName;
		break;
	case (u_char) XMONPROBEUUID:	/* ReadWrite */
		*write_method = write_xmonProbeUuid;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonProbeUuidLen;
		rval = (u_char *) StorageTmp->xmonProbeUuid;
		break;
	case (u_char) XMONPROBEHARDWARE:	/* ReadWrite */
		*write_method = write_xmonProbeHardware;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonProbeHardwareLen;
		rval = (u_char *) StorageTmp->xmonProbeHardware;
		break;
	case (u_char) XMONPROBEOS:	/* ReadWrite */
		*write_method = write_xmonProbeOs;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonProbeOsLen;
		rval = (u_char *) StorageTmp->xmonProbeOs;
		break;
	case (u_char) XMONPROBEUSERAPPL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonProbeUserApplLen;
		rval = (u_char *) StorageTmp->xmonProbeUserAppl;
		break;
	case (u_char) XMONBUFFERADMINSTATE:	/* ReadWrite */
		*write_method = write_xmonBufferAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferAdminState);
		rval = (u_char *) &StorageTmp->xmonBufferAdminState;
		break;
	case (u_char) XMONBUFFEROPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferOpState);
		rval = (u_char *) &StorageTmp->xmonBufferOpState;
		break;
	case (u_char) XMONBUFFERAVAILSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonBufferAvailStatusLen;
		rval = (u_char *) StorageTmp->xmonBufferAvailStatus;
		break;
	case (u_char) XMONBUFFERFULLACTION:	/* ReadWrite */
		*write_method = write_xmonBufferFullAction;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferFullAction);
		rval = (u_char *) &StorageTmp->xmonBufferFullAction;
		break;
	case (u_char) XMONBUFFERMAXSIZE:	/* ReadWrite */
		*write_method = write_xmonBufferMaxSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferMaxSize);
		rval = (u_char *) &StorageTmp->xmonBufferMaxSize;
		break;
	case (u_char) XMONBUFFERMAXPACKETS:	/* ReadWrite */
		*write_method = write_xmonBufferMaxPackets;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferMaxPackets);
		rval = (u_char *) &StorageTmp->xmonBufferMaxPackets;
		break;
	case (u_char) XMONBUFFERMAXTIME:	/* ReadWrite */
		*write_method = write_xmonBufferMaxTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferMaxTime);
		rval = (u_char *) &StorageTmp->xmonBufferMaxTime;
		break;
	case (u_char) XMONBUFFERCURRENTSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferCurrentSize);
		rval = (u_char *) &StorageTmp->xmonBufferCurrentSize;
		break;
	case (u_char) XMONBUFFERNUMBEROFPACKETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferNumberOfPackets);
		rval = (u_char *) &StorageTmp->xmonBufferNumberOfPackets;
		break;
	case (u_char) XMONBUFFERCURRENTINTERVAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferCurrentInterval);
		rval = (u_char *) &StorageTmp->xmonBufferCurrentInterval;
		break;
	case (u_char) XMONBUFFERALARMTHRESHOLD:	/* ReadWrite */
		*write_method = write_xmonBufferAlarmThreshold;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonBufferAlarmThresholdLen;
		rval = (u_char *) StorageTmp->xmonBufferAlarmThreshold;
		break;
	case (u_char) XMONBUFFEROCTETHIWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferOctetHiWaterMark);
		rval = (u_char *) &StorageTmp->xmonBufferOctetHiWaterMark;
		break;
	case (u_char) XMONBUFFEROCTETLOWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferOctetLoWaterMark);
		rval = (u_char *) &StorageTmp->xmonBufferOctetLoWaterMark;
		break;
	case (u_char) XMONBUFFERPKTSHIWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferPktsHiWaterMark);
		rval = (u_char *) &StorageTmp->xmonBufferPktsHiWaterMark;
		break;
	case (u_char) XMONBUFFERPKTSLOWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferPktsLoWaterMark);
		rval = (u_char *) &StorageTmp->xmonBufferPktsLoWaterMark;
		break;
	case (u_char) XMONBUFFERTIMEHIWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferTimeHiWaterMark);
		rval = (u_char *) &StorageTmp->xmonBufferTimeHiWaterMark;
		break;
	case (u_char) XMONBUFFERTIMELOWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferTimeLoWaterMark);
		rval = (u_char *) &StorageTmp->xmonBufferTimeLoWaterMark;
		break;
	case (u_char) XMONBUFFERDROPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferDrops);
		rval = (u_char *) &StorageTmp->xmonBufferDrops;
		break;
	case (u_char) XMONBUFFERRESET:	/* ReadWrite */
		*write_method = write_xmonBufferReset;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferReset);
		rval = (u_char *) &StorageTmp->xmonBufferReset;
		break;
	case (u_char) XMONBUFFERTIMEELAPSED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferTimeElapsed);
		rval = (u_char *) &StorageTmp->xmonBufferTimeElapsed;
		break;
	case (u_char) XMONBUFFERBEGTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferBegTime);
		rval = (u_char *) &StorageTmp->xmonBufferBegTime;
		break;
	case (u_char) XMONBUFFERENDTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferEndTime);
		rval = (u_char *) &StorageTmp->xmonBufferEndTime;
		break;
	case (u_char) XMONBUFFERIFRECV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferIfRecv);
		rval = (u_char *) &StorageTmp->xmonBufferIfRecv;
		break;
	case (u_char) XMONBUFFERIFDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferIfDrop);
		rval = (u_char *) &StorageTmp->xmonBufferIfDrop;
		break;
	case (u_char) XMONBUFFERFILTERACCEPT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferFilterAccept);
		rval = (u_char *) &StorageTmp->xmonBufferFilterAccept;
		break;
	case (u_char) XMONBUFFEROSDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferOsDrop);
		rval = (u_char *) &StorageTmp->xmonBufferOsDrop;
		break;
	case (u_char) XMONBUFFERUSERDELIV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferUserDeliv);
		rval = (u_char *) &StorageTmp->xmonBufferUserDeliv;
		break;
	case (u_char) XMONBUFFERIFCOMPRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferIfCompress);
		rval = (u_char *) &StorageTmp->xmonBufferIfCompress;
		break;
	case (u_char) XMONBUFFERUSEROCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferUserOctets);
		rval = (u_char *) &StorageTmp->xmonBufferUserOctets;
		break;
	case (u_char) XMONBUFFERACTIONRESULT:	/* ReadWrite */
		*write_method = write_xmonBufferActionResult;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonBufferActionResult);
		rval = (u_char *) &StorageTmp->xmonBufferActionResult;
		break;
	case (u_char) XMONCAPTUREPATH:	/* ReadWrite */
		*write_method = write_xmonCapturePath;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCapturePathLen;
		rval = (u_char *) StorageTmp->xmonCapturePath;
		break;
	case (u_char) XMONCAPTUREFILENAME:	/* ReadWrite */
		*write_method = write_xmonCaptureFilename;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCaptureFilenameLen;
		rval = (u_char *) StorageTmp->xmonCaptureFilename;
		break;
	case (u_char) XMONCAPTUREADMINSTATE:	/* ReadWrite */
		*write_method = write_xmonCaptureAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureAdminState);
		rval = (u_char *) &StorageTmp->xmonCaptureAdminState;
		break;
	case (u_char) XMONCAPTUREOPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureOpState);
		rval = (u_char *) &StorageTmp->xmonCaptureOpState;
		break;
	case (u_char) XMONCAPTUREAVAILSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCaptureAvailStatusLen;
		rval = (u_char *) StorageTmp->xmonCaptureAvailStatus;
		break;
	case (u_char) XMONCAPTUREFULLACTION:	/* ReadWrite */
		*write_method = write_xmonCaptureFullAction;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureFullAction);
		rval = (u_char *) &StorageTmp->xmonCaptureFullAction;
		break;
	case (u_char) XMONCAPTUREMAXSIZE:	/* ReadWrite */
		*write_method = write_xmonCaptureMaxSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureMaxSize);
		rval = (u_char *) &StorageTmp->xmonCaptureMaxSize;
		break;
	case (u_char) XMONCAPTUREMAXPACKETS:	/* ReadWrite */
		*write_method = write_xmonCaptureMaxPackets;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureMaxPackets);
		rval = (u_char *) &StorageTmp->xmonCaptureMaxPackets;
		break;
	case (u_char) XMONCAPTUREMAXTIME:	/* ReadWrite */
		*write_method = write_xmonCaptureMaxTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureMaxTime);
		rval = (u_char *) &StorageTmp->xmonCaptureMaxTime;
		break;
	case (u_char) XMONCAPTURECURRENTSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureCurrentSize);
		rval = (u_char *) &StorageTmp->xmonCaptureCurrentSize;
		break;
	case (u_char) XMONCAPTURENUMBEROFPACKETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureNumberOfPackets);
		rval = (u_char *) &StorageTmp->xmonCaptureNumberOfPackets;
		break;
	case (u_char) XMONCAPTURECURRENTINTERVAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureCurrentInterval);
		rval = (u_char *) &StorageTmp->xmonCaptureCurrentInterval;
		break;
	case (u_char) XMONCAPTUREALARMTHRESHOLD:	/* ReadWrite */
		*write_method = write_xmonCaptureAlarmThreshold;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCaptureAlarmThresholdLen;
		rval = (u_char *) StorageTmp->xmonCaptureAlarmThreshold;
		break;
	case (u_char) XMONCAPTUREOCTETHIWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureOctetHiWaterMark);
		rval = (u_char *) &StorageTmp->xmonCaptureOctetHiWaterMark;
		break;
	case (u_char) XMONCAPTUREOCTETLOWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureOctetLoWaterMark);
		rval = (u_char *) &StorageTmp->xmonCaptureOctetLoWaterMark;
		break;
	case (u_char) XMONCAPTUREPKTSHIWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCapturePktsHiWaterMark);
		rval = (u_char *) &StorageTmp->xmonCapturePktsHiWaterMark;
		break;
	case (u_char) XMONCAPTUREPKTSLOWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCapturePktsLoWaterMark);
		rval = (u_char *) &StorageTmp->xmonCapturePktsLoWaterMark;
		break;
	case (u_char) XMONCAPTURETIMEHIWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureTimeHiWaterMark);
		rval = (u_char *) &StorageTmp->xmonCaptureTimeHiWaterMark;
		break;
	case (u_char) XMONCAPTURETIMELOWATERMARK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCaptureTimeLoWaterMark);
		rval = (u_char *) &StorageTmp->xmonCaptureTimeLoWaterMark;
		break;
	case (u_char) XMONARCHIVEPATH:	/* ReadWrite */
		*write_method = write_xmonArchivePath;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonArchivePathLen;
		rval = (u_char *) StorageTmp->xmonArchivePath;
		break;
	case (u_char) XMONFEEDTYPES:	/* ReadWrite */
		*write_method = write_xmonFeedTypes;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonFeedTypesLen;
		rval = (u_char *) StorageTmp->xmonFeedTypes;
		break;
	case (u_char) XMONFEEDPORT:	/* ReadWrite */
		*write_method = write_xmonFeedPort;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedPort);
		rval = (u_char *) &StorageTmp->xmonFeedPort;
		break;
	case (u_char) XMONPUSHPORT:	/* ReadWrite */
		*write_method = write_xmonPushPort;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushPort);
		rval = (u_char *) &StorageTmp->xmonPushPort;
		break;
	case (u_char) XMONPULLPORT:	/* ReadWrite */
		*write_method = write_xmonPullPort;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullPort);
		rval = (u_char *) &StorageTmp->xmonPullPort;
		break;
	case (u_char) XMONPULLSPOOLPATH:	/* ReadWrite */
		*write_method = write_xmonPullSpoolPath;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPullSpoolPathLen;
		rval = (u_char *) StorageTmp->xmonPullSpoolPath;
		break;
	case (u_char) XMONPULLARCHIVEPATH:	/* ReadWrite */
		*write_method = write_xmonPullArchivePath;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPullArchivePathLen;
		rval = (u_char *) StorageTmp->xmonPullArchivePath;
		break;
	case (u_char) XMONCOLLECTOREXTENSIONS:	/* ReadWrite */
		*write_method = write_xmonCollectorExtensions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCollectorExtensionsLen;
		rval = (u_char *) StorageTmp->xmonCollectorExtensions;
		break;
	case (u_char) XMONCOLLECTORADMINSTATE:	/* ReadWrite */
		*write_method = write_xmonCollectorAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCollectorAdminState);
		rval = (u_char *) &StorageTmp->xmonCollectorAdminState;
		break;
	case (u_char) XMONCOLLECTOROPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCollectorOpState);
		rval = (u_char *) &StorageTmp->xmonCollectorOpState;
		break;
	case (u_char) XMONCOLLECTORAVAILSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCollectorAvailStatusLen;
		rval = (u_char *) StorageTmp->xmonCollectorAvailStatus;
		break;
	case (u_char) XMONCOLLECTORFULLACTION:	/* ReadWrite */
		*write_method = write_xmonCollectorFullAction;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCollectorFullAction);
		rval = (u_char *) &StorageTmp->xmonCollectorFullAction;
		break;
	case (u_char) XMONCOLLECTORALARMTHRESHOLD:	/* ReadWrite */
		*write_method = write_xmonCollectorAlarmThreshold;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCollectorAlarmThresholdLen;
		rval = (u_char *) StorageTmp->xmonCollectorAlarmThreshold;
		break;
	case (u_char) XMONCOLLECTORCACHEPATH:	/* ReadWrite */
		*write_method = write_xmonCollectorCachePath;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCollectorCachePathLen;
		rval = (u_char *) StorageTmp->xmonCollectorCachePath;
		break;
	case (u_char) XMONCOLLECTORSPOOLPATH:	/* ReadWrite */
		*write_method = write_xmonCollectorSpoolPath;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCollectorSpoolPathLen;
		rval = (u_char *) StorageTmp->xmonCollectorSpoolPath;
		break;
	case (u_char) XMONCOLLECTORARCHIVEPATH:	/* ReadWrite */
		*write_method = write_xmonCollectorArchivePath;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCollectorArchivePathLen;
		rval = (u_char *) StorageTmp->xmonCollectorArchivePath;
		break;
	case (u_char) XMONCOLLECTORARCHIVESUBDIRS:	/* ReadWrite */
		*write_method = write_xmonCollectorArchiveSubdirs;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonCollectorArchiveSubdirsLen;
		rval = (u_char *) StorageTmp->xmonCollectorArchiveSubdirs;
		break;
	case (u_char) XMONCOLLECTORCOMPRESSION:	/* ReadWrite */
		*write_method = write_xmonCollectorCompression;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCollectorCompression);
		rval = (u_char *) &StorageTmp->xmonCollectorCompression;
		break;
	case (u_char) XMONCOLLECTORFILESYSTEMALLOC:	/* ReadWrite */
		*write_method = write_xmonCollectorFileSystemAlloc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCollectorFileSystemAlloc);
		rval = (u_char *) &StorageTmp->xmonCollectorFileSystemAlloc;
		break;
	case (u_char) XMONCOLLECTORMAXDISKUSAGE:	/* ReadWrite */
		*write_method = write_xmonCollectorMaxDiskUsage;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCollectorMaxDiskUsage);
		rval = (u_char *) &StorageTmp->xmonCollectorMaxDiskUsage;
		break;
	case (u_char) XMONCOLLECTORDISCARDPOLICY:	/* ReadWrite */
		*write_method = write_xmonCollectorDiscardPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonCollectorDiscardPolicy);
		rval = (u_char *) &StorageTmp->xmonCollectorDiscardPolicy;
		break;
	case (u_char) XMONSCTPDEFAULTNODELAY:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultNoDelay);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultNoDelay;
		break;
	case (u_char) XMONSCTPDEFAULTMAXSEG:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultMaxseg);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultMaxseg;
		break;
	case (u_char) XMONSCTPDEFAULTHEARTBEATITVL:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultHeartbeatItvl);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultHeartbeatItvl;
		break;
	case (u_char) XMONSCTPDEFAULTHEARTBEAT:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultHeartbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultHeartbeat);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultHeartbeat;
		break;
	case (u_char) XMONSCTPDEFAULTRTOINITIAL:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultRtoInitial);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultRtoInitial;
		break;
	case (u_char) XMONSCTPDEFAULTRTOMIN:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultRtoMin);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultRtoMin;
		break;
	case (u_char) XMONSCTPDEFAULTRTOMAX:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultRtoMax);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultRtoMax;
		break;
	case (u_char) XMONSCTPDEFAULTPATHMAXRETRANS:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultPathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultPathMaxRetrans);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultPathMaxRetrans;
		break;
	case (u_char) XMONSCTPDEFAULTCOOKIELIFE:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultCookieLife);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultCookieLife;
		break;
	case (u_char) XMONSCTPDEFAULTCOOKIEINC:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultCookieInc);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultCookieInc;
		break;
	case (u_char) XMONSCTPDEFAULTMAXINITRETRIES:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultMaxInitRetries);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultMaxInitRetries;
		break;
	case (u_char) XMONSCTPDEFAULTMAXBURST:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultMaxBurst);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultMaxBurst;
		break;
	case (u_char) XMONSCTPDEFAULTASSOCMAXRETRANS:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultAssocMaxRetrans;
		break;
	case (u_char) XMONSCTPDEFAULTSACKDELAY:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultSackDelay);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultSackDelay;
		break;
	case (u_char) XMONSCTPDEFAULTLIFETIME:	/* ReadWrite */
		*write_method = write_xmonSctpDefaultLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpDefaultLifetime);
		rval = (u_char *) &StorageTmp->xmonSctpDefaultLifetime;
		break;
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("xmonMIB", "found.\n"));
	else
		DEBUGMSGTL(("xmonMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct xmonSourceTable_data *xmonSourceTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonSourceTable table.
 *
 * Creates a new xmonSourceTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonSourceTable_data *
xmonSourceTable_create(void)
{
	struct xmonSourceTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSourceTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSourceTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonSourceType = 0;
		if ((StorageNew->xmonSourceName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonSourceNameLen = 0;
		StorageNew->xmonSourceName[StorageNew->xmonSourceNameLen] = 0;
		StorageNew->xmonSourceIfIndex = 0;
		StorageNew->xmonSourceAdminState = XMONSOURCEADMINSTATE_UNLOCKED;
		StorageNew->xmonSourceOpState = XMONSOURCEOPSTATE_ENABLED;
		if (memdup((u_char **) &StorageNew->xmonSourceAvailStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonSourceAvailStatusLen = 2;
		if (memdup((u_char **) &StorageNew->xmonSourceProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonSourceProcStatusLen = 1;
		StorageNew->xmonSourceUsageState = XMONSOURCEUSAGESTATE_IDLE;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonSourceTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonSourceTable_data *xmonSourceTable_duplicate(struct xmonSourceTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonSourceTable_data *
xmonSourceTable_duplicate(struct xmonSourceTable_data *thedata)
{
	struct xmonSourceTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSourceTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSourceTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonSourceTable_id = thedata->xmonSourceTable_id;
		StorageNew->xmonSourceIndex = thedata->xmonSourceIndex;
		StorageNew->xmonSourceType = thedata->xmonSourceType;
		if (!(StorageNew->xmonSourceName = malloc(thedata->xmonSourceNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonSourceName, thedata->xmonSourceName, thedata->xmonSourceNameLen);
		StorageNew->xmonSourceNameLen = thedata->xmonSourceNameLen;
		StorageNew->xmonSourceName[StorageNew->xmonSourceNameLen] = 0;
		StorageNew->xmonSourceIfIndex = thedata->xmonSourceIfIndex;
		StorageNew->xmonSourceAdminState = thedata->xmonSourceAdminState;
		StorageNew->xmonSourceOpState = thedata->xmonSourceOpState;
		if (!(StorageNew->xmonSourceAvailStatus = malloc(thedata->xmonSourceAvailStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonSourceAvailStatus, thedata->xmonSourceAvailStatus, thedata->xmonSourceAvailStatusLen);
		StorageNew->xmonSourceAvailStatusLen = thedata->xmonSourceAvailStatusLen;
		StorageNew->xmonSourceAvailStatus[StorageNew->xmonSourceAvailStatusLen] = 0;
		if (!(StorageNew->xmonSourceProcStatus = malloc(thedata->xmonSourceProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonSourceProcStatus, thedata->xmonSourceProcStatus, thedata->xmonSourceProcStatusLen);
		StorageNew->xmonSourceProcStatusLen = thedata->xmonSourceProcStatusLen;
		StorageNew->xmonSourceProcStatus[StorageNew->xmonSourceProcStatusLen] = 0;
		StorageNew->xmonSourceUsageState = thedata->xmonSourceUsageState;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonSourceTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonSourceTable_destroy(struct xmonSourceTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonSourceTable_destroy(struct xmonSourceTable_data **thedata)
{
	struct xmonSourceTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSourceTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonSourceName);
		StorageDel->xmonSourceNameLen = 0;
		SNMP_FREE(StorageDel->xmonSourceAvailStatus);
		StorageDel->xmonSourceAvailStatusLen = 0;
		SNMP_FREE(StorageDel->xmonSourceProcStatus);
		StorageDel->xmonSourceProcStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSourceTable_add(struct xmonSourceTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonSourceTable table data set.
 *
 * Adds a table row structure to the xmonSourceTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonSourceTable_add(struct xmonSourceTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonSourceTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonSourceIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->xmonSourceIndex, sizeof(thedata->xmonSourceIndex));
		header_complex_add_data(&xmonSourceTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSourceTable_del(struct xmonSourceTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonSourceTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonSourceTable_del(struct xmonSourceTable_data *thedata)
{
	struct xmonSourceTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSourceTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonSourceTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonSourceTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonSourceTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonSourceTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonSourceTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonSourceTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonSourceTable_data *StorageTmp = xmonSourceTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonSourceTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceType, &tmpsize);
	SNMP_FREE(StorageTmp->xmonSourceName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonSourceName, &StorageTmp->xmonSourceNameLen);
	if (StorageTmp->xmonSourceName == NULL) {
		config_perror("invalid specification for xmonSourceName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceIfIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceOpState, &tmpsize);
	SNMP_FREE(StorageTmp->xmonSourceAvailStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonSourceAvailStatus, &StorageTmp->xmonSourceAvailStatusLen);
	if (StorageTmp->xmonSourceAvailStatus == NULL) {
		config_perror("invalid specification for xmonSourceAvailStatus");
		return;
	}
	SNMP_FREE(StorageTmp->xmonSourceProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonSourceProcStatus, &StorageTmp->xmonSourceProcStatusLen);
	if (StorageTmp->xmonSourceProcStatus == NULL) {
		config_perror("invalid specification for xmonSourceProcStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceUsageState, &tmpsize);
	xmonSourceTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonSourceTable(): store configuraiton file for xmonSourceTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonSourceTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonSourceTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonSourceTable: storing data...  "));
	refresh_xmonSourceTable(1);
	(void) tmpsize;
	for (hcindex = xmonSourceTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonSourceTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonSourceTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonSourceName, &StorageTmp->xmonSourceNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceIfIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceOpState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonSourceAvailStatus, &StorageTmp->xmonSourceAvailStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonSourceProcStatus, &StorageTmp->xmonSourceProcStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceUsageState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonSourceStatsTable_data *xmonSourceStatsTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonSourceStatsTable table.
 *
 * Creates a new xmonSourceStatsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonSourceStatsTable_data *
xmonSourceStatsTable_create(void)
{
	struct xmonSourceStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSourceStatsTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSourceStatsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonSourceIndex = 0;
		StorageNew->xmonSourceStatsTimeElapsed = 0;
		StorageNew->xmonSourceStatsTimeStamp = 0;
		StorageNew->xmonSourceStatsStartTime = 0;
		StorageNew->xmonSourceStatsEndTime = 0;
		StorageNew->xmonSourceStatsIfRecv = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceStatsIfDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceStatsFilterAccept = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceStatsOsDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceStatsUserDeliv = (struct counter64) {
		0, 0};
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonSourceStatsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonSourceStatsTable_data *xmonSourceStatsTable_duplicate(struct xmonSourceStatsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonSourceStatsTable_data *
xmonSourceStatsTable_duplicate(struct xmonSourceStatsTable_data *thedata)
{
	struct xmonSourceStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSourceStatsTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSourceStatsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonSourceStatsTable_id = thedata->xmonSourceStatsTable_id;
		StorageNew->xmonSourceIndex = thedata->xmonSourceIndex;
		StorageNew->xmonSourceStatsTimeElapsed = thedata->xmonSourceStatsTimeElapsed;
		StorageNew->xmonSourceStatsTimeStamp = thedata->xmonSourceStatsTimeStamp;
		StorageNew->xmonSourceStatsStartTime = thedata->xmonSourceStatsStartTime;
		StorageNew->xmonSourceStatsEndTime = thedata->xmonSourceStatsEndTime;
		StorageNew->xmonSourceStatsIfRecv = thedata->xmonSourceStatsIfRecv;
		StorageNew->xmonSourceStatsIfDrop = thedata->xmonSourceStatsIfDrop;
		StorageNew->xmonSourceStatsFilterAccept = thedata->xmonSourceStatsFilterAccept;
		StorageNew->xmonSourceStatsOsDrop = thedata->xmonSourceStatsOsDrop;
		StorageNew->xmonSourceStatsUserDeliv = thedata->xmonSourceStatsUserDeliv;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonSourceStatsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonSourceStatsTable_destroy(struct xmonSourceStatsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonSourceStatsTable_destroy(struct xmonSourceStatsTable_data **thedata)
{
	struct xmonSourceStatsTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSourceStatsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSourceStatsTable_add(struct xmonSourceStatsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonSourceStatsTable table data set.
 *
 * Adds a table row structure to the xmonSourceStatsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonSourceStatsTable_add(struct xmonSourceStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonSourceStatsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonSourceIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->xmonSourceIndex, sizeof(thedata->xmonSourceIndex));
		header_complex_add_data(&xmonSourceStatsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSourceStatsTable_del(struct xmonSourceStatsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonSourceStatsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonSourceStatsTable_del(struct xmonSourceStatsTable_data *thedata)
{
	struct xmonSourceStatsTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSourceStatsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonSourceStatsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonSourceStatsTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonSourceStatsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonSourceStatsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonSourceStatsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonSourceStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonSourceStatsTable_data *StorageTmp = xmonSourceStatsTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonSourceStatsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceStatsTimeElapsed, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonSourceStatsTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonSourceStatsStartTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonSourceStatsEndTime, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceStatsIfRecv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceStatsIfDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceStatsFilterAccept, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceStatsOsDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceStatsUserDeliv, &tmpsize);
	xmonSourceStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonSourceStatsTable(): store configuraiton file for xmonSourceStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonSourceStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonSourceStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonSourceStatsTable: storing data...  "));
	refresh_xmonSourceStatsTable(1);
	(void) tmpsize;
	for (hcindex = xmonSourceStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonSourceStatsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonSourceStatsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceStatsTimeElapsed, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonSourceStatsTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonSourceStatsStartTime, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonSourceStatsEndTime, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceStatsIfRecv, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceStatsIfDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceStatsFilterAccept, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceStatsOsDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceStatsUserDeliv, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonSourceHistTable_data *xmonSourceHistTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonSourceHistTable table.
 *
 * Creates a new xmonSourceHistTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonSourceHistTable_data *
xmonSourceHistTable_create(void)
{
	struct xmonSourceHistTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSourceHistTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSourceHistTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonSourceIndex = 0;
		StorageNew->xmonSourceHistIfRecv = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceHistIfDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceHistFilterAccept = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceHistOsDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceHistUserDeliv = (struct counter64) {
		0, 0};
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonSourceHistTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonSourceHistTable_data *xmonSourceHistTable_duplicate(struct xmonSourceHistTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonSourceHistTable_data *
xmonSourceHistTable_duplicate(struct xmonSourceHistTable_data *thedata)
{
	struct xmonSourceHistTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSourceHistTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSourceHistTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonSourceHistTable_id = thedata->xmonSourceHistTable_id;
		StorageNew->xmonSourceIndex = thedata->xmonSourceIndex;
		StorageNew->xmonSourceHistInterval = thedata->xmonSourceHistInterval;
		StorageNew->xmonSourceHistIfRecv = thedata->xmonSourceHistIfRecv;
		StorageNew->xmonSourceHistIfDrop = thedata->xmonSourceHistIfDrop;
		StorageNew->xmonSourceHistFilterAccept = thedata->xmonSourceHistFilterAccept;
		StorageNew->xmonSourceHistOsDrop = thedata->xmonSourceHistOsDrop;
		StorageNew->xmonSourceHistUserDeliv = thedata->xmonSourceHistUserDeliv;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonSourceHistTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonSourceHistTable_destroy(struct xmonSourceHistTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonSourceHistTable_destroy(struct xmonSourceHistTable_data **thedata)
{
	struct xmonSourceHistTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSourceHistTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSourceHistTable_add(struct xmonSourceHistTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonSourceHistTable table data set.
 *
 * Adds a table row structure to the xmonSourceHistTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonSourceHistTable_add(struct xmonSourceHistTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonSourceHistTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonSourceIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->xmonSourceIndex, sizeof(thedata->xmonSourceIndex));
		/* xmonSourceHistInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonSourceHistInterval, sizeof(thedata->xmonSourceHistInterval));
		header_complex_add_data(&xmonSourceHistTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSourceHistTable_del(struct xmonSourceHistTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonSourceHistTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonSourceHistTable_del(struct xmonSourceHistTable_data *thedata)
{
	struct xmonSourceHistTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSourceHistTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonSourceHistTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonSourceHistTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonSourceHistTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonSourceHistTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonSourceHistTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonSourceHistTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonSourceHistTable_data *StorageTmp = xmonSourceHistTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonSourceHistTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSourceHistInterval, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceHistIfRecv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceHistIfDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceHistFilterAccept, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceHistOsDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceHistUserDeliv, &tmpsize);
	xmonSourceHistTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonSourceHistTable(): store configuraiton file for xmonSourceHistTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonSourceHistTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonSourceHistTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonSourceHistTable: storing data...  "));
	refresh_xmonSourceHistTable(1);
	(void) tmpsize;
	for (hcindex = xmonSourceHistTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonSourceHistTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonSourceHistTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSourceHistInterval, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceHistIfRecv, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceHistIfDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceHistFilterAccept, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceHistOsDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceHistUserDeliv, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonSourceTotalTable_data *xmonSourceTotalTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonSourceTotalTable table.
 *
 * Creates a new xmonSourceTotalTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonSourceTotalTable_data *
xmonSourceTotalTable_create(void)
{
	struct xmonSourceTotalTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSourceTotalTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSourceTotalTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonSourceIndex = 0;
		StorageNew->xmonSourceTotalValidIntervals = 0;
		StorageNew->xmonSourceTotalIfRecv = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceTotalIfDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceTotalFilterAccept = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceTotalOsDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonSourceTotalUserDeliv = (struct counter64) {
		0, 0};
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonSourceTotalTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonSourceTotalTable_data *xmonSourceTotalTable_duplicate(struct xmonSourceTotalTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonSourceTotalTable_data *
xmonSourceTotalTable_duplicate(struct xmonSourceTotalTable_data *thedata)
{
	struct xmonSourceTotalTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSourceTotalTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSourceTotalTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonSourceTotalTable_id = thedata->xmonSourceTotalTable_id;
		StorageNew->xmonSourceIndex = thedata->xmonSourceIndex;
		StorageNew->xmonSourceTotalValidIntervals = thedata->xmonSourceTotalValidIntervals;
		StorageNew->xmonSourceTotalIfRecv = thedata->xmonSourceTotalIfRecv;
		StorageNew->xmonSourceTotalIfDrop = thedata->xmonSourceTotalIfDrop;
		StorageNew->xmonSourceTotalFilterAccept = thedata->xmonSourceTotalFilterAccept;
		StorageNew->xmonSourceTotalOsDrop = thedata->xmonSourceTotalOsDrop;
		StorageNew->xmonSourceTotalUserDeliv = thedata->xmonSourceTotalUserDeliv;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonSourceTotalTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonSourceTotalTable_destroy(struct xmonSourceTotalTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonSourceTotalTable_destroy(struct xmonSourceTotalTable_data **thedata)
{
	struct xmonSourceTotalTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSourceTotalTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSourceTotalTable_add(struct xmonSourceTotalTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonSourceTotalTable table data set.
 *
 * Adds a table row structure to the xmonSourceTotalTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonSourceTotalTable_add(struct xmonSourceTotalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonSourceTotalTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonSourceIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->xmonSourceIndex, sizeof(thedata->xmonSourceIndex));
		header_complex_add_data(&xmonSourceTotalTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSourceTotalTable_del(struct xmonSourceTotalTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonSourceTotalTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonSourceTotalTable_del(struct xmonSourceTotalTable_data *thedata)
{
	struct xmonSourceTotalTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSourceTotalTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonSourceTotalTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonSourceTotalTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonSourceTotalTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonSourceTotalTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonSourceTotalTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonSourceTotalTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonSourceTotalTable_data *StorageTmp = xmonSourceTotalTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonSourceTotalTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceTotalValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceTotalIfRecv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceTotalIfDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceTotalFilterAccept, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceTotalOsDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonSourceTotalUserDeliv, &tmpsize);
	xmonSourceTotalTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonSourceTotalTable(): store configuraiton file for xmonSourceTotalTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonSourceTotalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonSourceTotalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonSourceTotalTable: storing data...  "));
	refresh_xmonSourceTotalTable(1);
	(void) tmpsize;
	for (hcindex = xmonSourceTotalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonSourceTotalTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonSourceTotalTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceTotalValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceTotalIfRecv, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceTotalIfDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceTotalFilterAccept, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceTotalOsDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonSourceTotalUserDeliv, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonInterfaceTable_data *xmonInterfaceTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonInterfaceTable table.
 *
 * Creates a new xmonInterfaceTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonInterfaceTable_data *
xmonInterfaceTable_create(void)
{
	struct xmonInterfaceTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonInterfaceTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonInterfaceTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonSourceIndex = 0;
		StorageNew->xmonInterfaceLinkType = 0;
		StorageNew->xmonInterfaceSnapLen = 0;
		StorageNew->xmonInterfacePromiscuous = TV_TRUE;
		StorageNew->xmonInterfaceMonitor = TV_FALSE;
		StorageNew->xmonInterfaceDirection = XMONINTERFACEDIRECTION_ANY;
		if ((StorageNew->xmonInterfaceDescription = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonInterfaceDescriptionLen = 0;
		StorageNew->xmonInterfaceDescription[StorageNew->xmonInterfaceDescriptionLen] = 0;
		if ((StorageNew->xmonInterfacePhysAddr = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->xmonInterfacePhysAddrLen = strlen("");
		StorageNew->xmonInterfaceSpeed = (struct counter64) {
		0, 0};
		StorageNew->xmonInterfaceTsRes = XMONINTERFACETSRES_MICRO;
		StorageNew->xmonInterfaceTzone = 0;
		if (memdup((u_char **) &StorageNew->xmonInterfaceFilterType, (u_char *) "\xFF\x80", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonInterfaceFilterTypeLen = 2;
		if ((StorageNew->xmonInterfaceFilter = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->xmonInterfaceFilterLen = strlen("");
		if ((StorageNew->xmonInterfaceFilterBpf = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->xmonInterfaceFilterBpfLen = strlen("");
		StorageNew->xmonInterfaceFilterStatus = XMONINTERFACEFILTERSTATUS_COMPILED;
		if ((StorageNew->xmonInterfaceOs = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonInterfaceOsLen = 0;
		StorageNew->xmonInterfaceOs[StorageNew->xmonInterfaceOsLen] = 0;
		StorageNew->xmonInterfaceFcsLen = 0;
		StorageNew->xmonInterfaceTsOffset = (struct counter64) {
		(long) ((uint64_t) 0 >> 32), (long) (0)};
		StorageNew->xmonInterfaceStorageType = ST_NONVOLATILE;
		StorageNew->xmonInterfaceRowStatus = 0;
		StorageNew->xmonInterfaceRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonInterfaceTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonInterfaceTable_data *xmonInterfaceTable_duplicate(struct xmonInterfaceTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonInterfaceTable_data *
xmonInterfaceTable_duplicate(struct xmonInterfaceTable_data *thedata)
{
	struct xmonInterfaceTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonInterfaceTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonInterfaceTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonInterfaceTable_id = thedata->xmonInterfaceTable_id;
		StorageNew->xmonSourceIndex = thedata->xmonSourceIndex;
		StorageNew->xmonInterfaceLinkType = thedata->xmonInterfaceLinkType;
		StorageNew->xmonInterfaceSnapLen = thedata->xmonInterfaceSnapLen;
		StorageNew->xmonInterfacePromiscuous = thedata->xmonInterfacePromiscuous;
		StorageNew->xmonInterfaceMonitor = thedata->xmonInterfaceMonitor;
		StorageNew->xmonInterfaceDirection = thedata->xmonInterfaceDirection;
		if (!(StorageNew->xmonInterfaceDescription = malloc(thedata->xmonInterfaceDescriptionLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonInterfaceDescription, thedata->xmonInterfaceDescription, thedata->xmonInterfaceDescriptionLen);
		StorageNew->xmonInterfaceDescriptionLen = thedata->xmonInterfaceDescriptionLen;
		StorageNew->xmonInterfaceDescription[StorageNew->xmonInterfaceDescriptionLen] = 0;
		if (!(StorageNew->xmonInterfacePhysAddr = malloc(thedata->xmonInterfacePhysAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonInterfacePhysAddr, thedata->xmonInterfacePhysAddr, thedata->xmonInterfacePhysAddrLen);
		StorageNew->xmonInterfacePhysAddrLen = thedata->xmonInterfacePhysAddrLen;
		StorageNew->xmonInterfacePhysAddr[StorageNew->xmonInterfacePhysAddrLen] = 0;
		StorageNew->xmonInterfaceSpeed = thedata->xmonInterfaceSpeed;
		StorageNew->xmonInterfaceTsRes = thedata->xmonInterfaceTsRes;
		StorageNew->xmonInterfaceTzone = thedata->xmonInterfaceTzone;
		if (!(StorageNew->xmonInterfaceFilterType = malloc(thedata->xmonInterfaceFilterTypeLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonInterfaceFilterType, thedata->xmonInterfaceFilterType, thedata->xmonInterfaceFilterTypeLen);
		StorageNew->xmonInterfaceFilterTypeLen = thedata->xmonInterfaceFilterTypeLen;
		StorageNew->xmonInterfaceFilterType[StorageNew->xmonInterfaceFilterTypeLen] = 0;
		if (!(StorageNew->xmonInterfaceFilter = malloc(thedata->xmonInterfaceFilterLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonInterfaceFilter, thedata->xmonInterfaceFilter, thedata->xmonInterfaceFilterLen);
		StorageNew->xmonInterfaceFilterLen = thedata->xmonInterfaceFilterLen;
		StorageNew->xmonInterfaceFilter[StorageNew->xmonInterfaceFilterLen] = 0;
		if (!(StorageNew->xmonInterfaceFilterBpf = malloc(thedata->xmonInterfaceFilterBpfLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonInterfaceFilterBpf, thedata->xmonInterfaceFilterBpf, thedata->xmonInterfaceFilterBpfLen);
		StorageNew->xmonInterfaceFilterBpfLen = thedata->xmonInterfaceFilterBpfLen;
		StorageNew->xmonInterfaceFilterBpf[StorageNew->xmonInterfaceFilterBpfLen] = 0;
		StorageNew->xmonInterfaceFilterStatus = thedata->xmonInterfaceFilterStatus;
		if (!(StorageNew->xmonInterfaceOs = malloc(thedata->xmonInterfaceOsLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonInterfaceOs, thedata->xmonInterfaceOs, thedata->xmonInterfaceOsLen);
		StorageNew->xmonInterfaceOsLen = thedata->xmonInterfaceOsLen;
		StorageNew->xmonInterfaceOs[StorageNew->xmonInterfaceOsLen] = 0;
		StorageNew->xmonInterfaceFcsLen = thedata->xmonInterfaceFcsLen;
		StorageNew->xmonInterfaceTsOffset = thedata->xmonInterfaceTsOffset;
		StorageNew->xmonInterfaceStorageType = thedata->xmonInterfaceStorageType;
		StorageNew->xmonInterfaceRowStatus = thedata->xmonInterfaceRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonInterfaceTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonInterfaceTable_destroy(struct xmonInterfaceTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonInterfaceTable_destroy(struct xmonInterfaceTable_data **thedata)
{
	struct xmonInterfaceTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonInterfaceTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonInterfaceDescription);
		StorageDel->xmonInterfaceDescriptionLen = 0;
		SNMP_FREE(StorageDel->xmonInterfacePhysAddr);
		StorageDel->xmonInterfacePhysAddrLen = 0;
		SNMP_FREE(StorageDel->xmonInterfaceFilterType);
		StorageDel->xmonInterfaceFilterTypeLen = 0;
		SNMP_FREE(StorageDel->xmonInterfaceFilter);
		StorageDel->xmonInterfaceFilterLen = 0;
		SNMP_FREE(StorageDel->xmonInterfaceFilterBpf);
		StorageDel->xmonInterfaceFilterBpfLen = 0;
		SNMP_FREE(StorageDel->xmonInterfaceOs);
		StorageDel->xmonInterfaceOsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonInterfaceTable_add(struct xmonInterfaceTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonInterfaceTable table data set.
 *
 * Adds a table row structure to the xmonInterfaceTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonInterfaceTable_add(struct xmonInterfaceTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonInterfaceTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonSourceIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->xmonSourceIndex, sizeof(thedata->xmonSourceIndex));
		header_complex_add_data(&xmonInterfaceTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonInterfaceTable_del(struct xmonInterfaceTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonInterfaceTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonInterfaceTable_del(struct xmonInterfaceTable_data *thedata)
{
	struct xmonInterfaceTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonInterfaceTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonInterfaceTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonInterfaceTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonInterfaceTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonInterfaceTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonInterfaceTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonInterfaceTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonInterfaceTable_data *StorageTmp = xmonInterfaceTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonInterfaceTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonInterfaceLinkType, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonInterfaceSnapLen, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonInterfacePromiscuous, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonInterfaceMonitor, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonInterfaceDirection, &tmpsize);
	SNMP_FREE(StorageTmp->xmonInterfaceDescription);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonInterfaceDescription, &StorageTmp->xmonInterfaceDescriptionLen);
	if (StorageTmp->xmonInterfaceDescription == NULL) {
		config_perror("invalid specification for xmonInterfaceDescription");
		return;
	}
	SNMP_FREE(StorageTmp->xmonInterfacePhysAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonInterfacePhysAddr, &StorageTmp->xmonInterfacePhysAddrLen);
	if (StorageTmp->xmonInterfacePhysAddr == NULL) {
		config_perror("invalid specification for xmonInterfacePhysAddr");
		return;
	}
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonInterfaceSpeed, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonInterfaceTsRes, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonInterfaceTzone, &tmpsize);
	SNMP_FREE(StorageTmp->xmonInterfaceFilterType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonInterfaceFilterType, &StorageTmp->xmonInterfaceFilterTypeLen);
	if (StorageTmp->xmonInterfaceFilterType == NULL) {
		config_perror("invalid specification for xmonInterfaceFilterType");
		return;
	}
	SNMP_FREE(StorageTmp->xmonInterfaceFilter);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonInterfaceFilter, &StorageTmp->xmonInterfaceFilterLen);
	if (StorageTmp->xmonInterfaceFilter == NULL) {
		config_perror("invalid specification for xmonInterfaceFilter");
		return;
	}
	SNMP_FREE(StorageTmp->xmonInterfaceFilterBpf);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonInterfaceFilterBpf, &StorageTmp->xmonInterfaceFilterBpfLen);
	if (StorageTmp->xmonInterfaceFilterBpf == NULL) {
		config_perror("invalid specification for xmonInterfaceFilterBpf");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonInterfaceFilterStatus, &tmpsize);
	SNMP_FREE(StorageTmp->xmonInterfaceOs);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonInterfaceOs, &StorageTmp->xmonInterfaceOsLen);
	if (StorageTmp->xmonInterfaceOs == NULL) {
		config_perror("invalid specification for xmonInterfaceOs");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonInterfaceFcsLen, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonInterfaceTsOffset, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonInterfaceStorageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonInterfaceRowStatus, &tmpsize);
	xmonInterfaceTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonInterfaceTable(): store configuraiton file for xmonInterfaceTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonInterfaceTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonInterfaceTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonInterfaceTable: storing data...  "));
	refresh_xmonInterfaceTable(1);
	(void) tmpsize;
	for (hcindex = xmonInterfaceTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonInterfaceTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (StorageTmp->xmonInterfaceStorageType == ST_NONVOLATILE) {
			memset(line, 0, sizeof(line));
			strcat(line, "xmonInterfaceTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonInterfaceLinkType, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonInterfaceSnapLen, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonInterfacePromiscuous, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonInterfaceMonitor, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonInterfaceDirection, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonInterfaceDescription, &StorageTmp->xmonInterfaceDescriptionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonInterfacePhysAddr, &StorageTmp->xmonInterfacePhysAddrLen);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonInterfaceSpeed, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonInterfaceTsRes, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonInterfaceTzone, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonInterfaceFilterType, &StorageTmp->xmonInterfaceFilterTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonInterfaceFilter, &StorageTmp->xmonInterfaceFilterLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonInterfaceFilterBpf, &StorageTmp->xmonInterfaceFilterBpfLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonInterfaceFilterStatus, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonInterfaceOs, &StorageTmp->xmonInterfaceOsLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonInterfaceFcsLen, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonInterfaceTsOffset, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonInterfaceStorageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonInterfaceRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonRmonTable_data *xmonRmonTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonRmonTable table.
 *
 * Creates a new xmonRmonTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonRmonTable_data *
xmonRmonTable_create(void)
{
	struct xmonRmonTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonRmonTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonRmonTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonSourceIndex = 0;
		StorageNew->xmonRmonIndex = 0;
		StorageNew->xmonRmonAddrType = 0;
		if ((StorageNew->xmonRmonAddr = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonRmonAddrLen = 0;
		StorageNew->xmonRmonAddr[StorageNew->xmonRmonAddrLen] = 0;
		StorageNew->xmonRmonSnmpVersion = 0;
		if ((StorageNew->xmonRmonCommunity = (uint8_t *) strdup("public")) == NULL)
			goto nomem;
		StorageNew->xmonRmonCommunityLen = strlen("public");
		if ((StorageNew->xmonRmonUsername = (uint8_t *) strdup("unexicon")) == NULL)
			goto nomem;
		StorageNew->xmonRmonUsernameLen = strlen("unexicon");
		if ((StorageNew->xmonRmonPassword = (uint8_t *) strdup("unexicon")) == NULL)
			goto nomem;
		StorageNew->xmonRmonPasswordLen = strlen("unexicon");
		StorageNew->xmonRmonBuffCtrlIndex = 0;
		StorageNew->xmonRmonBuffIndex = 1;
		StorageNew->xmonRmonStorageType = ST_NONVOLATILE;
		StorageNew->xmonRmonRowStatus = 0;
		StorageNew->xmonRmonRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonRmonTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonRmonTable_data *xmonRmonTable_duplicate(struct xmonRmonTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonRmonTable_data *
xmonRmonTable_duplicate(struct xmonRmonTable_data *thedata)
{
	struct xmonRmonTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonRmonTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonRmonTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonRmonTable_id = thedata->xmonRmonTable_id;
		StorageNew->xmonSourceIndex = thedata->xmonSourceIndex;
		StorageNew->xmonRmonIndex = thedata->xmonRmonIndex;
		StorageNew->xmonRmonAddrType = thedata->xmonRmonAddrType;
		if (!(StorageNew->xmonRmonAddr = malloc(thedata->xmonRmonAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonRmonAddr, thedata->xmonRmonAddr, thedata->xmonRmonAddrLen);
		StorageNew->xmonRmonAddrLen = thedata->xmonRmonAddrLen;
		StorageNew->xmonRmonAddr[StorageNew->xmonRmonAddrLen] = 0;
		StorageNew->xmonRmonSnmpVersion = thedata->xmonRmonSnmpVersion;
		if (!(StorageNew->xmonRmonCommunity = malloc(thedata->xmonRmonCommunityLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonRmonCommunity, thedata->xmonRmonCommunity, thedata->xmonRmonCommunityLen);
		StorageNew->xmonRmonCommunityLen = thedata->xmonRmonCommunityLen;
		StorageNew->xmonRmonCommunity[StorageNew->xmonRmonCommunityLen] = 0;
		if (!(StorageNew->xmonRmonUsername = malloc(thedata->xmonRmonUsernameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonRmonUsername, thedata->xmonRmonUsername, thedata->xmonRmonUsernameLen);
		StorageNew->xmonRmonUsernameLen = thedata->xmonRmonUsernameLen;
		StorageNew->xmonRmonUsername[StorageNew->xmonRmonUsernameLen] = 0;
		if (!(StorageNew->xmonRmonPassword = malloc(thedata->xmonRmonPasswordLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonRmonPassword, thedata->xmonRmonPassword, thedata->xmonRmonPasswordLen);
		StorageNew->xmonRmonPasswordLen = thedata->xmonRmonPasswordLen;
		StorageNew->xmonRmonPassword[StorageNew->xmonRmonPasswordLen] = 0;
		StorageNew->xmonRmonBuffCtrlIndex = thedata->xmonRmonBuffCtrlIndex;
		StorageNew->xmonRmonBuffIndex = thedata->xmonRmonBuffIndex;
		StorageNew->xmonRmonStorageType = thedata->xmonRmonStorageType;
		StorageNew->xmonRmonRowStatus = thedata->xmonRmonRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonRmonTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonRmonTable_destroy(struct xmonRmonTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonRmonTable_destroy(struct xmonRmonTable_data **thedata)
{
	struct xmonRmonTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonRmonTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonRmonAddr);
		StorageDel->xmonRmonAddrLen = 0;
		SNMP_FREE(StorageDel->xmonRmonCommunity);
		StorageDel->xmonRmonCommunityLen = 0;
		SNMP_FREE(StorageDel->xmonRmonUsername);
		StorageDel->xmonRmonUsernameLen = 0;
		SNMP_FREE(StorageDel->xmonRmonPassword);
		StorageDel->xmonRmonPasswordLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonRmonTable_add(struct xmonRmonTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonRmonTable table data set.
 *
 * Adds a table row structure to the xmonRmonTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonRmonTable_add(struct xmonRmonTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonRmonTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonSourceIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->xmonSourceIndex, sizeof(thedata->xmonSourceIndex));
		header_complex_add_data(&xmonRmonTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonRmonTable_del(struct xmonRmonTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonRmonTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonRmonTable_del(struct xmonRmonTable_data *thedata)
{
	struct xmonRmonTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonRmonTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonRmonTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonRmonTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonRmonTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonRmonTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonRmonTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonRmonTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonRmonTable_data *StorageTmp = xmonRmonTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonRmonTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSourceIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonRmonIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonRmonAddrType, &tmpsize);
	SNMP_FREE(StorageTmp->xmonRmonAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonRmonAddr, &StorageTmp->xmonRmonAddrLen);
	if (StorageTmp->xmonRmonAddr == NULL) {
		config_perror("invalid specification for xmonRmonAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonRmonSnmpVersion, &tmpsize);
	SNMP_FREE(StorageTmp->xmonRmonCommunity);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonRmonCommunity, &StorageTmp->xmonRmonCommunityLen);
	if (StorageTmp->xmonRmonCommunity == NULL) {
		config_perror("invalid specification for xmonRmonCommunity");
		return;
	}
	SNMP_FREE(StorageTmp->xmonRmonUsername);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonRmonUsername, &StorageTmp->xmonRmonUsernameLen);
	if (StorageTmp->xmonRmonUsername == NULL) {
		config_perror("invalid specification for xmonRmonUsername");
		return;
	}
	SNMP_FREE(StorageTmp->xmonRmonPassword);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonRmonPassword, &StorageTmp->xmonRmonPasswordLen);
	if (StorageTmp->xmonRmonPassword == NULL) {
		config_perror("invalid specification for xmonRmonPassword");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonRmonBuffCtrlIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonRmonBuffIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonRmonStorageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonRmonRowStatus, &tmpsize);
	xmonRmonTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonRmonTable(): store configuraiton file for xmonRmonTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonRmonTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonRmonTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonRmonTable: storing data...  "));
	refresh_xmonRmonTable(1);
	(void) tmpsize;
	for (hcindex = xmonRmonTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonRmonTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (StorageTmp->xmonRmonStorageType == ST_NONVOLATILE) {
			memset(line, 0, sizeof(line));
			strcat(line, "xmonRmonTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSourceIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonRmonIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonRmonAddrType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonRmonAddr, &StorageTmp->xmonRmonAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonRmonSnmpVersion, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonRmonCommunity, &StorageTmp->xmonRmonCommunityLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonRmonUsername, &StorageTmp->xmonRmonUsernameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonRmonPassword, &StorageTmp->xmonRmonPasswordLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonRmonBuffCtrlIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonRmonBuffIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonRmonStorageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonRmonRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonArchiveTable_data *xmonArchiveTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonArchiveTable table.
 *
 * Creates a new xmonArchiveTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonArchiveTable_data *
xmonArchiveTable_create(void)
{
	struct xmonArchiveTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonArchiveTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonArchiveTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->xmonArchiveName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonArchiveNameLen = 0;
		StorageNew->xmonArchiveName[StorageNew->xmonArchiveNameLen] = 0;
		StorageNew->xmonArchiveFileFormat = XMONARCHIVEFILEFORMAT_PCAPNG;
		StorageNew->xmonArchiveCompressed = 0;
		StorageNew->xmonArchiveState = 0;
		StorageNew->xmonArchiveSize = (struct counter64) {
		0, 0};
		StorageNew->xmonArchiveCompSize = (struct counter64) {
		0, 0};
		StorageNew->xmonArchiveTimeElapsed = 0;
		StorageNew->xmonArchiveBegTime = 0;
		StorageNew->xmonArchiveEndTime = 0;
		StorageNew->xmonArchiveIfRecv = (struct counter64) {
		0, 0};
		StorageNew->xmonArchiveIfDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonArchiveFilterAccept = (struct counter64) {
		0, 0};
		StorageNew->xmonArchiveOsDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonArchiveUserDeliv = (struct counter64) {
		0, 0};
		StorageNew->xmonArchiveIfCompress = (struct counter64) {
		0, 0};
		StorageNew->xmonArchiveUserOctets = (struct counter64) {
		0, 0};
		StorageNew->xmonArchiveActionResult = 0;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonArchiveTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonArchiveTable_data *xmonArchiveTable_duplicate(struct xmonArchiveTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonArchiveTable_data *
xmonArchiveTable_duplicate(struct xmonArchiveTable_data *thedata)
{
	struct xmonArchiveTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonArchiveTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonArchiveTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonArchiveTable_id = thedata->xmonArchiveTable_id;
		StorageNew->xmonArchiveIndex = thedata->xmonArchiveIndex;
		if (!(StorageNew->xmonArchiveName = malloc(thedata->xmonArchiveNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonArchiveName, thedata->xmonArchiveName, thedata->xmonArchiveNameLen);
		StorageNew->xmonArchiveNameLen = thedata->xmonArchiveNameLen;
		StorageNew->xmonArchiveName[StorageNew->xmonArchiveNameLen] = 0;
		StorageNew->xmonArchiveFileFormat = thedata->xmonArchiveFileFormat;
		StorageNew->xmonArchiveCompressed = thedata->xmonArchiveCompressed;
		StorageNew->xmonArchiveState = thedata->xmonArchiveState;
		StorageNew->xmonArchiveSize = thedata->xmonArchiveSize;
		StorageNew->xmonArchiveCompSize = thedata->xmonArchiveCompSize;
		StorageNew->xmonArchiveTimeElapsed = thedata->xmonArchiveTimeElapsed;
		StorageNew->xmonArchiveBegTime = thedata->xmonArchiveBegTime;
		StorageNew->xmonArchiveEndTime = thedata->xmonArchiveEndTime;
		StorageNew->xmonArchiveIfRecv = thedata->xmonArchiveIfRecv;
		StorageNew->xmonArchiveIfDrop = thedata->xmonArchiveIfDrop;
		StorageNew->xmonArchiveFilterAccept = thedata->xmonArchiveFilterAccept;
		StorageNew->xmonArchiveOsDrop = thedata->xmonArchiveOsDrop;
		StorageNew->xmonArchiveUserDeliv = thedata->xmonArchiveUserDeliv;
		StorageNew->xmonArchiveIfCompress = thedata->xmonArchiveIfCompress;
		StorageNew->xmonArchiveUserOctets = thedata->xmonArchiveUserOctets;
		StorageNew->xmonArchiveActionResult = thedata->xmonArchiveActionResult;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonArchiveTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonArchiveTable_destroy(struct xmonArchiveTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonArchiveTable_destroy(struct xmonArchiveTable_data **thedata)
{
	struct xmonArchiveTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonArchiveTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonArchiveName);
		StorageDel->xmonArchiveNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonArchiveTable_add(struct xmonArchiveTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonArchiveTable table data set.
 *
 * Adds a table row structure to the xmonArchiveTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonArchiveTable_add(struct xmonArchiveTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonArchiveTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonArchiveIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonArchiveIndex, sizeof(thedata->xmonArchiveIndex));
		header_complex_add_data(&xmonArchiveTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonArchiveTable_del(struct xmonArchiveTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonArchiveTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonArchiveTable_del(struct xmonArchiveTable_data *thedata)
{
	struct xmonArchiveTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonArchiveTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonArchiveTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonArchiveTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonArchiveTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonArchiveTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonArchiveTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonArchiveTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonArchiveTable_data *StorageTmp = xmonArchiveTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonArchiveTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonArchiveIndex, &tmpsize);
	SNMP_FREE(StorageTmp->xmonArchiveName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonArchiveName, &StorageTmp->xmonArchiveNameLen);
	if (StorageTmp->xmonArchiveName == NULL) {
		config_perror("invalid specification for xmonArchiveName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonArchiveFileFormat, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonArchiveCompressed, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonArchiveState, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonArchiveSize, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonArchiveCompSize, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonArchiveTimeElapsed, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonArchiveBegTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonArchiveEndTime, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonArchiveIfRecv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonArchiveIfDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonArchiveFilterAccept, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonArchiveOsDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonArchiveUserDeliv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonArchiveIfCompress, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonArchiveUserOctets, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonArchiveActionResult, &tmpsize);
	xmonArchiveTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonArchiveTable(): store configuraiton file for xmonArchiveTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonArchiveTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonArchiveTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonArchiveTable: storing data...  "));
	refresh_xmonArchiveTable(1);
	(void) tmpsize;
	for (hcindex = xmonArchiveTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonArchiveTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonArchiveTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonArchiveIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonArchiveName, &StorageTmp->xmonArchiveNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonArchiveFileFormat, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonArchiveCompressed, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonArchiveState, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonArchiveSize, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonArchiveCompSize, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonArchiveTimeElapsed, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonArchiveBegTime, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonArchiveEndTime, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonArchiveIfRecv, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonArchiveIfDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonArchiveFilterAccept, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonArchiveOsDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonArchiveUserDeliv, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonArchiveIfCompress, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonArchiveUserOctets, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonArchiveActionResult, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonFeedListenTable_data *xmonFeedListenTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonFeedListenTable table.
 *
 * Creates a new xmonFeedListenTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonFeedListenTable_data *
xmonFeedListenTable_create(void)
{
	struct xmonFeedListenTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonFeedListenTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonFeedListenTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonFeedListenAddrType = 0;
		if ((StorageNew->xmonFeedListenAddr = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonFeedListenAddrLen = 0;
		StorageNew->xmonFeedListenAddr[StorageNew->xmonFeedListenAddrLen] = 0;
		StorageNew->xmonFeedListenRowStatus = 0;
		StorageNew->xmonFeedListenRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonFeedListenTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonFeedListenTable_data *xmonFeedListenTable_duplicate(struct xmonFeedListenTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonFeedListenTable_data *
xmonFeedListenTable_duplicate(struct xmonFeedListenTable_data *thedata)
{
	struct xmonFeedListenTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonFeedListenTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonFeedListenTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonFeedListenTable_id = thedata->xmonFeedListenTable_id;
		StorageNew->xmonFeedListenIndex = thedata->xmonFeedListenIndex;
		StorageNew->xmonFeedListenAddrType = thedata->xmonFeedListenAddrType;
		if (!(StorageNew->xmonFeedListenAddr = malloc(thedata->xmonFeedListenAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonFeedListenAddr, thedata->xmonFeedListenAddr, thedata->xmonFeedListenAddrLen);
		StorageNew->xmonFeedListenAddrLen = thedata->xmonFeedListenAddrLen;
		StorageNew->xmonFeedListenAddr[StorageNew->xmonFeedListenAddrLen] = 0;
		StorageNew->xmonFeedListenRowStatus = thedata->xmonFeedListenRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonFeedListenTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonFeedListenTable_destroy(struct xmonFeedListenTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonFeedListenTable_destroy(struct xmonFeedListenTable_data **thedata)
{
	struct xmonFeedListenTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonFeedListenTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonFeedListenAddr);
		StorageDel->xmonFeedListenAddrLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonFeedListenTable_add(struct xmonFeedListenTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonFeedListenTable table data set.
 *
 * Adds a table row structure to the xmonFeedListenTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonFeedListenTable_add(struct xmonFeedListenTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonFeedListenTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonFeedListenIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonFeedListenIndex, sizeof(thedata->xmonFeedListenIndex));
		header_complex_add_data(&xmonFeedListenTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonFeedListenTable_del(struct xmonFeedListenTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonFeedListenTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonFeedListenTable_del(struct xmonFeedListenTable_data *thedata)
{
	struct xmonFeedListenTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonFeedListenTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonFeedListenTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonFeedListenTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonFeedListenTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonFeedListenTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonFeedListenTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonFeedListenTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonFeedListenTable_data *StorageTmp = xmonFeedListenTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonFeedListenTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonFeedListenIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedListenAddrType, &tmpsize);
	SNMP_FREE(StorageTmp->xmonFeedListenAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonFeedListenAddr, &StorageTmp->xmonFeedListenAddrLen);
	if (StorageTmp->xmonFeedListenAddr == NULL) {
		config_perror("invalid specification for xmonFeedListenAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedListenRowStatus, &tmpsize);
	xmonFeedListenTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonFeedListenTable(): store configuraiton file for xmonFeedListenTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonFeedListenTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonFeedListenTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonFeedListenTable: storing data...  "));
	refresh_xmonFeedListenTable(1);
	(void) tmpsize;
	for (hcindex = xmonFeedListenTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonFeedListenTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonFeedListenTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonFeedListenIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedListenAddrType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonFeedListenAddr, &StorageTmp->xmonFeedListenAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedListenRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonFeedTable_data *xmonFeedTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonFeedTable table.
 *
 * Creates a new xmonFeedTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonFeedTable_data *
xmonFeedTable_create(void)
{
	struct xmonFeedTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonFeedTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonFeedTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonFeedRole = XMONFEEDROLE_INITIATOR;
		if ((StorageNew->xmonFeedName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonFeedNameLen = 0;
		StorageNew->xmonFeedName[StorageNew->xmonFeedNameLen] = 0;
		StorageNew->xmonFeedAddrType = 0;
		if ((StorageNew->xmonFeedAddr = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonFeedAddrLen = 0;
		StorageNew->xmonFeedAddr[StorageNew->xmonFeedAddrLen] = 0;
		StorageNew->xmonFeedConnInterval = 500;
		StorageNew->xmonFeedConnAttempts = 0;
		if ((StorageNew->xmonFeedProfile = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->xmonFeedProfileLen = strlen("");
		StorageNew->xmonFeedAdminState = XMONFEEDADMINSTATE_UNLOCKED;
		StorageNew->xmonFeedOpState = 0;
		if (memdup((u_char **) &StorageNew->xmonFeedProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonFeedProcStatusLen = 1;
		StorageNew->xmonFeedUsageState = 0;
		StorageNew->xmonFeedConnState = 0;
		StorageNew->xmonFeedStorageType = ST_NONVOLATILE;
		StorageNew->xmonFeedRowStatus = 0;
		StorageNew->xmonFeedRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonFeedTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonFeedTable_data *xmonFeedTable_duplicate(struct xmonFeedTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonFeedTable_data *
xmonFeedTable_duplicate(struct xmonFeedTable_data *thedata)
{
	struct xmonFeedTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonFeedTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonFeedTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonFeedTable_id = thedata->xmonFeedTable_id;
		StorageNew->xmonFeedIndex = thedata->xmonFeedIndex;
		StorageNew->xmonFeedRole = thedata->xmonFeedRole;
		if (!(StorageNew->xmonFeedName = malloc(thedata->xmonFeedNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonFeedName, thedata->xmonFeedName, thedata->xmonFeedNameLen);
		StorageNew->xmonFeedNameLen = thedata->xmonFeedNameLen;
		StorageNew->xmonFeedName[StorageNew->xmonFeedNameLen] = 0;
		StorageNew->xmonFeedAddrType = thedata->xmonFeedAddrType;
		if (!(StorageNew->xmonFeedAddr = malloc(thedata->xmonFeedAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonFeedAddr, thedata->xmonFeedAddr, thedata->xmonFeedAddrLen);
		StorageNew->xmonFeedAddrLen = thedata->xmonFeedAddrLen;
		StorageNew->xmonFeedAddr[StorageNew->xmonFeedAddrLen] = 0;
		StorageNew->xmonFeedConnInterval = thedata->xmonFeedConnInterval;
		StorageNew->xmonFeedConnAttempts = thedata->xmonFeedConnAttempts;
		if (!(StorageNew->xmonFeedProfile = malloc(thedata->xmonFeedProfileLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonFeedProfile, thedata->xmonFeedProfile, thedata->xmonFeedProfileLen);
		StorageNew->xmonFeedProfileLen = thedata->xmonFeedProfileLen;
		StorageNew->xmonFeedProfile[StorageNew->xmonFeedProfileLen] = 0;
		StorageNew->xmonFeedAdminState = thedata->xmonFeedAdminState;
		StorageNew->xmonFeedOpState = thedata->xmonFeedOpState;
		if (!(StorageNew->xmonFeedProcStatus = malloc(thedata->xmonFeedProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonFeedProcStatus, thedata->xmonFeedProcStatus, thedata->xmonFeedProcStatusLen);
		StorageNew->xmonFeedProcStatusLen = thedata->xmonFeedProcStatusLen;
		StorageNew->xmonFeedProcStatus[StorageNew->xmonFeedProcStatusLen] = 0;
		StorageNew->xmonFeedUsageState = thedata->xmonFeedUsageState;
		StorageNew->xmonFeedConnState = thedata->xmonFeedConnState;
		StorageNew->xmonFeedStorageType = thedata->xmonFeedStorageType;
		StorageNew->xmonFeedRowStatus = thedata->xmonFeedRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonFeedTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonFeedTable_destroy(struct xmonFeedTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonFeedTable_destroy(struct xmonFeedTable_data **thedata)
{
	struct xmonFeedTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonFeedTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonFeedName);
		StorageDel->xmonFeedNameLen = 0;
		SNMP_FREE(StorageDel->xmonFeedAddr);
		StorageDel->xmonFeedAddrLen = 0;
		SNMP_FREE(StorageDel->xmonFeedProfile);
		StorageDel->xmonFeedProfileLen = 0;
		SNMP_FREE(StorageDel->xmonFeedProcStatus);
		StorageDel->xmonFeedProcStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonFeedTable_add(struct xmonFeedTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonFeedTable table data set.
 *
 * Adds a table row structure to the xmonFeedTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonFeedTable_add(struct xmonFeedTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonFeedTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonFeedIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonFeedIndex, sizeof(thedata->xmonFeedIndex));
		header_complex_add_data(&xmonFeedTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonFeedTable_del(struct xmonFeedTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonFeedTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonFeedTable_del(struct xmonFeedTable_data *thedata)
{
	struct xmonFeedTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonFeedTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonFeedTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonFeedTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonFeedTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonFeedTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonFeedTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonFeedTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonFeedTable_data *StorageTmp = xmonFeedTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonFeedTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonFeedIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedRole, &tmpsize);
	SNMP_FREE(StorageTmp->xmonFeedName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonFeedName, &StorageTmp->xmonFeedNameLen);
	if (StorageTmp->xmonFeedName == NULL) {
		config_perror("invalid specification for xmonFeedName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedAddrType, &tmpsize);
	SNMP_FREE(StorageTmp->xmonFeedAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonFeedAddr, &StorageTmp->xmonFeedAddrLen);
	if (StorageTmp->xmonFeedAddr == NULL) {
		config_perror("invalid specification for xmonFeedAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedConnInterval, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonFeedConnAttempts, &tmpsize);
	SNMP_FREE(StorageTmp->xmonFeedProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonFeedProfile, &StorageTmp->xmonFeedProfileLen);
	if (StorageTmp->xmonFeedProfile == NULL) {
		config_perror("invalid specification for xmonFeedProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedOpState, &tmpsize);
	SNMP_FREE(StorageTmp->xmonFeedProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonFeedProcStatus, &StorageTmp->xmonFeedProcStatusLen);
	if (StorageTmp->xmonFeedProcStatus == NULL) {
		config_perror("invalid specification for xmonFeedProcStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedConnState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedStorageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedRowStatus, &tmpsize);
	xmonFeedTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonFeedTable(): store configuraiton file for xmonFeedTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonFeedTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonFeedTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonFeedTable: storing data...  "));
	refresh_xmonFeedTable(1);
	(void) tmpsize;
	for (hcindex = xmonFeedTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonFeedTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (StorageTmp->xmonFeedStorageType == ST_NONVOLATILE) {
			memset(line, 0, sizeof(line));
			strcat(line, "xmonFeedTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonFeedIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedRole, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonFeedName, &StorageTmp->xmonFeedNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedAddrType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonFeedAddr, &StorageTmp->xmonFeedAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedConnInterval, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonFeedConnAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonFeedProfile, &StorageTmp->xmonFeedProfileLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedOpState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonFeedProcStatus, &StorageTmp->xmonFeedProcStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedConnState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedStorageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonFeedStatsTable_data *xmonFeedStatsTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonFeedStatsTable table.
 *
 * Creates a new xmonFeedStatsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonFeedStatsTable_data *
xmonFeedStatsTable_create(void)
{
	struct xmonFeedStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonFeedStatsTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonFeedStatsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonFeedIndex = 0;
		StorageNew->xmonFeedTimeElapsed = 0;
		StorageNew->xmonFeedBegTime = 0;
		StorageNew->xmonFeedEndTime = 0;
		StorageNew->xmonFeedIfRecv = (struct counter64) {
		0, 0};
		StorageNew->xmonFeedIfDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonFeedFilterAccept = (struct counter64) {
		0, 0};
		StorageNew->xmonFeedOsDrop = (struct counter64) {
		0, 0};
		StorageNew->xmonFeedUserDeliv = (struct counter64) {
		0, 0};
		StorageNew->xmonFeedIfCompress = (struct counter64) {
		0, 0};
		StorageNew->xmonFeedUserOctets = (struct counter64) {
		0, 0};
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonFeedStatsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonFeedStatsTable_data *xmonFeedStatsTable_duplicate(struct xmonFeedStatsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonFeedStatsTable_data *
xmonFeedStatsTable_duplicate(struct xmonFeedStatsTable_data *thedata)
{
	struct xmonFeedStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonFeedStatsTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonFeedStatsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonFeedStatsTable_id = thedata->xmonFeedStatsTable_id;
		StorageNew->xmonFeedIndex = thedata->xmonFeedIndex;
		StorageNew->xmonFeedConnIndex = thedata->xmonFeedConnIndex;
		StorageNew->xmonFeedTimeElapsed = thedata->xmonFeedTimeElapsed;
		StorageNew->xmonFeedBegTime = thedata->xmonFeedBegTime;
		StorageNew->xmonFeedEndTime = thedata->xmonFeedEndTime;
		StorageNew->xmonFeedIfRecv = thedata->xmonFeedIfRecv;
		StorageNew->xmonFeedIfDrop = thedata->xmonFeedIfDrop;
		StorageNew->xmonFeedFilterAccept = thedata->xmonFeedFilterAccept;
		StorageNew->xmonFeedOsDrop = thedata->xmonFeedOsDrop;
		StorageNew->xmonFeedUserDeliv = thedata->xmonFeedUserDeliv;
		StorageNew->xmonFeedIfCompress = thedata->xmonFeedIfCompress;
		StorageNew->xmonFeedUserOctets = thedata->xmonFeedUserOctets;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonFeedStatsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonFeedStatsTable_destroy(struct xmonFeedStatsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonFeedStatsTable_destroy(struct xmonFeedStatsTable_data **thedata)
{
	struct xmonFeedStatsTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonFeedStatsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonFeedStatsTable_add(struct xmonFeedStatsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonFeedStatsTable table data set.
 *
 * Adds a table row structure to the xmonFeedStatsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonFeedStatsTable_add(struct xmonFeedStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonFeedStatsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonFeedIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonFeedIndex, sizeof(thedata->xmonFeedIndex));
		/* xmonFeedConnIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonFeedConnIndex, sizeof(thedata->xmonFeedConnIndex));
		header_complex_add_data(&xmonFeedStatsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonFeedStatsTable_del(struct xmonFeedStatsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonFeedStatsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonFeedStatsTable_del(struct xmonFeedStatsTable_data *thedata)
{
	struct xmonFeedStatsTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonFeedStatsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonFeedStatsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonFeedStatsTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonFeedStatsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonFeedStatsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonFeedStatsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonFeedStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonFeedStatsTable_data *StorageTmp = xmonFeedStatsTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonFeedStatsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonFeedIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonFeedConnIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonFeedTimeElapsed, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonFeedBegTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonFeedEndTime, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonFeedIfRecv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonFeedIfDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonFeedFilterAccept, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonFeedOsDrop, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonFeedUserDeliv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonFeedIfCompress, &tmpsize);
	line = read_config_read_data(ASN_COUNTER64, line, &StorageTmp->xmonFeedUserOctets, &tmpsize);
	xmonFeedStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonFeedStatsTable(): store configuraiton file for xmonFeedStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonFeedStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonFeedStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonFeedStatsTable: storing data...  "));
	refresh_xmonFeedStatsTable(1);
	(void) tmpsize;
	for (hcindex = xmonFeedStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonFeedStatsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonFeedStatsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonFeedIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonFeedConnIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonFeedTimeElapsed, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonFeedBegTime, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonFeedEndTime, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonFeedIfRecv, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonFeedIfDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonFeedFilterAccept, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonFeedOsDrop, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonFeedUserDeliv, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonFeedIfCompress, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->xmonFeedUserOctets, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonPushListenTable_data *xmonPushListenTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonPushListenTable table.
 *
 * Creates a new xmonPushListenTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonPushListenTable_data *
xmonPushListenTable_create(void)
{
	struct xmonPushListenTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonPushListenTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonPushListenTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonPushListenAddrType = 0;
		if ((StorageNew->xmonPushListenAddr = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonPushListenAddrLen = 0;
		StorageNew->xmonPushListenAddr[StorageNew->xmonPushListenAddrLen] = 0;
		StorageNew->xmonPushListenRowStatus = 0;
		StorageNew->xmonPushListenRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonPushListenTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonPushListenTable_data *xmonPushListenTable_duplicate(struct xmonPushListenTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonPushListenTable_data *
xmonPushListenTable_duplicate(struct xmonPushListenTable_data *thedata)
{
	struct xmonPushListenTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonPushListenTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonPushListenTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonPushListenTable_id = thedata->xmonPushListenTable_id;
		StorageNew->xmonPushListenIndex = thedata->xmonPushListenIndex;
		StorageNew->xmonPushListenAddrType = thedata->xmonPushListenAddrType;
		if (!(StorageNew->xmonPushListenAddr = malloc(thedata->xmonPushListenAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPushListenAddr, thedata->xmonPushListenAddr, thedata->xmonPushListenAddrLen);
		StorageNew->xmonPushListenAddrLen = thedata->xmonPushListenAddrLen;
		StorageNew->xmonPushListenAddr[StorageNew->xmonPushListenAddrLen] = 0;
		StorageNew->xmonPushListenRowStatus = thedata->xmonPushListenRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonPushListenTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonPushListenTable_destroy(struct xmonPushListenTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonPushListenTable_destroy(struct xmonPushListenTable_data **thedata)
{
	struct xmonPushListenTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonPushListenTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonPushListenAddr);
		StorageDel->xmonPushListenAddrLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonPushListenTable_add(struct xmonPushListenTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonPushListenTable table data set.
 *
 * Adds a table row structure to the xmonPushListenTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonPushListenTable_add(struct xmonPushListenTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonPushListenTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonPushListenIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonPushListenIndex, sizeof(thedata->xmonPushListenIndex));
		header_complex_add_data(&xmonPushListenTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonPushListenTable_del(struct xmonPushListenTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonPushListenTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonPushListenTable_del(struct xmonPushListenTable_data *thedata)
{
	struct xmonPushListenTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonPushListenTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonPushListenTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonPushListenTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonPushListenTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonPushListenTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonPushListenTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonPushListenTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonPushListenTable_data *StorageTmp = xmonPushListenTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonPushListenTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonPushListenIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushListenAddrType, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPushListenAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPushListenAddr, &StorageTmp->xmonPushListenAddrLen);
	if (StorageTmp->xmonPushListenAddr == NULL) {
		config_perror("invalid specification for xmonPushListenAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushListenRowStatus, &tmpsize);
	xmonPushListenTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonPushListenTable(): store configuraiton file for xmonPushListenTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonPushListenTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonPushListenTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonPushListenTable: storing data...  "));
	refresh_xmonPushListenTable(1);
	(void) tmpsize;
	for (hcindex = xmonPushListenTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonPushListenTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonPushListenTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonPushListenIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushListenAddrType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPushListenAddr, &StorageTmp->xmonPushListenAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushListenRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonPushTable_data *xmonPushTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonPushTable table.
 *
 * Creates a new xmonPushTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonPushTable_data *
xmonPushTable_create(void)
{
	struct xmonPushTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonPushTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonPushTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonPushRole = XMONPUSHROLE_INITIATOR;
		if ((StorageNew->xmonPushName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonPushNameLen = 0;
		StorageNew->xmonPushName[StorageNew->xmonPushNameLen] = 0;
		StorageNew->xmonPushAddrType = XMONPUSHADDRTYPE_SCTPIPV4;
		if ((StorageNew->xmonPushAddr = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonPushAddrLen = 0;
		StorageNew->xmonPushAddr[StorageNew->xmonPushAddrLen] = 0;
		StorageNew->xmonPushConnInterval = 500;
		StorageNew->xmonPushConnAttempts = 0;
		if ((StorageNew->xmonPushProfile = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->xmonPushProfileLen = strlen("");
		StorageNew->xmonPushAdminState = XMONPUSHADMINSTATE_UNLOCKED;
		StorageNew->xmonPushOpState = 0;
		if (memdup((u_char **) &StorageNew->xmonPushProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonPushProcStatusLen = 1;
		StorageNew->xmonPushUsageState = 0;
		StorageNew->xmonPushConnState = 0;
		StorageNew->xmonPushStorageType = ST_NONVOLATILE;
		StorageNew->xmonPushRowStatus = 0;
		StorageNew->xmonPushRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonPushTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonPushTable_data *xmonPushTable_duplicate(struct xmonPushTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonPushTable_data *
xmonPushTable_duplicate(struct xmonPushTable_data *thedata)
{
	struct xmonPushTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonPushTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonPushTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonPushTable_id = thedata->xmonPushTable_id;
		StorageNew->xmonPushIndex = thedata->xmonPushIndex;
		StorageNew->xmonPushRole = thedata->xmonPushRole;
		if (!(StorageNew->xmonPushName = malloc(thedata->xmonPushNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPushName, thedata->xmonPushName, thedata->xmonPushNameLen);
		StorageNew->xmonPushNameLen = thedata->xmonPushNameLen;
		StorageNew->xmonPushName[StorageNew->xmonPushNameLen] = 0;
		StorageNew->xmonPushAddrType = thedata->xmonPushAddrType;
		if (!(StorageNew->xmonPushAddr = malloc(thedata->xmonPushAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPushAddr, thedata->xmonPushAddr, thedata->xmonPushAddrLen);
		StorageNew->xmonPushAddrLen = thedata->xmonPushAddrLen;
		StorageNew->xmonPushAddr[StorageNew->xmonPushAddrLen] = 0;
		StorageNew->xmonPushConnInterval = thedata->xmonPushConnInterval;
		StorageNew->xmonPushConnAttempts = thedata->xmonPushConnAttempts;
		if (!(StorageNew->xmonPushProfile = malloc(thedata->xmonPushProfileLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPushProfile, thedata->xmonPushProfile, thedata->xmonPushProfileLen);
		StorageNew->xmonPushProfileLen = thedata->xmonPushProfileLen;
		StorageNew->xmonPushProfile[StorageNew->xmonPushProfileLen] = 0;
		StorageNew->xmonPushAdminState = thedata->xmonPushAdminState;
		StorageNew->xmonPushOpState = thedata->xmonPushOpState;
		if (!(StorageNew->xmonPushProcStatus = malloc(thedata->xmonPushProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPushProcStatus, thedata->xmonPushProcStatus, thedata->xmonPushProcStatusLen);
		StorageNew->xmonPushProcStatusLen = thedata->xmonPushProcStatusLen;
		StorageNew->xmonPushProcStatus[StorageNew->xmonPushProcStatusLen] = 0;
		StorageNew->xmonPushUsageState = thedata->xmonPushUsageState;
		StorageNew->xmonPushConnState = thedata->xmonPushConnState;
		StorageNew->xmonPushStorageType = thedata->xmonPushStorageType;
		StorageNew->xmonPushRowStatus = thedata->xmonPushRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonPushTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonPushTable_destroy(struct xmonPushTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonPushTable_destroy(struct xmonPushTable_data **thedata)
{
	struct xmonPushTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonPushTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonPushName);
		StorageDel->xmonPushNameLen = 0;
		SNMP_FREE(StorageDel->xmonPushAddr);
		StorageDel->xmonPushAddrLen = 0;
		SNMP_FREE(StorageDel->xmonPushProfile);
		StorageDel->xmonPushProfileLen = 0;
		SNMP_FREE(StorageDel->xmonPushProcStatus);
		StorageDel->xmonPushProcStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonPushTable_add(struct xmonPushTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonPushTable table data set.
 *
 * Adds a table row structure to the xmonPushTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonPushTable_add(struct xmonPushTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonPushTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonPushIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonPushIndex, sizeof(thedata->xmonPushIndex));
		header_complex_add_data(&xmonPushTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonPushTable_del(struct xmonPushTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonPushTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonPushTable_del(struct xmonPushTable_data *thedata)
{
	struct xmonPushTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonPushTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonPushTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonPushTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonPushTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonPushTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonPushTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonPushTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonPushTable_data *StorageTmp = xmonPushTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonPushTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonPushIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushRole, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPushName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPushName, &StorageTmp->xmonPushNameLen);
	if (StorageTmp->xmonPushName == NULL) {
		config_perror("invalid specification for xmonPushName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushAddrType, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPushAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPushAddr, &StorageTmp->xmonPushAddrLen);
	if (StorageTmp->xmonPushAddr == NULL) {
		config_perror("invalid specification for xmonPushAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushConnInterval, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonPushConnAttempts, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPushProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPushProfile, &StorageTmp->xmonPushProfileLen);
	if (StorageTmp->xmonPushProfile == NULL) {
		config_perror("invalid specification for xmonPushProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushOpState, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPushProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPushProcStatus, &StorageTmp->xmonPushProcStatusLen);
	if (StorageTmp->xmonPushProcStatus == NULL) {
		config_perror("invalid specification for xmonPushProcStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushConnState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushStorageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPushRowStatus, &tmpsize);
	xmonPushTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonPushTable(): store configuraiton file for xmonPushTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonPushTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonPushTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonPushTable: storing data...  "));
	refresh_xmonPushTable(1);
	(void) tmpsize;
	for (hcindex = xmonPushTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonPushTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (StorageTmp->xmonPushStorageType == ST_NONVOLATILE) {
			memset(line, 0, sizeof(line));
			strcat(line, "xmonPushTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonPushIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushRole, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPushName, &StorageTmp->xmonPushNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushAddrType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPushAddr, &StorageTmp->xmonPushAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushConnInterval, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonPushConnAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPushProfile, &StorageTmp->xmonPushProfileLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushOpState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPushProcStatus, &StorageTmp->xmonPushProcStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushConnState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushStorageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPushRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonPullListenTable_data *xmonPullListenTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonPullListenTable table.
 *
 * Creates a new xmonPullListenTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonPullListenTable_data *
xmonPullListenTable_create(void)
{
	struct xmonPullListenTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonPullListenTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonPullListenTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonPullListenAddrType = 0;
		if ((StorageNew->xmonPullListenAddr = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonPullListenAddrLen = 0;
		StorageNew->xmonPullListenAddr[StorageNew->xmonPullListenAddrLen] = 0;
		StorageNew->xmonPullListenRowStatus = 0;
		StorageNew->xmonPullListenRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonPullListenTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonPullListenTable_data *xmonPullListenTable_duplicate(struct xmonPullListenTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonPullListenTable_data *
xmonPullListenTable_duplicate(struct xmonPullListenTable_data *thedata)
{
	struct xmonPullListenTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonPullListenTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonPullListenTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonPullListenTable_id = thedata->xmonPullListenTable_id;
		StorageNew->xmonPullListenIndex = thedata->xmonPullListenIndex;
		StorageNew->xmonPullListenAddrType = thedata->xmonPullListenAddrType;
		if (!(StorageNew->xmonPullListenAddr = malloc(thedata->xmonPullListenAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPullListenAddr, thedata->xmonPullListenAddr, thedata->xmonPullListenAddrLen);
		StorageNew->xmonPullListenAddrLen = thedata->xmonPullListenAddrLen;
		StorageNew->xmonPullListenAddr[StorageNew->xmonPullListenAddrLen] = 0;
		StorageNew->xmonPullListenRowStatus = thedata->xmonPullListenRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonPullListenTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonPullListenTable_destroy(struct xmonPullListenTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonPullListenTable_destroy(struct xmonPullListenTable_data **thedata)
{
	struct xmonPullListenTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonPullListenTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonPullListenAddr);
		StorageDel->xmonPullListenAddrLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonPullListenTable_add(struct xmonPullListenTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonPullListenTable table data set.
 *
 * Adds a table row structure to the xmonPullListenTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonPullListenTable_add(struct xmonPullListenTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonPullListenTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonPullListenIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonPullListenIndex, sizeof(thedata->xmonPullListenIndex));
		header_complex_add_data(&xmonPullListenTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonPullListenTable_del(struct xmonPullListenTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonPullListenTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonPullListenTable_del(struct xmonPullListenTable_data *thedata)
{
	struct xmonPullListenTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonPullListenTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonPullListenTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonPullListenTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonPullListenTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonPullListenTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonPullListenTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonPullListenTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonPullListenTable_data *StorageTmp = xmonPullListenTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonPullListenTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonPullListenIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullListenAddrType, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPullListenAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPullListenAddr, &StorageTmp->xmonPullListenAddrLen);
	if (StorageTmp->xmonPullListenAddr == NULL) {
		config_perror("invalid specification for xmonPullListenAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullListenRowStatus, &tmpsize);
	xmonPullListenTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonPullListenTable(): store configuraiton file for xmonPullListenTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonPullListenTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonPullListenTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonPullListenTable: storing data...  "));
	refresh_xmonPullListenTable(1);
	(void) tmpsize;
	for (hcindex = xmonPullListenTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonPullListenTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonPullListenTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonPullListenIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullListenAddrType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPullListenAddr, &StorageTmp->xmonPullListenAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullListenRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonPullTable_data *xmonPullTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonPullTable table.
 *
 * Creates a new xmonPullTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonPullTable_data *
xmonPullTable_create(void)
{
	struct xmonPullTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonPullTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonPullTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonPullRole = XMONPULLROLE_INITIATOR;
		if ((StorageNew->xmonPullName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonPullNameLen = 0;
		StorageNew->xmonPullName[StorageNew->xmonPullNameLen] = 0;
		StorageNew->xmonPullAddrType = 0;
		if ((StorageNew->xmonPullAddr = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonPullAddrLen = 0;
		StorageNew->xmonPullAddr[StorageNew->xmonPullAddrLen] = 0;
		StorageNew->xmonPullConnInterval = 500;
		StorageNew->xmonPullConnAttempts = 0;
		if ((StorageNew->xmonPullProfile = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->xmonPullProfileLen = strlen("");
		StorageNew->xmonPullAdminState = XMONPULLADMINSTATE_UNLOCKED;
		StorageNew->xmonPullOpState = 0;
		if (memdup((u_char **) &StorageNew->xmonPullProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonPullProcStatusLen = 1;
		StorageNew->xmonPullUsageState = 0;
		StorageNew->xmonPullConnState = 0;
		StorageNew->xmonPullStorageType = ST_NONVOLATILE;
		StorageNew->xmonPullRowStatus = 0;
		StorageNew->xmonPullRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonPullTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonPullTable_data *xmonPullTable_duplicate(struct xmonPullTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonPullTable_data *
xmonPullTable_duplicate(struct xmonPullTable_data *thedata)
{
	struct xmonPullTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonPullTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonPullTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonPullTable_id = thedata->xmonPullTable_id;
		StorageNew->xmonPullIndex = thedata->xmonPullIndex;
		StorageNew->xmonPullRole = thedata->xmonPullRole;
		if (!(StorageNew->xmonPullName = malloc(thedata->xmonPullNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPullName, thedata->xmonPullName, thedata->xmonPullNameLen);
		StorageNew->xmonPullNameLen = thedata->xmonPullNameLen;
		StorageNew->xmonPullName[StorageNew->xmonPullNameLen] = 0;
		StorageNew->xmonPullAddrType = thedata->xmonPullAddrType;
		if (!(StorageNew->xmonPullAddr = malloc(thedata->xmonPullAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPullAddr, thedata->xmonPullAddr, thedata->xmonPullAddrLen);
		StorageNew->xmonPullAddrLen = thedata->xmonPullAddrLen;
		StorageNew->xmonPullAddr[StorageNew->xmonPullAddrLen] = 0;
		StorageNew->xmonPullConnInterval = thedata->xmonPullConnInterval;
		StorageNew->xmonPullConnAttempts = thedata->xmonPullConnAttempts;
		if (!(StorageNew->xmonPullProfile = malloc(thedata->xmonPullProfileLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPullProfile, thedata->xmonPullProfile, thedata->xmonPullProfileLen);
		StorageNew->xmonPullProfileLen = thedata->xmonPullProfileLen;
		StorageNew->xmonPullProfile[StorageNew->xmonPullProfileLen] = 0;
		StorageNew->xmonPullAdminState = thedata->xmonPullAdminState;
		StorageNew->xmonPullOpState = thedata->xmonPullOpState;
		if (!(StorageNew->xmonPullProcStatus = malloc(thedata->xmonPullProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonPullProcStatus, thedata->xmonPullProcStatus, thedata->xmonPullProcStatusLen);
		StorageNew->xmonPullProcStatusLen = thedata->xmonPullProcStatusLen;
		StorageNew->xmonPullProcStatus[StorageNew->xmonPullProcStatusLen] = 0;
		StorageNew->xmonPullUsageState = thedata->xmonPullUsageState;
		StorageNew->xmonPullConnState = thedata->xmonPullConnState;
		StorageNew->xmonPullStorageType = thedata->xmonPullStorageType;
		StorageNew->xmonPullRowStatus = thedata->xmonPullRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonPullTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonPullTable_destroy(struct xmonPullTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonPullTable_destroy(struct xmonPullTable_data **thedata)
{
	struct xmonPullTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonPullTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonPullName);
		StorageDel->xmonPullNameLen = 0;
		SNMP_FREE(StorageDel->xmonPullAddr);
		StorageDel->xmonPullAddrLen = 0;
		SNMP_FREE(StorageDel->xmonPullProfile);
		StorageDel->xmonPullProfileLen = 0;
		SNMP_FREE(StorageDel->xmonPullProcStatus);
		StorageDel->xmonPullProcStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonPullTable_add(struct xmonPullTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonPullTable table data set.
 *
 * Adds a table row structure to the xmonPullTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonPullTable_add(struct xmonPullTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonPullTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonPullIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonPullIndex, sizeof(thedata->xmonPullIndex));
		header_complex_add_data(&xmonPullTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonPullTable_del(struct xmonPullTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonPullTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonPullTable_del(struct xmonPullTable_data *thedata)
{
	struct xmonPullTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonPullTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonPullTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonPullTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonPullTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonPullTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonPullTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonPullTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonPullTable_data *StorageTmp = xmonPullTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonPullTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonPullIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullRole, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPullName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPullName, &StorageTmp->xmonPullNameLen);
	if (StorageTmp->xmonPullName == NULL) {
		config_perror("invalid specification for xmonPullName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullAddrType, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPullAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPullAddr, &StorageTmp->xmonPullAddrLen);
	if (StorageTmp->xmonPullAddr == NULL) {
		config_perror("invalid specification for xmonPullAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullConnInterval, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonPullConnAttempts, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPullProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPullProfile, &StorageTmp->xmonPullProfileLen);
	if (StorageTmp->xmonPullProfile == NULL) {
		config_perror("invalid specification for xmonPullProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullOpState, &tmpsize);
	SNMP_FREE(StorageTmp->xmonPullProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonPullProcStatus, &StorageTmp->xmonPullProcStatusLen);
	if (StorageTmp->xmonPullProcStatus == NULL) {
		config_perror("invalid specification for xmonPullProcStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullConnState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullStorageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonPullRowStatus, &tmpsize);
	xmonPullTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonPullTable(): store configuraiton file for xmonPullTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonPullTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonPullTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonPullTable: storing data...  "));
	refresh_xmonPullTable(1);
	(void) tmpsize;
	for (hcindex = xmonPullTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonPullTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (StorageTmp->xmonPullStorageType == ST_NONVOLATILE) {
			memset(line, 0, sizeof(line));
			strcat(line, "xmonPullTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonPullIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullRole, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPullName, &StorageTmp->xmonPullNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullAddrType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPullAddr, &StorageTmp->xmonPullAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullConnInterval, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonPullConnAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPullProfile, &StorageTmp->xmonPullProfileLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullOpState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonPullProcStatus, &StorageTmp->xmonPullProcStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullConnState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullStorageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonPullRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonUploadTable_data *xmonUploadTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonUploadTable table.
 *
 * Creates a new xmonUploadTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonUploadTable_data *
xmonUploadTable_create(void)
{
	struct xmonUploadTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonUploadTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonUploadTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->xmonUploadSpec = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonUploadSpecLen = 0;
		StorageNew->xmonUploadSpec[StorageNew->xmonUploadSpecLen] = 0;
		if ((StorageNew->xmonUploadUsername = (uint8_t *) strdup("openss7")) == NULL)
			goto nomem;
		StorageNew->xmonUploadUsernameLen = strlen("openss7");
		if ((StorageNew->xmonUploadPassword = (uint8_t *) strdup("openss7")) == NULL)
			goto nomem;
		StorageNew->xmonUploadPasswordLen = strlen("openss7");
		StorageNew->xmonUploadPeriod = 90000;
		StorageNew->xmonUploadStartTime = 0;
		StorageNew->xmonUploadStopTime = 0;
		if (memdup((u_char **) &StorageNew->xmonUploadIntervalsOfDay, (u_char *) "\x00\x00\x17\x3B", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonUploadIntervalsOfDayLen = 4;
		if (memdup((u_char **) &StorageNew->xmonUploadWeekMask, (u_char *) "\x7F\x01\x00\x00\x17\x3B", 6) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonUploadWeekMaskLen = 6;
		StorageNew->xmonUploadOnRotation = 0;
		StorageNew->xmonUploadSelection = 0;
		StorageNew->xmonUploadAdminState = XMONUPLOADADMINSTATE_UNLOCKED;
		StorageNew->xmonUploadUsageState = 0;
		if (memdup((u_char **) &StorageNew->xmonUploadProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonUploadProcStatusLen = 1;
		StorageNew->xmonUploadStorageType = ST_NONVOLATILE;
		StorageNew->xmonUploadRowStatus = 0;
		StorageNew->xmonUploadRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonUploadTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonUploadTable_data *xmonUploadTable_duplicate(struct xmonUploadTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonUploadTable_data *
xmonUploadTable_duplicate(struct xmonUploadTable_data *thedata)
{
	struct xmonUploadTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonUploadTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonUploadTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonUploadTable_id = thedata->xmonUploadTable_id;
		StorageNew->xmonUploadIndex = thedata->xmonUploadIndex;
		if (!(StorageNew->xmonUploadSpec = malloc(thedata->xmonUploadSpecLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonUploadSpec, thedata->xmonUploadSpec, thedata->xmonUploadSpecLen);
		StorageNew->xmonUploadSpecLen = thedata->xmonUploadSpecLen;
		StorageNew->xmonUploadSpec[StorageNew->xmonUploadSpecLen] = 0;
		if (!(StorageNew->xmonUploadUsername = malloc(thedata->xmonUploadUsernameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonUploadUsername, thedata->xmonUploadUsername, thedata->xmonUploadUsernameLen);
		StorageNew->xmonUploadUsernameLen = thedata->xmonUploadUsernameLen;
		StorageNew->xmonUploadUsername[StorageNew->xmonUploadUsernameLen] = 0;
		if (!(StorageNew->xmonUploadPassword = malloc(thedata->xmonUploadPasswordLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonUploadPassword, thedata->xmonUploadPassword, thedata->xmonUploadPasswordLen);
		StorageNew->xmonUploadPasswordLen = thedata->xmonUploadPasswordLen;
		StorageNew->xmonUploadPassword[StorageNew->xmonUploadPasswordLen] = 0;
		StorageNew->xmonUploadPeriod = thedata->xmonUploadPeriod;
		StorageNew->xmonUploadStartTime = thedata->xmonUploadStartTime;
		StorageNew->xmonUploadStopTime = thedata->xmonUploadStopTime;
		if (!(StorageNew->xmonUploadIntervalsOfDay = malloc(thedata->xmonUploadIntervalsOfDayLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonUploadIntervalsOfDay, thedata->xmonUploadIntervalsOfDay, thedata->xmonUploadIntervalsOfDayLen);
		StorageNew->xmonUploadIntervalsOfDayLen = thedata->xmonUploadIntervalsOfDayLen;
		StorageNew->xmonUploadIntervalsOfDay[StorageNew->xmonUploadIntervalsOfDayLen] = 0;
		if (!(StorageNew->xmonUploadWeekMask = malloc(thedata->xmonUploadWeekMaskLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonUploadWeekMask, thedata->xmonUploadWeekMask, thedata->xmonUploadWeekMaskLen);
		StorageNew->xmonUploadWeekMaskLen = thedata->xmonUploadWeekMaskLen;
		StorageNew->xmonUploadWeekMask[StorageNew->xmonUploadWeekMaskLen] = 0;
		StorageNew->xmonUploadOnRotation = thedata->xmonUploadOnRotation;
		StorageNew->xmonUploadSelection = thedata->xmonUploadSelection;
		StorageNew->xmonUploadAdminState = thedata->xmonUploadAdminState;
		StorageNew->xmonUploadUsageState = thedata->xmonUploadUsageState;
		if (!(StorageNew->xmonUploadProcStatus = malloc(thedata->xmonUploadProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonUploadProcStatus, thedata->xmonUploadProcStatus, thedata->xmonUploadProcStatusLen);
		StorageNew->xmonUploadProcStatusLen = thedata->xmonUploadProcStatusLen;
		StorageNew->xmonUploadProcStatus[StorageNew->xmonUploadProcStatusLen] = 0;
		StorageNew->xmonUploadStorageType = thedata->xmonUploadStorageType;
		StorageNew->xmonUploadRowStatus = thedata->xmonUploadRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonUploadTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonUploadTable_destroy(struct xmonUploadTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonUploadTable_destroy(struct xmonUploadTable_data **thedata)
{
	struct xmonUploadTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonUploadTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonUploadSpec);
		StorageDel->xmonUploadSpecLen = 0;
		SNMP_FREE(StorageDel->xmonUploadUsername);
		StorageDel->xmonUploadUsernameLen = 0;
		SNMP_FREE(StorageDel->xmonUploadPassword);
		StorageDel->xmonUploadPasswordLen = 0;
		SNMP_FREE(StorageDel->xmonUploadIntervalsOfDay);
		StorageDel->xmonUploadIntervalsOfDayLen = 0;
		SNMP_FREE(StorageDel->xmonUploadWeekMask);
		StorageDel->xmonUploadWeekMaskLen = 0;
		SNMP_FREE(StorageDel->xmonUploadProcStatus);
		StorageDel->xmonUploadProcStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonUploadTable_add(struct xmonUploadTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonUploadTable table data set.
 *
 * Adds a table row structure to the xmonUploadTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonUploadTable_add(struct xmonUploadTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonUploadTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonUploadIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonUploadIndex, sizeof(thedata->xmonUploadIndex));
		header_complex_add_data(&xmonUploadTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonUploadTable_del(struct xmonUploadTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonUploadTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonUploadTable_del(struct xmonUploadTable_data *thedata)
{
	struct xmonUploadTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonUploadTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonUploadTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonUploadTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonUploadTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonUploadTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonUploadTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonUploadTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonUploadTable_data *StorageTmp = xmonUploadTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonUploadTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonUploadIndex, &tmpsize);
	SNMP_FREE(StorageTmp->xmonUploadSpec);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonUploadSpec, &StorageTmp->xmonUploadSpecLen);
	if (StorageTmp->xmonUploadSpec == NULL) {
		config_perror("invalid specification for xmonUploadSpec");
		return;
	}
	SNMP_FREE(StorageTmp->xmonUploadUsername);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonUploadUsername, &StorageTmp->xmonUploadUsernameLen);
	if (StorageTmp->xmonUploadUsername == NULL) {
		config_perror("invalid specification for xmonUploadUsername");
		return;
	}
	SNMP_FREE(StorageTmp->xmonUploadPassword);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonUploadPassword, &StorageTmp->xmonUploadPasswordLen);
	if (StorageTmp->xmonUploadPassword == NULL) {
		config_perror("invalid specification for xmonUploadPassword");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonUploadPeriod, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonUploadStartTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonUploadStopTime, &tmpsize);
	SNMP_FREE(StorageTmp->xmonUploadIntervalsOfDay);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonUploadIntervalsOfDay, &StorageTmp->xmonUploadIntervalsOfDayLen);
	if (StorageTmp->xmonUploadIntervalsOfDay == NULL) {
		config_perror("invalid specification for xmonUploadIntervalsOfDay");
		return;
	}
	SNMP_FREE(StorageTmp->xmonUploadWeekMask);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonUploadWeekMask, &StorageTmp->xmonUploadWeekMaskLen);
	if (StorageTmp->xmonUploadWeekMask == NULL) {
		config_perror("invalid specification for xmonUploadWeekMask");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonUploadOnRotation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonUploadSelection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonUploadAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonUploadUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->xmonUploadProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonUploadProcStatus, &StorageTmp->xmonUploadProcStatusLen);
	if (StorageTmp->xmonUploadProcStatus == NULL) {
		config_perror("invalid specification for xmonUploadProcStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonUploadStorageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonUploadRowStatus, &tmpsize);
	xmonUploadTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonUploadTable(): store configuraiton file for xmonUploadTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonUploadTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonUploadTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonUploadTable: storing data...  "));
	refresh_xmonUploadTable(1);
	(void) tmpsize;
	for (hcindex = xmonUploadTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonUploadTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (StorageTmp->xmonUploadStorageType == ST_NONVOLATILE) {
			memset(line, 0, sizeof(line));
			strcat(line, "xmonUploadTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonUploadIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonUploadSpec, &StorageTmp->xmonUploadSpecLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonUploadUsername, &StorageTmp->xmonUploadUsernameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonUploadPassword, &StorageTmp->xmonUploadPasswordLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonUploadPeriod, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonUploadStartTime, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonUploadStopTime, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonUploadIntervalsOfDay, &StorageTmp->xmonUploadIntervalsOfDayLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonUploadWeekMask, &StorageTmp->xmonUploadWeekMaskLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonUploadOnRotation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonUploadSelection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonUploadAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonUploadUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonUploadProcStatus, &StorageTmp->xmonUploadProcStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonUploadStorageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonUploadRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonDownloadTable_data *xmonDownloadTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonDownloadTable table.
 *
 * Creates a new xmonDownloadTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonDownloadTable_data *
xmonDownloadTable_create(void)
{
	struct xmonDownloadTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonDownloadTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonDownloadTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->xmonDownloadSpec = malloc(1)) == NULL)
			goto nomem;
		StorageNew->xmonDownloadSpecLen = 0;
		StorageNew->xmonDownloadSpec[StorageNew->xmonDownloadSpecLen] = 0;
		if ((StorageNew->xmonDownloadUsername = (uint8_t *) strdup("unexicon")) == NULL)
			goto nomem;
		StorageNew->xmonDownloadUsernameLen = strlen("unexicon");
		if ((StorageNew->xmonDownloadPassword = (uint8_t *) strdup("unexicon")) == NULL)
			goto nomem;
		StorageNew->xmonDownloadPasswordLen = strlen("unexicon");
		StorageNew->xmonDownloadPeriod = 90000;
		StorageNew->xmonDownloadStartTime = 0;
		StorageNew->xmonDownloadStopTime = 0;
		if (memdup((u_char **) &StorageNew->xmonDownloadIntervalsOfDay, (u_char *) "\x00\x00\x17\x3B", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonDownloadIntervalsOfDayLen = 4;
		if (memdup((u_char **) &StorageNew->xmonDownloadWeekMask, (u_char *) "\x7F\x01\x00\x00\x17\x3B", 6) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonDownloadWeekMaskLen = 6;
		StorageNew->xmonDownloadOnRotation = 0;
		StorageNew->xmonDownloadSelection = 0;
		StorageNew->xmonDownloadAdminState = XMONDOWNLOADADMINSTATE_UNLOCKED;
		StorageNew->xmonDownloadUsageState = 0;
		if (memdup((u_char **) &StorageNew->xmonDownloadProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->xmonDownloadProcStatusLen = 1;
		StorageNew->xmonDownloadStorageType = ST_NONVOLATILE;
		StorageNew->xmonDownloadRowStatus = 0;
		StorageNew->xmonDownloadRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonDownloadTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonDownloadTable_data *xmonDownloadTable_duplicate(struct xmonDownloadTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonDownloadTable_data *
xmonDownloadTable_duplicate(struct xmonDownloadTable_data *thedata)
{
	struct xmonDownloadTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonDownloadTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonDownloadTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonDownloadTable_id = thedata->xmonDownloadTable_id;
		StorageNew->xmonDownloadIndex = thedata->xmonDownloadIndex;
		if (!(StorageNew->xmonDownloadSpec = malloc(thedata->xmonDownloadSpecLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonDownloadSpec, thedata->xmonDownloadSpec, thedata->xmonDownloadSpecLen);
		StorageNew->xmonDownloadSpecLen = thedata->xmonDownloadSpecLen;
		StorageNew->xmonDownloadSpec[StorageNew->xmonDownloadSpecLen] = 0;
		if (!(StorageNew->xmonDownloadUsername = malloc(thedata->xmonDownloadUsernameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonDownloadUsername, thedata->xmonDownloadUsername, thedata->xmonDownloadUsernameLen);
		StorageNew->xmonDownloadUsernameLen = thedata->xmonDownloadUsernameLen;
		StorageNew->xmonDownloadUsername[StorageNew->xmonDownloadUsernameLen] = 0;
		if (!(StorageNew->xmonDownloadPassword = malloc(thedata->xmonDownloadPasswordLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonDownloadPassword, thedata->xmonDownloadPassword, thedata->xmonDownloadPasswordLen);
		StorageNew->xmonDownloadPasswordLen = thedata->xmonDownloadPasswordLen;
		StorageNew->xmonDownloadPassword[StorageNew->xmonDownloadPasswordLen] = 0;
		StorageNew->xmonDownloadPeriod = thedata->xmonDownloadPeriod;
		StorageNew->xmonDownloadStartTime = thedata->xmonDownloadStartTime;
		StorageNew->xmonDownloadStopTime = thedata->xmonDownloadStopTime;
		if (!(StorageNew->xmonDownloadIntervalsOfDay = malloc(thedata->xmonDownloadIntervalsOfDayLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonDownloadIntervalsOfDay, thedata->xmonDownloadIntervalsOfDay, thedata->xmonDownloadIntervalsOfDayLen);
		StorageNew->xmonDownloadIntervalsOfDayLen = thedata->xmonDownloadIntervalsOfDayLen;
		StorageNew->xmonDownloadIntervalsOfDay[StorageNew->xmonDownloadIntervalsOfDayLen] = 0;
		if (!(StorageNew->xmonDownloadWeekMask = malloc(thedata->xmonDownloadWeekMaskLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonDownloadWeekMask, thedata->xmonDownloadWeekMask, thedata->xmonDownloadWeekMaskLen);
		StorageNew->xmonDownloadWeekMaskLen = thedata->xmonDownloadWeekMaskLen;
		StorageNew->xmonDownloadWeekMask[StorageNew->xmonDownloadWeekMaskLen] = 0;
		StorageNew->xmonDownloadOnRotation = thedata->xmonDownloadOnRotation;
		StorageNew->xmonDownloadSelection = thedata->xmonDownloadSelection;
		StorageNew->xmonDownloadAdminState = thedata->xmonDownloadAdminState;
		StorageNew->xmonDownloadUsageState = thedata->xmonDownloadUsageState;
		if (!(StorageNew->xmonDownloadProcStatus = malloc(thedata->xmonDownloadProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonDownloadProcStatus, thedata->xmonDownloadProcStatus, thedata->xmonDownloadProcStatusLen);
		StorageNew->xmonDownloadProcStatusLen = thedata->xmonDownloadProcStatusLen;
		StorageNew->xmonDownloadProcStatus[StorageNew->xmonDownloadProcStatusLen] = 0;
		StorageNew->xmonDownloadStorageType = thedata->xmonDownloadStorageType;
		StorageNew->xmonDownloadRowStatus = thedata->xmonDownloadRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonDownloadTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonDownloadTable_destroy(struct xmonDownloadTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonDownloadTable_destroy(struct xmonDownloadTable_data **thedata)
{
	struct xmonDownloadTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonDownloadTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonDownloadSpec);
		StorageDel->xmonDownloadSpecLen = 0;
		SNMP_FREE(StorageDel->xmonDownloadUsername);
		StorageDel->xmonDownloadUsernameLen = 0;
		SNMP_FREE(StorageDel->xmonDownloadPassword);
		StorageDel->xmonDownloadPasswordLen = 0;
		SNMP_FREE(StorageDel->xmonDownloadIntervalsOfDay);
		StorageDel->xmonDownloadIntervalsOfDayLen = 0;
		SNMP_FREE(StorageDel->xmonDownloadWeekMask);
		StorageDel->xmonDownloadWeekMaskLen = 0;
		SNMP_FREE(StorageDel->xmonDownloadProcStatus);
		StorageDel->xmonDownloadProcStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonDownloadTable_add(struct xmonDownloadTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonDownloadTable table data set.
 *
 * Adds a table row structure to the xmonDownloadTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonDownloadTable_add(struct xmonDownloadTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonDownloadTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonDownloadIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->xmonDownloadIndex, sizeof(thedata->xmonDownloadIndex));
		header_complex_add_data(&xmonDownloadTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonDownloadTable_del(struct xmonDownloadTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonDownloadTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonDownloadTable_del(struct xmonDownloadTable_data *thedata)
{
	struct xmonDownloadTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonDownloadTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonDownloadTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonDownloadTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonDownloadTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonDownloadTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonDownloadTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonDownloadTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonDownloadTable_data *StorageTmp = xmonDownloadTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonDownloadTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonDownloadIndex, &tmpsize);
	SNMP_FREE(StorageTmp->xmonDownloadSpec);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonDownloadSpec, &StorageTmp->xmonDownloadSpecLen);
	if (StorageTmp->xmonDownloadSpec == NULL) {
		config_perror("invalid specification for xmonDownloadSpec");
		return;
	}
	SNMP_FREE(StorageTmp->xmonDownloadUsername);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonDownloadUsername, &StorageTmp->xmonDownloadUsernameLen);
	if (StorageTmp->xmonDownloadUsername == NULL) {
		config_perror("invalid specification for xmonDownloadUsername");
		return;
	}
	SNMP_FREE(StorageTmp->xmonDownloadPassword);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonDownloadPassword, &StorageTmp->xmonDownloadPasswordLen);
	if (StorageTmp->xmonDownloadPassword == NULL) {
		config_perror("invalid specification for xmonDownloadPassword");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonDownloadPeriod, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonDownloadStartTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->xmonDownloadStopTime, &tmpsize);
	SNMP_FREE(StorageTmp->xmonDownloadIntervalsOfDay);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonDownloadIntervalsOfDay, &StorageTmp->xmonDownloadIntervalsOfDayLen);
	if (StorageTmp->xmonDownloadIntervalsOfDay == NULL) {
		config_perror("invalid specification for xmonDownloadIntervalsOfDay");
		return;
	}
	SNMP_FREE(StorageTmp->xmonDownloadWeekMask);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonDownloadWeekMask, &StorageTmp->xmonDownloadWeekMaskLen);
	if (StorageTmp->xmonDownloadWeekMask == NULL) {
		config_perror("invalid specification for xmonDownloadWeekMask");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonDownloadOnRotation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonDownloadSelection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonDownloadAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonDownloadUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->xmonDownloadProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonDownloadProcStatus, &StorageTmp->xmonDownloadProcStatusLen);
	if (StorageTmp->xmonDownloadProcStatus == NULL) {
		config_perror("invalid specification for xmonDownloadProcStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonDownloadStorageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonDownloadRowStatus, &tmpsize);
	xmonDownloadTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonDownloadTable(): store configuraiton file for xmonDownloadTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonDownloadTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonDownloadTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonDownloadTable: storing data...  "));
	refresh_xmonDownloadTable(1);
	(void) tmpsize;
	for (hcindex = xmonDownloadTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonDownloadTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (StorageTmp->xmonDownloadStorageType == ST_NONVOLATILE) {
			memset(line, 0, sizeof(line));
			strcat(line, "xmonDownloadTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonDownloadIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonDownloadSpec, &StorageTmp->xmonDownloadSpecLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonDownloadUsername, &StorageTmp->xmonDownloadUsernameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonDownloadPassword, &StorageTmp->xmonDownloadPasswordLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonDownloadPeriod, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonDownloadStartTime, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->xmonDownloadStopTime, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonDownloadIntervalsOfDay, &StorageTmp->xmonDownloadIntervalsOfDayLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonDownloadWeekMask, &StorageTmp->xmonDownloadWeekMaskLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonDownloadOnRotation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonDownloadSelection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonDownloadAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonDownloadUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonDownloadProcStatus, &StorageTmp->xmonDownloadProcStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonDownloadStorageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonDownloadRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct xmonSctpTable_data *xmonSctpTable_create(void)
 * @brief create a fresh data structure representing a new row in the xmonSctpTable table.
 *
 * Creates a new xmonSctpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct xmonSctpTable_data *
xmonSctpTable_create(void)
{
	struct xmonSctpTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSctpTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSctpTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->xmonSctpNoDelay = 0;
		StorageNew->xmonSctpMaxseg = 0;
		StorageNew->xmonSctpHeartbeatItvl = 0;
		StorageNew->xmonSctpHeartbeat = 0;
		StorageNew->xmonSctpRtoInitial = 0;
		StorageNew->xmonSctpRtoMin = 0;
		StorageNew->xmonSctpRtoMax = 0;
		StorageNew->xmonSctpPathMaxRetrans = 0;
		StorageNew->xmonSctpCookieLife = 0;
		StorageNew->xmonSctpCookieInc = 0;
		StorageNew->xmonSctpMaxInitRetries = 0;
		StorageNew->xmonSctpMaxBurst = 0;
		StorageNew->xmonSctpAssocMaxRetrans = 20;
		StorageNew->xmonSctpSackDelay = 20;
		StorageNew->xmonSctpLifetime = 0;
		StorageNew->xmonSctpRowStatus = 0;
		StorageNew->xmonSctpRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	xmonSctpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct xmonSctpTable_data *xmonSctpTable_duplicate(struct xmonSctpTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct xmonSctpTable_data *
xmonSctpTable_duplicate(struct xmonSctpTable_data *thedata)
{
	struct xmonSctpTable_data *StorageNew = SNMP_MALLOC_STRUCT(xmonSctpTable_data);

	DEBUGMSGTL(("xmonMIB", "xmonSctpTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->xmonSctpTable_id = thedata->xmonSctpTable_id;
		if (!(StorageNew->xmonSctpProfileName = malloc(thedata->xmonSctpProfileNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->xmonSctpProfileName, thedata->xmonSctpProfileName, thedata->xmonSctpProfileNameLen);
		StorageNew->xmonSctpProfileNameLen = thedata->xmonSctpProfileNameLen;
		StorageNew->xmonSctpProfileName[StorageNew->xmonSctpProfileNameLen] = 0;
		StorageNew->xmonSctpNoDelay = thedata->xmonSctpNoDelay;
		StorageNew->xmonSctpMaxseg = thedata->xmonSctpMaxseg;
		StorageNew->xmonSctpHeartbeatItvl = thedata->xmonSctpHeartbeatItvl;
		StorageNew->xmonSctpHeartbeat = thedata->xmonSctpHeartbeat;
		StorageNew->xmonSctpRtoInitial = thedata->xmonSctpRtoInitial;
		StorageNew->xmonSctpRtoMin = thedata->xmonSctpRtoMin;
		StorageNew->xmonSctpRtoMax = thedata->xmonSctpRtoMax;
		StorageNew->xmonSctpPathMaxRetrans = thedata->xmonSctpPathMaxRetrans;
		StorageNew->xmonSctpCookieLife = thedata->xmonSctpCookieLife;
		StorageNew->xmonSctpCookieInc = thedata->xmonSctpCookieInc;
		StorageNew->xmonSctpMaxInitRetries = thedata->xmonSctpMaxInitRetries;
		StorageNew->xmonSctpMaxBurst = thedata->xmonSctpMaxBurst;
		StorageNew->xmonSctpAssocMaxRetrans = thedata->xmonSctpAssocMaxRetrans;
		StorageNew->xmonSctpSackDelay = thedata->xmonSctpSackDelay;
		StorageNew->xmonSctpLifetime = thedata->xmonSctpLifetime;
		StorageNew->xmonSctpRowStatus = thedata->xmonSctpRowStatus;
	}
      done:
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	xmonSctpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int xmonSctpTable_destroy(struct xmonSctpTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
xmonSctpTable_destroy(struct xmonSctpTable_data **thedata)
{
	struct xmonSctpTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSctpTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->xmonSctpProfileName);
		StorageDel->xmonSctpProfileNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSctpTable_add(struct xmonSctpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the xmonSctpTable table data set.
 *
 * Adds a table row structure to the xmonSctpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
xmonSctpTable_add(struct xmonSctpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("xmonMIB", "xmonSctpTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* xmonSctpProfileName */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->xmonSctpProfileName, thedata->xmonSctpProfileNameLen);
		header_complex_add_data(&xmonSctpTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("xmonMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int xmonSctpTable_del(struct xmonSctpTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the xmonSctpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
xmonSctpTable_del(struct xmonSctpTable_data *thedata)
{
	struct xmonSctpTable_data *StorageDel;

	DEBUGMSGTL(("xmonMIB", "xmonSctpTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(xmonSctpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&xmonSctpTableStorage, hciptr);
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_xmonSctpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for xmonSctpTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case xmonSctpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_xmonSctpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct xmonSctpTable_data *StorageTmp = xmonSctpTable_create();

	DEBUGMSGTL(("xmonMIB", "parse_xmonSctpTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->xmonSctpProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->xmonSctpProfileName, &StorageTmp->xmonSctpProfileNameLen);
	if (StorageTmp->xmonSctpProfileName == NULL) {
		config_perror("invalid specification for xmonSctpProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->xmonSctpLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->xmonSctpRowStatus, &tmpsize);
	xmonSctpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/*
 * store_xmonSctpTable(): store configuraiton file for xmonSctpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_xmonSctpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct xmonSctpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("xmonMIB", "store_xmonSctpTable: storing data...  "));
	refresh_xmonSctpTable(1);
	(void) tmpsize;
	for (hcindex = xmonSctpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct xmonSctpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "xmonSctpTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->xmonSctpProfileName, &StorageTmp->xmonSctpProfileNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSctpNoDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpMaxseg, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpHeartbeatItvl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSctpHeartbeat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpRtoInitial, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpRtoMax, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpPathMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpCookieLife, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpCookieInc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpMaxInitRetries, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpMaxBurst, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpAssocMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpSackDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->xmonSctpLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->xmonSctpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int activate_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonPushTable_row(struct xmonPushTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonPushTable_row(struct xmonPushTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonPushTable_row(struct xmonPushTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonPushTable_row(struct xmonPushTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonPullTable_row(struct xmonPullTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonPullTable_row(struct xmonPullTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonPullTable_row(struct xmonPullTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonPullTable_row(struct xmonPullTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int check_xmonSourceTable_row(struct xmonSourceTable_data *StorageTmp, struct xmonSourceTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonSourceTable_row(struct xmonSourceTable_data *StorageTmp, struct xmonSourceTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonSourceTable_row(struct xmonSourceTable_data *StorageTmp, struct xmonSourceTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonSourceTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonSourceTable_row(struct xmonSourceTable_data *StorageTmp, struct xmonSourceTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonSourceTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonSourceTable_row(struct xmonSourceTable_data *StorageTmp, struct xmonSourceTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonSourceTable_row(struct xmonSourceTable_data *StorageTmp, struct xmonSourceTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonSourceTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonSourceTable_row(struct xmonSourceTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonSourceTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonSourceTable_data *
refresh_xmonSourceTable_row(struct xmonSourceTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonSourceTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonSourceTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonSourceTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonSourceTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonSourceTable(int force)
{
	if (!force && xmonSourceTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonSourceTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonSourceTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonSourceTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonSourceTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonSourceTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonSourceTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonSourceTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonSourceTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonSourceTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONSOURCETYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceType);
		rval = (u_char *) &StorageTmp->xmonSourceType;
		break;
	case (u_char) XMONSOURCENAME:	/* ReadWrite */
		*write_method = write_xmonSourceName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonSourceNameLen;
		rval = (u_char *) StorageTmp->xmonSourceName;
		break;
	case (u_char) XMONSOURCEIFINDEX:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceIfIndex);
		rval = (u_char *) &StorageTmp->xmonSourceIfIndex;
		break;
	case (u_char) XMONSOURCEADMINSTATE:	/* ReadWrite */
		*write_method = write_xmonSourceAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceAdminState);
		rval = (u_char *) &StorageTmp->xmonSourceAdminState;
		break;
	case (u_char) XMONSOURCEOPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceOpState);
		rval = (u_char *) &StorageTmp->xmonSourceOpState;
		break;
	case (u_char) XMONSOURCEAVAILSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonSourceAvailStatusLen;
		rval = (u_char *) StorageTmp->xmonSourceAvailStatus;
		break;
	case (u_char) XMONSOURCEPROCSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonSourceProcStatusLen;
		rval = (u_char *) StorageTmp->xmonSourceProcStatus;
		break;
	case (u_char) XMONSOURCEUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceUsageState);
		rval = (u_char *) &StorageTmp->xmonSourceUsageState;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonSourceStatsTable_row(struct xmonSourceStatsTable_data *StorageTmp, struct xmonSourceStatsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonSourceStatsTable_row(struct xmonSourceStatsTable_data *StorageTmp, struct xmonSourceStatsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonSourceStatsTable_row(struct xmonSourceStatsTable_data *StorageTmp, struct xmonSourceStatsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonSourceStatsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonSourceStatsTable_row(struct xmonSourceStatsTable_data *StorageTmp, struct xmonSourceStatsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonSourceStatsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonSourceStatsTable_row(struct xmonSourceStatsTable_data *StorageTmp, struct xmonSourceStatsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonSourceStatsTable_row(struct xmonSourceStatsTable_data *StorageTmp, struct xmonSourceStatsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonSourceStatsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonSourceStatsTable_row(struct xmonSourceStatsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonSourceStatsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonSourceStatsTable_data *
refresh_xmonSourceStatsTable_row(struct xmonSourceStatsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonSourceStatsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonSourceStatsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonSourceStatsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonSourceStatsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonSourceStatsTable(int force)
{
	if (!force && xmonSourceStatsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonSourceStatsTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonSourceStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonSourceStatsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonSourceStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonSourceStatsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonSourceStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonSourceStatsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonSourceStatsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonSourceStatsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONSOURCESTATSTIMEELAPSED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceStatsTimeElapsed);
		rval = (u_char *) &StorageTmp->xmonSourceStatsTimeElapsed;
		break;
	case (u_char) XMONSOURCESTATSTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceStatsTimeStamp);
		rval = (u_char *) &StorageTmp->xmonSourceStatsTimeStamp;
		break;
	case (u_char) XMONSOURCESTATSSTARTTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceStatsStartTime);
		rval = (u_char *) &StorageTmp->xmonSourceStatsStartTime;
		break;
	case (u_char) XMONSOURCESTATSENDTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceStatsEndTime);
		rval = (u_char *) &StorageTmp->xmonSourceStatsEndTime;
		break;
	case (u_char) XMONSOURCESTATSIFRECV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceStatsIfRecv);
		rval = (u_char *) &StorageTmp->xmonSourceStatsIfRecv;
		break;
	case (u_char) XMONSOURCESTATSIFDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceStatsIfDrop);
		rval = (u_char *) &StorageTmp->xmonSourceStatsIfDrop;
		break;
	case (u_char) XMONSOURCESTATSFILTERACCEPT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceStatsFilterAccept);
		rval = (u_char *) &StorageTmp->xmonSourceStatsFilterAccept;
		break;
	case (u_char) XMONSOURCESTATSOSDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceStatsOsDrop);
		rval = (u_char *) &StorageTmp->xmonSourceStatsOsDrop;
		break;
	case (u_char) XMONSOURCESTATSUSERDELIV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceStatsUserDeliv);
		rval = (u_char *) &StorageTmp->xmonSourceStatsUserDeliv;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonSourceHistTable_row(struct xmonSourceHistTable_data *StorageTmp, struct xmonSourceHistTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonSourceHistTable_row(struct xmonSourceHistTable_data *StorageTmp, struct xmonSourceHistTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonSourceHistTable_row(struct xmonSourceHistTable_data *StorageTmp, struct xmonSourceHistTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonSourceHistTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonSourceHistTable_row(struct xmonSourceHistTable_data *StorageTmp, struct xmonSourceHistTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonSourceHistTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonSourceHistTable_row(struct xmonSourceHistTable_data *StorageTmp, struct xmonSourceHistTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonSourceHistTable_row(struct xmonSourceHistTable_data *StorageTmp, struct xmonSourceHistTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonSourceHistTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonSourceHistTable_row(struct xmonSourceHistTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonSourceHistTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonSourceHistTable_data *
refresh_xmonSourceHistTable_row(struct xmonSourceHistTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonSourceHistTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonSourceHistTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonSourceHistTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonSourceHistTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonSourceHistTable(int force)
{
	if (!force && xmonSourceHistTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonSourceHistTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonSourceHistTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonSourceHistTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonSourceHistTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonSourceHistTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonSourceHistTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonSourceHistTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonSourceHistTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonSourceHistTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONSOURCEHISTIFRECV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceHistIfRecv);
		rval = (u_char *) &StorageTmp->xmonSourceHistIfRecv;
		break;
	case (u_char) XMONSOURCEHISTIFDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceHistIfDrop);
		rval = (u_char *) &StorageTmp->xmonSourceHistIfDrop;
		break;
	case (u_char) XMONSOURCEHISTFILTERACCEPT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceHistFilterAccept);
		rval = (u_char *) &StorageTmp->xmonSourceHistFilterAccept;
		break;
	case (u_char) XMONSOURCEHISTOSDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceHistOsDrop);
		rval = (u_char *) &StorageTmp->xmonSourceHistOsDrop;
		break;
	case (u_char) XMONSOURCEHISTUSERDELIV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceHistUserDeliv);
		rval = (u_char *) &StorageTmp->xmonSourceHistUserDeliv;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonSourceTotalTable_row(struct xmonSourceTotalTable_data *StorageTmp, struct xmonSourceTotalTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonSourceTotalTable_row(struct xmonSourceTotalTable_data *StorageTmp, struct xmonSourceTotalTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonSourceTotalTable_row(struct xmonSourceTotalTable_data *StorageTmp, struct xmonSourceTotalTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonSourceTotalTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonSourceTotalTable_row(struct xmonSourceTotalTable_data *StorageTmp, struct xmonSourceTotalTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonSourceTotalTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonSourceTotalTable_row(struct xmonSourceTotalTable_data *StorageTmp, struct xmonSourceTotalTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonSourceTotalTable_row(struct xmonSourceTotalTable_data *StorageTmp, struct xmonSourceTotalTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonSourceTotalTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonSourceTotalTable_row(struct xmonSourceTotalTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonSourceTotalTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonSourceTotalTable_data *
refresh_xmonSourceTotalTable_row(struct xmonSourceTotalTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonSourceTotalTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonSourceTotalTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonSourceTotalTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonSourceTotalTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonSourceTotalTable(int force)
{
	if (!force && xmonSourceTotalTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonSourceTotalTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonSourceTotalTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonSourceTotalTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonSourceTotalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonSourceTotalTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonSourceTotalTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonSourceTotalTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonSourceTotalTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonSourceTotalTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONSOURCETOTALVALIDINTERVALS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceTotalValidIntervals);
		rval = (u_char *) &StorageTmp->xmonSourceTotalValidIntervals;
		break;
	case (u_char) XMONSOURCETOTALIFRECV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceTotalIfRecv);
		rval = (u_char *) &StorageTmp->xmonSourceTotalIfRecv;
		break;
	case (u_char) XMONSOURCETOTALIFDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceTotalIfDrop);
		rval = (u_char *) &StorageTmp->xmonSourceTotalIfDrop;
		break;
	case (u_char) XMONSOURCETOTALFILTERACCEPT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceTotalFilterAccept);
		rval = (u_char *) &StorageTmp->xmonSourceTotalFilterAccept;
		break;
	case (u_char) XMONSOURCETOTALOSDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceTotalOsDrop);
		rval = (u_char *) &StorageTmp->xmonSourceTotalOsDrop;
		break;
	case (u_char) XMONSOURCETOTALUSERDELIV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSourceTotalUserDeliv);
		rval = (u_char *) &StorageTmp->xmonSourceTotalUserDeliv;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp, struct xmonInterfaceTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp, struct xmonInterfaceTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp, struct xmonInterfaceTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonInterfaceTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp, struct xmonInterfaceTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonInterfaceTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp, struct xmonInterfaceTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp, struct xmonInterfaceTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonInterfaceTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonInterfaceTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonInterfaceTable_data *
refresh_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonInterfaceTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonInterfaceTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonInterfaceTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonInterfaceTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonInterfaceTable(int force)
{
	if (!force && xmonInterfaceTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonInterfaceTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonInterfaceTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonInterfaceTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonInterfaceTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonInterfaceTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonInterfaceTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonInterfaceTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonInterfaceTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONINTERFACELINKTYPE:	/* Create */
		*write_method = write_xmonInterfaceLinkType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceLinkType);
		rval = (u_char *) &StorageTmp->xmonInterfaceLinkType;
		break;
	case (u_char) XMONINTERFACESNAPLEN:	/* Create */
		*write_method = write_xmonInterfaceSnapLen;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceSnapLen);
		rval = (u_char *) &StorageTmp->xmonInterfaceSnapLen;
		break;
	case (u_char) XMONINTERFACEPROMISCUOUS:	/* Create */
		*write_method = write_xmonInterfacePromiscuous;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfacePromiscuous);
		rval = (u_char *) &StorageTmp->xmonInterfacePromiscuous;
		break;
	case (u_char) XMONINTERFACEMONITOR:	/* Create */
		*write_method = write_xmonInterfaceMonitor;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceMonitor);
		rval = (u_char *) &StorageTmp->xmonInterfaceMonitor;
		break;
	case (u_char) XMONINTERFACEDIRECTION:	/* Create */
		*write_method = write_xmonInterfaceDirection;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceDirection);
		rval = (u_char *) &StorageTmp->xmonInterfaceDirection;
		break;
	case (u_char) XMONINTERFACEDESCRIPTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonInterfaceDescriptionLen;
		rval = (u_char *) StorageTmp->xmonInterfaceDescription;
		break;
	case (u_char) XMONINTERFACEPHYSADDR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonInterfacePhysAddrLen;
		rval = (u_char *) StorageTmp->xmonInterfacePhysAddr;
		break;
	case (u_char) XMONINTERFACESPEED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceSpeed);
		rval = (u_char *) &StorageTmp->xmonInterfaceSpeed;
		break;
	case (u_char) XMONINTERFACETSRES:	/* Create */
		*write_method = write_xmonInterfaceTsRes;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceTsRes);
		rval = (u_char *) &StorageTmp->xmonInterfaceTsRes;
		break;
	case (u_char) XMONINTERFACETZONE:	/* Create */
		*write_method = write_xmonInterfaceTzone;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceTzone);
		rval = (u_char *) &StorageTmp->xmonInterfaceTzone;
		break;
	case (u_char) XMONINTERFACEFILTERTYPE:	/* Create */
		*write_method = write_xmonInterfaceFilterType;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonInterfaceFilterTypeLen;
		rval = (u_char *) StorageTmp->xmonInterfaceFilterType;
		break;
	case (u_char) XMONINTERFACEFILTER:	/* Create */
		*write_method = write_xmonInterfaceFilter;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonInterfaceFilterLen;
		rval = (u_char *) StorageTmp->xmonInterfaceFilter;
		break;
	case (u_char) XMONINTERFACEFILTERBPF:	/* Create */
		*write_method = write_xmonInterfaceFilterBpf;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonInterfaceFilterBpfLen;
		rval = (u_char *) StorageTmp->xmonInterfaceFilterBpf;
		break;
	case (u_char) XMONINTERFACEFILTERSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceFilterStatus);
		rval = (u_char *) &StorageTmp->xmonInterfaceFilterStatus;
		break;
	case (u_char) XMONINTERFACEOS:	/* Create */
		*write_method = write_xmonInterfaceOs;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonInterfaceOsLen;
		rval = (u_char *) StorageTmp->xmonInterfaceOs;
		break;
	case (u_char) XMONINTERFACEFCSLEN:	/* Create */
		*write_method = write_xmonInterfaceFcsLen;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceFcsLen);
		rval = (u_char *) &StorageTmp->xmonInterfaceFcsLen;
		break;
	case (u_char) XMONINTERFACETSOFFSET:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceTsOffset);
		rval = (u_char *) &StorageTmp->xmonInterfaceTsOffset;
		break;
	case (u_char) XMONINTERFACESTORAGETYPE:	/* Create */
		*write_method = write_xmonInterfaceStorageType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceStorageType);
		rval = (u_char *) &StorageTmp->xmonInterfaceStorageType;
		break;
	case (u_char) XMONINTERFACEROWSTATUS:	/* Create */
		*write_method = write_xmonInterfaceRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonInterfaceRowStatus);
		rval = (u_char *) &StorageTmp->xmonInterfaceRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp, struct xmonRmonTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp, struct xmonRmonTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp, struct xmonRmonTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonRmonTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp, struct xmonRmonTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonRmonTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp, struct xmonRmonTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp, struct xmonRmonTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonRmonTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonRmonTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonRmonTable_data *
refresh_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonRmonTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonRmonTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonRmonTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonRmonTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonRmonTable(int force)
{
	if (!force && xmonRmonTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonRmonTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonRmonTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonRmonTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonRmonTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonRmonTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonRmonTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonRmonTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonRmonTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonRmonTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONRMONADDRTYPE:	/* Create */
		*write_method = write_xmonRmonAddrType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonRmonAddrType);
		rval = (u_char *) &StorageTmp->xmonRmonAddrType;
		break;
	case (u_char) XMONRMONADDR:	/* Create */
		*write_method = write_xmonRmonAddr;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonRmonAddrLen;
		rval = (u_char *) StorageTmp->xmonRmonAddr;
		break;
	case (u_char) XMONRMONSNMPVERSION:	/* Create */
		*write_method = write_xmonRmonSnmpVersion;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonRmonSnmpVersion);
		rval = (u_char *) &StorageTmp->xmonRmonSnmpVersion;
		break;
	case (u_char) XMONRMONCOMMUNITY:	/* Create */
		*write_method = write_xmonRmonCommunity;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonRmonCommunityLen;
		rval = (u_char *) StorageTmp->xmonRmonCommunity;
		break;
	case (u_char) XMONRMONUSERNAME:	/* Create */
		*write_method = write_xmonRmonUsername;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonRmonUsernameLen;
		rval = (u_char *) StorageTmp->xmonRmonUsername;
		break;
	case (u_char) XMONRMONPASSWORD:	/* Create */
		*write_method = write_xmonRmonPassword;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonRmonPasswordLen;
		rval = (u_char *) StorageTmp->xmonRmonPassword;
		break;
	case (u_char) XMONRMONBUFFCTRLINDEX:	/* Create */
		*write_method = write_xmonRmonBuffCtrlIndex;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonRmonBuffCtrlIndex);
		rval = (u_char *) &StorageTmp->xmonRmonBuffCtrlIndex;
		break;
	case (u_char) XMONRMONBUFFINDEX:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonRmonBuffIndex);
		rval = (u_char *) &StorageTmp->xmonRmonBuffIndex;
		break;
	case (u_char) XMONRMONSTORAGETYPE:	/* Create */
		*write_method = write_xmonRmonStorageType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonRmonStorageType);
		rval = (u_char *) &StorageTmp->xmonRmonStorageType;
		break;
	case (u_char) XMONRMONROWSTATUS:	/* Create */
		*write_method = write_xmonRmonRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonRmonRowStatus);
		rval = (u_char *) &StorageTmp->xmonRmonRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonArchiveTable_row(struct xmonArchiveTable_data *StorageTmp, struct xmonArchiveTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonArchiveTable_row(struct xmonArchiveTable_data *StorageTmp, struct xmonArchiveTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonArchiveTable_row(struct xmonArchiveTable_data *StorageTmp, struct xmonArchiveTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonArchiveTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonArchiveTable_row(struct xmonArchiveTable_data *StorageTmp, struct xmonArchiveTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonArchiveTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonArchiveTable_row(struct xmonArchiveTable_data *StorageTmp, struct xmonArchiveTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonArchiveTable_row(struct xmonArchiveTable_data *StorageTmp, struct xmonArchiveTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonArchiveTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonArchiveTable_row(struct xmonArchiveTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonArchiveTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonArchiveTable_data *
refresh_xmonArchiveTable_row(struct xmonArchiveTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonArchiveTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonArchiveTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonArchiveTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonArchiveTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonArchiveTable(int force)
{
	if (!force && xmonArchiveTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonArchiveTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonArchiveTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonArchiveTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonArchiveTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonArchiveTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonArchiveTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonArchiveTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonArchiveTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonArchiveTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONARCHIVENAME:	/* ReadWrite */
		*write_method = write_xmonArchiveName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonArchiveNameLen;
		rval = (u_char *) StorageTmp->xmonArchiveName;
		break;
	case (u_char) XMONARCHIVEFILEFORMAT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveFileFormat);
		rval = (u_char *) &StorageTmp->xmonArchiveFileFormat;
		break;
	case (u_char) XMONARCHIVECOMPRESSED:	/* ReadWrite */
		*write_method = write_xmonArchiveCompressed;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveCompressed);
		rval = (u_char *) &StorageTmp->xmonArchiveCompressed;
		break;
	case (u_char) XMONARCHIVESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveState);
		rval = (u_char *) &StorageTmp->xmonArchiveState;
		break;
	case (u_char) XMONARCHIVESIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveSize);
		rval = (u_char *) &StorageTmp->xmonArchiveSize;
		break;
	case (u_char) XMONARCHIVECOMPSIZE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveCompSize);
		rval = (u_char *) &StorageTmp->xmonArchiveCompSize;
		break;
	case (u_char) XMONARCHIVETIMEELAPSED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveTimeElapsed);
		rval = (u_char *) &StorageTmp->xmonArchiveTimeElapsed;
		break;
	case (u_char) XMONARCHIVEBEGTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveBegTime);
		rval = (u_char *) &StorageTmp->xmonArchiveBegTime;
		break;
	case (u_char) XMONARCHIVEENDTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveEndTime);
		rval = (u_char *) &StorageTmp->xmonArchiveEndTime;
		break;
	case (u_char) XMONARCHIVEIFRECV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveIfRecv);
		rval = (u_char *) &StorageTmp->xmonArchiveIfRecv;
		break;
	case (u_char) XMONARCHIVEIFDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveIfDrop);
		rval = (u_char *) &StorageTmp->xmonArchiveIfDrop;
		break;
	case (u_char) XMONARCHIVEFILTERACCEPT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveFilterAccept);
		rval = (u_char *) &StorageTmp->xmonArchiveFilterAccept;
		break;
	case (u_char) XMONARCHIVEOSDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveOsDrop);
		rval = (u_char *) &StorageTmp->xmonArchiveOsDrop;
		break;
	case (u_char) XMONARCHIVEUSERDELIV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveUserDeliv);
		rval = (u_char *) &StorageTmp->xmonArchiveUserDeliv;
		break;
	case (u_char) XMONARCHIVEIFCOMPRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveIfCompress);
		rval = (u_char *) &StorageTmp->xmonArchiveIfCompress;
		break;
	case (u_char) XMONARCHIVEUSEROCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveUserOctets);
		rval = (u_char *) &StorageTmp->xmonArchiveUserOctets;
		break;
	case (u_char) XMONARCHIVEACTIONRESULT:	/* ReadWrite */
		*write_method = write_xmonArchiveActionResult;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonArchiveActionResult);
		rval = (u_char *) &StorageTmp->xmonArchiveActionResult;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp, struct xmonFeedListenTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp, struct xmonFeedListenTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp, struct xmonFeedListenTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonFeedListenTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp, struct xmonFeedListenTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonFeedListenTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp, struct xmonFeedListenTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp, struct xmonFeedListenTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonFeedListenTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonFeedListenTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonFeedListenTable_data *
refresh_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonFeedListenTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonFeedListenTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonFeedListenTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonFeedListenTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonFeedListenTable(int force)
{
	if (!force && xmonFeedListenTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonFeedListenTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonFeedListenTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonFeedListenTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonFeedListenTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonFeedListenTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonFeedListenTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonFeedListenTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonFeedListenTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonFeedListenTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONFEEDLISTENADDRTYPE:	/* Create */
		*write_method = write_xmonFeedListenAddrType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedListenAddrType);
		rval = (u_char *) &StorageTmp->xmonFeedListenAddrType;
		break;
	case (u_char) XMONFEEDLISTENADDR:	/* Create */
		*write_method = write_xmonFeedListenAddr;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonFeedListenAddrLen;
		rval = (u_char *) StorageTmp->xmonFeedListenAddr;
		break;
	case (u_char) XMONFEEDLISTENROWSTATUS:	/* Create */
		*write_method = write_xmonFeedListenRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedListenRowStatus);
		rval = (u_char *) &StorageTmp->xmonFeedListenRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp, struct xmonFeedTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp, struct xmonFeedTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp, struct xmonFeedTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonFeedTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp, struct xmonFeedTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonFeedTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp, struct xmonFeedTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp, struct xmonFeedTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonFeedTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonFeedTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonFeedTable_data *
refresh_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonFeedTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonFeedTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonFeedTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonFeedTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonFeedTable(int force)
{
	if (!force && xmonFeedTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonFeedTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonFeedTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonFeedTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonFeedTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonFeedTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonFeedTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonFeedTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonFeedTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonFeedTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONFEEDROLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedRole);
		rval = (u_char *) &StorageTmp->xmonFeedRole;
		break;
	case (u_char) XMONFEEDNAME:	/* Create */
		*write_method = write_xmonFeedName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonFeedNameLen;
		rval = (u_char *) StorageTmp->xmonFeedName;
		break;
	case (u_char) XMONFEEDADDRTYPE:	/* Create */
		*write_method = write_xmonFeedAddrType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedAddrType);
		rval = (u_char *) &StorageTmp->xmonFeedAddrType;
		break;
	case (u_char) XMONFEEDADDR:	/* Create */
		*write_method = write_xmonFeedAddr;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonFeedAddrLen;
		rval = (u_char *) StorageTmp->xmonFeedAddr;
		break;
	case (u_char) XMONFEEDCONNINTERVAL:	/* Create */
		*write_method = write_xmonFeedConnInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedConnInterval);
		rval = (u_char *) &StorageTmp->xmonFeedConnInterval;
		break;
	case (u_char) XMONFEEDCONNATTEMPTS:	/* Create */
		*write_method = write_xmonFeedConnAttempts;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedConnAttempts);
		rval = (u_char *) &StorageTmp->xmonFeedConnAttempts;
		break;
	case (u_char) XMONFEEDPROFILE:	/* Create */
		*write_method = write_xmonFeedProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonFeedProfileLen;
		rval = (u_char *) StorageTmp->xmonFeedProfile;
		break;
	case (u_char) XMONFEEDADMINSTATE:	/* Create */
		*write_method = write_xmonFeedAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedAdminState);
		rval = (u_char *) &StorageTmp->xmonFeedAdminState;
		break;
	case (u_char) XMONFEEDOPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedOpState);
		rval = (u_char *) &StorageTmp->xmonFeedOpState;
		break;
	case (u_char) XMONFEEDPROCSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonFeedProcStatusLen;
		rval = (u_char *) StorageTmp->xmonFeedProcStatus;
		break;
	case (u_char) XMONFEEDUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedUsageState);
		rval = (u_char *) &StorageTmp->xmonFeedUsageState;
		break;
	case (u_char) XMONFEEDCONNSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedConnState);
		rval = (u_char *) &StorageTmp->xmonFeedConnState;
		break;
	case (u_char) XMONFEEDSTORAGETYPE:	/* Create */
		*write_method = write_xmonFeedStorageType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedStorageType);
		rval = (u_char *) &StorageTmp->xmonFeedStorageType;
		break;
	case (u_char) XMONFEEDROWSTATUS:	/* Create */
		*write_method = write_xmonFeedRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedRowStatus);
		rval = (u_char *) &StorageTmp->xmonFeedRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonFeedStatsTable_row(struct xmonFeedStatsTable_data *StorageTmp, struct xmonFeedStatsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonFeedStatsTable_row(struct xmonFeedStatsTable_data *StorageTmp, struct xmonFeedStatsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonFeedStatsTable_row(struct xmonFeedStatsTable_data *StorageTmp, struct xmonFeedStatsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonFeedStatsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonFeedStatsTable_row(struct xmonFeedStatsTable_data *StorageTmp, struct xmonFeedStatsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonFeedStatsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonFeedStatsTable_row(struct xmonFeedStatsTable_data *StorageTmp, struct xmonFeedStatsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonFeedStatsTable_row(struct xmonFeedStatsTable_data *StorageTmp, struct xmonFeedStatsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonFeedStatsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonFeedStatsTable_row(struct xmonFeedStatsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonFeedStatsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonFeedStatsTable_data *
refresh_xmonFeedStatsTable_row(struct xmonFeedStatsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonFeedStatsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonFeedStatsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonFeedStatsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonFeedStatsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonFeedStatsTable(int force)
{
	if (!force && xmonFeedStatsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonFeedStatsTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonFeedStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonFeedStatsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonFeedStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonFeedStatsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonFeedStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonFeedStatsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonFeedStatsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonFeedStatsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONFEEDTIMEELAPSED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedTimeElapsed);
		rval = (u_char *) &StorageTmp->xmonFeedTimeElapsed;
		break;
	case (u_char) XMONFEEDBEGTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedBegTime);
		rval = (u_char *) &StorageTmp->xmonFeedBegTime;
		break;
	case (u_char) XMONFEEDENDTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedEndTime);
		rval = (u_char *) &StorageTmp->xmonFeedEndTime;
		break;
	case (u_char) XMONFEEDIFRECV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedIfRecv);
		rval = (u_char *) &StorageTmp->xmonFeedIfRecv;
		break;
	case (u_char) XMONFEEDIFDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedIfDrop);
		rval = (u_char *) &StorageTmp->xmonFeedIfDrop;
		break;
	case (u_char) XMONFEEDFILTERACCEPT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedFilterAccept);
		rval = (u_char *) &StorageTmp->xmonFeedFilterAccept;
		break;
	case (u_char) XMONFEEDOSDROP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedOsDrop);
		rval = (u_char *) &StorageTmp->xmonFeedOsDrop;
		break;
	case (u_char) XMONFEEDUSERDELIV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedUserDeliv);
		rval = (u_char *) &StorageTmp->xmonFeedUserDeliv;
		break;
	case (u_char) XMONFEEDIFCOMPRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedIfCompress);
		rval = (u_char *) &StorageTmp->xmonFeedIfCompress;
		break;
	case (u_char) XMONFEEDUSEROCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonFeedUserOctets);
		rval = (u_char *) &StorageTmp->xmonFeedUserOctets;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp, struct xmonPushListenTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp, struct xmonPushListenTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp, struct xmonPushListenTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonPushListenTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp, struct xmonPushListenTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonPushListenTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp, struct xmonPushListenTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp, struct xmonPushListenTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonPushListenTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonPushListenTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonPushListenTable_data *
refresh_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonPushListenTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonPushListenTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonPushListenTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonPushListenTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonPushListenTable(int force)
{
	if (!force && xmonPushListenTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonPushListenTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonPushListenTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonPushListenTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonPushListenTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonPushListenTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonPushListenTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonPushListenTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonPushListenTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonPushListenTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONPUSHLISTENADDRTYPE:	/* Create */
		*write_method = write_xmonPushListenAddrType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushListenAddrType);
		rval = (u_char *) &StorageTmp->xmonPushListenAddrType;
		break;
	case (u_char) XMONPUSHLISTENADDR:	/* Create */
		*write_method = write_xmonPushListenAddr;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPushListenAddrLen;
		rval = (u_char *) StorageTmp->xmonPushListenAddr;
		break;
	case (u_char) XMONPUSHLISTENROWSTATUS:	/* Create */
		*write_method = write_xmonPushListenRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushListenRowStatus);
		rval = (u_char *) &StorageTmp->xmonPushListenRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonPushTable_row(struct xmonPushTable_data *StorageTmp, struct xmonPushTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonPushTable_row(struct xmonPushTable_data *StorageTmp, struct xmonPushTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonPushTable_row(struct xmonPushTable_data *StorageTmp, struct xmonPushTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonPushTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonPushTable_row(struct xmonPushTable_data *StorageTmp, struct xmonPushTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonPushTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonPushTable_row(struct xmonPushTable_data *StorageTmp, struct xmonPushTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonPushTable_row(struct xmonPushTable_data *StorageTmp, struct xmonPushTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonPushTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonPushTable_row(struct xmonPushTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonPushTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonPushTable_data *
refresh_xmonPushTable_row(struct xmonPushTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonPushTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonPushTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonPushTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonPushTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonPushTable(int force)
{
	if (!force && xmonPushTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonPushTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonPushTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonPushTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonPushTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonPushTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonPushTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonPushTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonPushTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonPushTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONPUSHROLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushRole);
		rval = (u_char *) &StorageTmp->xmonPushRole;
		break;
	case (u_char) XMONPUSHNAME:	/* Create */
		*write_method = write_xmonPushName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPushNameLen;
		rval = (u_char *) StorageTmp->xmonPushName;
		break;
	case (u_char) XMONPUSHADDRTYPE:	/* Create */
		*write_method = write_xmonPushAddrType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushAddrType);
		rval = (u_char *) &StorageTmp->xmonPushAddrType;
		break;
	case (u_char) XMONPUSHADDR:	/* Create */
		*write_method = write_xmonPushAddr;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPushAddrLen;
		rval = (u_char *) StorageTmp->xmonPushAddr;
		break;
	case (u_char) XMONPUSHCONNINTERVAL:	/* Create */
		*write_method = write_xmonPushConnInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushConnInterval);
		rval = (u_char *) &StorageTmp->xmonPushConnInterval;
		break;
	case (u_char) XMONPUSHCONNATTEMPTS:	/* Create */
		*write_method = write_xmonPushConnAttempts;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushConnAttempts);
		rval = (u_char *) &StorageTmp->xmonPushConnAttempts;
		break;
	case (u_char) XMONPUSHPROFILE:	/* Create */
		*write_method = write_xmonPushProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPushProfileLen;
		rval = (u_char *) StorageTmp->xmonPushProfile;
		break;
	case (u_char) XMONPUSHADMINSTATE:	/* Create */
		*write_method = write_xmonPushAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushAdminState);
		rval = (u_char *) &StorageTmp->xmonPushAdminState;
		break;
	case (u_char) XMONPUSHOPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushOpState);
		rval = (u_char *) &StorageTmp->xmonPushOpState;
		break;
	case (u_char) XMONPUSHPROCSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPushProcStatusLen;
		rval = (u_char *) StorageTmp->xmonPushProcStatus;
		break;
	case (u_char) XMONPUSHUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushUsageState);
		rval = (u_char *) &StorageTmp->xmonPushUsageState;
		break;
	case (u_char) XMONPUSHCONNSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushConnState);
		rval = (u_char *) &StorageTmp->xmonPushConnState;
		break;
	case (u_char) XMONPUSHSTORAGETYPE:	/* Create */
		*write_method = write_xmonPushStorageType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushStorageType);
		rval = (u_char *) &StorageTmp->xmonPushStorageType;
		break;
	case (u_char) XMONPUSHROWSTATUS:	/* Create */
		*write_method = write_xmonPushRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPushRowStatus);
		rval = (u_char *) &StorageTmp->xmonPushRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp, struct xmonPullListenTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp, struct xmonPullListenTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp, struct xmonPullListenTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonPullListenTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp, struct xmonPullListenTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonPullListenTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp, struct xmonPullListenTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp, struct xmonPullListenTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonPullListenTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonPullListenTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonPullListenTable_data *
refresh_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonPullListenTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonPullListenTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonPullListenTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonPullListenTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonPullListenTable(int force)
{
	if (!force && xmonPullListenTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonPullListenTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonPullListenTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonPullListenTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonPullListenTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonPullListenTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonPullListenTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonPullListenTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonPullListenTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonPullListenTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONPULLLISTENADDRTYPE:	/* Create */
		*write_method = write_xmonPullListenAddrType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullListenAddrType);
		rval = (u_char *) &StorageTmp->xmonPullListenAddrType;
		break;
	case (u_char) XMONPULLLISTENADDR:	/* Create */
		*write_method = write_xmonPullListenAddr;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPullListenAddrLen;
		rval = (u_char *) StorageTmp->xmonPullListenAddr;
		break;
	case (u_char) XMONPULLLISTENROWSTATUS:	/* Create */
		*write_method = write_xmonPullListenRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullListenRowStatus);
		rval = (u_char *) &StorageTmp->xmonPullListenRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonPullTable_row(struct xmonPullTable_data *StorageTmp, struct xmonPullTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonPullTable_row(struct xmonPullTable_data *StorageTmp, struct xmonPullTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonPullTable_row(struct xmonPullTable_data *StorageTmp, struct xmonPullTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonPullTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonPullTable_row(struct xmonPullTable_data *StorageTmp, struct xmonPullTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonPullTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonPullTable_row(struct xmonPullTable_data *StorageTmp, struct xmonPullTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonPullTable_row(struct xmonPullTable_data *StorageTmp, struct xmonPullTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonPullTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonPullTable_row(struct xmonPullTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonPullTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonPullTable_data *
refresh_xmonPullTable_row(struct xmonPullTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonPullTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonPullTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonPullTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonPullTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonPullTable(int force)
{
	if (!force && xmonPullTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonPullTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonPullTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonPullTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonPullTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonPullTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonPullTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonPullTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonPullTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonPullTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONPULLROLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullRole);
		rval = (u_char *) &StorageTmp->xmonPullRole;
		break;
	case (u_char) XMONPULLNAME:	/* Create */
		*write_method = write_xmonPullName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPullNameLen;
		rval = (u_char *) StorageTmp->xmonPullName;
		break;
	case (u_char) XMONPULLADDRTYPE:	/* Create */
		*write_method = write_xmonPullAddrType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullAddrType);
		rval = (u_char *) &StorageTmp->xmonPullAddrType;
		break;
	case (u_char) XMONPULLADDR:	/* Create */
		*write_method = write_xmonPullAddr;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPullAddrLen;
		rval = (u_char *) StorageTmp->xmonPullAddr;
		break;
	case (u_char) XMONPULLCONNINTERVAL:	/* Create */
		*write_method = write_xmonPullConnInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullConnInterval);
		rval = (u_char *) &StorageTmp->xmonPullConnInterval;
		break;
	case (u_char) XMONPULLCONNATTEMPTS:	/* Create */
		*write_method = write_xmonPullConnAttempts;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullConnAttempts);
		rval = (u_char *) &StorageTmp->xmonPullConnAttempts;
		break;
	case (u_char) XMONPULLPROFILE:	/* Create */
		*write_method = write_xmonPullProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPullProfileLen;
		rval = (u_char *) StorageTmp->xmonPullProfile;
		break;
	case (u_char) XMONPULLADMINSTATE:	/* Create */
		*write_method = write_xmonPullAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullAdminState);
		rval = (u_char *) &StorageTmp->xmonPullAdminState;
		break;
	case (u_char) XMONPULLOPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullOpState);
		rval = (u_char *) &StorageTmp->xmonPullOpState;
		break;
	case (u_char) XMONPULLPROCSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonPullProcStatusLen;
		rval = (u_char *) StorageTmp->xmonPullProcStatus;
		break;
	case (u_char) XMONPULLUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullUsageState);
		rval = (u_char *) &StorageTmp->xmonPullUsageState;
		break;
	case (u_char) XMONPULLCONNSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullConnState);
		rval = (u_char *) &StorageTmp->xmonPullConnState;
		break;
	case (u_char) XMONPULLSTORAGETYPE:	/* Create */
		*write_method = write_xmonPullStorageType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullStorageType);
		rval = (u_char *) &StorageTmp->xmonPullStorageType;
		break;
	case (u_char) XMONPULLROWSTATUS:	/* Create */
		*write_method = write_xmonPullRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonPullRowStatus);
		rval = (u_char *) &StorageTmp->xmonPullRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp, struct xmonUploadTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp, struct xmonUploadTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp, struct xmonUploadTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonUploadTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp, struct xmonUploadTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonUploadTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp, struct xmonUploadTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp, struct xmonUploadTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonUploadTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonUploadTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonUploadTable_data *
refresh_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonUploadTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonUploadTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonUploadTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonUploadTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonUploadTable(int force)
{
	if (!force && xmonUploadTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonUploadTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonUploadTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonUploadTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonUploadTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonUploadTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonUploadTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonUploadTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonUploadTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonUploadTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONUPLOADSPEC:	/* Create */
		*write_method = write_xmonUploadSpec;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonUploadSpecLen;
		rval = (u_char *) StorageTmp->xmonUploadSpec;
		break;
	case (u_char) XMONUPLOADUSERNAME:	/* Create */
		*write_method = write_xmonUploadUsername;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonUploadUsernameLen;
		rval = (u_char *) StorageTmp->xmonUploadUsername;
		break;
	case (u_char) XMONUPLOADPASSWORD:	/* Create */
		*write_method = write_xmonUploadPassword;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonUploadPasswordLen;
		rval = (u_char *) StorageTmp->xmonUploadPassword;
		break;
	case (u_char) XMONUPLOADPERIOD:	/* Create */
		*write_method = write_xmonUploadPeriod;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonUploadPeriod);
		rval = (u_char *) &StorageTmp->xmonUploadPeriod;
		break;
	case (u_char) XMONUPLOADSTARTTIME:	/* Create */
		*write_method = write_xmonUploadStartTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonUploadStartTime);
		rval = (u_char *) &StorageTmp->xmonUploadStartTime;
		break;
	case (u_char) XMONUPLOADSTOPTIME:	/* Create */
		*write_method = write_xmonUploadStopTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonUploadStopTime);
		rval = (u_char *) &StorageTmp->xmonUploadStopTime;
		break;
	case (u_char) XMONUPLOADINTERVALSOFDAY:	/* Create */
		*write_method = write_xmonUploadIntervalsOfDay;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonUploadIntervalsOfDayLen;
		rval = (u_char *) StorageTmp->xmonUploadIntervalsOfDay;
		break;
	case (u_char) XMONUPLOADWEEKMASK:	/* Create */
		*write_method = write_xmonUploadWeekMask;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonUploadWeekMaskLen;
		rval = (u_char *) StorageTmp->xmonUploadWeekMask;
		break;
	case (u_char) XMONUPLOADONROTATION:	/* Create */
		*write_method = write_xmonUploadOnRotation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonUploadOnRotation);
		rval = (u_char *) &StorageTmp->xmonUploadOnRotation;
		break;
	case (u_char) XMONUPLOADSELECTION:	/* Create */
		*write_method = write_xmonUploadSelection;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonUploadSelection);
		rval = (u_char *) &StorageTmp->xmonUploadSelection;
		break;
	case (u_char) XMONUPLOADADMINSTATE:	/* Create */
		*write_method = write_xmonUploadAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonUploadAdminState);
		rval = (u_char *) &StorageTmp->xmonUploadAdminState;
		break;
	case (u_char) XMONUPLOADUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonUploadUsageState);
		rval = (u_char *) &StorageTmp->xmonUploadUsageState;
		break;
	case (u_char) XMONUPLOADPROCSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonUploadProcStatusLen;
		rval = (u_char *) StorageTmp->xmonUploadProcStatus;
		break;
	case (u_char) XMONUPLOADSTORAGETYPE:	/* Create */
		*write_method = write_xmonUploadStorageType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonUploadStorageType);
		rval = (u_char *) &StorageTmp->xmonUploadStorageType;
		break;
	case (u_char) XMONUPLOADROWSTATUS:	/* Create */
		*write_method = write_xmonUploadRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonUploadRowStatus);
		rval = (u_char *) &StorageTmp->xmonUploadRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp, struct xmonDownloadTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp, struct xmonDownloadTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp, struct xmonDownloadTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonDownloadTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp, struct xmonDownloadTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonDownloadTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp, struct xmonDownloadTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp, struct xmonDownloadTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonDownloadTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonDownloadTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonDownloadTable_data *
refresh_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonDownloadTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonDownloadTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonDownloadTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonDownloadTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonDownloadTable(int force)
{
	if (!force && xmonDownloadTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonDownloadTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonDownloadTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonDownloadTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonDownloadTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonDownloadTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonDownloadTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonDownloadTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonDownloadTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonDownloadTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONDOWNLOADSPEC:	/* Create */
		*write_method = write_xmonDownloadSpec;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonDownloadSpecLen;
		rval = (u_char *) StorageTmp->xmonDownloadSpec;
		break;
	case (u_char) XMONDOWNLOADUSERNAME:	/* Create */
		*write_method = write_xmonDownloadUsername;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonDownloadUsernameLen;
		rval = (u_char *) StorageTmp->xmonDownloadUsername;
		break;
	case (u_char) XMONDOWNLOADPASSWORD:	/* Create */
		*write_method = write_xmonDownloadPassword;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonDownloadPasswordLen;
		rval = (u_char *) StorageTmp->xmonDownloadPassword;
		break;
	case (u_char) XMONDOWNLOADPERIOD:	/* Create */
		*write_method = write_xmonDownloadPeriod;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonDownloadPeriod);
		rval = (u_char *) &StorageTmp->xmonDownloadPeriod;
		break;
	case (u_char) XMONDOWNLOADSTARTTIME:	/* Create */
		*write_method = write_xmonDownloadStartTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonDownloadStartTime);
		rval = (u_char *) &StorageTmp->xmonDownloadStartTime;
		break;
	case (u_char) XMONDOWNLOADSTOPTIME:	/* Create */
		*write_method = write_xmonDownloadStopTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonDownloadStopTime);
		rval = (u_char *) &StorageTmp->xmonDownloadStopTime;
		break;
	case (u_char) XMONDOWNLOADINTERVALSOFDAY:	/* Create */
		*write_method = write_xmonDownloadIntervalsOfDay;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonDownloadIntervalsOfDayLen;
		rval = (u_char *) StorageTmp->xmonDownloadIntervalsOfDay;
		break;
	case (u_char) XMONDOWNLOADWEEKMASK:	/* Create */
		*write_method = write_xmonDownloadWeekMask;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonDownloadWeekMaskLen;
		rval = (u_char *) StorageTmp->xmonDownloadWeekMask;
		break;
	case (u_char) XMONDOWNLOADONROTATION:	/* Create */
		*write_method = write_xmonDownloadOnRotation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonDownloadOnRotation);
		rval = (u_char *) &StorageTmp->xmonDownloadOnRotation;
		break;
	case (u_char) XMONDOWNLOADSELECTION:	/* Create */
		*write_method = write_xmonDownloadSelection;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonDownloadSelection);
		rval = (u_char *) &StorageTmp->xmonDownloadSelection;
		break;
	case (u_char) XMONDOWNLOADADMINSTATE:	/* Create */
		*write_method = write_xmonDownloadAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonDownloadAdminState);
		rval = (u_char *) &StorageTmp->xmonDownloadAdminState;
		break;
	case (u_char) XMONDOWNLOADUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonDownloadUsageState);
		rval = (u_char *) &StorageTmp->xmonDownloadUsageState;
		break;
	case (u_char) XMONDOWNLOADPROCSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->xmonDownloadProcStatusLen;
		rval = (u_char *) StorageTmp->xmonDownloadProcStatus;
		break;
	case (u_char) XMONDOWNLOADSTORAGETYPE:	/* Create */
		*write_method = write_xmonDownloadStorageType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonDownloadStorageType);
		rval = (u_char *) &StorageTmp->xmonDownloadStorageType;
		break;
	case (u_char) XMONDOWNLOADROWSTATUS:	/* Create */
		*write_method = write_xmonDownloadRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonDownloadRowStatus);
		rval = (u_char *) &StorageTmp->xmonDownloadRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp, struct xmonSctpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp, struct xmonSctpTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp, struct xmonSctpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_xmonSctpTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp, struct xmonSctpTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	xmonSctpTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp, struct xmonSctpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp, struct xmonSctpTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_xmonSctpTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the xmonSctpTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct xmonSctpTable_data *
refresh_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->xmonSctpTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->xmonSctpTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_xmonSctpTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the xmonSctpTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_xmonSctpTable(int force)
{
	if (!force && xmonSctpTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	xmonSctpTable_refresh = 0;
}

/**
 * @fn u_char *var_xmonSctpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in xmonSctpTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_xmonMIB above.
 */
u_char *
var_xmonSctpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct xmonSctpTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("xmonMIB", "var_xmonSctpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_xmonSctpTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(xmonSctpTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_xmonSctpTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) XMONSCTPNODELAY:	/* Create */
		*write_method = write_xmonSctpNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpNoDelay);
		rval = (u_char *) &StorageTmp->xmonSctpNoDelay;
		break;
	case (u_char) XMONSCTPMAXSEG:	/* Create */
		*write_method = write_xmonSctpMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpMaxseg);
		rval = (u_char *) &StorageTmp->xmonSctpMaxseg;
		break;
	case (u_char) XMONSCTPHEARTBEATITVL:	/* Create */
		*write_method = write_xmonSctpHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpHeartbeatItvl);
		rval = (u_char *) &StorageTmp->xmonSctpHeartbeatItvl;
		break;
	case (u_char) XMONSCTPHEARTBEAT:	/* Create */
		*write_method = write_xmonSctpHeartbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpHeartbeat);
		rval = (u_char *) &StorageTmp->xmonSctpHeartbeat;
		break;
	case (u_char) XMONSCTPRTOINITIAL:	/* Create */
		*write_method = write_xmonSctpRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpRtoInitial);
		rval = (u_char *) &StorageTmp->xmonSctpRtoInitial;
		break;
	case (u_char) XMONSCTPRTOMIN:	/* Create */
		*write_method = write_xmonSctpRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpRtoMin);
		rval = (u_char *) &StorageTmp->xmonSctpRtoMin;
		break;
	case (u_char) XMONSCTPRTOMAX:	/* Create */
		*write_method = write_xmonSctpRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpRtoMax);
		rval = (u_char *) &StorageTmp->xmonSctpRtoMax;
		break;
	case (u_char) XMONSCTPPATHMAXRETRANS:	/* Create */
		*write_method = write_xmonSctpPathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpPathMaxRetrans);
		rval = (u_char *) &StorageTmp->xmonSctpPathMaxRetrans;
		break;
	case (u_char) XMONSCTPCOOKIELIFE:	/* Create */
		*write_method = write_xmonSctpCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpCookieLife);
		rval = (u_char *) &StorageTmp->xmonSctpCookieLife;
		break;
	case (u_char) XMONSCTPCOOKIEINC:	/* Create */
		*write_method = write_xmonSctpCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpCookieInc);
		rval = (u_char *) &StorageTmp->xmonSctpCookieInc;
		break;
	case (u_char) XMONSCTPMAXINITRETRIES:	/* Create */
		*write_method = write_xmonSctpMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpMaxInitRetries);
		rval = (u_char *) &StorageTmp->xmonSctpMaxInitRetries;
		break;
	case (u_char) XMONSCTPMAXBURST:	/* Create */
		*write_method = write_xmonSctpMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpMaxBurst);
		rval = (u_char *) &StorageTmp->xmonSctpMaxBurst;
		break;
	case (u_char) XMONSCTPASSOCMAXRETRANS:	/* Create */
		*write_method = write_xmonSctpAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->xmonSctpAssocMaxRetrans;
		break;
	case (u_char) XMONSCTPSACKDELAY:	/* Create */
		*write_method = write_xmonSctpSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpSackDelay);
		rval = (u_char *) &StorageTmp->xmonSctpSackDelay;
		break;
	case (u_char) XMONSCTPLIFETIME:	/* Create */
		*write_method = write_xmonSctpLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpLifetime);
		rval = (u_char *) &StorageTmp->xmonSctpLifetime;
		break;
	case (u_char) XMONSCTPROWSTATUS:	/* Create */
		*write_method = write_xmonSctpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->xmonSctpRowStatus);
		rval = (u_char *) &StorageTmp->xmonSctpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_xmonSourceName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSourceName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSourceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSourceName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSourceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSourceName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSourceName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) == NULL)
			if (StorageTmp->xmonSourceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSourceTable_old = xmonSourceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSourceTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonSourceName);
		StorageTmp->xmonSourceName = string;
		StorageTmp->xmonSourceNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSourceTable_tsts == 0)
				if ((ret = check_xmonSourceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSourceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSourceName for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSourceTable_sets == 0)
				if ((ret = update_xmonSourceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSourceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) != NULL) {
			xmonSourceTable_destroy(&StorageTmp->xmonSourceTable_old);
			StorageTmp->xmonSourceTable_rsvs = 0;
			StorageTmp->xmonSourceTable_tsts = 0;
			StorageTmp->xmonSourceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSourceTable_sets == 0)
			revert_xmonSourceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) == NULL)
			break;
		if (StorageOld->xmonSourceName != NULL) {
			SNMP_FREE(StorageTmp->xmonSourceName);
			StorageTmp->xmonSourceName = StorageOld->xmonSourceName;
			StorageTmp->xmonSourceNameLen = StorageOld->xmonSourceNameLen;
			StorageOld->xmonSourceName = NULL;
			StorageOld->xmonSourceNameLen = 0;
		}
		if (--StorageTmp->xmonSourceTable_rsvs == 0)
			xmonSourceTable_destroy(&StorageTmp->xmonSourceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSourceAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSourceAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSourceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSourceAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSourceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSourceAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSourceAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unlocked */
		switch (set_value) {
		case XMONSOURCEADMINSTATE_LOCKED:
		case XMONSOURCEADMINSTATE_UNLOCKED:
		case XMONSOURCEADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSourceAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) == NULL)
			if (StorageTmp->xmonSourceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSourceTable_old = xmonSourceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSourceTable_rsvs++;
		StorageTmp->xmonSourceAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSourceTable_tsts == 0)
				if ((ret = check_xmonSourceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSourceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSourceAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSourceTable_sets == 0)
				if ((ret = update_xmonSourceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSourceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) != NULL) {
			xmonSourceTable_destroy(&StorageTmp->xmonSourceTable_old);
			StorageTmp->xmonSourceTable_rsvs = 0;
			StorageTmp->xmonSourceTable_tsts = 0;
			StorageTmp->xmonSourceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSourceTable_sets == 0)
			revert_xmonSourceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSourceTable_old) == NULL)
			break;
		StorageTmp->xmonSourceAdminState = StorageOld->xmonSourceAdminState;
		if (--StorageTmp->xmonSourceTable_rsvs == 0)
			xmonSourceTable_destroy(&StorageTmp->xmonSourceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceLinkType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceLinkType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceLinkType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceLinkType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceLinkType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceLinkType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONINTERFACELINKTYPE_NULL:
		case XMONINTERFACELINKTYPE_ETHERNET:
		case XMONINTERFACELINKTYPE_EXPETHER:
		case XMONINTERFACELINKTYPE_AX25:
		case XMONINTERFACELINKTYPE_PRONET:
		case XMONINTERFACELINKTYPE_CHAOS:
		case XMONINTERFACELINKTYPE_TOKENRING:
		case XMONINTERFACELINKTYPE_ARCNET:
		case XMONINTERFACELINKTYPE_SLIP:
		case XMONINTERFACELINKTYPE_PPP:
		case XMONINTERFACELINKTYPE_FDDI:
		case XMONINTERFACELINKTYPE_PPPHDLC:
		case XMONINTERFACELINKTYPE_PPPETHER:
		case XMONINTERFACELINKTYPE_SYMANTEC:
		case XMONINTERFACELINKTYPE_RFC1483:
		case XMONINTERFACELINKTYPE_RAWIP:
		case XMONINTERFACELINKTYPE_BSDSLIP:
		case XMONINTERFACELINKTYPE_BSDPPP:
		case XMONINTERFACELINKTYPE_CISCOHDLC:
		case XMONINTERFACELINKTYPE_IEEE80211:
		case XMONINTERFACELINKTYPE_ATMCLIP:
		case XMONINTERFACELINKTYPE_FRELAY:
		case XMONINTERFACELINKTYPE_LOOP:
		case XMONINTERFACELINKTYPE_ENC:
		case XMONINTERFACELINKTYPE_LANE8023:
		case XMONINTERFACELINKTYPE_HIPPI:
		case XMONINTERFACELINKTYPE_HDLC:
		case XMONINTERFACELINKTYPE_LINUXSLL:
		case XMONINTERFACELINKTYPE_LTALK:
		case XMONINTERFACELINKTYPE_ECONET:
		case XMONINTERFACELINKTYPE_IPFILTER:
		case XMONINTERFACELINKTYPE_PFLOG:
		case XMONINTERFACELINKTYPE_PRISM:
		case XMONINTERFACELINKTYPE_AIRONET:
		case XMONINTERFACELINKTYPE_HHDLC:
		case XMONINTERFACELINKTYPE_RFC2825:
		case XMONINTERFACELINKTYPE_SUNATM:
		case XMONINTERFACELINKTYPE_RIO:
		case XMONINTERFACELINKTYPE_PCIE:
		case XMONINTERFACELINKTYPE_AURORA:
		case XMONINTERFACELINKTYPE_IEEE80211RADIO:
		case XMONINTERFACELINKTYPE_TZSP:
		case XMONINTERFACELINKTYPE_ARCNETLINUX:
		case XMONINTERFACELINKTYPE_IPIEEE1394:
		case XMONINTERFACELINKTYPE_MTP2PH:
		case XMONINTERFACELINKTYPE_MTP2:
		case XMONINTERFACELINKTYPE_MTP3:
		case XMONINTERFACELINKTYPE_SCCP:
		case XMONINTERFACELINKTYPE_DOCSIS:
		case XMONINTERFACELINKTYPE_IRDA:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceLinkType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		StorageTmp->xmonInterfaceLinkType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceLinkType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		StorageTmp->xmonInterfaceLinkType = StorageOld->xmonInterfaceLinkType;
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceSnapLen(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceSnapLen(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceSnapLen entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceSnapLen: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceSnapLen not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceSnapLen: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		StorageTmp->xmonInterfaceSnapLen = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceSnapLen for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		StorageTmp->xmonInterfaceSnapLen = StorageOld->xmonInterfaceSnapLen;
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfacePromiscuous(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfacePromiscuous(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfacePromiscuous entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfacePromiscuous: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfacePromiscuous not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfacePromiscuous: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfacePromiscuous: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		StorageTmp->xmonInterfacePromiscuous = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfacePromiscuous for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		StorageTmp->xmonInterfacePromiscuous = StorageOld->xmonInterfacePromiscuous;
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceMonitor(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceMonitor(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceMonitor entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceMonitor: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceMonitor not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceMonitor: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceMonitor: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		StorageTmp->xmonInterfaceMonitor = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceMonitor for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		StorageTmp->xmonInterfaceMonitor = StorageOld->xmonInterfaceMonitor;
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceDirection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceDirection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceDirection entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceDirection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceDirection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceDirection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value any */
		switch (set_value) {
		case XMONINTERFACEDIRECTION_ANY:
		case XMONINTERFACEDIRECTION_IN:
		case XMONINTERFACEDIRECTION_OUT:
		case XMONINTERFACEDIRECTION_INOUT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceDirection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		StorageTmp->xmonInterfaceDirection = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceDirection for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		StorageTmp->xmonInterfaceDirection = StorageOld->xmonInterfaceDirection;
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceTsRes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceTsRes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceTsRes entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceTsRes: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceTsRes not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceTsRes: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value micro */
		switch (set_value) {
		case XMONINTERFACETSRES_UNKNOWN:
		case XMONINTERFACETSRES_MILLI:
		case XMONINTERFACETSRES_MICRO:
		case XMONINTERFACETSRES_NANO:
		case XMONINTERFACETSRES_BINK:
		case XMONINTERFACETSRES_BINM:
		case XMONINTERFACETSRES_BING:
		case XMONINTERFACETSRES_BINARY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceTsRes: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		StorageTmp->xmonInterfaceTsRes = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceTsRes for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		StorageTmp->xmonInterfaceTsRes = StorageOld->xmonInterfaceTsRes;
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceTzone(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceTzone(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceTzone entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceTzone: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceTzone not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceTzone: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		StorageTmp->xmonInterfaceTzone = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceTzone for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		StorageTmp->xmonInterfaceTzone = StorageOld->xmonInterfaceTzone;
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceFilterType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceFilterType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceFilterType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilterType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilterType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 3) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilterType: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilterType: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { arp , rarp , lldp , dns , mdns , m2pa , m2ua , m3ua , sua } */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonInterfaceFilterType);
		StorageTmp->xmonInterfaceFilterType = string;
		StorageTmp->xmonInterfaceFilterTypeLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceFilterType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		if (StorageOld->xmonInterfaceFilterType != NULL) {
			SNMP_FREE(StorageTmp->xmonInterfaceFilterType);
			StorageTmp->xmonInterfaceFilterType = StorageOld->xmonInterfaceFilterType;
			StorageTmp->xmonInterfaceFilterTypeLen = StorageOld->xmonInterfaceFilterTypeLen;
			StorageOld->xmonInterfaceFilterType = NULL;
			StorageOld->xmonInterfaceFilterTypeLen = 0;
		}
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceFilter(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceFilter(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceFilter entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilter: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilter not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilter: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonInterfaceFilter);
		StorageTmp->xmonInterfaceFilter = string;
		StorageTmp->xmonInterfaceFilterLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceFilter for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		if (StorageOld->xmonInterfaceFilter != NULL) {
			SNMP_FREE(StorageTmp->xmonInterfaceFilter);
			StorageTmp->xmonInterfaceFilter = StorageOld->xmonInterfaceFilter;
			StorageTmp->xmonInterfaceFilterLen = StorageOld->xmonInterfaceFilterLen;
			StorageOld->xmonInterfaceFilter = NULL;
			StorageOld->xmonInterfaceFilterLen = 0;
		}
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceFilterBpf(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceFilterBpf(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceFilterBpf entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilterBpf: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilterBpf not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFilterBpf: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonInterfaceFilterBpf);
		StorageTmp->xmonInterfaceFilterBpf = string;
		StorageTmp->xmonInterfaceFilterBpfLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceFilterBpf for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		if (StorageOld->xmonInterfaceFilterBpf != NULL) {
			SNMP_FREE(StorageTmp->xmonInterfaceFilterBpf);
			StorageTmp->xmonInterfaceFilterBpf = StorageOld->xmonInterfaceFilterBpf;
			StorageTmp->xmonInterfaceFilterBpfLen = StorageOld->xmonInterfaceFilterBpfLen;
			StorageOld->xmonInterfaceFilterBpf = NULL;
			StorageOld->xmonInterfaceFilterBpfLen = 0;
		}
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceOs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceOs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceOs entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceOs: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceOs not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceOs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonInterfaceOs);
		StorageTmp->xmonInterfaceOs = string;
		StorageTmp->xmonInterfaceOsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceOs for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		if (StorageOld->xmonInterfaceOs != NULL) {
			SNMP_FREE(StorageTmp->xmonInterfaceOs);
			StorageTmp->xmonInterfaceOs = StorageOld->xmonInterfaceOs;
			StorageTmp->xmonInterfaceOsLen = StorageOld->xmonInterfaceOsLen;
			StorageOld->xmonInterfaceOs = NULL;
			StorageOld->xmonInterfaceOsLen = 0;
		}
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceFcsLen(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceFcsLen(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceFcsLen entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFcsLen: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFcsLen not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceFcsLen: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		StorageTmp->xmonInterfaceFcsLen = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceFcsLen for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		StorageTmp->xmonInterfaceFcsLen = StorageOld->xmonInterfaceFcsLen;
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonInterfaceStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceStorageType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceStorageType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceStorageType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceStorageType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value nonVolatile */
		switch (set_value) {
		case ST_OTHER:
		case ST_VOLATILE:
		case ST_NONVOLATILE:
		case ST_PERMANENT:
		case ST_READONLY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceStorageType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			if (StorageTmp->xmonInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonInterfaceTable_rsvs++;
		StorageTmp->xmonInterfaceStorageType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonInterfaceTable_tsts == 0)
				if ((ret = check_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonInterfaceStorageType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonInterfaceTable_sets == 0)
				if ((ret = update_xmonInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			StorageTmp->xmonInterfaceTable_rsvs = 0;
			StorageTmp->xmonInterfaceTable_tsts = 0;
			StorageTmp->xmonInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonInterfaceTable_sets == 0)
			revert_xmonInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
			break;
		StorageTmp->xmonInterfaceStorageType = StorageOld->xmonInterfaceStorageType;
		if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
			xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonRmonAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonRmonAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonRmonTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonRmonAddrType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonRmonTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonRmonRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonAddrType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonAddrType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonAddrType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONRMONADDRTYPE_UNKNOWN:
		case XMONRMONADDRTYPE_UDPIPV4:
		case XMONRMONADDRTYPE_UDPIPV6:
		case XMONRMONADDRTYPE_UDPIPV4Z:
		case XMONRMONADDRTYPE_UDPIPV6Z:
		case XMONRMONADDRTYPE_TCPIPV4:
		case XMONRMONADDRTYPE_TCPIPV6:
		case XMONRMONADDRTYPE_TCPIPV4Z:
		case XMONRMONADDRTYPE_TCPIPV6Z:
		case XMONRMONADDRTYPE_SCTPIPV4:
		case XMONRMONADDRTYPE_SCTPIPV6:
		case XMONRMONADDRTYPE_SCTPIPV4Z:
		case XMONRMONADDRTYPE_SCTPIPV6Z:
		case XMONRMONADDRTYPE_LOCAL:
		case XMONRMONADDRTYPE_UDPDNS:
		case XMONRMONADDRTYPE_TCPDNS:
		case XMONRMONADDRTYPE_SCTPDNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonAddrType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			if (StorageTmp->xmonRmonTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonRmonTable_old = xmonRmonTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonRmonTable_rsvs++;
		StorageTmp->xmonRmonAddrType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonRmonTable_tsts == 0)
				if ((ret = check_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonRmonAddrType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonRmonTable_sets == 0)
				if ((ret = update_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
			StorageTmp->xmonRmonTable_rsvs = 0;
			StorageTmp->xmonRmonTable_tsts = 0;
			StorageTmp->xmonRmonTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonRmonTable_sets == 0)
			revert_xmonRmonTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		StorageTmp->xmonRmonAddrType = StorageOld->xmonRmonAddrType;
		if (--StorageTmp->xmonRmonTable_rsvs == 0)
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonRmonAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonRmonAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonRmonTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonRmonAddr entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonRmonTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonRmonRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonAddr: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonAddr not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonAddr: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			if (StorageTmp->xmonRmonTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonRmonTable_old = xmonRmonTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonRmonTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonRmonAddr);
		StorageTmp->xmonRmonAddr = string;
		StorageTmp->xmonRmonAddrLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonRmonTable_tsts == 0)
				if ((ret = check_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonRmonAddr for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonRmonTable_sets == 0)
				if ((ret = update_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
			StorageTmp->xmonRmonTable_rsvs = 0;
			StorageTmp->xmonRmonTable_tsts = 0;
			StorageTmp->xmonRmonTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonRmonTable_sets == 0)
			revert_xmonRmonTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		if (StorageOld->xmonRmonAddr != NULL) {
			SNMP_FREE(StorageTmp->xmonRmonAddr);
			StorageTmp->xmonRmonAddr = StorageOld->xmonRmonAddr;
			StorageTmp->xmonRmonAddrLen = StorageOld->xmonRmonAddrLen;
			StorageOld->xmonRmonAddr = NULL;
			StorageOld->xmonRmonAddrLen = 0;
		}
		if (--StorageTmp->xmonRmonTable_rsvs == 0)
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonRmonSnmpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonRmonSnmpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonRmonTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonRmonSnmpVersion entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonRmonTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonRmonRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonSnmpVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonSnmpVersion not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonSnmpVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONRMONSNMPVERSION_ANY:
		case XMONRMONSNMPVERSION_V1:
		case XMONRMONSNMPVERSION_V2C:
		case XMONRMONSNMPVERSION_V3:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonSnmpVersion: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			if (StorageTmp->xmonRmonTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonRmonTable_old = xmonRmonTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonRmonTable_rsvs++;
		StorageTmp->xmonRmonSnmpVersion = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonRmonTable_tsts == 0)
				if ((ret = check_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonRmonSnmpVersion for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonRmonTable_sets == 0)
				if ((ret = update_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
			StorageTmp->xmonRmonTable_rsvs = 0;
			StorageTmp->xmonRmonTable_tsts = 0;
			StorageTmp->xmonRmonTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonRmonTable_sets == 0)
			revert_xmonRmonTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		StorageTmp->xmonRmonSnmpVersion = StorageOld->xmonRmonSnmpVersion;
		if (--StorageTmp->xmonRmonTable_rsvs == 0)
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonRmonCommunity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonRmonCommunity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonRmonTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonRmonCommunity entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonRmonTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonRmonRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonCommunity: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonCommunity not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonCommunity: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"public\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			if (StorageTmp->xmonRmonTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonRmonTable_old = xmonRmonTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonRmonTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonRmonCommunity);
		StorageTmp->xmonRmonCommunity = string;
		StorageTmp->xmonRmonCommunityLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonRmonTable_tsts == 0)
				if ((ret = check_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonRmonCommunity for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonRmonTable_sets == 0)
				if ((ret = update_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
			StorageTmp->xmonRmonTable_rsvs = 0;
			StorageTmp->xmonRmonTable_tsts = 0;
			StorageTmp->xmonRmonTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonRmonTable_sets == 0)
			revert_xmonRmonTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		if (StorageOld->xmonRmonCommunity != NULL) {
			SNMP_FREE(StorageTmp->xmonRmonCommunity);
			StorageTmp->xmonRmonCommunity = StorageOld->xmonRmonCommunity;
			StorageTmp->xmonRmonCommunityLen = StorageOld->xmonRmonCommunityLen;
			StorageOld->xmonRmonCommunity = NULL;
			StorageOld->xmonRmonCommunityLen = 0;
		}
		if (--StorageTmp->xmonRmonTable_rsvs == 0)
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonRmonUsername(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonRmonUsername(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonRmonTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonRmonUsername entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonRmonTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonRmonRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonUsername: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonUsername not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonUsername: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"unexicon\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			if (StorageTmp->xmonRmonTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonRmonTable_old = xmonRmonTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonRmonTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonRmonUsername);
		StorageTmp->xmonRmonUsername = string;
		StorageTmp->xmonRmonUsernameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonRmonTable_tsts == 0)
				if ((ret = check_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonRmonUsername for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonRmonTable_sets == 0)
				if ((ret = update_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
			StorageTmp->xmonRmonTable_rsvs = 0;
			StorageTmp->xmonRmonTable_tsts = 0;
			StorageTmp->xmonRmonTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonRmonTable_sets == 0)
			revert_xmonRmonTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		if (StorageOld->xmonRmonUsername != NULL) {
			SNMP_FREE(StorageTmp->xmonRmonUsername);
			StorageTmp->xmonRmonUsername = StorageOld->xmonRmonUsername;
			StorageTmp->xmonRmonUsernameLen = StorageOld->xmonRmonUsernameLen;
			StorageOld->xmonRmonUsername = NULL;
			StorageOld->xmonRmonUsernameLen = 0;
		}
		if (--StorageTmp->xmonRmonTable_rsvs == 0)
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonRmonPassword(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonRmonPassword(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonRmonTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonRmonPassword entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonRmonTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonRmonRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonPassword: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonPassword not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonPassword: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"unexicon\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			if (StorageTmp->xmonRmonTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonRmonTable_old = xmonRmonTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonRmonTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonRmonPassword);
		StorageTmp->xmonRmonPassword = string;
		StorageTmp->xmonRmonPasswordLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonRmonTable_tsts == 0)
				if ((ret = check_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonRmonPassword for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonRmonTable_sets == 0)
				if ((ret = update_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
			StorageTmp->xmonRmonTable_rsvs = 0;
			StorageTmp->xmonRmonTable_tsts = 0;
			StorageTmp->xmonRmonTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonRmonTable_sets == 0)
			revert_xmonRmonTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		if (StorageOld->xmonRmonPassword != NULL) {
			SNMP_FREE(StorageTmp->xmonRmonPassword);
			StorageTmp->xmonRmonPassword = StorageOld->xmonRmonPassword;
			StorageTmp->xmonRmonPasswordLen = StorageOld->xmonRmonPasswordLen;
			StorageOld->xmonRmonPassword = NULL;
			StorageOld->xmonRmonPasswordLen = 0;
		}
		if (--StorageTmp->xmonRmonTable_rsvs == 0)
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonRmonBuffCtrlIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonRmonBuffCtrlIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonRmonTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonRmonBuffCtrlIndex entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonRmonTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonRmonRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonBuffCtrlIndex: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonBuffCtrlIndex not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonBuffCtrlIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..65535 */
		if ((1 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonBuffCtrlIndex: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			if (StorageTmp->xmonRmonTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonRmonTable_old = xmonRmonTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonRmonTable_rsvs++;
		StorageTmp->xmonRmonBuffCtrlIndex = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonRmonTable_tsts == 0)
				if ((ret = check_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonRmonBuffCtrlIndex for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonRmonTable_sets == 0)
				if ((ret = update_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
			StorageTmp->xmonRmonTable_rsvs = 0;
			StorageTmp->xmonRmonTable_tsts = 0;
			StorageTmp->xmonRmonTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonRmonTable_sets == 0)
			revert_xmonRmonTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		StorageTmp->xmonRmonBuffCtrlIndex = StorageOld->xmonRmonBuffCtrlIndex;
		if (--StorageTmp->xmonRmonTable_rsvs == 0)
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonRmonStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonRmonStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonRmonTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonRmonStorageType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonRmonTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonRmonRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonStorageType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonStorageType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonStorageType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value nonVolatile */
		switch (set_value) {
		case ST_OTHER:
		case ST_VOLATILE:
		case ST_NONVOLATILE:
		case ST_PERMANENT:
		case ST_READONLY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonStorageType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			if (StorageTmp->xmonRmonTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonRmonTable_old = xmonRmonTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonRmonTable_rsvs++;
		StorageTmp->xmonRmonStorageType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonRmonTable_tsts == 0)
				if ((ret = check_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonRmonStorageType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonRmonTable_sets == 0)
				if ((ret = update_xmonRmonTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonRmonTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
			StorageTmp->xmonRmonTable_rsvs = 0;
			StorageTmp->xmonRmonTable_tsts = 0;
			StorageTmp->xmonRmonTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonRmonTable_sets == 0)
			revert_xmonRmonTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
			break;
		StorageTmp->xmonRmonStorageType = StorageOld->xmonRmonStorageType;
		if (--StorageTmp->xmonRmonTable_rsvs == 0)
			xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonArchiveName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonArchiveName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonArchiveTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonArchiveName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonArchiveTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchiveName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchiveName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) == NULL)
			if (StorageTmp->xmonArchiveTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonArchiveTable_old = xmonArchiveTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonArchiveTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonArchiveName);
		StorageTmp->xmonArchiveName = string;
		StorageTmp->xmonArchiveNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonArchiveTable_tsts == 0)
				if ((ret = check_xmonArchiveTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonArchiveTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonArchiveName for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonArchiveTable_sets == 0)
				if ((ret = update_xmonArchiveTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonArchiveTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) != NULL) {
			xmonArchiveTable_destroy(&StorageTmp->xmonArchiveTable_old);
			StorageTmp->xmonArchiveTable_rsvs = 0;
			StorageTmp->xmonArchiveTable_tsts = 0;
			StorageTmp->xmonArchiveTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonArchiveTable_sets == 0)
			revert_xmonArchiveTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) == NULL)
			break;
		if (StorageOld->xmonArchiveName != NULL) {
			SNMP_FREE(StorageTmp->xmonArchiveName);
			StorageTmp->xmonArchiveName = StorageOld->xmonArchiveName;
			StorageTmp->xmonArchiveNameLen = StorageOld->xmonArchiveNameLen;
			StorageOld->xmonArchiveName = NULL;
			StorageOld->xmonArchiveNameLen = 0;
		}
		if (--StorageTmp->xmonArchiveTable_rsvs == 0)
			xmonArchiveTable_destroy(&StorageTmp->xmonArchiveTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonArchiveCompressed(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonArchiveCompressed(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonArchiveTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonArchiveCompressed entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonArchiveTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchiveCompressed not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchiveCompressed: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONARCHIVECOMPRESSED_NONE:
		case XMONARCHIVECOMPRESSED_GZ:
		case XMONARCHIVECOMPRESSED_BZ2:
		case XMONARCHIVECOMPRESSED_XZ:
		case XMONARCHIVECOMPRESSED_ZIP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchiveCompressed: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) == NULL)
			if (StorageTmp->xmonArchiveTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonArchiveTable_old = xmonArchiveTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonArchiveTable_rsvs++;
		StorageTmp->xmonArchiveCompressed = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonArchiveTable_tsts == 0)
				if ((ret = check_xmonArchiveTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonArchiveTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonArchiveCompressed for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonArchiveTable_sets == 0)
				if ((ret = update_xmonArchiveTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonArchiveTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) != NULL) {
			xmonArchiveTable_destroy(&StorageTmp->xmonArchiveTable_old);
			StorageTmp->xmonArchiveTable_rsvs = 0;
			StorageTmp->xmonArchiveTable_tsts = 0;
			StorageTmp->xmonArchiveTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonArchiveTable_sets == 0)
			revert_xmonArchiveTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) == NULL)
			break;
		StorageTmp->xmonArchiveCompressed = StorageOld->xmonArchiveCompressed;
		if (--StorageTmp->xmonArchiveTable_rsvs == 0)
			xmonArchiveTable_destroy(&StorageTmp->xmonArchiveTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonArchiveActionResult(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonArchiveActionResult(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonArchiveTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonArchiveActionResult entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonArchiveTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchiveActionResult not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchiveActionResult: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONARCHIVEACTIONRESULT_SUCCESS:
		case XMONARCHIVEACTIONRESULT_FAILURE:
		case XMONARCHIVEACTIONRESULT_SPOOL:
		case XMONARCHIVEACTIONRESULT_ARCHIVE:
		case XMONARCHIVEACTIONRESULT_DELETE:
		case XMONARCHIVEACTIONRESULT_UPLOAD:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchiveActionResult: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) == NULL)
			if (StorageTmp->xmonArchiveTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonArchiveTable_old = xmonArchiveTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonArchiveTable_rsvs++;
		StorageTmp->xmonArchiveActionResult = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonArchiveTable_tsts == 0)
				if ((ret = check_xmonArchiveTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonArchiveTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonArchiveActionResult for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonArchiveTable_sets == 0)
				if ((ret = update_xmonArchiveTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonArchiveTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) != NULL) {
			xmonArchiveTable_destroy(&StorageTmp->xmonArchiveTable_old);
			StorageTmp->xmonArchiveTable_rsvs = 0;
			StorageTmp->xmonArchiveTable_tsts = 0;
			StorageTmp->xmonArchiveTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonArchiveTable_sets == 0)
			revert_xmonArchiveTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonArchiveTable_old) == NULL)
			break;
		StorageTmp->xmonArchiveActionResult = StorageOld->xmonArchiveActionResult;
		if (--StorageTmp->xmonArchiveTable_rsvs == 0)
			xmonArchiveTable_destroy(&StorageTmp->xmonArchiveTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedListenAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedListenAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedListenTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedListenAddrType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedListenTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedListenRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedListenAddrType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedListenAddrType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedListenAddrType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONFEEDLISTENADDRTYPE_UNKNOWN:
		case XMONFEEDLISTENADDRTYPE_UDPIPV4:
		case XMONFEEDLISTENADDRTYPE_UDPIPV6:
		case XMONFEEDLISTENADDRTYPE_UDPIPV4Z:
		case XMONFEEDLISTENADDRTYPE_UDPIPV6Z:
		case XMONFEEDLISTENADDRTYPE_TCPIPV4:
		case XMONFEEDLISTENADDRTYPE_TCPIPV6:
		case XMONFEEDLISTENADDRTYPE_TCPIPV4Z:
		case XMONFEEDLISTENADDRTYPE_TCPIPV6Z:
		case XMONFEEDLISTENADDRTYPE_SCTPIPV4:
		case XMONFEEDLISTENADDRTYPE_SCTPIPV6:
		case XMONFEEDLISTENADDRTYPE_SCTPIPV4Z:
		case XMONFEEDLISTENADDRTYPE_SCTPIPV6Z:
		case XMONFEEDLISTENADDRTYPE_LOCAL:
		case XMONFEEDLISTENADDRTYPE_UDPDNS:
		case XMONFEEDLISTENADDRTYPE_TCPDNS:
		case XMONFEEDLISTENADDRTYPE_SCTPDNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedListenAddrType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) == NULL)
			if (StorageTmp->xmonFeedListenTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedListenTable_old = xmonFeedListenTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedListenTable_rsvs++;
		StorageTmp->xmonFeedListenAddrType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedListenTable_tsts == 0)
				if ((ret = check_xmonFeedListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedListenTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedListenAddrType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedListenTable_sets == 0)
				if ((ret = update_xmonFeedListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedListenTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) != NULL) {
			xmonFeedListenTable_destroy(&StorageTmp->xmonFeedListenTable_old);
			StorageTmp->xmonFeedListenTable_rsvs = 0;
			StorageTmp->xmonFeedListenTable_tsts = 0;
			StorageTmp->xmonFeedListenTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedListenTable_sets == 0)
			revert_xmonFeedListenTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) == NULL)
			break;
		StorageTmp->xmonFeedListenAddrType = StorageOld->xmonFeedListenAddrType;
		if (--StorageTmp->xmonFeedListenTable_rsvs == 0)
			xmonFeedListenTable_destroy(&StorageTmp->xmonFeedListenTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedListenAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedListenAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedListenTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedListenAddr entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedListenTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedListenRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedListenAddr: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedListenAddr not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedListenAddr: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) == NULL)
			if (StorageTmp->xmonFeedListenTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedListenTable_old = xmonFeedListenTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedListenTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonFeedListenAddr);
		StorageTmp->xmonFeedListenAddr = string;
		StorageTmp->xmonFeedListenAddrLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedListenTable_tsts == 0)
				if ((ret = check_xmonFeedListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedListenTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedListenAddr for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedListenTable_sets == 0)
				if ((ret = update_xmonFeedListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedListenTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) != NULL) {
			xmonFeedListenTable_destroy(&StorageTmp->xmonFeedListenTable_old);
			StorageTmp->xmonFeedListenTable_rsvs = 0;
			StorageTmp->xmonFeedListenTable_tsts = 0;
			StorageTmp->xmonFeedListenTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedListenTable_sets == 0)
			revert_xmonFeedListenTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedListenTable_old) == NULL)
			break;
		if (StorageOld->xmonFeedListenAddr != NULL) {
			SNMP_FREE(StorageTmp->xmonFeedListenAddr);
			StorageTmp->xmonFeedListenAddr = StorageOld->xmonFeedListenAddr;
			StorageTmp->xmonFeedListenAddrLen = StorageOld->xmonFeedListenAddrLen;
			StorageOld->xmonFeedListenAddr = NULL;
			StorageOld->xmonFeedListenAddrLen = 0;
		}
		if (--StorageTmp->xmonFeedListenTable_rsvs == 0)
			xmonFeedListenTable_destroy(&StorageTmp->xmonFeedListenTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			if (StorageTmp->xmonFeedTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedTable_old = xmonFeedTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonFeedName);
		StorageTmp->xmonFeedName = string;
		StorageTmp->xmonFeedNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedTable_tsts == 0)
				if ((ret = check_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedName for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedTable_sets == 0)
				if ((ret = update_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
			StorageTmp->xmonFeedTable_rsvs = 0;
			StorageTmp->xmonFeedTable_tsts = 0;
			StorageTmp->xmonFeedTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedTable_sets == 0)
			revert_xmonFeedTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		if (StorageOld->xmonFeedName != NULL) {
			SNMP_FREE(StorageTmp->xmonFeedName);
			StorageTmp->xmonFeedName = StorageOld->xmonFeedName;
			StorageTmp->xmonFeedNameLen = StorageOld->xmonFeedNameLen;
			StorageOld->xmonFeedName = NULL;
			StorageOld->xmonFeedNameLen = 0;
		}
		if (--StorageTmp->xmonFeedTable_rsvs == 0)
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedAddrType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAddrType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAddrType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAddrType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONFEEDADDRTYPE_UNKNOWN:
		case XMONFEEDADDRTYPE_UDPIPV4:
		case XMONFEEDADDRTYPE_UDPIPV6:
		case XMONFEEDADDRTYPE_UDPIPV4Z:
		case XMONFEEDADDRTYPE_UDPIPV6Z:
		case XMONFEEDADDRTYPE_TCPIPV4:
		case XMONFEEDADDRTYPE_TCPIPV6:
		case XMONFEEDADDRTYPE_TCPIPV4Z:
		case XMONFEEDADDRTYPE_TCPIPV6Z:
		case XMONFEEDADDRTYPE_SCTPIPV4:
		case XMONFEEDADDRTYPE_SCTPIPV6:
		case XMONFEEDADDRTYPE_SCTPIPV4Z:
		case XMONFEEDADDRTYPE_SCTPIPV6Z:
		case XMONFEEDADDRTYPE_LOCAL:
		case XMONFEEDADDRTYPE_UDPDNS:
		case XMONFEEDADDRTYPE_TCPDNS:
		case XMONFEEDADDRTYPE_SCTPDNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAddrType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			if (StorageTmp->xmonFeedTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedTable_old = xmonFeedTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedTable_rsvs++;
		StorageTmp->xmonFeedAddrType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedTable_tsts == 0)
				if ((ret = check_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedAddrType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedTable_sets == 0)
				if ((ret = update_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
			StorageTmp->xmonFeedTable_rsvs = 0;
			StorageTmp->xmonFeedTable_tsts = 0;
			StorageTmp->xmonFeedTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedTable_sets == 0)
			revert_xmonFeedTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		StorageTmp->xmonFeedAddrType = StorageOld->xmonFeedAddrType;
		if (--StorageTmp->xmonFeedTable_rsvs == 0)
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedAddr entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAddr: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAddr not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAddr: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			if (StorageTmp->xmonFeedTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedTable_old = xmonFeedTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonFeedAddr);
		StorageTmp->xmonFeedAddr = string;
		StorageTmp->xmonFeedAddrLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedTable_tsts == 0)
				if ((ret = check_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedAddr for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedTable_sets == 0)
				if ((ret = update_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
			StorageTmp->xmonFeedTable_rsvs = 0;
			StorageTmp->xmonFeedTable_tsts = 0;
			StorageTmp->xmonFeedTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedTable_sets == 0)
			revert_xmonFeedTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		if (StorageOld->xmonFeedAddr != NULL) {
			SNMP_FREE(StorageTmp->xmonFeedAddr);
			StorageTmp->xmonFeedAddr = StorageOld->xmonFeedAddr;
			StorageTmp->xmonFeedAddrLen = StorageOld->xmonFeedAddrLen;
			StorageOld->xmonFeedAddr = NULL;
			StorageOld->xmonFeedAddrLen = 0;
		}
		if (--StorageTmp->xmonFeedTable_rsvs == 0)
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedConnInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedConnInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedConnInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedConnInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedConnInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedConnInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedConnInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			if (StorageTmp->xmonFeedTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedTable_old = xmonFeedTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedTable_rsvs++;
		StorageTmp->xmonFeedConnInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedTable_tsts == 0)
				if ((ret = check_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedConnInterval for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedTable_sets == 0)
				if ((ret = update_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
			StorageTmp->xmonFeedTable_rsvs = 0;
			StorageTmp->xmonFeedTable_tsts = 0;
			StorageTmp->xmonFeedTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedTable_sets == 0)
			revert_xmonFeedTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		StorageTmp->xmonFeedConnInterval = StorageOld->xmonFeedConnInterval;
		if (--StorageTmp->xmonFeedTable_rsvs == 0)
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedConnAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedConnAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedConnAttempts entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedConnAttempts: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedConnAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedConnAttempts: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			if (StorageTmp->xmonFeedTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedTable_old = xmonFeedTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedTable_rsvs++;
		StorageTmp->xmonFeedConnAttempts = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedTable_tsts == 0)
				if ((ret = check_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedConnAttempts for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedTable_sets == 0)
				if ((ret = update_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
			StorageTmp->xmonFeedTable_rsvs = 0;
			StorageTmp->xmonFeedTable_tsts = 0;
			StorageTmp->xmonFeedTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedTable_sets == 0)
			revert_xmonFeedTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		StorageTmp->xmonFeedConnAttempts = StorageOld->xmonFeedConnAttempts;
		if (--StorageTmp->xmonFeedTable_rsvs == 0)
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedProfile entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			if (StorageTmp->xmonFeedTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedTable_old = xmonFeedTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonFeedProfile);
		StorageTmp->xmonFeedProfile = string;
		StorageTmp->xmonFeedProfileLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedTable_tsts == 0)
				if ((ret = check_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedTable_sets == 0)
				if ((ret = update_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
			StorageTmp->xmonFeedTable_rsvs = 0;
			StorageTmp->xmonFeedTable_tsts = 0;
			StorageTmp->xmonFeedTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedTable_sets == 0)
			revert_xmonFeedTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		if (StorageOld->xmonFeedProfile != NULL) {
			SNMP_FREE(StorageTmp->xmonFeedProfile);
			StorageTmp->xmonFeedProfile = StorageOld->xmonFeedProfile;
			StorageTmp->xmonFeedProfileLen = StorageOld->xmonFeedProfileLen;
			StorageOld->xmonFeedProfile = NULL;
			StorageOld->xmonFeedProfileLen = 0;
		}
		if (--StorageTmp->xmonFeedTable_rsvs == 0)
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unlocked */
		switch (set_value) {
		case XMONFEEDADMINSTATE_LOCKED:
		case XMONFEEDADMINSTATE_UNLOCKED:
		case XMONFEEDADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			if (StorageTmp->xmonFeedTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedTable_old = xmonFeedTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedTable_rsvs++;
		StorageTmp->xmonFeedAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedTable_tsts == 0)
				if ((ret = check_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedTable_sets == 0)
				if ((ret = update_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
			StorageTmp->xmonFeedTable_rsvs = 0;
			StorageTmp->xmonFeedTable_tsts = 0;
			StorageTmp->xmonFeedTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedTable_sets == 0)
			revert_xmonFeedTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		StorageTmp->xmonFeedAdminState = StorageOld->xmonFeedAdminState;
		if (--StorageTmp->xmonFeedTable_rsvs == 0)
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonFeedStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedStorageType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonFeedTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonFeedRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedStorageType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedStorageType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedStorageType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value nonVolatile */
		switch (set_value) {
		case ST_OTHER:
		case ST_VOLATILE:
		case ST_NONVOLATILE:
		case ST_PERMANENT:
		case ST_READONLY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedStorageType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			if (StorageTmp->xmonFeedTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonFeedTable_old = xmonFeedTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonFeedTable_rsvs++;
		StorageTmp->xmonFeedStorageType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonFeedTable_tsts == 0)
				if ((ret = check_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedStorageType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonFeedTable_sets == 0)
				if ((ret = update_xmonFeedTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonFeedTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
			StorageTmp->xmonFeedTable_rsvs = 0;
			StorageTmp->xmonFeedTable_tsts = 0;
			StorageTmp->xmonFeedTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonFeedTable_sets == 0)
			revert_xmonFeedTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
			break;
		StorageTmp->xmonFeedStorageType = StorageOld->xmonFeedStorageType;
		if (--StorageTmp->xmonFeedTable_rsvs == 0)
			xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushListenAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushListenAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushListenTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushListenAddrType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushListenTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushListenRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushListenAddrType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushListenAddrType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushListenAddrType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONPUSHLISTENADDRTYPE_UNKNOWN:
		case XMONPUSHLISTENADDRTYPE_UDPIPV4:
		case XMONPUSHLISTENADDRTYPE_UDPIPV6:
		case XMONPUSHLISTENADDRTYPE_UDPIPV4Z:
		case XMONPUSHLISTENADDRTYPE_UDPIPV6Z:
		case XMONPUSHLISTENADDRTYPE_TCPIPV4:
		case XMONPUSHLISTENADDRTYPE_TCPIPV6:
		case XMONPUSHLISTENADDRTYPE_TCPIPV4Z:
		case XMONPUSHLISTENADDRTYPE_TCPIPV6Z:
		case XMONPUSHLISTENADDRTYPE_SCTPIPV4:
		case XMONPUSHLISTENADDRTYPE_SCTPIPV6:
		case XMONPUSHLISTENADDRTYPE_SCTPIPV4Z:
		case XMONPUSHLISTENADDRTYPE_SCTPIPV6Z:
		case XMONPUSHLISTENADDRTYPE_LOCAL:
		case XMONPUSHLISTENADDRTYPE_UDPDNS:
		case XMONPUSHLISTENADDRTYPE_TCPDNS:
		case XMONPUSHLISTENADDRTYPE_SCTPDNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushListenAddrType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) == NULL)
			if (StorageTmp->xmonPushListenTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushListenTable_old = xmonPushListenTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushListenTable_rsvs++;
		StorageTmp->xmonPushListenAddrType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushListenTable_tsts == 0)
				if ((ret = check_xmonPushListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushListenTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushListenAddrType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushListenTable_sets == 0)
				if ((ret = update_xmonPushListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushListenTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) != NULL) {
			xmonPushListenTable_destroy(&StorageTmp->xmonPushListenTable_old);
			StorageTmp->xmonPushListenTable_rsvs = 0;
			StorageTmp->xmonPushListenTable_tsts = 0;
			StorageTmp->xmonPushListenTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushListenTable_sets == 0)
			revert_xmonPushListenTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) == NULL)
			break;
		StorageTmp->xmonPushListenAddrType = StorageOld->xmonPushListenAddrType;
		if (--StorageTmp->xmonPushListenTable_rsvs == 0)
			xmonPushListenTable_destroy(&StorageTmp->xmonPushListenTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushListenAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushListenAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushListenTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushListenAddr entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushListenTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushListenRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushListenAddr: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushListenAddr not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushListenAddr: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) == NULL)
			if (StorageTmp->xmonPushListenTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushListenTable_old = xmonPushListenTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushListenTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPushListenAddr);
		StorageTmp->xmonPushListenAddr = string;
		StorageTmp->xmonPushListenAddrLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushListenTable_tsts == 0)
				if ((ret = check_xmonPushListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushListenTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushListenAddr for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushListenTable_sets == 0)
				if ((ret = update_xmonPushListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushListenTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) != NULL) {
			xmonPushListenTable_destroy(&StorageTmp->xmonPushListenTable_old);
			StorageTmp->xmonPushListenTable_rsvs = 0;
			StorageTmp->xmonPushListenTable_tsts = 0;
			StorageTmp->xmonPushListenTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushListenTable_sets == 0)
			revert_xmonPushListenTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushListenTable_old) == NULL)
			break;
		if (StorageOld->xmonPushListenAddr != NULL) {
			SNMP_FREE(StorageTmp->xmonPushListenAddr);
			StorageTmp->xmonPushListenAddr = StorageOld->xmonPushListenAddr;
			StorageTmp->xmonPushListenAddrLen = StorageOld->xmonPushListenAddrLen;
			StorageOld->xmonPushListenAddr = NULL;
			StorageOld->xmonPushListenAddrLen = 0;
		}
		if (--StorageTmp->xmonPushListenTable_rsvs == 0)
			xmonPushListenTable_destroy(&StorageTmp->xmonPushListenTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			if (StorageTmp->xmonPushTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushTable_old = xmonPushTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPushName);
		StorageTmp->xmonPushName = string;
		StorageTmp->xmonPushNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushTable_tsts == 0)
				if ((ret = check_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushName for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushTable_sets == 0)
				if ((ret = update_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
			StorageTmp->xmonPushTable_rsvs = 0;
			StorageTmp->xmonPushTable_tsts = 0;
			StorageTmp->xmonPushTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushTable_sets == 0)
			revert_xmonPushTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		if (StorageOld->xmonPushName != NULL) {
			SNMP_FREE(StorageTmp->xmonPushName);
			StorageTmp->xmonPushName = StorageOld->xmonPushName;
			StorageTmp->xmonPushNameLen = StorageOld->xmonPushNameLen;
			StorageOld->xmonPushName = NULL;
			StorageOld->xmonPushNameLen = 0;
		}
		if (--StorageTmp->xmonPushTable_rsvs == 0)
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushAddrType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAddrType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAddrType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAddrType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sctpIpv4 */
		switch (set_value) {
		case XMONPUSHADDRTYPE_UNKNOWN:
		case XMONPUSHADDRTYPE_UDPIPV4:
		case XMONPUSHADDRTYPE_UDPIPV6:
		case XMONPUSHADDRTYPE_UDPIPV4Z:
		case XMONPUSHADDRTYPE_UDPIPV6Z:
		case XMONPUSHADDRTYPE_TCPIPV4:
		case XMONPUSHADDRTYPE_TCPIPV6:
		case XMONPUSHADDRTYPE_TCPIPV4Z:
		case XMONPUSHADDRTYPE_TCPIPV6Z:
		case XMONPUSHADDRTYPE_SCTPIPV4:
		case XMONPUSHADDRTYPE_SCTPIPV6:
		case XMONPUSHADDRTYPE_SCTPIPV4Z:
		case XMONPUSHADDRTYPE_SCTPIPV6Z:
		case XMONPUSHADDRTYPE_LOCAL:
		case XMONPUSHADDRTYPE_UDPDNS:
		case XMONPUSHADDRTYPE_TCPDNS:
		case XMONPUSHADDRTYPE_SCTPDNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAddrType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			if (StorageTmp->xmonPushTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushTable_old = xmonPushTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushTable_rsvs++;
		StorageTmp->xmonPushAddrType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushTable_tsts == 0)
				if ((ret = check_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushAddrType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushTable_sets == 0)
				if ((ret = update_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
			StorageTmp->xmonPushTable_rsvs = 0;
			StorageTmp->xmonPushTable_tsts = 0;
			StorageTmp->xmonPushTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushTable_sets == 0)
			revert_xmonPushTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		StorageTmp->xmonPushAddrType = StorageOld->xmonPushAddrType;
		if (--StorageTmp->xmonPushTable_rsvs == 0)
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushAddr entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAddr: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAddr not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAddr: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			if (StorageTmp->xmonPushTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushTable_old = xmonPushTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPushAddr);
		StorageTmp->xmonPushAddr = string;
		StorageTmp->xmonPushAddrLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushTable_tsts == 0)
				if ((ret = check_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushAddr for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushTable_sets == 0)
				if ((ret = update_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
			StorageTmp->xmonPushTable_rsvs = 0;
			StorageTmp->xmonPushTable_tsts = 0;
			StorageTmp->xmonPushTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushTable_sets == 0)
			revert_xmonPushTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		if (StorageOld->xmonPushAddr != NULL) {
			SNMP_FREE(StorageTmp->xmonPushAddr);
			StorageTmp->xmonPushAddr = StorageOld->xmonPushAddr;
			StorageTmp->xmonPushAddrLen = StorageOld->xmonPushAddrLen;
			StorageOld->xmonPushAddr = NULL;
			StorageOld->xmonPushAddrLen = 0;
		}
		if (--StorageTmp->xmonPushTable_rsvs == 0)
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushConnInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushConnInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushConnInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushConnInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushConnInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushConnInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushConnInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			if (StorageTmp->xmonPushTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushTable_old = xmonPushTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushTable_rsvs++;
		StorageTmp->xmonPushConnInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushTable_tsts == 0)
				if ((ret = check_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushConnInterval for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushTable_sets == 0)
				if ((ret = update_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
			StorageTmp->xmonPushTable_rsvs = 0;
			StorageTmp->xmonPushTable_tsts = 0;
			StorageTmp->xmonPushTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushTable_sets == 0)
			revert_xmonPushTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		StorageTmp->xmonPushConnInterval = StorageOld->xmonPushConnInterval;
		if (--StorageTmp->xmonPushTable_rsvs == 0)
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushConnAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushConnAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushConnAttempts entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushConnAttempts: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushConnAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushConnAttempts: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			if (StorageTmp->xmonPushTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushTable_old = xmonPushTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushTable_rsvs++;
		StorageTmp->xmonPushConnAttempts = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushTable_tsts == 0)
				if ((ret = check_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushConnAttempts for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushTable_sets == 0)
				if ((ret = update_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
			StorageTmp->xmonPushTable_rsvs = 0;
			StorageTmp->xmonPushTable_tsts = 0;
			StorageTmp->xmonPushTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushTable_sets == 0)
			revert_xmonPushTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		StorageTmp->xmonPushConnAttempts = StorageOld->xmonPushConnAttempts;
		if (--StorageTmp->xmonPushTable_rsvs == 0)
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushProfile entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			if (StorageTmp->xmonPushTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushTable_old = xmonPushTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPushProfile);
		StorageTmp->xmonPushProfile = string;
		StorageTmp->xmonPushProfileLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushTable_tsts == 0)
				if ((ret = check_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushTable_sets == 0)
				if ((ret = update_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
			StorageTmp->xmonPushTable_rsvs = 0;
			StorageTmp->xmonPushTable_tsts = 0;
			StorageTmp->xmonPushTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushTable_sets == 0)
			revert_xmonPushTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		if (StorageOld->xmonPushProfile != NULL) {
			SNMP_FREE(StorageTmp->xmonPushProfile);
			StorageTmp->xmonPushProfile = StorageOld->xmonPushProfile;
			StorageTmp->xmonPushProfileLen = StorageOld->xmonPushProfileLen;
			StorageOld->xmonPushProfile = NULL;
			StorageOld->xmonPushProfileLen = 0;
		}
		if (--StorageTmp->xmonPushTable_rsvs == 0)
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unlocked */
		switch (set_value) {
		case XMONPUSHADMINSTATE_LOCKED:
		case XMONPUSHADMINSTATE_UNLOCKED:
		case XMONPUSHADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			if (StorageTmp->xmonPushTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushTable_old = xmonPushTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushTable_rsvs++;
		StorageTmp->xmonPushAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushTable_tsts == 0)
				if ((ret = check_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushTable_sets == 0)
				if ((ret = update_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
			StorageTmp->xmonPushTable_rsvs = 0;
			StorageTmp->xmonPushTable_tsts = 0;
			StorageTmp->xmonPushTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushTable_sets == 0)
			revert_xmonPushTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		StorageTmp->xmonPushAdminState = StorageOld->xmonPushAdminState;
		if (--StorageTmp->xmonPushTable_rsvs == 0)
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPushStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushStorageType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPushTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPushRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushStorageType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushStorageType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushStorageType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value nonVolatile */
		switch (set_value) {
		case ST_OTHER:
		case ST_VOLATILE:
		case ST_NONVOLATILE:
		case ST_PERMANENT:
		case ST_READONLY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushStorageType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			if (StorageTmp->xmonPushTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPushTable_old = xmonPushTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPushTable_rsvs++;
		StorageTmp->xmonPushStorageType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPushTable_tsts == 0)
				if ((ret = check_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushStorageType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPushTable_sets == 0)
				if ((ret = update_xmonPushTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPushTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
			StorageTmp->xmonPushTable_rsvs = 0;
			StorageTmp->xmonPushTable_tsts = 0;
			StorageTmp->xmonPushTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPushTable_sets == 0)
			revert_xmonPushTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
			break;
		StorageTmp->xmonPushStorageType = StorageOld->xmonPushStorageType;
		if (--StorageTmp->xmonPushTable_rsvs == 0)
			xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullListenAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullListenAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullListenTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullListenAddrType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullListenTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullListenRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullListenAddrType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullListenAddrType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullListenAddrType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONPULLLISTENADDRTYPE_UNKNOWN:
		case XMONPULLLISTENADDRTYPE_UDPIPV4:
		case XMONPULLLISTENADDRTYPE_UDPIPV6:
		case XMONPULLLISTENADDRTYPE_UDPIPV4Z:
		case XMONPULLLISTENADDRTYPE_UDPIPV6Z:
		case XMONPULLLISTENADDRTYPE_TCPIPV4:
		case XMONPULLLISTENADDRTYPE_TCPIPV6:
		case XMONPULLLISTENADDRTYPE_TCPIPV4Z:
		case XMONPULLLISTENADDRTYPE_TCPIPV6Z:
		case XMONPULLLISTENADDRTYPE_SCTPIPV4:
		case XMONPULLLISTENADDRTYPE_SCTPIPV6:
		case XMONPULLLISTENADDRTYPE_SCTPIPV4Z:
		case XMONPULLLISTENADDRTYPE_SCTPIPV6Z:
		case XMONPULLLISTENADDRTYPE_LOCAL:
		case XMONPULLLISTENADDRTYPE_UDPDNS:
		case XMONPULLLISTENADDRTYPE_TCPDNS:
		case XMONPULLLISTENADDRTYPE_SCTPDNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullListenAddrType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) == NULL)
			if (StorageTmp->xmonPullListenTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullListenTable_old = xmonPullListenTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullListenTable_rsvs++;
		StorageTmp->xmonPullListenAddrType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullListenTable_tsts == 0)
				if ((ret = check_xmonPullListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullListenTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullListenAddrType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullListenTable_sets == 0)
				if ((ret = update_xmonPullListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullListenTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) != NULL) {
			xmonPullListenTable_destroy(&StorageTmp->xmonPullListenTable_old);
			StorageTmp->xmonPullListenTable_rsvs = 0;
			StorageTmp->xmonPullListenTable_tsts = 0;
			StorageTmp->xmonPullListenTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullListenTable_sets == 0)
			revert_xmonPullListenTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) == NULL)
			break;
		StorageTmp->xmonPullListenAddrType = StorageOld->xmonPullListenAddrType;
		if (--StorageTmp->xmonPullListenTable_rsvs == 0)
			xmonPullListenTable_destroy(&StorageTmp->xmonPullListenTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullListenAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullListenAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullListenTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullListenAddr entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullListenTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullListenRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullListenAddr: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullListenAddr not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullListenAddr: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) == NULL)
			if (StorageTmp->xmonPullListenTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullListenTable_old = xmonPullListenTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullListenTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPullListenAddr);
		StorageTmp->xmonPullListenAddr = string;
		StorageTmp->xmonPullListenAddrLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullListenTable_tsts == 0)
				if ((ret = check_xmonPullListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullListenTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullListenAddr for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullListenTable_sets == 0)
				if ((ret = update_xmonPullListenTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullListenTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) != NULL) {
			xmonPullListenTable_destroy(&StorageTmp->xmonPullListenTable_old);
			StorageTmp->xmonPullListenTable_rsvs = 0;
			StorageTmp->xmonPullListenTable_tsts = 0;
			StorageTmp->xmonPullListenTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullListenTable_sets == 0)
			revert_xmonPullListenTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullListenTable_old) == NULL)
			break;
		if (StorageOld->xmonPullListenAddr != NULL) {
			SNMP_FREE(StorageTmp->xmonPullListenAddr);
			StorageTmp->xmonPullListenAddr = StorageOld->xmonPullListenAddr;
			StorageTmp->xmonPullListenAddrLen = StorageOld->xmonPullListenAddrLen;
			StorageOld->xmonPullListenAddr = NULL;
			StorageOld->xmonPullListenAddrLen = 0;
		}
		if (--StorageTmp->xmonPullListenTable_rsvs == 0)
			xmonPullListenTable_destroy(&StorageTmp->xmonPullListenTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			if (StorageTmp->xmonPullTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullTable_old = xmonPullTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPullName);
		StorageTmp->xmonPullName = string;
		StorageTmp->xmonPullNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullTable_tsts == 0)
				if ((ret = check_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullName for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullTable_sets == 0)
				if ((ret = update_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
			StorageTmp->xmonPullTable_rsvs = 0;
			StorageTmp->xmonPullTable_tsts = 0;
			StorageTmp->xmonPullTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullTable_sets == 0)
			revert_xmonPullTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		if (StorageOld->xmonPullName != NULL) {
			SNMP_FREE(StorageTmp->xmonPullName);
			StorageTmp->xmonPullName = StorageOld->xmonPullName;
			StorageTmp->xmonPullNameLen = StorageOld->xmonPullNameLen;
			StorageOld->xmonPullName = NULL;
			StorageOld->xmonPullNameLen = 0;
		}
		if (--StorageTmp->xmonPullTable_rsvs == 0)
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullAddrType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullAddrType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAddrType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAddrType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAddrType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONPULLADDRTYPE_UNKNOWN:
		case XMONPULLADDRTYPE_UDPIPV4:
		case XMONPULLADDRTYPE_UDPIPV6:
		case XMONPULLADDRTYPE_UDPIPV4Z:
		case XMONPULLADDRTYPE_UDPIPV6Z:
		case XMONPULLADDRTYPE_TCPIPV4:
		case XMONPULLADDRTYPE_TCPIPV6:
		case XMONPULLADDRTYPE_TCPIPV4Z:
		case XMONPULLADDRTYPE_TCPIPV6Z:
		case XMONPULLADDRTYPE_SCTPIPV4:
		case XMONPULLADDRTYPE_SCTPIPV6:
		case XMONPULLADDRTYPE_SCTPIPV4Z:
		case XMONPULLADDRTYPE_SCTPIPV6Z:
		case XMONPULLADDRTYPE_LOCAL:
		case XMONPULLADDRTYPE_UDPDNS:
		case XMONPULLADDRTYPE_TCPDNS:
		case XMONPULLADDRTYPE_SCTPDNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAddrType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			if (StorageTmp->xmonPullTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullTable_old = xmonPullTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullTable_rsvs++;
		StorageTmp->xmonPullAddrType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullTable_tsts == 0)
				if ((ret = check_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullAddrType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullTable_sets == 0)
				if ((ret = update_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
			StorageTmp->xmonPullTable_rsvs = 0;
			StorageTmp->xmonPullTable_tsts = 0;
			StorageTmp->xmonPullTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullTable_sets == 0)
			revert_xmonPullTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		StorageTmp->xmonPullAddrType = StorageOld->xmonPullAddrType;
		if (--StorageTmp->xmonPullTable_rsvs == 0)
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullAddr entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAddr: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAddr not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAddr: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			if (StorageTmp->xmonPullTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullTable_old = xmonPullTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPullAddr);
		StorageTmp->xmonPullAddr = string;
		StorageTmp->xmonPullAddrLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullTable_tsts == 0)
				if ((ret = check_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullAddr for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullTable_sets == 0)
				if ((ret = update_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
			StorageTmp->xmonPullTable_rsvs = 0;
			StorageTmp->xmonPullTable_tsts = 0;
			StorageTmp->xmonPullTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullTable_sets == 0)
			revert_xmonPullTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		if (StorageOld->xmonPullAddr != NULL) {
			SNMP_FREE(StorageTmp->xmonPullAddr);
			StorageTmp->xmonPullAddr = StorageOld->xmonPullAddr;
			StorageTmp->xmonPullAddrLen = StorageOld->xmonPullAddrLen;
			StorageOld->xmonPullAddr = NULL;
			StorageOld->xmonPullAddrLen = 0;
		}
		if (--StorageTmp->xmonPullTable_rsvs == 0)
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullConnInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullConnInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullConnInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullConnInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullConnInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullConnInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullConnInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			if (StorageTmp->xmonPullTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullTable_old = xmonPullTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullTable_rsvs++;
		StorageTmp->xmonPullConnInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullTable_tsts == 0)
				if ((ret = check_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullConnInterval for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullTable_sets == 0)
				if ((ret = update_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
			StorageTmp->xmonPullTable_rsvs = 0;
			StorageTmp->xmonPullTable_tsts = 0;
			StorageTmp->xmonPullTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullTable_sets == 0)
			revert_xmonPullTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		StorageTmp->xmonPullConnInterval = StorageOld->xmonPullConnInterval;
		if (--StorageTmp->xmonPullTable_rsvs == 0)
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullConnAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullConnAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullConnAttempts entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullConnAttempts: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullConnAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullConnAttempts: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			if (StorageTmp->xmonPullTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullTable_old = xmonPullTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullTable_rsvs++;
		StorageTmp->xmonPullConnAttempts = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullTable_tsts == 0)
				if ((ret = check_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullConnAttempts for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullTable_sets == 0)
				if ((ret = update_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
			StorageTmp->xmonPullTable_rsvs = 0;
			StorageTmp->xmonPullTable_tsts = 0;
			StorageTmp->xmonPullTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullTable_sets == 0)
			revert_xmonPullTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		StorageTmp->xmonPullConnAttempts = StorageOld->xmonPullConnAttempts;
		if (--StorageTmp->xmonPullTable_rsvs == 0)
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullProfile entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			if (StorageTmp->xmonPullTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullTable_old = xmonPullTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPullProfile);
		StorageTmp->xmonPullProfile = string;
		StorageTmp->xmonPullProfileLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullTable_tsts == 0)
				if ((ret = check_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullTable_sets == 0)
				if ((ret = update_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
			StorageTmp->xmonPullTable_rsvs = 0;
			StorageTmp->xmonPullTable_tsts = 0;
			StorageTmp->xmonPullTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullTable_sets == 0)
			revert_xmonPullTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		if (StorageOld->xmonPullProfile != NULL) {
			SNMP_FREE(StorageTmp->xmonPullProfile);
			StorageTmp->xmonPullProfile = StorageOld->xmonPullProfile;
			StorageTmp->xmonPullProfileLen = StorageOld->xmonPullProfileLen;
			StorageOld->xmonPullProfile = NULL;
			StorageOld->xmonPullProfileLen = 0;
		}
		if (--StorageTmp->xmonPullTable_rsvs == 0)
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unlocked */
		switch (set_value) {
		case XMONPULLADMINSTATE_LOCKED:
		case XMONPULLADMINSTATE_UNLOCKED:
		case XMONPULLADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			if (StorageTmp->xmonPullTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullTable_old = xmonPullTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullTable_rsvs++;
		StorageTmp->xmonPullAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullTable_tsts == 0)
				if ((ret = check_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullTable_sets == 0)
				if ((ret = update_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
			StorageTmp->xmonPullTable_rsvs = 0;
			StorageTmp->xmonPullTable_tsts = 0;
			StorageTmp->xmonPullTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullTable_sets == 0)
			revert_xmonPullTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		StorageTmp->xmonPullAdminState = StorageOld->xmonPullAdminState;
		if (--StorageTmp->xmonPullTable_rsvs == 0)
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonPullStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullStorageType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonPullTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonPullRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullStorageType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullStorageType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullStorageType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value nonVolatile */
		switch (set_value) {
		case ST_OTHER:
		case ST_VOLATILE:
		case ST_NONVOLATILE:
		case ST_PERMANENT:
		case ST_READONLY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullStorageType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			if (StorageTmp->xmonPullTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonPullTable_old = xmonPullTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonPullTable_rsvs++;
		StorageTmp->xmonPullStorageType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonPullTable_tsts == 0)
				if ((ret = check_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullStorageType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonPullTable_sets == 0)
				if ((ret = update_xmonPullTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonPullTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
			StorageTmp->xmonPullTable_rsvs = 0;
			StorageTmp->xmonPullTable_tsts = 0;
			StorageTmp->xmonPullTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonPullTable_sets == 0)
			revert_xmonPullTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
			break;
		StorageTmp->xmonPullStorageType = StorageOld->xmonPullStorageType;
		if (--StorageTmp->xmonPullTable_rsvs == 0)
			xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadSpec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadSpec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadSpec entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadSpec: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadSpec not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadSpec: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonUploadSpec);
		StorageTmp->xmonUploadSpec = string;
		StorageTmp->xmonUploadSpecLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadSpec for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		if (StorageOld->xmonUploadSpec != NULL) {
			SNMP_FREE(StorageTmp->xmonUploadSpec);
			StorageTmp->xmonUploadSpec = StorageOld->xmonUploadSpec;
			StorageTmp->xmonUploadSpecLen = StorageOld->xmonUploadSpecLen;
			StorageOld->xmonUploadSpec = NULL;
			StorageOld->xmonUploadSpecLen = 0;
		}
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadUsername(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadUsername(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadUsername entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadUsername: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadUsername not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadUsername: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"openss7\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonUploadUsername);
		StorageTmp->xmonUploadUsername = string;
		StorageTmp->xmonUploadUsernameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadUsername for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		if (StorageOld->xmonUploadUsername != NULL) {
			SNMP_FREE(StorageTmp->xmonUploadUsername);
			StorageTmp->xmonUploadUsername = StorageOld->xmonUploadUsername;
			StorageTmp->xmonUploadUsernameLen = StorageOld->xmonUploadUsernameLen;
			StorageOld->xmonUploadUsername = NULL;
			StorageOld->xmonUploadUsernameLen = 0;
		}
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadPassword(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadPassword(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadPassword entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadPassword: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadPassword not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadPassword: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"openss7\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonUploadPassword);
		StorageTmp->xmonUploadPassword = string;
		StorageTmp->xmonUploadPasswordLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadPassword for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		if (StorageOld->xmonUploadPassword != NULL) {
			SNMP_FREE(StorageTmp->xmonUploadPassword);
			StorageTmp->xmonUploadPassword = StorageOld->xmonUploadPassword;
			StorageTmp->xmonUploadPasswordLen = StorageOld->xmonUploadPasswordLen;
			StorageOld->xmonUploadPassword = NULL;
			StorageOld->xmonUploadPasswordLen = 0;
		}
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadPeriod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadPeriod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadPeriod entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadPeriod: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadPeriod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadPeriod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 90000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadPeriod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		StorageTmp->xmonUploadPeriod = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadPeriod for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		StorageTmp->xmonUploadPeriod = StorageOld->xmonUploadPeriod;
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadStartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadStartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadStartTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStartTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStartTime not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		StorageTmp->xmonUploadStartTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadStartTime for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		StorageTmp->xmonUploadStartTime = StorageOld->xmonUploadStartTime;
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadStopTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadStopTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadStopTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStopTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStopTime not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStopTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		StorageTmp->xmonUploadStopTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadStopTime for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		StorageTmp->xmonUploadStopTime = StorageOld->xmonUploadStopTime;
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadIntervalsOfDay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadIntervalsOfDay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadIntervalsOfDay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadIntervalsOfDay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadIntervalsOfDay not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadIntervalsOfDay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x17\x3B\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonUploadIntervalsOfDay);
		StorageTmp->xmonUploadIntervalsOfDay = string;
		StorageTmp->xmonUploadIntervalsOfDayLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadIntervalsOfDay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		if (StorageOld->xmonUploadIntervalsOfDay != NULL) {
			SNMP_FREE(StorageTmp->xmonUploadIntervalsOfDay);
			StorageTmp->xmonUploadIntervalsOfDay = StorageOld->xmonUploadIntervalsOfDay;
			StorageTmp->xmonUploadIntervalsOfDayLen = StorageOld->xmonUploadIntervalsOfDayLen;
			StorageOld->xmonUploadIntervalsOfDay = NULL;
			StorageOld->xmonUploadIntervalsOfDayLen = 0;
		}
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadWeekMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadWeekMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadWeekMask entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadWeekMask: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadWeekMask not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadWeekMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x7F\x01\x00\x00\x17\x3B\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonUploadWeekMask);
		StorageTmp->xmonUploadWeekMask = string;
		StorageTmp->xmonUploadWeekMaskLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadWeekMask for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		if (StorageOld->xmonUploadWeekMask != NULL) {
			SNMP_FREE(StorageTmp->xmonUploadWeekMask);
			StorageTmp->xmonUploadWeekMask = StorageOld->xmonUploadWeekMask;
			StorageTmp->xmonUploadWeekMaskLen = StorageOld->xmonUploadWeekMaskLen;
			StorageOld->xmonUploadWeekMask = NULL;
			StorageOld->xmonUploadWeekMaskLen = 0;
		}
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadOnRotation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadOnRotation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadOnRotation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadOnRotation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadOnRotation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadOnRotation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadOnRotation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		StorageTmp->xmonUploadOnRotation = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadOnRotation for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		StorageTmp->xmonUploadOnRotation = StorageOld->xmonUploadOnRotation;
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadSelection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadSelection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadSelection entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadSelection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadSelection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadSelection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONUPLOADSELECTION_NEW:
		case XMONUPLOADSELECTION_ROTATED:
		case XMONUPLOADSELECTION_SYNC:
		case XMONUPLOADSELECTION_ALL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadSelection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		StorageTmp->xmonUploadSelection = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadSelection for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		StorageTmp->xmonUploadSelection = StorageOld->xmonUploadSelection;
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unlocked */
		switch (set_value) {
		case XMONUPLOADADMINSTATE_LOCKED:
		case XMONUPLOADADMINSTATE_UNLOCKED:
		case XMONUPLOADADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		StorageTmp->xmonUploadAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		StorageTmp->xmonUploadAdminState = StorageOld->xmonUploadAdminState;
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonUploadStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadStorageType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonUploadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStorageType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStorageType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStorageType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value nonVolatile */
		switch (set_value) {
		case ST_OTHER:
		case ST_VOLATILE:
		case ST_NONVOLATILE:
		case ST_PERMANENT:
		case ST_READONLY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadStorageType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			if (StorageTmp->xmonUploadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonUploadTable_rsvs++;
		StorageTmp->xmonUploadStorageType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonUploadTable_tsts == 0)
				if ((ret = check_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonUploadStorageType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonUploadTable_sets == 0)
				if ((ret = update_xmonUploadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonUploadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			StorageTmp->xmonUploadTable_rsvs = 0;
			StorageTmp->xmonUploadTable_tsts = 0;
			StorageTmp->xmonUploadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonUploadTable_sets == 0)
			revert_xmonUploadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
			break;
		StorageTmp->xmonUploadStorageType = StorageOld->xmonUploadStorageType;
		if (--StorageTmp->xmonUploadTable_rsvs == 0)
			xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadSpec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadSpec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadSpec entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadSpec: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadSpec not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadSpec: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonDownloadSpec);
		StorageTmp->xmonDownloadSpec = string;
		StorageTmp->xmonDownloadSpecLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadSpec for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		if (StorageOld->xmonDownloadSpec != NULL) {
			SNMP_FREE(StorageTmp->xmonDownloadSpec);
			StorageTmp->xmonDownloadSpec = StorageOld->xmonDownloadSpec;
			StorageTmp->xmonDownloadSpecLen = StorageOld->xmonDownloadSpecLen;
			StorageOld->xmonDownloadSpec = NULL;
			StorageOld->xmonDownloadSpecLen = 0;
		}
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadUsername(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadUsername(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadUsername entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadUsername: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadUsername not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadUsername: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"unexicon\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonDownloadUsername);
		StorageTmp->xmonDownloadUsername = string;
		StorageTmp->xmonDownloadUsernameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadUsername for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		if (StorageOld->xmonDownloadUsername != NULL) {
			SNMP_FREE(StorageTmp->xmonDownloadUsername);
			StorageTmp->xmonDownloadUsername = StorageOld->xmonDownloadUsername;
			StorageTmp->xmonDownloadUsernameLen = StorageOld->xmonDownloadUsernameLen;
			StorageOld->xmonDownloadUsername = NULL;
			StorageOld->xmonDownloadUsernameLen = 0;
		}
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadPassword(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadPassword(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadPassword entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadPassword: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadPassword not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadPassword: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"unexicon\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonDownloadPassword);
		StorageTmp->xmonDownloadPassword = string;
		StorageTmp->xmonDownloadPasswordLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadPassword for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		if (StorageOld->xmonDownloadPassword != NULL) {
			SNMP_FREE(StorageTmp->xmonDownloadPassword);
			StorageTmp->xmonDownloadPassword = StorageOld->xmonDownloadPassword;
			StorageTmp->xmonDownloadPasswordLen = StorageOld->xmonDownloadPasswordLen;
			StorageOld->xmonDownloadPassword = NULL;
			StorageOld->xmonDownloadPasswordLen = 0;
		}
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadPeriod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadPeriod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadPeriod entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadPeriod: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadPeriod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadPeriod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 90000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadPeriod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		StorageTmp->xmonDownloadPeriod = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadPeriod for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		StorageTmp->xmonDownloadPeriod = StorageOld->xmonDownloadPeriod;
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadStartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadStartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadStartTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStartTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStartTime not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		StorageTmp->xmonDownloadStartTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadStartTime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		StorageTmp->xmonDownloadStartTime = StorageOld->xmonDownloadStartTime;
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadStopTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadStopTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadStopTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStopTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStopTime not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStopTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		StorageTmp->xmonDownloadStopTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadStopTime for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		StorageTmp->xmonDownloadStopTime = StorageOld->xmonDownloadStopTime;
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadIntervalsOfDay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadIntervalsOfDay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadIntervalsOfDay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadIntervalsOfDay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadIntervalsOfDay not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadIntervalsOfDay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x17\x3B\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonDownloadIntervalsOfDay);
		StorageTmp->xmonDownloadIntervalsOfDay = string;
		StorageTmp->xmonDownloadIntervalsOfDayLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadIntervalsOfDay for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		if (StorageOld->xmonDownloadIntervalsOfDay != NULL) {
			SNMP_FREE(StorageTmp->xmonDownloadIntervalsOfDay);
			StorageTmp->xmonDownloadIntervalsOfDay = StorageOld->xmonDownloadIntervalsOfDay;
			StorageTmp->xmonDownloadIntervalsOfDayLen = StorageOld->xmonDownloadIntervalsOfDayLen;
			StorageOld->xmonDownloadIntervalsOfDay = NULL;
			StorageOld->xmonDownloadIntervalsOfDayLen = 0;
		}
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadWeekMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadWeekMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadWeekMask entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadWeekMask: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadWeekMask not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadWeekMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x7F\x01\x00\x00\x17\x3B\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonDownloadWeekMask);
		StorageTmp->xmonDownloadWeekMask = string;
		StorageTmp->xmonDownloadWeekMaskLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadWeekMask for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		if (StorageOld->xmonDownloadWeekMask != NULL) {
			SNMP_FREE(StorageTmp->xmonDownloadWeekMask);
			StorageTmp->xmonDownloadWeekMask = StorageOld->xmonDownloadWeekMask;
			StorageTmp->xmonDownloadWeekMaskLen = StorageOld->xmonDownloadWeekMaskLen;
			StorageOld->xmonDownloadWeekMask = NULL;
			StorageOld->xmonDownloadWeekMaskLen = 0;
		}
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadOnRotation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadOnRotation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadOnRotation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadOnRotation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadOnRotation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadOnRotation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadOnRotation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		StorageTmp->xmonDownloadOnRotation = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadOnRotation for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		StorageTmp->xmonDownloadOnRotation = StorageOld->xmonDownloadOnRotation;
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadSelection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadSelection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadSelection entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadSelection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadSelection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadSelection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONDOWNLOADSELECTION_NEW:
		case XMONDOWNLOADSELECTION_ROTATED:
		case XMONDOWNLOADSELECTION_SYNC:
		case XMONDOWNLOADSELECTION_ALL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadSelection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		StorageTmp->xmonDownloadSelection = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadSelection for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		StorageTmp->xmonDownloadSelection = StorageOld->xmonDownloadSelection;
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unlocked */
		switch (set_value) {
		case XMONDOWNLOADADMINSTATE_LOCKED:
		case XMONDOWNLOADADMINSTATE_UNLOCKED:
		case XMONDOWNLOADADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		StorageTmp->xmonDownloadAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadAdminState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		StorageTmp->xmonDownloadAdminState = StorageOld->xmonDownloadAdminState;
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonDownloadStorageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadStorageType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonDownloadRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStorageType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStorageType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStorageType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value nonVolatile */
		switch (set_value) {
		case ST_OTHER:
		case ST_VOLATILE:
		case ST_NONVOLATILE:
		case ST_PERMANENT:
		case ST_READONLY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadStorageType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			if (StorageTmp->xmonDownloadTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonDownloadTable_rsvs++;
		StorageTmp->xmonDownloadStorageType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonDownloadTable_tsts == 0)
				if ((ret = check_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonDownloadStorageType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonDownloadTable_sets == 0)
				if ((ret = update_xmonDownloadTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonDownloadTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			StorageTmp->xmonDownloadTable_rsvs = 0;
			StorageTmp->xmonDownloadTable_tsts = 0;
			StorageTmp->xmonDownloadTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonDownloadTable_sets == 0)
			revert_xmonDownloadTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
			break;
		StorageTmp->xmonDownloadStorageType = StorageOld->xmonDownloadStorageType;
		if (--StorageTmp->xmonDownloadTable_rsvs == 0)
			xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpNoDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpNoDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpNoDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpNoDelay = StorageOld->xmonSctpNoDelay;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpMaxseg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpMaxseg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpMaxseg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpMaxseg = StorageOld->xmonSctpMaxseg;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpHeartbeatItvl entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpHeartbeatItvl: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpHeartbeatItvl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpHeartbeatItvl for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpHeartbeatItvl = StorageOld->xmonSctpHeartbeatItvl;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpHeartbeat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpHeartbeat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpHeartbeat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpHeartbeat for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpHeartbeat = StorageOld->xmonSctpHeartbeat;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpRtoInitial entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRtoInitial: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpRtoInitial = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpRtoInitial for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpRtoInitial = StorageOld->xmonSctpRtoInitial;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpRtoMin entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRtoMin: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpRtoMin = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpRtoMin = StorageOld->xmonSctpRtoMin;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpRtoMax entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRtoMax: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpRtoMax = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpRtoMax = StorageOld->xmonSctpRtoMax;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpPathMaxRetrans entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpPathMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpPathMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpPathMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpPathMaxRetrans = StorageOld->xmonSctpPathMaxRetrans;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpCookieLife entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpCookieLife: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpCookieLife = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpCookieLife for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpCookieLife = StorageOld->xmonSctpCookieLife;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpCookieInc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpCookieInc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpCookieInc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpCookieInc for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpCookieInc = StorageOld->xmonSctpCookieInc;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpMaxInitRetries entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpMaxInitRetries: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpMaxInitRetries = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpMaxInitRetries for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpMaxInitRetries = StorageOld->xmonSctpMaxInitRetries;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpMaxBurst entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpMaxBurst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpMaxBurst = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpMaxBurst for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpMaxBurst = StorageOld->xmonSctpMaxBurst;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpAssocMaxRetrans entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpAssocMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpAssocMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpAssocMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpAssocMaxRetrans = StorageOld->xmonSctpAssocMaxRetrans;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpSackDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpSackDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpSackDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpSackDelay for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpSackDelay = StorageOld->xmonSctpSackDelay;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_xmonSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpLifetime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->xmonSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpLifetime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			if (StorageTmp->xmonSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonSctpTable_rsvs++;
		StorageTmp->xmonSctpLifetime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->xmonSctpTable_tsts == 0)
				if ((ret = check_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpLifetime for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonSctpTable_sets == 0)
				if ((ret = update_xmonSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			StorageTmp->xmonSctpTable_rsvs = 0;
			StorageTmp->xmonSctpTable_tsts = 0;
			StorageTmp->xmonSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonSctpTable_sets == 0)
			revert_xmonSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
			break;
		StorageTmp->xmonSctpLifetime = StorageOld->xmonSctpLifetime;
		if (--StorageTmp->xmonSctpTable_rsvs == 0)
			xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonProbeName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonProbeName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonProbeName entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonProbeName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonProbeName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonProbeName);
		StorageTmp->xmonProbeName = string;
		StorageTmp->xmonProbeNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonProbeName for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonProbeName != NULL) {
			SNMP_FREE(StorageTmp->xmonProbeName);
			StorageTmp->xmonProbeName = StorageOld->xmonProbeName;
			StorageTmp->xmonProbeNameLen = StorageOld->xmonProbeNameLen;
			StorageOld->xmonProbeName = NULL;
			StorageOld->xmonProbeNameLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonProbeUuid(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonProbeUuid(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonProbeUuid entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonProbeUuid not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 16..16 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 16)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonProbeUuid: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonProbeUuid);
		StorageTmp->xmonProbeUuid = string;
		StorageTmp->xmonProbeUuidLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonProbeUuid for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonProbeUuid != NULL) {
			SNMP_FREE(StorageTmp->xmonProbeUuid);
			StorageTmp->xmonProbeUuid = StorageOld->xmonProbeUuid;
			StorageTmp->xmonProbeUuidLen = StorageOld->xmonProbeUuidLen;
			StorageOld->xmonProbeUuid = NULL;
			StorageOld->xmonProbeUuidLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonProbeHardware(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonProbeHardware(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonProbeHardware entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonProbeHardware not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonProbeHardware: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonProbeHardware);
		StorageTmp->xmonProbeHardware = string;
		StorageTmp->xmonProbeHardwareLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonProbeHardware for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonProbeHardware != NULL) {
			SNMP_FREE(StorageTmp->xmonProbeHardware);
			StorageTmp->xmonProbeHardware = StorageOld->xmonProbeHardware;
			StorageTmp->xmonProbeHardwareLen = StorageOld->xmonProbeHardwareLen;
			StorageOld->xmonProbeHardware = NULL;
			StorageOld->xmonProbeHardwareLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonProbeOs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonProbeOs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonProbeOs entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonProbeOs not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonProbeOs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonProbeOs);
		StorageTmp->xmonProbeOs = string;
		StorageTmp->xmonProbeOsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonProbeOs for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonProbeOs != NULL) {
			SNMP_FREE(StorageTmp->xmonProbeOs);
			StorageTmp->xmonProbeOs = StorageOld->xmonProbeOs;
			StorageTmp->xmonProbeOsLen = StorageOld->xmonProbeOsLen;
			StorageOld->xmonProbeOs = NULL;
			StorageOld->xmonProbeOsLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonBufferAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonBufferAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonBufferAdminState entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONBUFFERADMINSTATE_LOCKED:
		case XMONBUFFERADMINSTATE_UNLOCKED:
		case XMONBUFFERADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonBufferAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonBufferAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonBufferAdminState = StorageOld->xmonBufferAdminState;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonBufferFullAction(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonBufferFullAction(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonBufferFullAction entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferFullAction not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferFullAction: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value wrap */
		switch (set_value) {
		case XMONBUFFERFULLACTION_WRAP:
		case XMONBUFFERFULLACTION_HALT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferFullAction: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonBufferFullAction = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonBufferFullAction for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonBufferFullAction = StorageOld->xmonBufferFullAction;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonBufferMaxSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonBufferMaxSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonBufferMaxSize entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferMaxSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferMaxSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonBufferMaxSize = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonBufferMaxSize for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonBufferMaxSize = StorageOld->xmonBufferMaxSize;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonBufferMaxPackets(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonBufferMaxPackets(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonBufferMaxPackets entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferMaxPackets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferMaxPackets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonBufferMaxPackets = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonBufferMaxPackets for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonBufferMaxPackets = StorageOld->xmonBufferMaxPackets;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonBufferMaxTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonBufferMaxTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonBufferMaxTime entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferMaxTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferMaxTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferMaxTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonBufferMaxTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonBufferMaxTime for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonBufferMaxTime = StorageOld->xmonBufferMaxTime;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonBufferAlarmThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonBufferAlarmThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonBufferAlarmThreshold entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferAlarmThreshold not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferAlarmThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x64\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonBufferAlarmThreshold);
		StorageTmp->xmonBufferAlarmThreshold = string;
		StorageTmp->xmonBufferAlarmThresholdLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonBufferAlarmThreshold for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonBufferAlarmThreshold != NULL) {
			SNMP_FREE(StorageTmp->xmonBufferAlarmThreshold);
			StorageTmp->xmonBufferAlarmThreshold = StorageOld->xmonBufferAlarmThreshold;
			StorageTmp->xmonBufferAlarmThresholdLen = StorageOld->xmonBufferAlarmThresholdLen;
			StorageOld->xmonBufferAlarmThreshold = NULL;
			StorageOld->xmonBufferAlarmThresholdLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonBufferReset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonBufferReset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonBufferReset entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferReset not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferReset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value reset */
		switch (set_value) {
		case XMONBUFFERRESET_RESET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferReset: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonBufferReset = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonBufferReset for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonBufferReset = StorageOld->xmonBufferReset;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonBufferActionResult(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonBufferActionResult(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonBufferActionResult entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferActionResult not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferActionResult: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONBUFFERACTIONRESULT_SUCCESS:
		case XMONBUFFERACTIONRESULT_FAILURE:
		case XMONBUFFERACTIONRESULT_CLEAR:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonBufferActionResult: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonBufferActionResult = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonBufferActionResult for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonBufferActionResult = StorageOld->xmonBufferActionResult;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCapturePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCapturePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCapturePath entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCapturePath not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCapturePath: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"/var/local/openss7/xmon/spool/%P\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonCapturePath);
		StorageTmp->xmonCapturePath = string;
		StorageTmp->xmonCapturePathLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCapturePath for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonCapturePath != NULL) {
			SNMP_FREE(StorageTmp->xmonCapturePath);
			StorageTmp->xmonCapturePath = StorageOld->xmonCapturePath;
			StorageTmp->xmonCapturePathLen = StorageOld->xmonCapturePathLen;
			StorageOld->xmonCapturePath = NULL;
			StorageOld->xmonCapturePathLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCaptureFilename(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCaptureFilename(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCaptureFilename entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureFilename not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureFilename: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"xmon-%I-%Y-%M-%D-%h:%m:%s\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonCaptureFilename);
		StorageTmp->xmonCaptureFilename = string;
		StorageTmp->xmonCaptureFilenameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCaptureFilename for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonCaptureFilename != NULL) {
			SNMP_FREE(StorageTmp->xmonCaptureFilename);
			StorageTmp->xmonCaptureFilename = StorageOld->xmonCaptureFilename;
			StorageTmp->xmonCaptureFilenameLen = StorageOld->xmonCaptureFilenameLen;
			StorageOld->xmonCaptureFilename = NULL;
			StorageOld->xmonCaptureFilenameLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCaptureAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCaptureAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCaptureAdminState entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONCAPTUREADMINSTATE_LOCKED:
		case XMONCAPTUREADMINSTATE_UNLOCKED:
		case XMONCAPTUREADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCaptureAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCaptureAdminState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCaptureAdminState = StorageOld->xmonCaptureAdminState;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCaptureFullAction(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCaptureFullAction(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCaptureFullAction entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureFullAction not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureFullAction: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value wrap */
		switch (set_value) {
		case XMONCAPTUREFULLACTION_WRAP:
		case XMONCAPTUREFULLACTION_HALT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureFullAction: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCaptureFullAction = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCaptureFullAction for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCaptureFullAction = StorageOld->xmonCaptureFullAction;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCaptureMaxSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCaptureMaxSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCaptureMaxSize entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureMaxSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureMaxSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCaptureMaxSize = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCaptureMaxSize for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCaptureMaxSize = StorageOld->xmonCaptureMaxSize;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCaptureMaxPackets(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCaptureMaxPackets(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCaptureMaxPackets entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureMaxPackets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureMaxPackets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCaptureMaxPackets = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCaptureMaxPackets for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCaptureMaxPackets = StorageOld->xmonCaptureMaxPackets;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCaptureMaxTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCaptureMaxTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCaptureMaxTime entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureMaxTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureMaxTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureMaxTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCaptureMaxTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCaptureMaxTime for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCaptureMaxTime = StorageOld->xmonCaptureMaxTime;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCaptureAlarmThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCaptureAlarmThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCaptureAlarmThreshold entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureAlarmThreshold not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCaptureAlarmThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x64\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonCaptureAlarmThreshold);
		StorageTmp->xmonCaptureAlarmThreshold = string;
		StorageTmp->xmonCaptureAlarmThresholdLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCaptureAlarmThreshold for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonCaptureAlarmThreshold != NULL) {
			SNMP_FREE(StorageTmp->xmonCaptureAlarmThreshold);
			StorageTmp->xmonCaptureAlarmThreshold = StorageOld->xmonCaptureAlarmThreshold;
			StorageTmp->xmonCaptureAlarmThresholdLen = StorageOld->xmonCaptureAlarmThresholdLen;
			StorageOld->xmonCaptureAlarmThreshold = NULL;
			StorageOld->xmonCaptureAlarmThresholdLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonArchivePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonArchivePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonArchivePath entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchivePath not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonArchivePath: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"/var/local/openss7/xmon/spool/%P\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonArchivePath);
		StorageTmp->xmonArchivePath = string;
		StorageTmp->xmonArchivePathLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonArchivePath for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonArchivePath != NULL) {
			SNMP_FREE(StorageTmp->xmonArchivePath);
			StorageTmp->xmonArchivePath = StorageOld->xmonArchivePath;
			StorageTmp->xmonArchivePathLen = StorageOld->xmonArchivePathLen;
			StorageOld->xmonArchivePath = NULL;
			StorageOld->xmonArchivePathLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonFeedTypes(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedTypes entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedTypes not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedTypes: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedTypes: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { udp , tcp } */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonFeedTypes);
		StorageTmp->xmonFeedTypes = string;
		StorageTmp->xmonFeedTypesLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedTypes for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonFeedTypes != NULL) {
			SNMP_FREE(StorageTmp->xmonFeedTypes);
			StorageTmp->xmonFeedTypes = StorageOld->xmonFeedTypes;
			StorageTmp->xmonFeedTypesLen = StorageOld->xmonFeedTypesLen;
			StorageOld->xmonFeedTypes = NULL;
			StorageOld->xmonFeedTypesLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonFeedPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedPort entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5572 */
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedPort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonFeedPort = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonFeedPort for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonFeedPort = StorageOld->xmonFeedPort;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonPushPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushPort entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5573 */
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushPort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonPushPort = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPushPort for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonPushPort = StorageOld->xmonPushPort;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonPullPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullPort entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullPort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonPullPort = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullPort for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonPullPort = StorageOld->xmonPullPort;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullSpoolPath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonPullSpoolPath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullSpoolPath entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullSpoolPath not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullSpoolPath: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"/var/local/openss7/xmon/spool/%U\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPullSpoolPath);
		StorageTmp->xmonPullSpoolPath = string;
		StorageTmp->xmonPullSpoolPathLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullSpoolPath for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonPullSpoolPath != NULL) {
			SNMP_FREE(StorageTmp->xmonPullSpoolPath);
			StorageTmp->xmonPullSpoolPath = StorageOld->xmonPullSpoolPath;
			StorageTmp->xmonPullSpoolPathLen = StorageOld->xmonPullSpoolPathLen;
			StorageOld->xmonPullSpoolPath = NULL;
			StorageOld->xmonPullSpoolPathLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullArchivePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonPullArchivePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullArchivePath entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullArchivePath not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullArchivePath: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"/var/local/openss7/xmon/archive/%U\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonPullArchivePath);
		StorageTmp->xmonPullArchivePath = string;
		StorageTmp->xmonPullArchivePathLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonPullArchivePath for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonPullArchivePath != NULL) {
			SNMP_FREE(StorageTmp->xmonPullArchivePath);
			StorageTmp->xmonPullArchivePath = StorageOld->xmonPullArchivePath;
			StorageTmp->xmonPullArchivePathLen = StorageOld->xmonPullArchivePathLen;
			StorageOld->xmonPullArchivePath = NULL;
			StorageOld->xmonPullArchivePathLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorExtensions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorExtensions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorExtensions entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorExtensions not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorExtensions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorExtensions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonCollectorExtensions);
		StorageTmp->xmonCollectorExtensions = string;
		StorageTmp->xmonCollectorExtensionsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorExtensions for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonCollectorExtensions != NULL) {
			SNMP_FREE(StorageTmp->xmonCollectorExtensions);
			StorageTmp->xmonCollectorExtensions = StorageOld->xmonCollectorExtensions;
			StorageTmp->xmonCollectorExtensionsLen = StorageOld->xmonCollectorExtensionsLen;
			StorageOld->xmonCollectorExtensions = NULL;
			StorageOld->xmonCollectorExtensionsLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorAdminState entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unlocked */
		switch (set_value) {
		case XMONCOLLECTORADMINSTATE_LOCKED:
		case XMONCOLLECTORADMINSTATE_UNLOCKED:
		case XMONCOLLECTORADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCollectorAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorAdminState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCollectorAdminState = StorageOld->xmonCollectorAdminState;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorFullAction(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorFullAction(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorFullAction entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorFullAction not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorFullAction: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case XMONCOLLECTORFULLACTION_WRAP:
		case XMONCOLLECTORFULLACTION_HALT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorFullAction: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCollectorFullAction = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorFullAction for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCollectorFullAction = StorageOld->xmonCollectorFullAction;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorAlarmThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorAlarmThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorAlarmThreshold entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorAlarmThreshold not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorAlarmThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x64\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonCollectorAlarmThreshold);
		StorageTmp->xmonCollectorAlarmThreshold = string;
		StorageTmp->xmonCollectorAlarmThresholdLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorAlarmThreshold for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonCollectorAlarmThreshold != NULL) {
			SNMP_FREE(StorageTmp->xmonCollectorAlarmThreshold);
			StorageTmp->xmonCollectorAlarmThreshold = StorageOld->xmonCollectorAlarmThreshold;
			StorageTmp->xmonCollectorAlarmThresholdLen = StorageOld->xmonCollectorAlarmThresholdLen;
			StorageOld->xmonCollectorAlarmThreshold = NULL;
			StorageOld->xmonCollectorAlarmThresholdLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorCachePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorCachePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorCachePath entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorCachePath not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorCachePath: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"/var/local/openss7/xmon/cache/%U\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonCollectorCachePath);
		StorageTmp->xmonCollectorCachePath = string;
		StorageTmp->xmonCollectorCachePathLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorCachePath for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonCollectorCachePath != NULL) {
			SNMP_FREE(StorageTmp->xmonCollectorCachePath);
			StorageTmp->xmonCollectorCachePath = StorageOld->xmonCollectorCachePath;
			StorageTmp->xmonCollectorCachePathLen = StorageOld->xmonCollectorCachePathLen;
			StorageOld->xmonCollectorCachePath = NULL;
			StorageOld->xmonCollectorCachePathLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorSpoolPath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorSpoolPath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorSpoolPath entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorSpoolPath not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorSpoolPath: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"/var/local/openss7/xmon/spool/%U\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonCollectorSpoolPath);
		StorageTmp->xmonCollectorSpoolPath = string;
		StorageTmp->xmonCollectorSpoolPathLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorSpoolPath for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonCollectorSpoolPath != NULL) {
			SNMP_FREE(StorageTmp->xmonCollectorSpoolPath);
			StorageTmp->xmonCollectorSpoolPath = StorageOld->xmonCollectorSpoolPath;
			StorageTmp->xmonCollectorSpoolPathLen = StorageOld->xmonCollectorSpoolPathLen;
			StorageOld->xmonCollectorSpoolPath = NULL;
			StorageOld->xmonCollectorSpoolPathLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorArchivePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorArchivePath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorArchivePath entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorArchivePath not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..127 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 127))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorArchivePath: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"/var/local/openss7/xmon/spool/%U\" */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonCollectorArchivePath);
		StorageTmp->xmonCollectorArchivePath = string;
		StorageTmp->xmonCollectorArchivePathLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorArchivePath for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonCollectorArchivePath != NULL) {
			SNMP_FREE(StorageTmp->xmonCollectorArchivePath);
			StorageTmp->xmonCollectorArchivePath = StorageOld->xmonCollectorArchivePath;
			StorageTmp->xmonCollectorArchivePathLen = StorageOld->xmonCollectorArchivePathLen;
			StorageOld->xmonCollectorArchivePath = NULL;
			StorageOld->xmonCollectorArchivePathLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorArchiveSubdirs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorArchiveSubdirs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorArchiveSubdirs entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorArchiveSubdirs not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorArchiveSubdirs: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorArchiveSubdirs: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { daily , monthly } */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->xmonCollectorArchiveSubdirs);
		StorageTmp->xmonCollectorArchiveSubdirs = string;
		StorageTmp->xmonCollectorArchiveSubdirsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorArchiveSubdirs for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		if (StorageOld->xmonCollectorArchiveSubdirs != NULL) {
			SNMP_FREE(StorageTmp->xmonCollectorArchiveSubdirs);
			StorageTmp->xmonCollectorArchiveSubdirs = StorageOld->xmonCollectorArchiveSubdirs;
			StorageTmp->xmonCollectorArchiveSubdirsLen = StorageOld->xmonCollectorArchiveSubdirsLen;
			StorageOld->xmonCollectorArchiveSubdirs = NULL;
			StorageOld->xmonCollectorArchiveSubdirsLen = 0;
		}
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorCompression(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorCompression(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorCompression entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorCompression not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorCompression: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value xz */
		switch (set_value) {
		case XMONCOLLECTORCOMPRESSION_NONE:
		case XMONCOLLECTORCOMPRESSION_GZ:
		case XMONCOLLECTORCOMPRESSION_BZ2:
		case XMONCOLLECTORCOMPRESSION_XZ:
		case XMONCOLLECTORCOMPRESSION_ZIP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorCompression: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCollectorCompression = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorCompression for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCollectorCompression = StorageOld->xmonCollectorCompression;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorFileSystemAlloc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorFileSystemAlloc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorFileSystemAlloc entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorFileSystemAlloc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorFileSystemAlloc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 90 */
		/* Note: ranges 0..100 */
		if ((0 > set_value || set_value > 100)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorFileSystemAlloc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCollectorFileSystemAlloc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorFileSystemAlloc for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCollectorFileSystemAlloc = StorageOld->xmonCollectorFileSystemAlloc;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorMaxDiskUsage(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorMaxDiskUsage(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorMaxDiskUsage entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorMaxDiskUsage not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorMaxDiskUsage: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 0..100 */
		if ((0 > set_value || set_value > 100)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorMaxDiskUsage: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCollectorMaxDiskUsage = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorMaxDiskUsage for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCollectorMaxDiskUsage = StorageOld->xmonCollectorMaxDiskUsage;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonCollectorDiscardPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonCollectorDiscardPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonCollectorDiscardPolicy entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorDiscardPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorDiscardPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value ignore */
		switch (set_value) {
		case XMONCOLLECTORDISCARDPOLICY_IGNORE:
		case XMONCOLLECTORDISCARDPOLICY_OLDEST:
		case XMONCOLLECTORDISCARDPOLICY_LARGEST:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonCollectorDiscardPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonCollectorDiscardPolicy = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonCollectorDiscardPolicy for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonCollectorDiscardPolicy = StorageOld->xmonCollectorDiscardPolicy;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultNoDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultNoDelay = StorageOld->xmonSctpDefaultNoDelay;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 536 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultMaxseg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultMaxseg = StorageOld->xmonSctpDefaultMaxseg;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultHeartbeatItvl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultHeartbeatItvl for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultHeartbeatItvl = StorageOld->xmonSctpDefaultHeartbeatItvl;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultHeartbeat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultHeartbeat for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultHeartbeat = StorageOld->xmonSctpDefaultHeartbeat;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultRtoInitial = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultRtoInitial for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultRtoInitial = StorageOld->xmonSctpDefaultRtoInitial;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultRtoMin = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultRtoMin = StorageOld->xmonSctpDefaultRtoMin;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultRtoMax = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultRtoMax = StorageOld->xmonSctpDefaultRtoMax;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultPathMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultPathMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultPathMaxRetrans = StorageOld->xmonSctpDefaultPathMaxRetrans;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultCookieLife = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultCookieLife for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultCookieLife = StorageOld->xmonSctpDefaultCookieLife;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultCookieInc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultCookieInc for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultCookieInc = StorageOld->xmonSctpDefaultCookieInc;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultMaxInitRetries = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultMaxInitRetries for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultMaxInitRetries = StorageOld->xmonSctpDefaultMaxInitRetries;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultMaxBurst = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultMaxBurst for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultMaxBurst = StorageOld->xmonSctpDefaultMaxBurst;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultAssocMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultAssocMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultAssocMaxRetrans = StorageOld->xmonSctpDefaultAssocMaxRetrans;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultSackDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultSackDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultSackDelay = StorageOld->xmonSctpDefaultSackDelay;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpDefaultLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_xmonSctpDefaultLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpDefaultLifetime entering action=%d...  \n", action));
	if ((StorageTmp = xmonMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpDefaultLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			if (StorageTmp->xmonMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->xmonMIB_old = xmonMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->xmonMIB_rsvs++;
		StorageTmp->xmonSctpDefaultLifetime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->xmonMIB_tsts == 0)
				if ((ret = check_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->xmonSctpDefaultLifetime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->xmonMIB_sets == 0)
				if ((ret = update_xmonMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->xmonMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->xmonMIB_old) != NULL) {
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
			StorageTmp->xmonMIB_rsvs = 0;
			StorageTmp->xmonMIB_tsts = 0;
			StorageTmp->xmonMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->xmonMIB_tsts == 0)
			revert_xmonMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->xmonMIB_old) == NULL)
			break;
		StorageTmp->xmonSctpDefaultLifetime = StorageOld->xmonSctpDefaultLifetime;
		if (--StorageTmp->xmonMIB_rsvs == 0)
			xmonMIB_destroy(&StorageTmp->xmonMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonInterfaceTable_row(struct xmonInterfaceTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonRmonTable_row(struct xmonRmonTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonFeedListenTable_row(struct xmonFeedListenTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonFeedTable_row(struct xmonFeedTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonPushListenTable_row(struct xmonPushListenTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonPushTable_row(struct xmonPushTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonPushTable_row(struct xmonPushTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonPushTable_row(struct xmonPushTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonPushTable_row(struct xmonPushTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonPullListenTable_row(struct xmonPullListenTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonPullTable_row(struct xmonPullTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonPullTable_row(struct xmonPullTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonPullTable_row(struct xmonPullTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonPullTable_row(struct xmonPullTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonUploadTable_row(struct xmonUploadTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonDownloadTable_row(struct xmonDownloadTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_xmonSctpTable_row(struct xmonSctpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonInterfaceRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonInterfaceRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonInterfaceTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonInterfaceRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonInterfaceRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonSourceIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonSourceIndex */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonSourceIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 0..65535 */
			if ((0 > (long) *vp->val.integer || (long) *vp->val.integer > 65535)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonSourceIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonInterfaceTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonInterfaceTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonSourceIndex = (long) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonInterfaceTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonInterfaceRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonInterfaceTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
				if (StorageTmp->xmonInterfaceTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonInterfaceTable_old = xmonInterfaceTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonInterfaceTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonInterfaceTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonInterfaceTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonInterfaceTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonInterfaceRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonInterfaceTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonInterfaceRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonInterfaceTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonInterfaceRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonInterfaceTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonInterfaceRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonInterfaceTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonInterfaceRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonInterfaceTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonInterfaceRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonInterfaceTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonInterfaceTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonInterfaceRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonInterfaceRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonInterfaceRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonInterfaceTable_old) != NULL) {
				xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
				StorageTmp->xmonInterfaceTable_rsvs = 0;
				StorageTmp->xmonInterfaceTable_tsts = 0;
				StorageTmp->xmonInterfaceTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonInterfaceTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonInterfaceTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonInterfaceRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonInterfaceTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonInterfaceRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonInterfaceTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonInterfaceTable_del(StorageNew);
				xmonInterfaceTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonInterfaceTable_old) == NULL)
				break;
			if (--StorageTmp->xmonInterfaceTable_rsvs == 0)
				xmonInterfaceTable_destroy(&StorageTmp->xmonInterfaceTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonInterfaceTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonRmonRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonRmonRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonRmonTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonRmonTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonRmonRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonRmonTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonRmonRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonSourceIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonSourceIndex */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonSourceIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 0..65535 */
			if ((0 > (long) *vp->val.integer || (long) *vp->val.integer > 65535)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonSourceIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonRmonTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonRmonTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonSourceIndex = (long) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonRmonTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonRmonRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonRmonTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
				if (StorageTmp->xmonRmonTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonRmonTable_old = xmonRmonTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonRmonTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonRmonTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonRmonTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonRmonTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonRmonRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonRmonTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonRmonRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonRmonTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonRmonRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonRmonTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonRmonRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable 
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonRmonTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonRmonRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonRmonTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonRmonRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonRmonTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonRmonTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonRmonRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonRmonRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonRmonRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonRmonTable_old) != NULL) {
				xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
				StorageTmp->xmonRmonTable_rsvs = 0;
				StorageTmp->xmonRmonTable_tsts = 0;
				StorageTmp->xmonRmonTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonRmonTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonRmonTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonRmonRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonRmonTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonRmonRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonRmonTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonRmonTable_del(StorageNew);
				xmonRmonTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonRmonTable_old) == NULL)
				break;
			if (--StorageTmp->xmonRmonTable_rsvs == 0)
				xmonRmonTable_destroy(&StorageTmp->xmonRmonTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonRmonTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedListenRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonFeedListenRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedListenTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonFeedListenTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedListenRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonFeedListenTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedListenRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedListenRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonFeedListenIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonFeedListenIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonFeedListenIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonFeedListenTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonFeedListenTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonFeedListenIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonFeedListenTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonFeedListenRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonFeedListenTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonFeedListenTable_old) == NULL)
				if (StorageTmp->xmonFeedListenTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonFeedListenTable_old = xmonFeedListenTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonFeedListenTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonFeedListenTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonFeedListenTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonFeedListenTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonFeedListenRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonFeedListenTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonFeedListenRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonFeedListenTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonFeedListenRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonFeedListenTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonFeedListenRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonFeedListenTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonFeedListenRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonFeedListenTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonFeedListenRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonFeedListenTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonFeedListenTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonFeedListenRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonFeedListenRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonFeedListenRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonFeedListenTable_old) != NULL) {
				xmonFeedListenTable_destroy(&StorageTmp->xmonFeedListenTable_old);
				StorageTmp->xmonFeedListenTable_rsvs = 0;
				StorageTmp->xmonFeedListenTable_tsts = 0;
				StorageTmp->xmonFeedListenTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonFeedListenTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonFeedListenTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonFeedListenRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonFeedListenTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonFeedListenRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonFeedListenTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonFeedListenTable_del(StorageNew);
				xmonFeedListenTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonFeedListenTable_old) == NULL)
				break;
			if (--StorageTmp->xmonFeedListenTable_rsvs == 0)
				xmonFeedListenTable_destroy(&StorageTmp->xmonFeedListenTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonFeedListenTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonFeedRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonFeedRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonFeedTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonFeedTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonFeedRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonFeedTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonFeedRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonFeedIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonFeedIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonFeedIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonFeedTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonFeedTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonFeedIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonFeedTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonFeedRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonFeedTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
				if (StorageTmp->xmonFeedTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonFeedTable_old = xmonFeedTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonFeedTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonFeedTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonFeedTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonFeedTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonFeedRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonFeedTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonFeedRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonFeedTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonFeedRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonFeedTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonFeedRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable 
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonFeedTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonFeedRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonFeedTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonFeedRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonFeedTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonFeedTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonFeedRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonFeedRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonFeedRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonFeedTable_old) != NULL) {
				xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
				StorageTmp->xmonFeedTable_rsvs = 0;
				StorageTmp->xmonFeedTable_tsts = 0;
				StorageTmp->xmonFeedTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonFeedTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonFeedTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonFeedRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonFeedTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonFeedRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonFeedTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonFeedTable_del(StorageNew);
				xmonFeedTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonFeedTable_old) == NULL)
				break;
			if (--StorageTmp->xmonFeedTable_rsvs == 0)
				xmonFeedTable_destroy(&StorageTmp->xmonFeedTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonFeedTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushListenRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonPushListenRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushListenTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonPushListenTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushListenRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonPushListenTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushListenRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushListenRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonPushListenIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonPushListenIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonPushListenIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonPushListenTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonPushListenTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonPushListenIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonPushListenTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonPushListenRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonPushListenTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonPushListenTable_old) == NULL)
				if (StorageTmp->xmonPushListenTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonPushListenTable_old = xmonPushListenTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonPushListenTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonPushListenTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonPushListenTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonPushListenTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonPushListenRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonPushListenTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonPushListenRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonPushListenTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonPushListenRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonPushListenTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonPushListenRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonPushListenTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonPushListenRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonPushListenTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonPushListenRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonPushListenTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonPushListenTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonPushListenRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonPushListenRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonPushListenRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonPushListenTable_old) != NULL) {
				xmonPushListenTable_destroy(&StorageTmp->xmonPushListenTable_old);
				StorageTmp->xmonPushListenTable_rsvs = 0;
				StorageTmp->xmonPushListenTable_tsts = 0;
				StorageTmp->xmonPushListenTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonPushListenTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonPushListenTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonPushListenRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonPushListenTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonPushListenRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonPushListenTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonPushListenTable_del(StorageNew);
				xmonPushListenTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonPushListenTable_old) == NULL)
				break;
			if (--StorageTmp->xmonPushListenTable_rsvs == 0)
				xmonPushListenTable_destroy(&StorageTmp->xmonPushListenTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonPushListenTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPushRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonPushRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPushTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonPushTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonPushRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonPushTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPushRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonPushIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonPushIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonPushIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonPushTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonPushTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonPushIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonPushTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonPushRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonPushTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
				if (StorageTmp->xmonPushTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonPushTable_old = xmonPushTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonPushTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonPushTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonPushTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonPushTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonPushRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonPushTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonPushRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonPushTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonPushRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonPushTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonPushRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable 
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonPushTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonPushRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonPushTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonPushRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonPushTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonPushTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonPushRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonPushRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonPushRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonPushTable_old) != NULL) {
				xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
				StorageTmp->xmonPushTable_rsvs = 0;
				StorageTmp->xmonPushTable_tsts = 0;
				StorageTmp->xmonPushTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonPushTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonPushTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonPushRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonPushTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonPushRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonPushTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonPushTable_del(StorageNew);
				xmonPushTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonPushTable_old) == NULL)
				break;
			if (--StorageTmp->xmonPushTable_rsvs == 0)
				xmonPushTable_destroy(&StorageTmp->xmonPushTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonPushTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullListenRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonPullListenRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullListenTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonPullListenTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullListenRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonPullListenTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullListenRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullListenRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonPullListenIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonPullListenIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonPullListenIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonPullListenTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonPullListenTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonPullListenIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonPullListenTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonPullListenRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonPullListenTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonPullListenTable_old) == NULL)
				if (StorageTmp->xmonPullListenTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonPullListenTable_old = xmonPullListenTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonPullListenTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonPullListenTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonPullListenTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonPullListenTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonPullListenRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonPullListenTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonPullListenRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonPullListenTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonPullListenRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonPullListenTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonPullListenRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonPullListenTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonPullListenRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonPullListenTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonPullListenRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonPullListenTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonPullListenTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonPullListenRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonPullListenRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonPullListenRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonPullListenTable_old) != NULL) {
				xmonPullListenTable_destroy(&StorageTmp->xmonPullListenTable_old);
				StorageTmp->xmonPullListenTable_rsvs = 0;
				StorageTmp->xmonPullListenTable_tsts = 0;
				StorageTmp->xmonPullListenTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonPullListenTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonPullListenTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonPullListenRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonPullListenTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonPullListenRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonPullListenTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonPullListenTable_del(StorageNew);
				xmonPullListenTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonPullListenTable_old) == NULL)
				break;
			if (--StorageTmp->xmonPullListenTable_rsvs == 0)
				xmonPullListenTable_destroy(&StorageTmp->xmonPullListenTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonPullListenTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonPullRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonPullRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonPullTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonPullTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonPullRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonPullTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonPullRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonPullIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonPullIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonPullIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonPullTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonPullTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonPullIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonPullTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonPullRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonPullTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
				if (StorageTmp->xmonPullTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonPullTable_old = xmonPullTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonPullTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonPullTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonPullTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonPullTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonPullRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonPullTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonPullRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonPullTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonPullRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonPullTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonPullRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable 
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonPullTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonPullRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonPullTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonPullRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonPullTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonPullTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonPullRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonPullRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonPullRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonPullTable_old) != NULL) {
				xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
				StorageTmp->xmonPullTable_rsvs = 0;
				StorageTmp->xmonPullTable_tsts = 0;
				StorageTmp->xmonPullTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonPullTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonPullTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonPullRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonPullTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonPullRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonPullTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonPullTable_del(StorageNew);
				xmonPullTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonPullTable_old) == NULL)
				break;
			if (--StorageTmp->xmonPullTable_rsvs == 0)
				xmonPullTable_destroy(&StorageTmp->xmonPullTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonPullTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonUploadRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonUploadRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonUploadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonUploadTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonUploadRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonUploadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonUploadRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonUploadIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonUploadIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonUploadIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonUploadTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonUploadTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonUploadIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonUploadTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonUploadRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonUploadTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
				if (StorageTmp->xmonUploadTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonUploadTable_old = xmonUploadTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonUploadTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonUploadTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonUploadTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonUploadTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonUploadRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonUploadTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonUploadRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonUploadTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonUploadRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonUploadTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonUploadRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonUploadTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonUploadRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonUploadTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonUploadRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonUploadTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonUploadTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonUploadRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonUploadRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonUploadRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonUploadTable_old) != NULL) {
				xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
				StorageTmp->xmonUploadTable_rsvs = 0;
				StorageTmp->xmonUploadTable_tsts = 0;
				StorageTmp->xmonUploadTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonUploadTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonUploadTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonUploadRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonUploadTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonUploadRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonUploadTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonUploadTable_del(StorageNew);
				xmonUploadTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonUploadTable_old) == NULL)
				break;
			if (--StorageTmp->xmonUploadTable_rsvs == 0)
				xmonUploadTable_destroy(&StorageTmp->xmonUploadTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonUploadTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonDownloadRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonDownloadRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonDownloadTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonDownloadTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonDownloadRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonDownloadTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonDownloadRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonDownloadIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonDownloadIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonDownloadIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonDownloadTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonDownloadTable_rsvs = 1;
			vp = vars;
			StorageNew->xmonDownloadIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&xmonDownloadTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonDownloadRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonDownloadTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
				if (StorageTmp->xmonDownloadTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonDownloadTable_old = xmonDownloadTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonDownloadTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonDownloadTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonDownloadTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonDownloadTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonDownloadRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonDownloadTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonDownloadRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonDownloadTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonDownloadRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonDownloadTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonDownloadRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonDownloadTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonDownloadRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonDownloadTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonDownloadRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonDownloadTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonDownloadTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonDownloadRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonDownloadRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonDownloadRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonDownloadTable_old) != NULL) {
				xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
				StorageTmp->xmonDownloadTable_rsvs = 0;
				StorageTmp->xmonDownloadTable_tsts = 0;
				StorageTmp->xmonDownloadTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonDownloadTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonDownloadTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonDownloadRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonDownloadTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonDownloadRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonDownloadTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonDownloadTable_del(StorageNew);
				xmonDownloadTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonDownloadTable_old) == NULL)
				break;
			if (--StorageTmp->xmonDownloadTable_rsvs == 0)
				xmonDownloadTable_destroy(&StorageTmp->xmonDownloadTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonDownloadTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_xmonSctpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_xmonSctpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct xmonSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct xmonSctpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("xmonMIB", "write_xmonSctpRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(xmonSctpTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to xmonSctpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* xmonSctpProfileName */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* xmonSctpProfileName */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index xmonSctpProfileName: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = xmonSctpTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->xmonSctpTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->xmonSctpProfileName, vp->val.string, vp->val_len);
			StorageNew->xmonSctpProfileNameLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&xmonSctpTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->xmonSctpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->xmonSctpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
				if (StorageTmp->xmonSctpTable_rsvs == 0)
					if ((StorageOld = StorageTmp->xmonSctpTable_old = xmonSctpTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->xmonSctpTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->xmonSctpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				xmonSctpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_xmonSctpTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->xmonSctpRowStatus != RS_ACTIVE)
				if ((ret = can_act_xmonSctpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->xmonSctpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonSctpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->xmonSctpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_xmonSctpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->xmonSctpRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable 
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_xmonSctpTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->xmonSctpRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_xmonSctpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->xmonSctpRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_xmonSctpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_xmonSctpTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->xmonSctpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->xmonSctpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->xmonSctpRowStatus = set_value;
			if ((StorageOld = StorageTmp->xmonSctpTable_old) != NULL) {
				xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
				StorageTmp->xmonSctpTable_rsvs = 0;
				StorageTmp->xmonSctpTable_tsts = 0;
				StorageTmp->xmonSctpTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			xmonSctpTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_xmonSctpTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->xmonSctpRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_xmonSctpTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->xmonSctpRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_xmonSctpTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				xmonSctpTable_del(StorageNew);
				xmonSctpTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->xmonSctpTable_old) == NULL)
				break;
			if (--StorageTmp->xmonSctpTable_rsvs == 0)
				xmonSctpTable_destroy(&StorageTmp->xmonSctpTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				xmonSctpTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn void xmonMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
xmonMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("xmonMIB", "xmonMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (xmonMIBold_signal_handler != NULL)
		(*xmonMIBold_signal_handler) (sig);
	DEBUGMSGTL(("xmonMIB", "done.\n"));
}

/**
 * @fn void xmonMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
xmonMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("xmonMIB", "xmonMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("xmonMIB", "done.\n"));
	return;
}
