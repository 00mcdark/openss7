/*****************************************************************************

 @(#) src/snmp/isupMIB.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] = "src/snmp/isupMIB.c (" PACKAGE_ENVR ") " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NETSNMP_MEMDUP
#include "ucd_memdup.h"
#endif
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "isupMIB.h"
#define MASTER 1
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "isupMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int isupMIB_refresh = 1;
volatile int isupMsTable_refresh = 1;
volatile int isupPgTable_refresh = 1;
volatile int isupPuTable_refresh = 1;
volatile int isupLgTable_refresh = 1;
volatile int isupMtpTable_refresh = 1;
volatile int isupNaTable_refresh = 1;
volatile int isupSpTable_refresh = 1;
volatile int isupSrTable_refresh = 1;
volatile int isupRtTable_refresh = 1;
volatile int isupRtTgSelectionTable_refresh = 1;
volatile int isupTgTable_refresh = 1;
volatile int isupCgTable_refresh = 1;
volatile int isupCtTable_refresh = 1;

/*
 * isupMIB_variables_oid: object identifier for isupMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid isupMIB_variables_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3 };
oid isupMsTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 1, 1, 1 };
oid isupPgTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 2, 1, 1 };
oid isupPuTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 3, 1, 1 };
oid isupLgTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 4, 1, 1 };
oid isupMtpTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 5, 1, 1 };
oid isupNaTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 6, 1, 1 };
oid isupSpTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 7, 1, 1 };
oid isupSrTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 8, 1, 1 };
oid isupRtTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 9, 1, 1 };
oid isupRtTgSelectionTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 10, 1, 1 };
oid isupTgTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 11, 1, 1 };
oid isupCgTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 12, 1, 1 };
oid isupCtTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 1, 13, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */

/*
 * Oids accessible only for notify defined in this MIB.
 */

/*
 * Other oids defined in this MIB.
 */
oid t17Timeout_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1201 };
oid t23Timeout_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1202 };
oid t5Timeout_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1205 };
oid abnormalRelease_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1206 };
oid hardwareBlocking_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1207 };
oid missingCGBA_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1208 };
oid missingCGUA_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1209 };
oid abnormalCGBA_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1210 };
oid abnormalCGUA_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1211 };
oid unexpectedCGBA_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1212 };
oid unexpectedCGUA_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1213 };
oid unexpectedBLA_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1214 };
oid unexpectedUBA_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1215 };
oid t13Timeout_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1216 };
oid t15Timeout_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1217 };
oid t19Timeout_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1218 };
oid t21Timeout_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1219 };
oid messageFormatError_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1220 };
oid unexpectedMessage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1221 };
oid unrecInfoRelease_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1222 };
oid unableToRelease_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 1, 4, 4, 1223 };
oid isupFullCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 2, 1, 1 };
oid isupObjectGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 3, 2, 2, 1 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 isupMIB_variables: tree for isupMIB
 * This variable defines function callbacks and type return information for the isupMIB mib section
 */
struct variable7 isupMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   ISUPMSNAME            1
	{(u_char) ISUPMSNAME, ASN_OCTET_STR, RWRITE, var_isupMsTable, 6, {1, 1, 1, 1, 1, 2}},
#define   ISUPMSALARMSTATUS     2
	{(u_char) ISUPMSALARMSTATUS, ASN_OCTET_STR, RWRITE, var_isupMsTable, 6, {1, 1, 1, 1, 1, 3}},
#define   ISUPMSOPERATIONALSTATE  3
	{(u_char) ISUPMSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 4}},
#define   ISUPMSUSAGESTATE      4
	{(u_char) ISUPMSUSAGESTATE, ASN_INTEGER, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 5}},
#define   ISUPMSVENDORNAME      5
	{(u_char) ISUPMSVENDORNAME, ASN_OCTET_STR, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 6}},
#define   ISUPMSUSERLABEL       6
	{(u_char) ISUPMSUSERLABEL, ASN_OCTET_STR, RWRITE, var_isupMsTable, 6, {1, 1, 1, 1, 1, 7}},
#define   ISUPMSVERSION         7
	{(u_char) ISUPMSVERSION, ASN_OCTET_STR, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 8}},
#define   ISUPMSLOCATIONNAME    8
	{(u_char) ISUPMSLOCATIONNAME, ASN_OCTET_STR, RWRITE, var_isupMsTable, 6, {1, 1, 1, 1, 1, 9}},
#define   ISUPMSPRIMARYTIMINGSOURCE  9
	{(u_char) ISUPMSPRIMARYTIMINGSOURCE, ASN_INTEGER, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 10}},
#define   ISUPMSPRIMARYTIMINGOBJECT  10
	{(u_char) ISUPMSPRIMARYTIMINGOBJECT, ASN_OBJECT_ID, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 11}},
#define   ISUPMSSECONDARYTIMINGSOURCE  11
	{(u_char) ISUPMSSECONDARYTIMINGSOURCE, ASN_INTEGER, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 12}},
#define   ISUPMSSECONDARYTIMINGOBJECT  12
	{(u_char) ISUPMSSECONDARYTIMINGOBJECT, ASN_OBJECT_ID, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 13}},
#define   ISUPMSASAPROFILEPOINTER  13
	{(u_char) ISUPMSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_isupMsTable, 6, {1, 1, 1, 1, 1, 14}},
#define   ISUPMSMANAGEDELEMENTTYPE  14
	{(u_char) ISUPMSMANAGEDELEMENTTYPE, ASN_OCTET_STR, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 15}},
#define   ISUPMSMODELCODE       15
	{(u_char) ISUPMSMODELCODE, ASN_OCTET_STR, RONLY, var_isupMsTable, 6, {1, 1, 1, 1, 1, 16}},
#define   ISUPMSNETWORKELEMENTALIASES  16
	{(u_char) ISUPMSNETWORKELEMENTALIASES, ASN_OCTET_STR, RWRITE, var_isupMsTable, 6, {1, 1, 1, 1, 1, 17}},
#define   ISUPMSROWSTATUS       17
	{(u_char) ISUPMSROWSTATUS, ASN_INTEGER, RWRITE, var_isupMsTable, 6, {1, 1, 1, 1, 1, 18}},
#define   ISUPPGOPERSTATE       18
	{(u_char) ISUPPGOPERSTATE, ASN_INTEGER, RONLY, var_isupPgTable, 6, {1, 1, 2, 1, 1, 2}},
#define   ISUPPGAVAILSTATUS     19
	{(u_char) ISUPPGAVAILSTATUS, ASN_OCTET_STR, RONLY, var_isupPgTable, 6, {1, 1, 2, 1, 1, 3}},
#define   ISUPPGTYPE            20
	{(u_char) ISUPPGTYPE, ASN_INTEGER, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 4}},
#define   ISUPPGREVERTIVE       21
	{(u_char) ISUPPGREVERTIVE, ASN_INTEGER, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 5}},
#define   ISUPPGSUPPORTEDBYOBJECTLIST  22
	{(u_char) ISUPPGSUPPORTEDBYOBJECTLIST, ASN_OBJECT_ID, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 6}},
#define   ISUPPGWAITTORESTORETIME  23
	{(u_char) ISUPPGWAITTORESTORETIME, ASN_INTEGER, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 7}},
#define   ISUPPGSETTINGWINDOWTIME  24
	{(u_char) ISUPPGSETTINGWINDOWTIME, ASN_INTEGER, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 8}},
#define   ISUPPGRELEASINGWINDOWTIME  25
	{(u_char) ISUPPGRELEASINGWINDOWTIME, ASN_INTEGER, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 9}},
#define   ISUPPGHITSCOUNT       26
	{(u_char) ISUPPGHITSCOUNT, ASN_UNSIGNED, RONLY, var_isupPgTable, 6, {1, 1, 2, 1, 1, 10}},
#define   ISUPPGSWITCHTYPE      27
	{(u_char) ISUPPGSWITCHTYPE, ASN_INTEGER, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 11}},
#define   ISUPPGPROTECTEDUNITS  28
	{(u_char) ISUPPGPROTECTEDUNITS, ASN_OCTET_STR, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 12}},
#define   ISUPPGPROTECTINGUNITS  29
	{(u_char) ISUPPGPROTECTINGUNITS, ASN_OCTET_STR, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 13}},
#define   ISUPPGINVOKEPROTECTION  30
	{(u_char) ISUPPGINVOKEPROTECTION, ASN_INTEGER, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 14}},
#define   ISUPPGRELEASEPROTECTION  31
	{(u_char) ISUPPGRELEASEPROTECTION, ASN_INTEGER, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 15}},
#define   ISUPPGROWSTATUS       32
	{(u_char) ISUPPGROWSTATUS, ASN_INTEGER, RWRITE, var_isupPgTable, 6, {1, 1, 2, 1, 1, 16}},
#define   ISUPPUPROTECTING      33
	{(u_char) ISUPPUPROTECTING, ASN_INTEGER, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 2}},
#define   ISUPPURELIABLERESOURCEPOINTER  34
	{(u_char) ISUPPURELIABLERESOURCEPOINTER, ASN_OBJECT_ID, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 3}},
#define   ISUPPUUNRELIABLERESOURCEPOINTER  35
	{(u_char) ISUPPUUNRELIABLERESOURCEPOINTER, ASN_OBJECT_ID, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 4}},
#define   ISUPPUPROTECTIONSTATUS  36
	{(u_char) ISUPPUPROTECTIONSTATUS, ASN_OCTET_STR, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 5}},
#define   ISUPPUSWITCHSTATUS    37
	{(u_char) ISUPPUSWITCHSTATUS, ASN_INTEGER, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 6}},
#define   ISUPPUFROMPROTECTIONUNITNUMBER  38
	{(u_char) ISUPPUFROMPROTECTIONUNITNUMBER, ASN_UNSIGNED, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 7}},
#define   ISUPPUTOPROTECTIONUNITNUMBER  39
	{(u_char) ISUPPUTOPROTECTIONUNITNUMBER, ASN_UNSIGNED, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 8}},
#define   ISUPPUAUTOSWITCHREASON  40
	{(u_char) ISUPPUAUTOSWITCHREASON, ASN_INTEGER, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 9}},
#define   ISUPPULOCKOUTRELEASEFAILED  41
	{(u_char) ISUPPULOCKOUTRELEASEFAILED, ASN_INTEGER, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 10}},
#define   ISUPPUPRIORITY        42
	{(u_char) ISUPPUPRIORITY, ASN_UNSIGNED, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 11}},
#define   ISUPPUROWSTATUS       43
	{(u_char) ISUPPUROWSTATUS, ASN_INTEGER, RWRITE, var_isupPuTable, 6, {1, 1, 3, 1, 1, 12}},
#define   ISUPLGOPERATIONALSTATE  44
	{(u_char) ISUPLGOPERATIONALSTATE, ASN_INTEGER, RONLY, var_isupLgTable, 6, {1, 1, 4, 1, 1, 2}},
#define   ISUPLGADMINISTRATIVESTATE  45
	{(u_char) ISUPLGADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_isupLgTable, 6, {1, 1, 4, 1, 1, 3}},
#define   ISUPLGSNSERVICEPROVIDER  46
	{(u_char) ISUPLGSNSERVICEPROVIDER, ASN_OBJECT_ID, RWRITE, var_isupLgTable, 6, {1, 1, 4, 1, 1, 4}},
#define   ISUPLGSNSAP           47
	{(u_char) ISUPLGSNSAP, ASN_OBJECT_ID, RWRITE, var_isupLgTable, 6, {1, 1, 4, 1, 1, 5}},
#define   ISUPLGOPERATIONALPROTOCOLS  48
	{(u_char) ISUPLGOPERATIONALPROTOCOLS, ASN_OCTET_STR, RWRITE, var_isupLgTable, 6, {1, 1, 4, 1, 1, 6}},
#define   ISUPLGOPERATIONALSUBSETS  49
	{(u_char) ISUPLGOPERATIONALSUBSETS, ASN_OCTET_STR, RWRITE, var_isupLgTable, 6, {1, 1, 4, 1, 1, 7}},
#define   ISUPLGROWSTATUS       50
	{(u_char) ISUPLGROWSTATUS, ASN_INTEGER, RWRITE, var_isupLgTable, 6, {1, 1, 4, 1, 1, 8}},
#define   ISUPMTPADDRESS        51
	{(u_char) ISUPMTPADDRESS, ASN_OCTET_STR, RONLY, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 2}},
#define   ISUPMTPUSERPART       52
	{(u_char) ISUPMTPUSERPART, ASN_INTEGER, RWRITE, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 3}},
#define   ISUPMTPUSERPARTSTATUS  53
	{(u_char) ISUPMTPUSERPARTSTATUS, ASN_INTEGER, RWRITE, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 4}},
#define   ISUPMTPUSERENTITYNAMES  54
	{(u_char) ISUPMTPUSERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 5}},
#define   ISUPMTPPROVIDERENTITYNAMES  55
	{(u_char) ISUPMTPPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 6}},
#define   ISUPMTPUSAGESTATE     56
	{(u_char) ISUPMTPUSAGESTATE, ASN_INTEGER, RONLY, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 7}},
#define   ISUPMTPASAPROFILEPOINTER  57
	{(u_char) ISUPMTPASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 8}},
#define   ISUPMTPNAME           58
	{(u_char) ISUPMTPNAME, ASN_OCTET_STR, RWRITE, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 9}},
#define   ISUPMTPLONGMESSAGESUPPORTED  59
	{(u_char) ISUPMTPLONGMESSAGESUPPORTED, ASN_INTEGER, RWRITE, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 10}},
#define   ISUPMTPROWSTATUS      60
	{(u_char) ISUPMTPROWSTATUS, ASN_INTEGER, RWRITE, var_isupMtpTable, 6, {1, 1, 5, 1, 1, 11}},
#define   ISUPNAPROTOCOLVARIANT  61
	{(u_char) ISUPNAPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_isupNaTable, 6, {1, 1, 6, 1, 1, 2}},
#define   ISUPNAPROTOCOLYEAR    62
	{(u_char) ISUPNAPROTOCOLYEAR, ASN_INTEGER, RWRITE, var_isupNaTable, 6, {1, 1, 6, 1, 1, 3}},
#define   ISUPNAPROTOCOLOPTIONS  63
	{(u_char) ISUPNAPROTOCOLOPTIONS, ASN_OCTET_STR, RWRITE, var_isupNaTable, 6, {1, 1, 6, 1, 1, 4}},
#define   ISUPNAPOINTCODEFORMAT  64
	{(u_char) ISUPNAPOINTCODEFORMAT, ASN_OCTET_STR, RWRITE, var_isupNaTable, 6, {1, 1, 6, 1, 1, 5}},
#define   ISUPNASLSLENGTH       65
	{(u_char) ISUPNASLSLENGTH, ASN_INTEGER, RWRITE, var_isupNaTable, 6, {1, 1, 6, 1, 1, 6}},
#define   ISUPNASPDEFAULT       66
	{(u_char) ISUPNASPDEFAULT, ASN_OCTET_STR, RWRITE, var_isupNaTable, 6, {1, 1, 6, 1, 1, 7}},
#define   ISUPNANAME            67
	{(u_char) ISUPNANAME, ASN_OCTET_STR, RWRITE, var_isupNaTable, 6, {1, 1, 6, 1, 1, 8}},
#define   ISUPNAROWSTATUS       68
	{(u_char) ISUPNAROWSTATUS, ASN_INTEGER, RWRITE, var_isupNaTable, 6, {1, 1, 6, 1, 1, 9}},
#define   ISUPSPPOINTCODE       69
	{(u_char) ISUPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 2}},
#define   ISUPSPTYPE            70
	{(u_char) ISUPSPTYPE, ASN_INTEGER, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 3}},
#define   ISUPSPPROCEDURALSTATUS  71
	{(u_char) ISUPSPPROCEDURALSTATUS, ASN_OCTET_STR, RONLY, var_isupSpTable, 6, {1, 1, 7, 1, 1, 4}},
#define   ISUPSPAVAILABILITYSTATUS  72
	{(u_char) ISUPSPAVAILABILITYSTATUS, ASN_OCTET_STR, RONLY, var_isupSpTable, 6, {1, 1, 7, 1, 1, 5}},
#define   ISUPSPVERSION         73
	{(u_char) ISUPSPVERSION, ASN_OCTET_STR, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 6}},
#define   ISUPSPNAME            74
	{(u_char) ISUPSPNAME, ASN_OCTET_STR, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 7}},
#define   ISUPSPNAPOINTER       75
	{(u_char) ISUPSPNAPOINTER, ASN_OBJECT_ID, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 8}},
#define   ISUPSPOPTIONS         76
	{(u_char) ISUPSPOPTIONS, ASN_OCTET_STR, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 9}},
#define   ISUPSPALARMSTATUS     77
	{(u_char) ISUPSPALARMSTATUS, ASN_OCTET_STR, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 10}},
#define   ISUPSPOPERATIONALSTATE  78
	{(u_char) ISUPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_isupSpTable, 6, {1, 1, 7, 1, 1, 11}},
#define   ISUPSPTOTALREMOTESAPS  79
	{(u_char) ISUPSPTOTALREMOTESAPS, ASN_UNSIGNED, RONLY, var_isupSpTable, 6, {1, 1, 7, 1, 1, 12}},
#define   ISUPSPADMINISTRATIVESTATE  80
	{(u_char) ISUPSPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 13}},
#define   ISUPSPSUPPORTEDPROTOCOLS  81
	{(u_char) ISUPSPSUPPORTEDPROTOCOLS, ASN_OCTET_STR, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 14}},
#define   ISUPSPOPERATIONALSYSTEMTYPE  82
	{(u_char) ISUPSPOPERATIONALSYSTEMTYPE, ASN_INTEGER, RONLY, var_isupSpTable, 6, {1, 1, 7, 1, 1, 15}},
#define   ISUPSPACTIVATE        83
	{(u_char) ISUPSPACTIVATE, ASN_INTEGER, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 16}},
#define   ISUPSPDEACTIVATE      84
	{(u_char) ISUPSPDEACTIVATE, ASN_INTEGER, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 17}},
#define   ISUPSPROWSTATUS       85
	{(u_char) ISUPSPROWSTATUS, ASN_INTEGER, RWRITE, var_isupSpTable, 6, {1, 1, 7, 1, 1, 18}},
#define   ISUPSRDEST            86
	{(u_char) ISUPSRDEST, ASN_OCTET_STR, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 2}},
#define   ISUPSROPTIONS         87
	{(u_char) ISUPSROPTIONS, ASN_OCTET_STR, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 3}},
#define   ISUPSRSLSASSIGNMENT   88
	{(u_char) ISUPSRSLSASSIGNMENT, ASN_INTEGER, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 4}},
#define   ISUPSRADMINSTATE      89
	{(u_char) ISUPSRADMINSTATE, ASN_INTEGER, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 5}},
#define   ISUPSROPSTATE         90
	{(u_char) ISUPSROPSTATE, ASN_INTEGER, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 6}},
#define   ISUPSRASAPROFILEPOINTER  91
	{(u_char) ISUPSRASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 7}},
#define   ISUPSRCONGESTEDSTATE  92
	{(u_char) ISUPSRCONGESTEDSTATE, ASN_INTEGER, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 8}},
#define   ISUPSRCONGESTIONLEVEL  93
	{(u_char) ISUPSRCONGESTIONLEVEL, ASN_INTEGER, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 9}},
#define   ISUPSRLOADSHARINGINFORMATION  94
	{(u_char) ISUPSRLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 10}},
#define   ISUPSRLOADSHARINGOBJECT  95
	{(u_char) ISUPSRLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 11}},
#define   ISUPSRREMOTEEXCHANGELABEL  96
	{(u_char) ISUPSRREMOTEEXCHANGELABEL, ASN_OCTET_STR, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 12}},
#define   ISUPSRNAME            97
	{(u_char) ISUPSRNAME, ASN_OCTET_STR, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 13}},
#define   ISUPSRPROFILE         98
	{(u_char) ISUPSRPROFILE, ASN_OCTET_STR, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 14}},
#define   ISUPSRALARMSTATUS     99
	{(u_char) ISUPSRALARMSTATUS, ASN_OCTET_STR, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 15}},
#define   ISUPSRROWSTATUS       100
	{(u_char) ISUPSRROWSTATUS, ASN_INTEGER, RWRITE, var_isupSrTable, 6, {1, 1, 8, 1, 1, 16}},
#define   ISUPRTTRUNKGROUPLIST  101
	{(u_char) ISUPRTTRUNKGROUPLIST, ASN_OCTET_STR, RONLY, var_isupRtTable, 6, {1, 1, 9, 1, 1, 2}},
#define   ISUPRTUSEDALGORITHM   102
	{(u_char) ISUPRTUSEDALGORITHM, ASN_INTEGER, RWRITE, var_isupRtTable, 6, {1, 1, 9, 1, 1, 3}},
#define   ISUPRTSELECTION       103
	{(u_char) ISUPRTSELECTION, ASN_OCTET_STR, RWRITE, var_isupRtTable, 6, {1, 1, 9, 1, 1, 4}},
#define   ISUPRTPROPORTIONLIST  104
	{(u_char) ISUPRTPROPORTIONLIST, ASN_OCTET_STR, RWRITE, var_isupRtTable, 6, {1, 1, 9, 1, 1, 5}},
#define   ISUPRTPOSSIBILITIESINLIST  105
	{(u_char) ISUPRTPOSSIBILITIESINLIST, ASN_OCTET_STR, RONLY, var_isupRtTable, 6, {1, 1, 9, 1, 1, 6}},
#define   ISUPRTUSERLABEL       106
	{(u_char) ISUPRTUSERLABEL, ASN_OCTET_STR, RWRITE, var_isupRtTable, 6, {1, 1, 9, 1, 1, 7}},
#define   ISUPRTPROCSTATUS      107
	{(u_char) ISUPRTPROCSTATUS, ASN_OCTET_STR, RONLY, var_isupRtTable, 6, {1, 1, 9, 1, 1, 8}},
#define   ISUPRTCONTROLSTATUS   108
	{(u_char) ISUPRTCONTROLSTATUS, ASN_OCTET_STR, RWRITE, var_isupRtTable, 6, {1, 1, 9, 1, 1, 9}},
#define   ISUPRTADMINSTATE      109
	{(u_char) ISUPRTADMINSTATE, ASN_INTEGER, RWRITE, var_isupRtTable, 6, {1, 1, 9, 1, 1, 10}},
#define   ISUPRTOPERSTATE       110
	{(u_char) ISUPRTOPERSTATE, ASN_INTEGER, RONLY, var_isupRtTable, 6, {1, 1, 9, 1, 1, 11}},
#define   ISUPRTUSAGESTATE      111
	{(u_char) ISUPRTUSAGESTATE, ASN_INTEGER, RONLY, var_isupRtTable, 6, {1, 1, 9, 1, 1, 12}},
#define   ISUPRTROWSTATUS       112
	{(u_char) ISUPRTROWSTATUS, ASN_INTEGER, RWRITE, var_isupRtTable, 6, {1, 1, 9, 1, 1, 13}},
#define   ISUPRTTGSELECTIONORDINAL  113
	{(u_char) ISUPRTTGSELECTIONORDINAL, ASN_UNSIGNED, RONLY, var_isupRtTgSelectionTable, 6, {1, 1, 10, 1, 1, 2}},
#define   ISUPRTTGSELECTIONPROPORTION  114
	{(u_char) ISUPRTTGSELECTIONPROPORTION, ASN_UNSIGNED, RONLY, var_isupRtTgSelectionTable, 6, {1, 1, 10, 1, 1, 3}},
#define   ISUPRTTGSELECTIONLIST  115
	{(u_char) ISUPRTTGSELECTIONLIST, ASN_OCTET_STR, RWRITE, var_isupRtTgSelectionTable, 6, {1, 1, 10, 1, 1, 4}},
#define   ISUPRTTGSELECTIONROWSTATUS  116
	{(u_char) ISUPRTTGSELECTIONROWSTATUS, ASN_INTEGER, RWRITE, var_isupRtTgSelectionTable, 6, {1, 1, 10, 1, 1, 5}},
#define   ISUPTGNUMBEROFCIRCUITS  117
	{(u_char) ISUPTGNUMBEROFCIRCUITS, ASN_UNSIGNED, RONLY, var_isupTgTable, 6, {1, 1, 11, 1, 1, 2}},
#define   ISUPTGLABELOFFARENDEXCHANGE  118
	{(u_char) ISUPTGLABELOFFARENDEXCHANGE, ASN_OCTET_STR, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 3}},
#define   ISUPTGSIGNALLINGCAPABILITIES  119
	{(u_char) ISUPTGSIGNALLINGCAPABILITIES, ASN_INTEGER, RONLY, var_isupTgTable, 6, {1, 1, 11, 1, 1, 4}},
#define   ISUPTGINFORMATIONTRANSFERCAPABILITIES  120
	{(u_char) ISUPTGINFORMATIONTRANSFERCAPABILITIES, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 5}},
#define   ISUPTGCIRCUITDIRECTIONALITY  121
	{(u_char) ISUPTGCIRCUITDIRECTIONALITY, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 6}},
#define   ISUPTGTRANSMISSIONCHARACTERISTICS  122
	{(u_char) ISUPTGTRANSMISSIONCHARACTERISTICS, ASN_OCTET_STR, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 7}},
#define   ISUPTGUSERLABEL       123
	{(u_char) ISUPTGUSERLABEL, ASN_OCTET_STR, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 8}},
#define   ISUPTGADMINSTATE      124
	{(u_char) ISUPTGADMINSTATE, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 9}},
#define   ISUPTGASSOCSIGNROUTESETNEPART  125
	{(u_char) ISUPTGASSOCSIGNROUTESETNEPART, ASN_UNSIGNED, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 10}},
#define   ISUPTGBOUNDARYCROSSING  126
	{(u_char) ISUPTGBOUNDARYCROSSING, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 11}},
#define   ISUPTGSEARCHMETHOD    127
	{(u_char) ISUPTGSEARCHMETHOD, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 12}},
#define   ISUPTGPREFTRAFFICREDIRECT  128
	{(u_char) ISUPTGPREFTRAFFICREDIRECT, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 13}},
#define   ISUPTGSUPPRESSOWNCAC  129
	{(u_char) ISUPTGSUPPRESSOWNCAC, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 14}},
#define   ISUPTGCARRIERTYPE     130
	{(u_char) ISUPTGCARRIERTYPE, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 15}},
#define   ISUPTGDOUBLESEIZURECONTROL  131
	{(u_char) ISUPTGDOUBLESEIZURECONTROL, ASN_INTEGER, RONLY, var_isupTgTable, 6, {1, 1, 11, 1, 1, 16}},
#define   ISUPTGALARMCARRIER    132
	{(u_char) ISUPTGALARMCARRIER, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 17}},
#define   ISUPTGCONTCHECK       133
	{(u_char) ISUPTGCONTCHECK, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 18}},
#define   ISUPTGCONTCHECKRATIO  134
	{(u_char) ISUPTGCONTCHECKRATIO, ASN_UNSIGNED, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 19}},
#define   ISUPTGPG              135
	{(u_char) ISUPTGPG, ASN_UNSIGNED, RONLY, var_isupTgTable, 6, {1, 1, 11, 1, 1, 20}},
#define   ISUPTGSTANDBYSTATUS   136
	{(u_char) ISUPTGSTANDBYSTATUS, ASN_INTEGER, RONLY, var_isupTgTable, 6, {1, 1, 11, 1, 1, 21}},
#define   ISUPTGALARMSTATUS     137
	{(u_char) ISUPTGALARMSTATUS, ASN_OCTET_STR, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 22}},
#define   ISUPTGROWSTATUS       138
	{(u_char) ISUPTGROWSTATUS, ASN_INTEGER, RWRITE, var_isupTgTable, 6, {1, 1, 11, 1, 1, 23}},
#define   ISUPCGCIC             139
	{(u_char) ISUPCGCIC, ASN_INTEGER, RWRITE, var_isupCgTable, 6, {1, 1, 12, 1, 1, 2}},
#define   ISUPCGOPERATIONALSTATE  140
	{(u_char) ISUPCGOPERATIONALSTATE, ASN_INTEGER, RONLY, var_isupCgTable, 6, {1, 1, 12, 1, 1, 3}},
#define   ISUPCGALARMSTATUS     141
	{(u_char) ISUPCGALARMSTATUS, ASN_OCTET_STR, RWRITE, var_isupCgTable, 6, {1, 1, 12, 1, 1, 4}},
#define   ISUPCGRANGETYPE       142
	{(u_char) ISUPCGRANGETYPE, ASN_INTEGER, RWRITE, var_isupCgTable, 6, {1, 1, 12, 1, 1, 5}},
#define   ISUPCGRANGEANDSTATUS  143
	{(u_char) ISUPCGRANGEANDSTATUS, ASN_OCTET_STR, RONLY, var_isupCgTable, 6, {1, 1, 12, 1, 1, 6}},
#define   ISUPCGCARRIERTYPE     144
	{(u_char) ISUPCGCARRIERTYPE, ASN_INTEGER, RONLY, var_isupCgTable, 6, {1, 1, 12, 1, 1, 7}},
#define   ISUPCGALARMCARRIER    145
	{(u_char) ISUPCGALARMCARRIER, ASN_INTEGER, RWRITE, var_isupCgTable, 6, {1, 1, 12, 1, 1, 8}},
#define   ISUPCGCONTCHECK       146
	{(u_char) ISUPCGCONTCHECK, ASN_INTEGER, RWRITE, var_isupCgTable, 6, {1, 1, 12, 1, 1, 9}},
#define   ISUPCGCONTCHECKRATIO  147
	{(u_char) ISUPCGCONTCHECKRATIO, ASN_UNSIGNED, RWRITE, var_isupCgTable, 6, {1, 1, 12, 1, 1, 10}},
#define   ISUPCGPG              148
	{(u_char) ISUPCGPG, ASN_UNSIGNED, RWRITE, var_isupCgTable, 6, {1, 1, 12, 1, 1, 11}},
#define   ISUPCGSTANDBYSTATUS   149
	{(u_char) ISUPCGSTANDBYSTATUS, ASN_INTEGER, RONLY, var_isupCgTable, 6, {1, 1, 12, 1, 1, 12}},
#define   ISUPCGROWSTATUS       150
	{(u_char) ISUPCGROWSTATUS, ASN_INTEGER, RWRITE, var_isupCgTable, 6, {1, 1, 12, 1, 1, 13}},
#define   ISUPCTCG              151
	{(u_char) ISUPCTCG, ASN_UNSIGNED, RWRITE, var_isupCtTable, 6, {1, 1, 13, 1, 1, 2}},
#define   ISUPCTTG              152
	{(u_char) ISUPCTTG, ASN_UNSIGNED, RWRITE, var_isupCtTable, 6, {1, 1, 13, 1, 1, 3}},
#define   ISUPCTADMINSTATE      153
	{(u_char) ISUPCTADMINSTATE, ASN_INTEGER, RWRITE, var_isupCtTable, 6, {1, 1, 13, 1, 1, 4}},
#define   ISUPCTUSAGESTATE      154
	{(u_char) ISUPCTUSAGESTATE, ASN_INTEGER, RONLY, var_isupCtTable, 6, {1, 1, 13, 1, 1, 5}},
#define   ISUPCTCTPBINSTANCE    155
	{(u_char) ISUPCTCTPBINSTANCE, ASN_OBJECT_ID, RWRITE, var_isupCtTable, 6, {1, 1, 13, 1, 1, 6}},
#define   ISUPCTCIRCUITNUMBER   156
	{(u_char) ISUPCTCIRCUITNUMBER, ASN_UNSIGNED, RWRITE, var_isupCtTable, 6, {1, 1, 13, 1, 1, 7}},
#define   ISUPCTOFFICEEQUIP     157
	{(u_char) ISUPCTOFFICEEQUIP, ASN_OCTET_STR, RWRITE, var_isupCtTable, 6, {1, 1, 13, 1, 1, 8}},
#define   ISUPCTCIC             158
	{(u_char) ISUPCTCIC, ASN_INTEGER, RWRITE, var_isupCtTable, 6, {1, 1, 13, 1, 1, 9}},
#define   ISUPCTROWSTATUS       159
	{(u_char) ISUPCTROWSTATUS, ASN_INTEGER, RWRITE, var_isupCtTable, 6, {1, 1, 13, 1, 1, 10}},
};

/* (L = length of the oidsuffix) */
struct isupMIB_data *isupMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *isupMsTableStorage = NULL;
struct header_complex_index *isupPgTableStorage = NULL;
struct header_complex_index *isupPuTableStorage = NULL;
struct header_complex_index *isupLgTableStorage = NULL;
struct header_complex_index *isupMtpTableStorage = NULL;
struct header_complex_index *isupNaTableStorage = NULL;
struct header_complex_index *isupSpTableStorage = NULL;
struct header_complex_index *isupSrTableStorage = NULL;
struct header_complex_index *isupRtTableStorage = NULL;
struct header_complex_index *isupRtTgSelectionTableStorage = NULL;
struct header_complex_index *isupTgTableStorage = NULL;
struct header_complex_index *isupCgTableStorage = NULL;
struct header_complex_index *isupCtTableStorage = NULL;

void (*isupMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void isupMIB_loop_handler(int);
void isupMIB_fd_handler(int, void *);

/**
 * @fn void init_isupMIB(void)
 * @brief isupMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (isupMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_isupMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("isupMIB", "init_isupMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("isupMIB", isupMIB_variables, variable7, isupMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_isupMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("isupMIB", parse_isupMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("isupMsTable", parse_isupMsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupPgTable", parse_isupPgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupPuTable", parse_isupPuTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupLgTable", parse_isupLgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupMtpTable", parse_isupMtpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupNaTable", parse_isupNaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupSpTable", parse_isupSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupSrTable", parse_isupSrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupRtTable", parse_isupRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupRtTgSelectionTable", parse_isupRtTgSelectionTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupTgTable", parse_isupTgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupCgTable", parse_isupCgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isupCtTable", parse_isupCtTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupMsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupPgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupPuTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupLgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupMtpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupNaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupSrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupRtTgSelectionTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupTgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupCgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isupCtTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, isupMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, isupMIB_fd_handler, (void *) 1);
	}
	isupMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &isupMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/**
 * @fn void deinit_isupMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (isupMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_isupMIB(void)
{
	DEBUGMSGTL(("isupMIB", "deinit_isupMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = isupMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(isupMIB_variables_oid, sizeof(isupMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("isupMIB");
	snmpd_unregister_config_handler("isupMsTable");
	snmpd_unregister_config_handler("isupPgTable");
	snmpd_unregister_config_handler("isupPuTable");
	snmpd_unregister_config_handler("isupLgTable");
	snmpd_unregister_config_handler("isupMtpTable");
	snmpd_unregister_config_handler("isupNaTable");
	snmpd_unregister_config_handler("isupSpTable");
	snmpd_unregister_config_handler("isupSrTable");
	snmpd_unregister_config_handler("isupRtTable");
	snmpd_unregister_config_handler("isupRtTgSelectionTable");
	snmpd_unregister_config_handler("isupTgTable");
	snmpd_unregister_config_handler("isupCgTable");
	snmpd_unregister_config_handler("isupCtTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

int
term_isupMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("isupMIB", "term_isupMIB: terminating...  "));
	deinit_isupMIB();
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct isupMIB_data *isupMIB_create(void)
 * @brief create a fresh data structure representing scalars in isupMIB.
 *
 * Creates a new isupMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in isupMIB.
 */
struct isupMIB_data *
isupMIB_create(void)
{
	struct isupMIB_data *StorageNew = SNMP_MALLOC_STRUCT(isupMIB_data);

	DEBUGMSGTL(("isupMIB", "isupMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */

	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupMIB_data *isupMIB_duplicate(struct isupMIB_data *thedata)
 * @param thedata the mib structure to duplicate
 * @brief duplicate a mib structure for the mib
 *
 * Duplicates the specified mib structure @param thedata and returns a pointer to the newly
 * allocated mib structure on success, or NULL on failure.
 */
struct isupMIB_data *
isupMIB_duplicate(struct isupMIB_data *thedata)
{
	struct isupMIB_data *StorageNew = SNMP_MALLOC_STRUCT(isupMIB_data);

	DEBUGMSGTL(("isupMIB", "isupMIB_duplicate: duplicating mib... "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupMIB_destroy(struct isupMIB_data **thedata)
 * @param thedata pointer to the data structure in isupMIB.
 * @brief delete a scalars structure from isupMIB.
 *
 * Frees scalars that were previously removed from isupMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupMIB_destroy(struct isupMIB_data **thedata)
{
	struct isupMIB_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupMIB_add(struct isupMIB_data *thedata)
 * @param thedata the structure representing isupMIB scalars.
 * @brief adds node to the isupMIB scalar data set.
 *
 * Adds a scalar structure to the isupMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
isupMIB_add(struct isupMIB_data *thedata)
{
	DEBUGMSGTL(("isupMIB", "isupMIB_add: adding data...  "));
	if (thedata)
		isupMIBStorage = thedata;
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupMIB entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_isupMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct isupMIB_data *StorageTmp = isupMIB_create();

	DEBUGMSGTL(("isupMIB", "parse_isupMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	isupMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_isupMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupMIB_data *StorageTmp;

	DEBUGMSGTL(("isupMIB", "store_isupMIB: storing data...  "));
	refresh_isupMIB(1);
	if ((StorageTmp = isupMIBStorage) == NULL) {
		DEBUGMSGTL(("isupMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "isupMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_isupMIB(struct isupMIB_data *StorageTmp, struct isupMIB_data *StorageOld)
 * @param StorageTmp the data as updated
 * @param StorageOld the data previous to update
 *
 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
 * made for setting values that were not in the varbinds.
 */
int
check_isupMIB(struct isupMIB_data *StorageTmp, struct isupMIB_data *StorageOld)
{
	/* XXX: provide code to check the scalars for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupMIB(struct isupMIB_data *StorageTmp, struct isupMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase)
 *
 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
 * consistency already checked (see check_isupMIB()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the mib were applied: the values in StorageTmp are the new values.
 */
int
update_isupMIB(struct isupMIB_data *StorageTmp, struct isupMIB_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupMIB_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn revert_isupMIB(struct 
 * @fn void revert_isupMIB(struct isupMIB_data *StorageTmp, struct isupMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase)
 */
void
revert_isupMIB(struct isupMIB_data *StorageTmp, struct isupMIB_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupMIB(StorageOld, NULL);
}

/**
 * @fn void refresh_isupMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of isupMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_isupMIB(int force)
{
	if (isupMIBStorage == NULL) {
		struct isupMIB_data *StorageNew;

		if ((StorageNew = isupMIB_create()) == NULL)
			return;
		isupMIBStorage = StorageNew;
		isupMIB_refresh = 1;
	}
	if (!force && isupMIB_refresh == 0)
		return;
	DEBUGMSGTL(("isupMIB", "refresh_isupMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	isupMIB_refresh = 0;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/**
 * @fn u_char * var_isupMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in isupMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_isupMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_isupMIB(0);
	if ((StorageTmp = isupMIBStorage) == NULL) {
		DEBUGMSGTL(("isupMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("isupMIB", "found.\n"));
	else
		DEBUGMSGTL(("isupMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct isupMsTable_data *isupMsTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupMsTable table.
 *
 * Creates a new isupMsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupMsTable_data *
isupMsTable_create(void)
{
	struct isupMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupMsTable_data);

	DEBUGMSGTL(("isupMIB", "isupMsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->isupMsName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMsNameLen = 0;
		StorageNew->isupMsName[StorageNew->isupMsNameLen] = 0;
		if (memdup((u_char **) &StorageNew->isupMsAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupMsAlarmStatusLen = 1;
		StorageNew->isupMsOperationalState = ISUPMSOPERATIONALSTATE_DISABLED;
		StorageNew->isupMsUsageState = ISUPMSUSAGESTATE_IDLE;
		if ((StorageNew->isupMsVendorName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMsVendorNameLen = 0;
		StorageNew->isupMsVendorName[StorageNew->isupMsVendorNameLen] = 0;
		if ((StorageNew->isupMsUserLabel = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMsUserLabelLen = 0;
		StorageNew->isupMsUserLabel[StorageNew->isupMsUserLabelLen] = 0;
		if ((StorageNew->isupMsVersion = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMsVersionLen = 0;
		StorageNew->isupMsVersion[StorageNew->isupMsVersionLen] = 0;
		if ((StorageNew->isupMsLocationName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMsLocationNameLen = 0;
		StorageNew->isupMsLocationName[StorageNew->isupMsLocationNameLen] = 0;
		StorageNew->isupMsPrimaryTimingSource = 0;
		if ((StorageNew->isupMsPrimaryTimingObject = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupMsPrimaryTimingObjectLen = 2;
		StorageNew->isupMsSecondaryTimingSource = 0;
		if ((StorageNew->isupMsSecondaryTimingObject = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupMsSecondaryTimingObjectLen = 2;
		if ((StorageNew->isupMsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupMsAsaProfilePointerLen = 2;
		if ((StorageNew->isupMsManagedElementType = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMsManagedElementTypeLen = 0;
		StorageNew->isupMsManagedElementType[StorageNew->isupMsManagedElementTypeLen] = 0;
		if ((StorageNew->isupMsModelCode = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMsModelCodeLen = 0;
		StorageNew->isupMsModelCode[StorageNew->isupMsModelCodeLen] = 0;
		if ((StorageNew->isupMsNetworkElementAliases = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMsNetworkElementAliasesLen = 0;
		StorageNew->isupMsNetworkElementAliases[StorageNew->isupMsNetworkElementAliasesLen] = 0;
		StorageNew->isupMsRowStatus = 0;
		StorageNew->isupMsRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupMsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupMsTable_data *isupMsTable_duplicate(struct isupMsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupMsTable_data *
isupMsTable_duplicate(struct isupMsTable_data *thedata)
{
	struct isupMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupMsTable_data);

	DEBUGMSGTL(("isupMIB", "isupMsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupMsTable_id = thedata->isupMsTable_id;
		StorageNew->isupMsId = thedata->isupMsId;
		if (!(StorageNew->isupMsName = malloc(thedata->isupMsNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMsName, thedata->isupMsName, thedata->isupMsNameLen);
		StorageNew->isupMsNameLen = thedata->isupMsNameLen;
		StorageNew->isupMsName[StorageNew->isupMsNameLen] = 0;
		if (!(StorageNew->isupMsAlarmStatus = malloc(thedata->isupMsAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMsAlarmStatus, thedata->isupMsAlarmStatus, thedata->isupMsAlarmStatusLen);
		StorageNew->isupMsAlarmStatusLen = thedata->isupMsAlarmStatusLen;
		StorageNew->isupMsAlarmStatus[StorageNew->isupMsAlarmStatusLen] = 0;
		StorageNew->isupMsOperationalState = thedata->isupMsOperationalState;
		StorageNew->isupMsUsageState = thedata->isupMsUsageState;
		if (!(StorageNew->isupMsVendorName = malloc(thedata->isupMsVendorNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMsVendorName, thedata->isupMsVendorName, thedata->isupMsVendorNameLen);
		StorageNew->isupMsVendorNameLen = thedata->isupMsVendorNameLen;
		StorageNew->isupMsVendorName[StorageNew->isupMsVendorNameLen] = 0;
		if (!(StorageNew->isupMsUserLabel = malloc(thedata->isupMsUserLabelLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMsUserLabel, thedata->isupMsUserLabel, thedata->isupMsUserLabelLen);
		StorageNew->isupMsUserLabelLen = thedata->isupMsUserLabelLen;
		StorageNew->isupMsUserLabel[StorageNew->isupMsUserLabelLen] = 0;
		if (!(StorageNew->isupMsVersion = malloc(thedata->isupMsVersionLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMsVersion, thedata->isupMsVersion, thedata->isupMsVersionLen);
		StorageNew->isupMsVersionLen = thedata->isupMsVersionLen;
		StorageNew->isupMsVersion[StorageNew->isupMsVersionLen] = 0;
		if (!(StorageNew->isupMsLocationName = malloc(thedata->isupMsLocationNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMsLocationName, thedata->isupMsLocationName, thedata->isupMsLocationNameLen);
		StorageNew->isupMsLocationNameLen = thedata->isupMsLocationNameLen;
		StorageNew->isupMsLocationName[StorageNew->isupMsLocationNameLen] = 0;
		StorageNew->isupMsPrimaryTimingSource = thedata->isupMsPrimaryTimingSource;
		if (!(StorageNew->isupMsPrimaryTimingObject = snmp_duplicate_objid(thedata->isupMsPrimaryTimingObject, thedata->isupMsPrimaryTimingObjectLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupMsPrimaryTimingObjectLen = thedata->isupMsPrimaryTimingObjectLen;
		StorageNew->isupMsSecondaryTimingSource = thedata->isupMsSecondaryTimingSource;
		if (!(StorageNew->isupMsSecondaryTimingObject = snmp_duplicate_objid(thedata->isupMsSecondaryTimingObject, thedata->isupMsSecondaryTimingObjectLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupMsSecondaryTimingObjectLen = thedata->isupMsSecondaryTimingObjectLen;
		if (!(StorageNew->isupMsAsaProfilePointer = snmp_duplicate_objid(thedata->isupMsAsaProfilePointer, thedata->isupMsAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupMsAsaProfilePointerLen = thedata->isupMsAsaProfilePointerLen;
		if (!(StorageNew->isupMsManagedElementType = malloc(thedata->isupMsManagedElementTypeLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMsManagedElementType, thedata->isupMsManagedElementType, thedata->isupMsManagedElementTypeLen);
		StorageNew->isupMsManagedElementTypeLen = thedata->isupMsManagedElementTypeLen;
		StorageNew->isupMsManagedElementType[StorageNew->isupMsManagedElementTypeLen] = 0;
		if (!(StorageNew->isupMsModelCode = malloc(thedata->isupMsModelCodeLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMsModelCode, thedata->isupMsModelCode, thedata->isupMsModelCodeLen);
		StorageNew->isupMsModelCodeLen = thedata->isupMsModelCodeLen;
		StorageNew->isupMsModelCode[StorageNew->isupMsModelCodeLen] = 0;
		if (!(StorageNew->isupMsNetworkElementAliases = malloc(thedata->isupMsNetworkElementAliasesLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMsNetworkElementAliases, thedata->isupMsNetworkElementAliases, thedata->isupMsNetworkElementAliasesLen);
		StorageNew->isupMsNetworkElementAliasesLen = thedata->isupMsNetworkElementAliasesLen;
		StorageNew->isupMsNetworkElementAliases[StorageNew->isupMsNetworkElementAliasesLen] = 0;
		StorageNew->isupMsRowStatus = thedata->isupMsRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupMsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupMsTable_destroy(struct isupMsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupMsTable_destroy(struct isupMsTable_data **thedata)
{
	struct isupMsTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupMsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupMsName);
		StorageDel->isupMsNameLen = 0;
		SNMP_FREE(StorageDel->isupMsAlarmStatus);
		StorageDel->isupMsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->isupMsVendorName);
		StorageDel->isupMsVendorNameLen = 0;
		SNMP_FREE(StorageDel->isupMsUserLabel);
		StorageDel->isupMsUserLabelLen = 0;
		SNMP_FREE(StorageDel->isupMsVersion);
		StorageDel->isupMsVersionLen = 0;
		SNMP_FREE(StorageDel->isupMsLocationName);
		StorageDel->isupMsLocationNameLen = 0;
		SNMP_FREE(StorageDel->isupMsPrimaryTimingObject);
		StorageDel->isupMsPrimaryTimingObjectLen = 0;
		SNMP_FREE(StorageDel->isupMsSecondaryTimingObject);
		StorageDel->isupMsSecondaryTimingObjectLen = 0;
		SNMP_FREE(StorageDel->isupMsAsaProfilePointer);
		StorageDel->isupMsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->isupMsManagedElementType);
		StorageDel->isupMsManagedElementTypeLen = 0;
		SNMP_FREE(StorageDel->isupMsModelCode);
		StorageDel->isupMsModelCodeLen = 0;
		SNMP_FREE(StorageDel->isupMsNetworkElementAliases);
		StorageDel->isupMsNetworkElementAliasesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupMsTable_add(struct isupMsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupMsTable table data set.
 *
 * Adds a table row structure to the isupMsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupMsTable_add(struct isupMsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupMsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupMsId, sizeof(thedata->isupMsId));
		header_complex_add_data(&isupMsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupMsTable_del(struct isupMsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupMsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupMsTable_del(struct isupMsTable_data *thedata)
{
	struct isupMsTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupMsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupMsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupMsTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupMsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupMsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupMsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupMsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupMsTable_data *StorageTmp = isupMsTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupMsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupMsId, &tmpsize);
	SNMP_FREE(StorageTmp->isupMsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMsName, &StorageTmp->isupMsNameLen);
	if (StorageTmp->isupMsName == NULL) {
		config_perror("invalid specification for isupMsName");
		return;
	}
	SNMP_FREE(StorageTmp->isupMsAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMsAlarmStatus, &StorageTmp->isupMsAlarmStatusLen);
	if (StorageTmp->isupMsAlarmStatus == NULL) {
		config_perror("invalid specification for isupMsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMsUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->isupMsVendorName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMsVendorName, &StorageTmp->isupMsVendorNameLen);
	if (StorageTmp->isupMsVendorName == NULL) {
		config_perror("invalid specification for isupMsVendorName");
		return;
	}
	SNMP_FREE(StorageTmp->isupMsUserLabel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMsUserLabel, &StorageTmp->isupMsUserLabelLen);
	if (StorageTmp->isupMsUserLabel == NULL) {
		config_perror("invalid specification for isupMsUserLabel");
		return;
	}
	SNMP_FREE(StorageTmp->isupMsVersion);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMsVersion, &StorageTmp->isupMsVersionLen);
	if (StorageTmp->isupMsVersion == NULL) {
		config_perror("invalid specification for isupMsVersion");
		return;
	}
	SNMP_FREE(StorageTmp->isupMsLocationName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMsLocationName, &StorageTmp->isupMsLocationNameLen);
	if (StorageTmp->isupMsLocationName == NULL) {
		config_perror("invalid specification for isupMsLocationName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMsPrimaryTimingSource, &tmpsize);
	SNMP_FREE(StorageTmp->isupMsPrimaryTimingObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupMsPrimaryTimingObject, &StorageTmp->isupMsPrimaryTimingObjectLen);
	if (StorageTmp->isupMsPrimaryTimingObject == NULL) {
		config_perror("invalid specification for isupMsPrimaryTimingObject");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMsSecondaryTimingSource, &tmpsize);
	SNMP_FREE(StorageTmp->isupMsSecondaryTimingObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupMsSecondaryTimingObject, &StorageTmp->isupMsSecondaryTimingObjectLen);
	if (StorageTmp->isupMsSecondaryTimingObject == NULL) {
		config_perror("invalid specification for isupMsSecondaryTimingObject");
		return;
	}
	SNMP_FREE(StorageTmp->isupMsAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupMsAsaProfilePointer, &StorageTmp->isupMsAsaProfilePointerLen);
	if (StorageTmp->isupMsAsaProfilePointer == NULL) {
		config_perror("invalid specification for isupMsAsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->isupMsManagedElementType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMsManagedElementType, &StorageTmp->isupMsManagedElementTypeLen);
	if (StorageTmp->isupMsManagedElementType == NULL) {
		config_perror("invalid specification for isupMsManagedElementType");
		return;
	}
	SNMP_FREE(StorageTmp->isupMsModelCode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMsModelCode, &StorageTmp->isupMsModelCodeLen);
	if (StorageTmp->isupMsModelCode == NULL) {
		config_perror("invalid specification for isupMsModelCode");
		return;
	}
	SNMP_FREE(StorageTmp->isupMsNetworkElementAliases);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMsNetworkElementAliases, &StorageTmp->isupMsNetworkElementAliasesLen);
	if (StorageTmp->isupMsNetworkElementAliases == NULL) {
		config_perror("invalid specification for isupMsNetworkElementAliases");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMsRowStatus, &tmpsize);
	isupMsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupMsTable(): store configuraiton file for isupMsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupMsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupMsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupMsTable: storing data...  "));
	refresh_isupMsTable(1);
	(void) tmpsize;
	for (hcindex = isupMsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupMsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupMsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupMsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMsName, &StorageTmp->isupMsNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMsAlarmStatus, &StorageTmp->isupMsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMsVendorName, &StorageTmp->isupMsVendorNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMsUserLabel, &StorageTmp->isupMsUserLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMsVersion, &StorageTmp->isupMsVersionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMsLocationName, &StorageTmp->isupMsLocationNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMsPrimaryTimingSource, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupMsPrimaryTimingObject, &StorageTmp->isupMsPrimaryTimingObjectLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMsSecondaryTimingSource, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupMsSecondaryTimingObject, &StorageTmp->isupMsSecondaryTimingObjectLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupMsAsaProfilePointer, &StorageTmp->isupMsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMsManagedElementType, &StorageTmp->isupMsManagedElementTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMsModelCode, &StorageTmp->isupMsModelCodeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMsNetworkElementAliases, &StorageTmp->isupMsNetworkElementAliasesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupPgTable_data *isupPgTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupPgTable table.
 *
 * Creates a new isupPgTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupPgTable_data *
isupPgTable_create(void)
{
	struct isupPgTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupPgTable_data);

	DEBUGMSGTL(("isupMIB", "isupPgTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupPgOperState = 0;
		if (memdup((u_char **) &StorageNew->isupPgAvailStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupPgAvailStatusLen = 2;
		StorageNew->isupPgType = 0;
		StorageNew->isupPgRevertive = 0;
		if ((StorageNew->isupPgSupportedByObjectList = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupPgSupportedByObjectListLen = 2;
		StorageNew->isupPgWaitToRestoreTime = 0;
		StorageNew->isupPgSettingWindowTime = 0;
		StorageNew->isupPgReleasingWindowTime = 0;
		StorageNew->isupPgHitsCount = 0;
		StorageNew->isupPgSwitchType = 0;
		if ((StorageNew->isupPgProtectedUnits = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupPgProtectedUnitsLen = 0;
		StorageNew->isupPgProtectedUnits[StorageNew->isupPgProtectedUnitsLen] = 0;
		if ((StorageNew->isupPgProtectingUnits = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupPgProtectingUnitsLen = 0;
		StorageNew->isupPgProtectingUnits[StorageNew->isupPgProtectingUnitsLen] = 0;
		StorageNew->isupPgInvokeProtection = 0;
		StorageNew->isupPgReleaseProtection = 0;
		StorageNew->isupPgRowStatus = 0;
		StorageNew->isupPgRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupPgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupPgTable_data *isupPgTable_duplicate(struct isupPgTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupPgTable_data *
isupPgTable_duplicate(struct isupPgTable_data *thedata)
{
	struct isupPgTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupPgTable_data);

	DEBUGMSGTL(("isupMIB", "isupPgTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupPgTable_id = thedata->isupPgTable_id;
		StorageNew->isupPgId = thedata->isupPgId;
		StorageNew->isupPgOperState = thedata->isupPgOperState;
		if (!(StorageNew->isupPgAvailStatus = malloc(thedata->isupPgAvailStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupPgAvailStatus, thedata->isupPgAvailStatus, thedata->isupPgAvailStatusLen);
		StorageNew->isupPgAvailStatusLen = thedata->isupPgAvailStatusLen;
		StorageNew->isupPgAvailStatus[StorageNew->isupPgAvailStatusLen] = 0;
		StorageNew->isupPgType = thedata->isupPgType;
		StorageNew->isupPgRevertive = thedata->isupPgRevertive;
		if (!(StorageNew->isupPgSupportedByObjectList = snmp_duplicate_objid(thedata->isupPgSupportedByObjectList, thedata->isupPgSupportedByObjectListLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupPgSupportedByObjectListLen = thedata->isupPgSupportedByObjectListLen;
		StorageNew->isupPgWaitToRestoreTime = thedata->isupPgWaitToRestoreTime;
		StorageNew->isupPgSettingWindowTime = thedata->isupPgSettingWindowTime;
		StorageNew->isupPgReleasingWindowTime = thedata->isupPgReleasingWindowTime;
		StorageNew->isupPgHitsCount = thedata->isupPgHitsCount;
		StorageNew->isupPgSwitchType = thedata->isupPgSwitchType;
		if (!(StorageNew->isupPgProtectedUnits = malloc(thedata->isupPgProtectedUnitsLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupPgProtectedUnits, thedata->isupPgProtectedUnits, thedata->isupPgProtectedUnitsLen);
		StorageNew->isupPgProtectedUnitsLen = thedata->isupPgProtectedUnitsLen;
		StorageNew->isupPgProtectedUnits[StorageNew->isupPgProtectedUnitsLen] = 0;
		if (!(StorageNew->isupPgProtectingUnits = malloc(thedata->isupPgProtectingUnitsLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupPgProtectingUnits, thedata->isupPgProtectingUnits, thedata->isupPgProtectingUnitsLen);
		StorageNew->isupPgProtectingUnitsLen = thedata->isupPgProtectingUnitsLen;
		StorageNew->isupPgProtectingUnits[StorageNew->isupPgProtectingUnitsLen] = 0;
		StorageNew->isupPgInvokeProtection = thedata->isupPgInvokeProtection;
		StorageNew->isupPgReleaseProtection = thedata->isupPgReleaseProtection;
		StorageNew->isupPgRowStatus = thedata->isupPgRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupPgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupPgTable_destroy(struct isupPgTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupPgTable_destroy(struct isupPgTable_data **thedata)
{
	struct isupPgTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupPgTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupPgAvailStatus);
		StorageDel->isupPgAvailStatusLen = 0;
		SNMP_FREE(StorageDel->isupPgSupportedByObjectList);
		StorageDel->isupPgSupportedByObjectListLen = 0;
		SNMP_FREE(StorageDel->isupPgProtectedUnits);
		StorageDel->isupPgProtectedUnitsLen = 0;
		SNMP_FREE(StorageDel->isupPgProtectingUnits);
		StorageDel->isupPgProtectingUnitsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupPgTable_add(struct isupPgTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupPgTable table data set.
 *
 * Adds a table row structure to the isupPgTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupPgTable_add(struct isupPgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupPgTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupPgId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupPgId, sizeof(thedata->isupPgId));
		header_complex_add_data(&isupPgTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupPgTable_del(struct isupPgTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupPgTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupPgTable_del(struct isupPgTable_data *thedata)
{
	struct isupPgTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupPgTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupPgTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupPgTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupPgTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupPgTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupPgTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupPgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupPgTable_data *StorageTmp = isupPgTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupPgTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupPgId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgOperState, &tmpsize);
	SNMP_FREE(StorageTmp->isupPgAvailStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupPgAvailStatus, &StorageTmp->isupPgAvailStatusLen);
	if (StorageTmp->isupPgAvailStatus == NULL) {
		config_perror("invalid specification for isupPgAvailStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgRevertive, &tmpsize);
	SNMP_FREE(StorageTmp->isupPgSupportedByObjectList);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupPgSupportedByObjectList, &StorageTmp->isupPgSupportedByObjectListLen);
	if (StorageTmp->isupPgSupportedByObjectList == NULL) {
		config_perror("invalid specification for isupPgSupportedByObjectList");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgWaitToRestoreTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgSettingWindowTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgReleasingWindowTime, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupPgHitsCount, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgSwitchType, &tmpsize);
	SNMP_FREE(StorageTmp->isupPgProtectedUnits);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupPgProtectedUnits, &StorageTmp->isupPgProtectedUnitsLen);
	if (StorageTmp->isupPgProtectedUnits == NULL) {
		config_perror("invalid specification for isupPgProtectedUnits");
		return;
	}
	SNMP_FREE(StorageTmp->isupPgProtectingUnits);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupPgProtectingUnits, &StorageTmp->isupPgProtectingUnitsLen);
	if (StorageTmp->isupPgProtectingUnits == NULL) {
		config_perror("invalid specification for isupPgProtectingUnits");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgInvokeProtection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgReleaseProtection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPgRowStatus, &tmpsize);
	isupPgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupPgTable(): store configuraiton file for isupPgTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupPgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupPgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupPgTable: storing data...  "));
	refresh_isupPgTable(1);
	(void) tmpsize;
	for (hcindex = isupPgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupPgTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupPgTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupPgId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgOperState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupPgAvailStatus, &StorageTmp->isupPgAvailStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgRevertive, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupPgSupportedByObjectList, &StorageTmp->isupPgSupportedByObjectListLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgWaitToRestoreTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgSettingWindowTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgReleasingWindowTime, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupPgHitsCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgSwitchType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupPgProtectedUnits, &StorageTmp->isupPgProtectedUnitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupPgProtectingUnits, &StorageTmp->isupPgProtectingUnitsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgInvokeProtection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgReleaseProtection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPgRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupPuTable_data *isupPuTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupPuTable table.
 *
 * Creates a new isupPuTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupPuTable_data *
isupPuTable_create(void)
{
	struct isupPuTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupPuTable_data);

	DEBUGMSGTL(("isupMIB", "isupPuTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupPgId = 0;
		StorageNew->isupPuProtecting = 0;
		if ((StorageNew->isupPuReliableResourcePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupPuReliableResourcePointerLen = 2;
		if ((StorageNew->isupPuUnreliableResourcePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupPuUnreliableResourcePointerLen = 2;
		if (memdup((u_char **) &StorageNew->isupPuProtectionStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupPuProtectionStatusLen = 2;
		StorageNew->isupPuSwitchStatus = 0;
		StorageNew->isupPuFromProtectionUnitNumber = 0;
		StorageNew->isupPuToProtectionUnitNumber = 0;
		StorageNew->isupPuAutoSwitchReason = 0;
		StorageNew->isupPuLockoutReleaseFailed = 0;
		StorageNew->isupPuPriority = 0;
		StorageNew->isupPuRowStatus = 0;
		StorageNew->isupPuRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupPuTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupPuTable_data *isupPuTable_duplicate(struct isupPuTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupPuTable_data *
isupPuTable_duplicate(struct isupPuTable_data *thedata)
{
	struct isupPuTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupPuTable_data);

	DEBUGMSGTL(("isupMIB", "isupPuTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupPuTable_id = thedata->isupPuTable_id;
		StorageNew->isupPgId = thedata->isupPgId;
		StorageNew->isupPuId = thedata->isupPuId;
		StorageNew->isupPuProtecting = thedata->isupPuProtecting;
		if (!(StorageNew->isupPuReliableResourcePointer = snmp_duplicate_objid(thedata->isupPuReliableResourcePointer, thedata->isupPuReliableResourcePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupPuReliableResourcePointerLen = thedata->isupPuReliableResourcePointerLen;
		if (!(StorageNew->isupPuUnreliableResourcePointer = snmp_duplicate_objid(thedata->isupPuUnreliableResourcePointer, thedata->isupPuUnreliableResourcePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupPuUnreliableResourcePointerLen = thedata->isupPuUnreliableResourcePointerLen;
		if (!(StorageNew->isupPuProtectionStatus = malloc(thedata->isupPuProtectionStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupPuProtectionStatus, thedata->isupPuProtectionStatus, thedata->isupPuProtectionStatusLen);
		StorageNew->isupPuProtectionStatusLen = thedata->isupPuProtectionStatusLen;
		StorageNew->isupPuProtectionStatus[StorageNew->isupPuProtectionStatusLen] = 0;
		StorageNew->isupPuSwitchStatus = thedata->isupPuSwitchStatus;
		StorageNew->isupPuFromProtectionUnitNumber = thedata->isupPuFromProtectionUnitNumber;
		StorageNew->isupPuToProtectionUnitNumber = thedata->isupPuToProtectionUnitNumber;
		StorageNew->isupPuAutoSwitchReason = thedata->isupPuAutoSwitchReason;
		StorageNew->isupPuLockoutReleaseFailed = thedata->isupPuLockoutReleaseFailed;
		StorageNew->isupPuPriority = thedata->isupPuPriority;
		StorageNew->isupPuRowStatus = thedata->isupPuRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupPuTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupPuTable_destroy(struct isupPuTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupPuTable_destroy(struct isupPuTable_data **thedata)
{
	struct isupPuTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupPuTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupPuReliableResourcePointer);
		StorageDel->isupPuReliableResourcePointerLen = 0;
		SNMP_FREE(StorageDel->isupPuUnreliableResourcePointer);
		StorageDel->isupPuUnreliableResourcePointerLen = 0;
		SNMP_FREE(StorageDel->isupPuProtectionStatus);
		StorageDel->isupPuProtectionStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupPuTable_add(struct isupPuTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupPuTable table data set.
 *
 * Adds a table row structure to the isupPuTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupPuTable_add(struct isupPuTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupPuTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupPgId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupPgId, sizeof(thedata->isupPgId));
		/* isupPuId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupPuId, sizeof(thedata->isupPuId));
		header_complex_add_data(&isupPuTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupPuTable_del(struct isupPuTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupPuTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupPuTable_del(struct isupPuTable_data *thedata)
{
	struct isupPuTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupPuTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupPuTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupPuTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupPuTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupPuTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupPuTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupPuTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupPuTable_data *StorageTmp = isupPuTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupPuTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupPgId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupPuId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPuProtecting, &tmpsize);
	SNMP_FREE(StorageTmp->isupPuReliableResourcePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupPuReliableResourcePointer, &StorageTmp->isupPuReliableResourcePointerLen);
	if (StorageTmp->isupPuReliableResourcePointer == NULL) {
		config_perror("invalid specification for isupPuReliableResourcePointer");
		return;
	}
	SNMP_FREE(StorageTmp->isupPuUnreliableResourcePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupPuUnreliableResourcePointer, &StorageTmp->isupPuUnreliableResourcePointerLen);
	if (StorageTmp->isupPuUnreliableResourcePointer == NULL) {
		config_perror("invalid specification for isupPuUnreliableResourcePointer");
		return;
	}
	SNMP_FREE(StorageTmp->isupPuProtectionStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupPuProtectionStatus, &StorageTmp->isupPuProtectionStatusLen);
	if (StorageTmp->isupPuProtectionStatus == NULL) {
		config_perror("invalid specification for isupPuProtectionStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPuSwitchStatus, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupPuFromProtectionUnitNumber, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupPuToProtectionUnitNumber, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPuAutoSwitchReason, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPuLockoutReleaseFailed, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupPuPriority, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupPuRowStatus, &tmpsize);
	isupPuTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupPuTable(): store configuraiton file for isupPuTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupPuTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupPuTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupPuTable: storing data...  "));
	refresh_isupPuTable(1);
	(void) tmpsize;
	for (hcindex = isupPuTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupPuTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupPuTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupPgId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupPuId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPuProtecting, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupPuReliableResourcePointer, &StorageTmp->isupPuReliableResourcePointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupPuUnreliableResourcePointer, &StorageTmp->isupPuUnreliableResourcePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupPuProtectionStatus, &StorageTmp->isupPuProtectionStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPuSwitchStatus, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupPuFromProtectionUnitNumber, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupPuToProtectionUnitNumber, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPuAutoSwitchReason, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPuLockoutReleaseFailed, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupPuPriority, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupPuRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupLgTable_data *isupLgTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupLgTable table.
 *
 * Creates a new isupLgTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupLgTable_data *
isupLgTable_create(void)
{
	struct isupLgTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupLgTable_data);

	DEBUGMSGTL(("isupMIB", "isupLgTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupLgOperationalState = ISUPLGOPERATIONALSTATE_DISABLED;
		StorageNew->isupLgAdministrativeState = 0;
		if ((StorageNew->isupLgSnServiceProvider = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupLgSnServiceProviderLen = 2;
		if ((StorageNew->isupLgSnSap = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupLgSnSapLen = 2;
		if (memdup((u_char **) &StorageNew->isupLgOperationalProtocols, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupLgOperationalProtocolsLen = 1;
		if (memdup((u_char **) &StorageNew->isupLgOperationalSubsets, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupLgOperationalSubsetsLen = 1;
		StorageNew->isupLgRowStatus = 0;
		StorageNew->isupLgRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupLgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupLgTable_data *isupLgTable_duplicate(struct isupLgTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupLgTable_data *
isupLgTable_duplicate(struct isupLgTable_data *thedata)
{
	struct isupLgTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupLgTable_data);

	DEBUGMSGTL(("isupMIB", "isupLgTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupLgTable_id = thedata->isupLgTable_id;
		StorageNew->isupLgId = thedata->isupLgId;
		StorageNew->isupLgOperationalState = thedata->isupLgOperationalState;
		StorageNew->isupLgAdministrativeState = thedata->isupLgAdministrativeState;
		if (!(StorageNew->isupLgSnServiceProvider = snmp_duplicate_objid(thedata->isupLgSnServiceProvider, thedata->isupLgSnServiceProviderLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupLgSnServiceProviderLen = thedata->isupLgSnServiceProviderLen;
		if (!(StorageNew->isupLgSnSap = snmp_duplicate_objid(thedata->isupLgSnSap, thedata->isupLgSnSapLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupLgSnSapLen = thedata->isupLgSnSapLen;
		if (!(StorageNew->isupLgOperationalProtocols = malloc(thedata->isupLgOperationalProtocolsLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupLgOperationalProtocols, thedata->isupLgOperationalProtocols, thedata->isupLgOperationalProtocolsLen);
		StorageNew->isupLgOperationalProtocolsLen = thedata->isupLgOperationalProtocolsLen;
		StorageNew->isupLgOperationalProtocols[StorageNew->isupLgOperationalProtocolsLen] = 0;
		if (!(StorageNew->isupLgOperationalSubsets = malloc(thedata->isupLgOperationalSubsetsLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupLgOperationalSubsets, thedata->isupLgOperationalSubsets, thedata->isupLgOperationalSubsetsLen);
		StorageNew->isupLgOperationalSubsetsLen = thedata->isupLgOperationalSubsetsLen;
		StorageNew->isupLgOperationalSubsets[StorageNew->isupLgOperationalSubsetsLen] = 0;
		StorageNew->isupLgRowStatus = thedata->isupLgRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupLgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupLgTable_destroy(struct isupLgTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupLgTable_destroy(struct isupLgTable_data **thedata)
{
	struct isupLgTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupLgTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupLgSnServiceProvider);
		StorageDel->isupLgSnServiceProviderLen = 0;
		SNMP_FREE(StorageDel->isupLgSnSap);
		StorageDel->isupLgSnSapLen = 0;
		SNMP_FREE(StorageDel->isupLgOperationalProtocols);
		StorageDel->isupLgOperationalProtocolsLen = 0;
		SNMP_FREE(StorageDel->isupLgOperationalSubsets);
		StorageDel->isupLgOperationalSubsetsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupLgTable_add(struct isupLgTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupLgTable table data set.
 *
 * Adds a table row structure to the isupLgTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupLgTable_add(struct isupLgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupLgTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupLgId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupLgId, sizeof(thedata->isupLgId));
		header_complex_add_data(&isupLgTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupLgTable_del(struct isupLgTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupLgTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupLgTable_del(struct isupLgTable_data *thedata)
{
	struct isupLgTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupLgTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupLgTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupLgTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupLgTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupLgTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupLgTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupLgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupLgTable_data *StorageTmp = isupLgTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupLgTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupLgId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupLgOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupLgAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->isupLgSnServiceProvider);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupLgSnServiceProvider, &StorageTmp->isupLgSnServiceProviderLen);
	if (StorageTmp->isupLgSnServiceProvider == NULL) {
		config_perror("invalid specification for isupLgSnServiceProvider");
		return;
	}
	SNMP_FREE(StorageTmp->isupLgSnSap);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupLgSnSap, &StorageTmp->isupLgSnSapLen);
	if (StorageTmp->isupLgSnSap == NULL) {
		config_perror("invalid specification for isupLgSnSap");
		return;
	}
	SNMP_FREE(StorageTmp->isupLgOperationalProtocols);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupLgOperationalProtocols, &StorageTmp->isupLgOperationalProtocolsLen);
	if (StorageTmp->isupLgOperationalProtocols == NULL) {
		config_perror("invalid specification for isupLgOperationalProtocols");
		return;
	}
	SNMP_FREE(StorageTmp->isupLgOperationalSubsets);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupLgOperationalSubsets, &StorageTmp->isupLgOperationalSubsetsLen);
	if (StorageTmp->isupLgOperationalSubsets == NULL) {
		config_perror("invalid specification for isupLgOperationalSubsets");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupLgRowStatus, &tmpsize);
	isupLgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupLgTable(): store configuraiton file for isupLgTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupLgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupLgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupLgTable: storing data...  "));
	refresh_isupLgTable(1);
	(void) tmpsize;
	for (hcindex = isupLgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupLgTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupLgTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupLgId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupLgOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupLgAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupLgSnServiceProvider, &StorageTmp->isupLgSnServiceProviderLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupLgSnSap, &StorageTmp->isupLgSnSapLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupLgOperationalProtocols, &StorageTmp->isupLgOperationalProtocolsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupLgOperationalSubsets, &StorageTmp->isupLgOperationalSubsetsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupLgRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupMtpTable_data *isupMtpTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupMtpTable table.
 *
 * Creates a new isupMtpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupMtpTable_data *
isupMtpTable_create(void)
{
	struct isupMtpTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupMtpTable_data);

	DEBUGMSGTL(("isupMIB", "isupMtpTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupMsId = 0;
		StorageNew->isupSpId = 0;
		if ((StorageNew->isupMtpAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMtpAddressLen = 0;
		StorageNew->isupMtpAddress[StorageNew->isupMtpAddressLen] = 0;
		StorageNew->isupMtpUserPart = 0;
		StorageNew->isupMtpUserPartStatus = 0;
		if ((StorageNew->isupMtpUserEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupMtpUserEntityNamesLen = 2;
		if ((StorageNew->isupMtpProviderEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupMtpProviderEntityNamesLen = 2;
		StorageNew->isupMtpUsageState = 0;
		if ((StorageNew->isupMtpAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupMtpAsaProfilePointerLen = 2;
		if ((StorageNew->isupMtpName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupMtpNameLen = 0;
		StorageNew->isupMtpName[StorageNew->isupMtpNameLen] = 0;
		StorageNew->isupMtpLongMessageSupported = 0;
		StorageNew->isupMtpRowStatus = 0;
		StorageNew->isupMtpRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupMtpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupMtpTable_data *isupMtpTable_duplicate(struct isupMtpTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupMtpTable_data *
isupMtpTable_duplicate(struct isupMtpTable_data *thedata)
{
	struct isupMtpTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupMtpTable_data);

	DEBUGMSGTL(("isupMIB", "isupMtpTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupMtpTable_id = thedata->isupMtpTable_id;
		StorageNew->isupMsId = thedata->isupMsId;
		StorageNew->isupSpId = thedata->isupSpId;
		StorageNew->isupMtpId = thedata->isupMtpId;
		if (!(StorageNew->isupMtpAddress = malloc(thedata->isupMtpAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMtpAddress, thedata->isupMtpAddress, thedata->isupMtpAddressLen);
		StorageNew->isupMtpAddressLen = thedata->isupMtpAddressLen;
		StorageNew->isupMtpAddress[StorageNew->isupMtpAddressLen] = 0;
		StorageNew->isupMtpUserPart = thedata->isupMtpUserPart;
		StorageNew->isupMtpUserPartStatus = thedata->isupMtpUserPartStatus;
		if (!(StorageNew->isupMtpUserEntityNames = snmp_duplicate_objid(thedata->isupMtpUserEntityNames, thedata->isupMtpUserEntityNamesLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupMtpUserEntityNamesLen = thedata->isupMtpUserEntityNamesLen;
		if (!(StorageNew->isupMtpProviderEntityNames = snmp_duplicate_objid(thedata->isupMtpProviderEntityNames, thedata->isupMtpProviderEntityNamesLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupMtpProviderEntityNamesLen = thedata->isupMtpProviderEntityNamesLen;
		StorageNew->isupMtpUsageState = thedata->isupMtpUsageState;
		if (!(StorageNew->isupMtpAsaProfilePointer = snmp_duplicate_objid(thedata->isupMtpAsaProfilePointer, thedata->isupMtpAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupMtpAsaProfilePointerLen = thedata->isupMtpAsaProfilePointerLen;
		if (!(StorageNew->isupMtpName = malloc(thedata->isupMtpNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupMtpName, thedata->isupMtpName, thedata->isupMtpNameLen);
		StorageNew->isupMtpNameLen = thedata->isupMtpNameLen;
		StorageNew->isupMtpName[StorageNew->isupMtpNameLen] = 0;
		StorageNew->isupMtpLongMessageSupported = thedata->isupMtpLongMessageSupported;
		StorageNew->isupMtpRowStatus = thedata->isupMtpRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupMtpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupMtpTable_destroy(struct isupMtpTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupMtpTable_destroy(struct isupMtpTable_data **thedata)
{
	struct isupMtpTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupMtpTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupMtpAddress);
		StorageDel->isupMtpAddressLen = 0;
		SNMP_FREE(StorageDel->isupMtpUserEntityNames);
		StorageDel->isupMtpUserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->isupMtpProviderEntityNames);
		StorageDel->isupMtpProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel->isupMtpAsaProfilePointer);
		StorageDel->isupMtpAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->isupMtpName);
		StorageDel->isupMtpNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupMtpTable_add(struct isupMtpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupMtpTable table data set.
 *
 * Adds a table row structure to the isupMtpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupMtpTable_add(struct isupMtpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupMtpTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupMsId, sizeof(thedata->isupMsId));
		/* isupSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupSpId, sizeof(thedata->isupSpId));
		/* isupMtpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupMtpId, sizeof(thedata->isupMtpId));
		header_complex_add_data(&isupMtpTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupMtpTable_del(struct isupMtpTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupMtpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupMtpTable_del(struct isupMtpTable_data *thedata)
{
	struct isupMtpTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupMtpTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupMtpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupMtpTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupMtpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupMtpTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupMtpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupMtpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupMtpTable_data *StorageTmp = isupMtpTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupMtpTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupMtpId, &tmpsize);
	SNMP_FREE(StorageTmp->isupMtpAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMtpAddress, &StorageTmp->isupMtpAddressLen);
	if (StorageTmp->isupMtpAddress == NULL) {
		config_perror("invalid specification for isupMtpAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMtpUserPart, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMtpUserPartStatus, &tmpsize);
	SNMP_FREE(StorageTmp->isupMtpUserEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupMtpUserEntityNames, &StorageTmp->isupMtpUserEntityNamesLen);
	if (StorageTmp->isupMtpUserEntityNames == NULL) {
		config_perror("invalid specification for isupMtpUserEntityNames");
		return;
	}
	SNMP_FREE(StorageTmp->isupMtpProviderEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupMtpProviderEntityNames, &StorageTmp->isupMtpProviderEntityNamesLen);
	if (StorageTmp->isupMtpProviderEntityNames == NULL) {
		config_perror("invalid specification for isupMtpProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMtpUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->isupMtpAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupMtpAsaProfilePointer, &StorageTmp->isupMtpAsaProfilePointerLen);
	if (StorageTmp->isupMtpAsaProfilePointer == NULL) {
		config_perror("invalid specification for isupMtpAsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->isupMtpName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupMtpName, &StorageTmp->isupMtpNameLen);
	if (StorageTmp->isupMtpName == NULL) {
		config_perror("invalid specification for isupMtpName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMtpLongMessageSupported, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupMtpRowStatus, &tmpsize);
	isupMtpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupMtpTable(): store configuraiton file for isupMtpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupMtpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupMtpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupMtpTable: storing data...  "));
	refresh_isupMtpTable(1);
	(void) tmpsize;
	for (hcindex = isupMtpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupMtpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupMtpTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupMtpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMtpAddress, &StorageTmp->isupMtpAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMtpUserPart, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMtpUserPartStatus, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupMtpUserEntityNames, &StorageTmp->isupMtpUserEntityNamesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupMtpProviderEntityNames, &StorageTmp->isupMtpProviderEntityNamesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMtpUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupMtpAsaProfilePointer, &StorageTmp->isupMtpAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupMtpName, &StorageTmp->isupMtpNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMtpLongMessageSupported, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupMtpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupNaTable_data *isupNaTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupNaTable table.
 *
 * Creates a new isupNaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupNaTable_data *
isupNaTable_create(void)
{
	struct isupNaTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupNaTable_data);

	DEBUGMSGTL(("isupMIB", "isupNaTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		{
			static oid tmpoid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 0, 1, 4, 1, 1 };
			if ((StorageNew->isupNaProtocolVariant = snmp_duplicate_objid(tmpoid, 14)) == NULL)
				goto nomem;
			StorageNew->isupNaProtocolVariantLen = 14;
		}
		StorageNew->isupNaProtocolYear = ISUPNAPROTOCOLYEAR_YCURRENT;
		if (memdup((u_char **) &StorageNew->isupNaProtocolOptions, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupNaProtocolOptionsLen = 1;
		if (memdup((u_char **) &StorageNew->isupNaPointCodeFormat, (u_char *) "\x03\x08\x03", 3) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupNaPointCodeFormatLen = 3;
		StorageNew->isupNaSlsLength = ISUPNASLSLENGTH_SLS4BITS;
		if ((StorageNew->isupNaSpDefault = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->isupNaSpDefaultLen = strlen("");
		if ((StorageNew->isupNaName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupNaNameLen = 0;
		StorageNew->isupNaName[StorageNew->isupNaNameLen] = 0;
		StorageNew->isupNaRowStatus = 0;
		StorageNew->isupNaRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupNaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupNaTable_data *isupNaTable_duplicate(struct isupNaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupNaTable_data *
isupNaTable_duplicate(struct isupNaTable_data *thedata)
{
	struct isupNaTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupNaTable_data);

	DEBUGMSGTL(("isupMIB", "isupNaTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupNaTable_id = thedata->isupNaTable_id;
		StorageNew->isupNaId = thedata->isupNaId;
		if (!(StorageNew->isupNaProtocolVariant = snmp_duplicate_objid(thedata->isupNaProtocolVariant, thedata->isupNaProtocolVariantLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupNaProtocolVariantLen = thedata->isupNaProtocolVariantLen;
		StorageNew->isupNaProtocolYear = thedata->isupNaProtocolYear;
		if (!(StorageNew->isupNaProtocolOptions = malloc(thedata->isupNaProtocolOptionsLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupNaProtocolOptions, thedata->isupNaProtocolOptions, thedata->isupNaProtocolOptionsLen);
		StorageNew->isupNaProtocolOptionsLen = thedata->isupNaProtocolOptionsLen;
		StorageNew->isupNaProtocolOptions[StorageNew->isupNaProtocolOptionsLen] = 0;
		if (!(StorageNew->isupNaPointCodeFormat = malloc(thedata->isupNaPointCodeFormatLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupNaPointCodeFormat, thedata->isupNaPointCodeFormat, thedata->isupNaPointCodeFormatLen);
		StorageNew->isupNaPointCodeFormatLen = thedata->isupNaPointCodeFormatLen;
		StorageNew->isupNaPointCodeFormat[StorageNew->isupNaPointCodeFormatLen] = 0;
		StorageNew->isupNaSlsLength = thedata->isupNaSlsLength;
		if (!(StorageNew->isupNaSpDefault = malloc(thedata->isupNaSpDefaultLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupNaSpDefault, thedata->isupNaSpDefault, thedata->isupNaSpDefaultLen);
		StorageNew->isupNaSpDefaultLen = thedata->isupNaSpDefaultLen;
		StorageNew->isupNaSpDefault[StorageNew->isupNaSpDefaultLen] = 0;
		if (!(StorageNew->isupNaName = malloc(thedata->isupNaNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupNaName, thedata->isupNaName, thedata->isupNaNameLen);
		StorageNew->isupNaNameLen = thedata->isupNaNameLen;
		StorageNew->isupNaName[StorageNew->isupNaNameLen] = 0;
		StorageNew->isupNaRowStatus = thedata->isupNaRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupNaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupNaTable_destroy(struct isupNaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupNaTable_destroy(struct isupNaTable_data **thedata)
{
	struct isupNaTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupNaTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupNaProtocolVariant);
		StorageDel->isupNaProtocolVariantLen = 0;
		SNMP_FREE(StorageDel->isupNaProtocolOptions);
		StorageDel->isupNaProtocolOptionsLen = 0;
		SNMP_FREE(StorageDel->isupNaPointCodeFormat);
		StorageDel->isupNaPointCodeFormatLen = 0;
		SNMP_FREE(StorageDel->isupNaSpDefault);
		StorageDel->isupNaSpDefaultLen = 0;
		SNMP_FREE(StorageDel->isupNaName);
		StorageDel->isupNaNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupNaTable_add(struct isupNaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupNaTable table data set.
 *
 * Adds a table row structure to the isupNaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupNaTable_add(struct isupNaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupNaTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupNaId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isupNaId, sizeof(thedata->isupNaId));
		header_complex_add_data(&isupNaTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupNaTable_del(struct isupNaTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupNaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupNaTable_del(struct isupNaTable_data *thedata)
{
	struct isupNaTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupNaTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupNaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupNaTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupNaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupNaTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupNaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupNaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupNaTable_data *StorageTmp = isupNaTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupNaTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupNaId, &tmpsize);
	SNMP_FREE(StorageTmp->isupNaProtocolVariant);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupNaProtocolVariant, &StorageTmp->isupNaProtocolVariantLen);
	if (StorageTmp->isupNaProtocolVariant == NULL) {
		config_perror("invalid specification for isupNaProtocolVariant");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupNaProtocolYear, &tmpsize);
	SNMP_FREE(StorageTmp->isupNaProtocolOptions);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupNaProtocolOptions, &StorageTmp->isupNaProtocolOptionsLen);
	if (StorageTmp->isupNaProtocolOptions == NULL) {
		config_perror("invalid specification for isupNaProtocolOptions");
		return;
	}
	SNMP_FREE(StorageTmp->isupNaPointCodeFormat);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupNaPointCodeFormat, &StorageTmp->isupNaPointCodeFormatLen);
	if (StorageTmp->isupNaPointCodeFormat == NULL) {
		config_perror("invalid specification for isupNaPointCodeFormat");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupNaSlsLength, &tmpsize);
	SNMP_FREE(StorageTmp->isupNaSpDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupNaSpDefault, &StorageTmp->isupNaSpDefaultLen);
	if (StorageTmp->isupNaSpDefault == NULL) {
		config_perror("invalid specification for isupNaSpDefault");
		return;
	}
	SNMP_FREE(StorageTmp->isupNaName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupNaName, &StorageTmp->isupNaNameLen);
	if (StorageTmp->isupNaName == NULL) {
		config_perror("invalid specification for isupNaName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupNaRowStatus, &tmpsize);
	isupNaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupNaTable(): store configuraiton file for isupNaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupNaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupNaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupNaTable: storing data...  "));
	refresh_isupNaTable(1);
	(void) tmpsize;
	for (hcindex = isupNaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupNaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupNaTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupNaId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupNaProtocolVariant, &StorageTmp->isupNaProtocolVariantLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupNaProtocolYear, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupNaProtocolOptions, &StorageTmp->isupNaProtocolOptionsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupNaPointCodeFormat, &StorageTmp->isupNaPointCodeFormatLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupNaSlsLength, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupNaSpDefault, &StorageTmp->isupNaSpDefaultLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupNaName, &StorageTmp->isupNaNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupNaRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupSpTable_data *isupSpTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupSpTable table.
 *
 * Creates a new isupSpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupSpTable_data *
isupSpTable_create(void)
{
	struct isupSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupSpTable_data);

	DEBUGMSGTL(("isupMIB", "isupSpTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupMsId = 0;
		if (memdup((u_char **) &StorageNew->isupSpPointCode, (u_char *) "\x00\x00\x00\x00", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupSpPointCodeLen = 4;
		StorageNew->isupSpType = ISUPSPTYPE_ENDOFFICE;
		if (memdup((u_char **) &StorageNew->isupSpProceduralStatus, (u_char *) "\x80", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupSpProceduralStatusLen = 1;
		if (memdup((u_char **) &StorageNew->isupSpAvailabilityStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupSpAvailabilityStatusLen = 2;
		if ((StorageNew->isupSpVersion = (uint8_t *) strdup("ITU-T Q.764 1999")) == NULL)
			goto nomem;
		StorageNew->isupSpVersionLen = strlen("ITU-T Q.764 1999");
		if ((StorageNew->isupSpName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupSpNameLen = 0;
		StorageNew->isupSpName[StorageNew->isupSpNameLen] = 0;
		if ((StorageNew->isupSpNaPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupSpNaPointerLen = 2;
		if (memdup((u_char **) &StorageNew->isupSpOptions, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupSpOptionsLen = 1;
		if (memdup((u_char **) &StorageNew->isupSpAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupSpAlarmStatusLen = 1;
		StorageNew->isupSpOperationalState = ISUPSPOPERATIONALSTATE_DISABLED;
		StorageNew->isupSpTotalRemoteSAPs = 0;
		StorageNew->isupSpAdministrativeState = ISUPSPADMINISTRATIVESTATE_LOCKED;
		if (memdup((u_char **) &StorageNew->isupSpSupportedProtocols, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupSpSupportedProtocolsLen = 1;
		StorageNew->isupSpOperationalSystemType = ISUPSPOPERATIONALSYSTEMTYPE_ES;
		StorageNew->isupSpActivate = 0;
		StorageNew->isupSpDeactivate = 0;
		StorageNew->isupSpRowStatus = 0;
		StorageNew->isupSpRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupSpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupSpTable_data *isupSpTable_duplicate(struct isupSpTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupSpTable_data *
isupSpTable_duplicate(struct isupSpTable_data *thedata)
{
	struct isupSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupSpTable_data);

	DEBUGMSGTL(("isupMIB", "isupSpTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupSpTable_id = thedata->isupSpTable_id;
		StorageNew->isupMsId = thedata->isupMsId;
		StorageNew->isupSpId = thedata->isupSpId;
		if (!(StorageNew->isupSpPointCode = malloc(thedata->isupSpPointCodeLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSpPointCode, thedata->isupSpPointCode, thedata->isupSpPointCodeLen);
		StorageNew->isupSpPointCodeLen = thedata->isupSpPointCodeLen;
		StorageNew->isupSpPointCode[StorageNew->isupSpPointCodeLen] = 0;
		StorageNew->isupSpType = thedata->isupSpType;
		if (!(StorageNew->isupSpProceduralStatus = malloc(thedata->isupSpProceduralStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSpProceduralStatus, thedata->isupSpProceduralStatus, thedata->isupSpProceduralStatusLen);
		StorageNew->isupSpProceduralStatusLen = thedata->isupSpProceduralStatusLen;
		StorageNew->isupSpProceduralStatus[StorageNew->isupSpProceduralStatusLen] = 0;
		if (!(StorageNew->isupSpAvailabilityStatus = malloc(thedata->isupSpAvailabilityStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSpAvailabilityStatus, thedata->isupSpAvailabilityStatus, thedata->isupSpAvailabilityStatusLen);
		StorageNew->isupSpAvailabilityStatusLen = thedata->isupSpAvailabilityStatusLen;
		StorageNew->isupSpAvailabilityStatus[StorageNew->isupSpAvailabilityStatusLen] = 0;
		if (!(StorageNew->isupSpVersion = malloc(thedata->isupSpVersionLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSpVersion, thedata->isupSpVersion, thedata->isupSpVersionLen);
		StorageNew->isupSpVersionLen = thedata->isupSpVersionLen;
		StorageNew->isupSpVersion[StorageNew->isupSpVersionLen] = 0;
		if (!(StorageNew->isupSpName = malloc(thedata->isupSpNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSpName, thedata->isupSpName, thedata->isupSpNameLen);
		StorageNew->isupSpNameLen = thedata->isupSpNameLen;
		StorageNew->isupSpName[StorageNew->isupSpNameLen] = 0;
		if (!(StorageNew->isupSpNaPointer = snmp_duplicate_objid(thedata->isupSpNaPointer, thedata->isupSpNaPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupSpNaPointerLen = thedata->isupSpNaPointerLen;
		if (!(StorageNew->isupSpOptions = malloc(thedata->isupSpOptionsLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSpOptions, thedata->isupSpOptions, thedata->isupSpOptionsLen);
		StorageNew->isupSpOptionsLen = thedata->isupSpOptionsLen;
		StorageNew->isupSpOptions[StorageNew->isupSpOptionsLen] = 0;
		if (!(StorageNew->isupSpAlarmStatus = malloc(thedata->isupSpAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSpAlarmStatus, thedata->isupSpAlarmStatus, thedata->isupSpAlarmStatusLen);
		StorageNew->isupSpAlarmStatusLen = thedata->isupSpAlarmStatusLen;
		StorageNew->isupSpAlarmStatus[StorageNew->isupSpAlarmStatusLen] = 0;
		StorageNew->isupSpOperationalState = thedata->isupSpOperationalState;
		StorageNew->isupSpTotalRemoteSAPs = thedata->isupSpTotalRemoteSAPs;
		StorageNew->isupSpAdministrativeState = thedata->isupSpAdministrativeState;
		if (!(StorageNew->isupSpSupportedProtocols = malloc(thedata->isupSpSupportedProtocolsLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSpSupportedProtocols, thedata->isupSpSupportedProtocols, thedata->isupSpSupportedProtocolsLen);
		StorageNew->isupSpSupportedProtocolsLen = thedata->isupSpSupportedProtocolsLen;
		StorageNew->isupSpSupportedProtocols[StorageNew->isupSpSupportedProtocolsLen] = 0;
		StorageNew->isupSpOperationalSystemType = thedata->isupSpOperationalSystemType;
		StorageNew->isupSpActivate = thedata->isupSpActivate;
		StorageNew->isupSpDeactivate = thedata->isupSpDeactivate;
		StorageNew->isupSpRowStatus = thedata->isupSpRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupSpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupSpTable_destroy(struct isupSpTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupSpTable_destroy(struct isupSpTable_data **thedata)
{
	struct isupSpTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupSpTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupSpPointCode);
		StorageDel->isupSpPointCodeLen = 0;
		SNMP_FREE(StorageDel->isupSpProceduralStatus);
		StorageDel->isupSpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->isupSpAvailabilityStatus);
		StorageDel->isupSpAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->isupSpVersion);
		StorageDel->isupSpVersionLen = 0;
		SNMP_FREE(StorageDel->isupSpName);
		StorageDel->isupSpNameLen = 0;
		SNMP_FREE(StorageDel->isupSpNaPointer);
		StorageDel->isupSpNaPointerLen = 0;
		SNMP_FREE(StorageDel->isupSpOptions);
		StorageDel->isupSpOptionsLen = 0;
		SNMP_FREE(StorageDel->isupSpAlarmStatus);
		StorageDel->isupSpAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->isupSpSupportedProtocols);
		StorageDel->isupSpSupportedProtocolsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupSpTable_add(struct isupSpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupSpTable table data set.
 *
 * Adds a table row structure to the isupSpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupSpTable_add(struct isupSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupSpTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupMsId, sizeof(thedata->isupMsId));
		/* isupSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupSpId, sizeof(thedata->isupSpId));
		header_complex_add_data(&isupSpTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupSpTable_del(struct isupSpTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupSpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupSpTable_del(struct isupSpTable_data *thedata)
{
	struct isupSpTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupSpTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupSpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupSpTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupSpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupSpTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupSpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupSpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupSpTable_data *StorageTmp = isupSpTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupSpTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupSpId, &tmpsize);
	SNMP_FREE(StorageTmp->isupSpPointCode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSpPointCode, &StorageTmp->isupSpPointCodeLen);
	if (StorageTmp->isupSpPointCode == NULL) {
		config_perror("invalid specification for isupSpPointCode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSpType, &tmpsize);
	SNMP_FREE(StorageTmp->isupSpProceduralStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSpProceduralStatus, &StorageTmp->isupSpProceduralStatusLen);
	if (StorageTmp->isupSpProceduralStatus == NULL) {
		config_perror("invalid specification for isupSpProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->isupSpAvailabilityStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSpAvailabilityStatus, &StorageTmp->isupSpAvailabilityStatusLen);
	if (StorageTmp->isupSpAvailabilityStatus == NULL) {
		config_perror("invalid specification for isupSpAvailabilityStatus");
		return;
	}
	SNMP_FREE(StorageTmp->isupSpVersion);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSpVersion, &StorageTmp->isupSpVersionLen);
	if (StorageTmp->isupSpVersion == NULL) {
		config_perror("invalid specification for isupSpVersion");
		return;
	}
	SNMP_FREE(StorageTmp->isupSpName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSpName, &StorageTmp->isupSpNameLen);
	if (StorageTmp->isupSpName == NULL) {
		config_perror("invalid specification for isupSpName");
		return;
	}
	SNMP_FREE(StorageTmp->isupSpNaPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupSpNaPointer, &StorageTmp->isupSpNaPointerLen);
	if (StorageTmp->isupSpNaPointer == NULL) {
		config_perror("invalid specification for isupSpNaPointer");
		return;
	}
	SNMP_FREE(StorageTmp->isupSpOptions);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSpOptions, &StorageTmp->isupSpOptionsLen);
	if (StorageTmp->isupSpOptions == NULL) {
		config_perror("invalid specification for isupSpOptions");
		return;
	}
	SNMP_FREE(StorageTmp->isupSpAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSpAlarmStatus, &StorageTmp->isupSpAlarmStatusLen);
	if (StorageTmp->isupSpAlarmStatus == NULL) {
		config_perror("invalid specification for isupSpAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupSpTotalRemoteSAPs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSpAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->isupSpSupportedProtocols);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSpSupportedProtocols, &StorageTmp->isupSpSupportedProtocolsLen);
	if (StorageTmp->isupSpSupportedProtocols == NULL) {
		config_perror("invalid specification for isupSpSupportedProtocols");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSpOperationalSystemType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSpActivate, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSpDeactivate, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSpRowStatus, &tmpsize);
	isupSpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupSpTable(): store configuraiton file for isupSpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupSpTable: storing data...  "));
	refresh_isupSpTable(1);
	(void) tmpsize;
	for (hcindex = isupSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupSpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupSpTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSpPointCode, &StorageTmp->isupSpPointCodeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSpType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSpProceduralStatus, &StorageTmp->isupSpProceduralStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSpAvailabilityStatus, &StorageTmp->isupSpAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSpVersion, &StorageTmp->isupSpVersionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSpName, &StorageTmp->isupSpNameLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupSpNaPointer, &StorageTmp->isupSpNaPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSpOptions, &StorageTmp->isupSpOptionsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSpAlarmStatus, &StorageTmp->isupSpAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupSpTotalRemoteSAPs, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSpAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSpSupportedProtocols, &StorageTmp->isupSpSupportedProtocolsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSpOperationalSystemType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSpActivate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSpDeactivate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupSrTable_data *isupSrTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupSrTable table.
 *
 * Creates a new isupSrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupSrTable_data *
isupSrTable_create(void)
{
	struct isupSrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupSrTable_data);

	DEBUGMSGTL(("isupMIB", "isupSrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupMsId = 0;
		StorageNew->isupSpId = 0;
		if (memdup((u_char **) &StorageNew->isupSrDest, (u_char *) "\x00\x00\x00\x00", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupSrDestLen = 4;
		if (memdup((u_char **) &StorageNew->isupSrOptions, (u_char *) "\x20", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupSrOptionsLen = 1;
		StorageNew->isupSrSlsAssignment = ISUPSRSLSASSIGNMENT_CIC;
		StorageNew->isupSrAdminState = ISUPSRADMINSTATE_LOCKED;
		StorageNew->isupSrOpState = ISUPSROPSTATE_DISABLED;
		if ((StorageNew->isupSrAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupSrAsaProfilePointerLen = 2;
		StorageNew->isupSrCongestedState = 0;
		StorageNew->isupSrCongestionLevel = ISUPSRCONGESTIONLEVEL_NONE;
		if ((StorageNew->isupSrLoadsharingInformation = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupSrLoadsharingInformationLen = 0;
		StorageNew->isupSrLoadsharingInformation[StorageNew->isupSrLoadsharingInformationLen] = 0;
		if ((StorageNew->isupSrLoadsharingObject = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupSrLoadsharingObjectLen = 2;
		if ((StorageNew->isupSrRemoteExchangeLabel = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupSrRemoteExchangeLabelLen = 0;
		StorageNew->isupSrRemoteExchangeLabel[StorageNew->isupSrRemoteExchangeLabelLen] = 0;
		if ((StorageNew->isupSrName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupSrNameLen = 0;
		StorageNew->isupSrName[StorageNew->isupSrNameLen] = 0;
		if ((StorageNew->isupSrProfile = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->isupSrProfileLen = strlen("");
		if (memdup((u_char **) &StorageNew->isupSrAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupSrAlarmStatusLen = 1;
		StorageNew->isupSrRowStatus = 0;
		StorageNew->isupSrRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupSrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupSrTable_data *isupSrTable_duplicate(struct isupSrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupSrTable_data *
isupSrTable_duplicate(struct isupSrTable_data *thedata)
{
	struct isupSrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupSrTable_data);

	DEBUGMSGTL(("isupMIB", "isupSrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupSrTable_id = thedata->isupSrTable_id;
		StorageNew->isupMsId = thedata->isupMsId;
		StorageNew->isupSpId = thedata->isupSpId;
		StorageNew->isupSrId = thedata->isupSrId;
		if (!(StorageNew->isupSrDest = malloc(thedata->isupSrDestLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSrDest, thedata->isupSrDest, thedata->isupSrDestLen);
		StorageNew->isupSrDestLen = thedata->isupSrDestLen;
		StorageNew->isupSrDest[StorageNew->isupSrDestLen] = 0;
		if (!(StorageNew->isupSrOptions = malloc(thedata->isupSrOptionsLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSrOptions, thedata->isupSrOptions, thedata->isupSrOptionsLen);
		StorageNew->isupSrOptionsLen = thedata->isupSrOptionsLen;
		StorageNew->isupSrOptions[StorageNew->isupSrOptionsLen] = 0;
		StorageNew->isupSrSlsAssignment = thedata->isupSrSlsAssignment;
		StorageNew->isupSrAdminState = thedata->isupSrAdminState;
		StorageNew->isupSrOpState = thedata->isupSrOpState;
		if (!(StorageNew->isupSrAsaProfilePointer = snmp_duplicate_objid(thedata->isupSrAsaProfilePointer, thedata->isupSrAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupSrAsaProfilePointerLen = thedata->isupSrAsaProfilePointerLen;
		StorageNew->isupSrCongestedState = thedata->isupSrCongestedState;
		StorageNew->isupSrCongestionLevel = thedata->isupSrCongestionLevel;
		if (!(StorageNew->isupSrLoadsharingInformation = malloc(thedata->isupSrLoadsharingInformationLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSrLoadsharingInformation, thedata->isupSrLoadsharingInformation, thedata->isupSrLoadsharingInformationLen);
		StorageNew->isupSrLoadsharingInformationLen = thedata->isupSrLoadsharingInformationLen;
		StorageNew->isupSrLoadsharingInformation[StorageNew->isupSrLoadsharingInformationLen] = 0;
		if (!(StorageNew->isupSrLoadsharingObject = snmp_duplicate_objid(thedata->isupSrLoadsharingObject, thedata->isupSrLoadsharingObjectLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupSrLoadsharingObjectLen = thedata->isupSrLoadsharingObjectLen;
		if (!(StorageNew->isupSrRemoteExchangeLabel = malloc(thedata->isupSrRemoteExchangeLabelLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSrRemoteExchangeLabel, thedata->isupSrRemoteExchangeLabel, thedata->isupSrRemoteExchangeLabelLen);
		StorageNew->isupSrRemoteExchangeLabelLen = thedata->isupSrRemoteExchangeLabelLen;
		StorageNew->isupSrRemoteExchangeLabel[StorageNew->isupSrRemoteExchangeLabelLen] = 0;
		if (!(StorageNew->isupSrName = malloc(thedata->isupSrNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSrName, thedata->isupSrName, thedata->isupSrNameLen);
		StorageNew->isupSrNameLen = thedata->isupSrNameLen;
		StorageNew->isupSrName[StorageNew->isupSrNameLen] = 0;
		if (!(StorageNew->isupSrProfile = malloc(thedata->isupSrProfileLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSrProfile, thedata->isupSrProfile, thedata->isupSrProfileLen);
		StorageNew->isupSrProfileLen = thedata->isupSrProfileLen;
		StorageNew->isupSrProfile[StorageNew->isupSrProfileLen] = 0;
		if (!(StorageNew->isupSrAlarmStatus = malloc(thedata->isupSrAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupSrAlarmStatus, thedata->isupSrAlarmStatus, thedata->isupSrAlarmStatusLen);
		StorageNew->isupSrAlarmStatusLen = thedata->isupSrAlarmStatusLen;
		StorageNew->isupSrAlarmStatus[StorageNew->isupSrAlarmStatusLen] = 0;
		StorageNew->isupSrRowStatus = thedata->isupSrRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupSrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupSrTable_destroy(struct isupSrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupSrTable_destroy(struct isupSrTable_data **thedata)
{
	struct isupSrTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupSrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupSrDest);
		StorageDel->isupSrDestLen = 0;
		SNMP_FREE(StorageDel->isupSrOptions);
		StorageDel->isupSrOptionsLen = 0;
		SNMP_FREE(StorageDel->isupSrAsaProfilePointer);
		StorageDel->isupSrAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->isupSrLoadsharingInformation);
		StorageDel->isupSrLoadsharingInformationLen = 0;
		SNMP_FREE(StorageDel->isupSrLoadsharingObject);
		StorageDel->isupSrLoadsharingObjectLen = 0;
		SNMP_FREE(StorageDel->isupSrRemoteExchangeLabel);
		StorageDel->isupSrRemoteExchangeLabelLen = 0;
		SNMP_FREE(StorageDel->isupSrName);
		StorageDel->isupSrNameLen = 0;
		SNMP_FREE(StorageDel->isupSrProfile);
		StorageDel->isupSrProfileLen = 0;
		SNMP_FREE(StorageDel->isupSrAlarmStatus);
		StorageDel->isupSrAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupSrTable_add(struct isupSrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupSrTable table data set.
 *
 * Adds a table row structure to the isupSrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupSrTable_add(struct isupSrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupSrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupMsId, sizeof(thedata->isupMsId));
		/* isupSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupSpId, sizeof(thedata->isupSpId));
		/* isupSrId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupSrId, sizeof(thedata->isupSrId));
		header_complex_add_data(&isupSrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupSrTable_del(struct isupSrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupSrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupSrTable_del(struct isupSrTable_data *thedata)
{
	struct isupSrTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupSrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupSrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupSrTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupSrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupSrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupSrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupSrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupSrTable_data *StorageTmp = isupSrTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupSrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupSrId, &tmpsize);
	SNMP_FREE(StorageTmp->isupSrDest);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSrDest, &StorageTmp->isupSrDestLen);
	if (StorageTmp->isupSrDest == NULL) {
		config_perror("invalid specification for isupSrDest");
		return;
	}
	SNMP_FREE(StorageTmp->isupSrOptions);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSrOptions, &StorageTmp->isupSrOptionsLen);
	if (StorageTmp->isupSrOptions == NULL) {
		config_perror("invalid specification for isupSrOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSrSlsAssignment, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSrAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSrOpState, &tmpsize);
	SNMP_FREE(StorageTmp->isupSrAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupSrAsaProfilePointer, &StorageTmp->isupSrAsaProfilePointerLen);
	if (StorageTmp->isupSrAsaProfilePointer == NULL) {
		config_perror("invalid specification for isupSrAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSrCongestedState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSrCongestionLevel, &tmpsize);
	SNMP_FREE(StorageTmp->isupSrLoadsharingInformation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSrLoadsharingInformation, &StorageTmp->isupSrLoadsharingInformationLen);
	if (StorageTmp->isupSrLoadsharingInformation == NULL) {
		config_perror("invalid specification for isupSrLoadsharingInformation");
		return;
	}
	SNMP_FREE(StorageTmp->isupSrLoadsharingObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupSrLoadsharingObject, &StorageTmp->isupSrLoadsharingObjectLen);
	if (StorageTmp->isupSrLoadsharingObject == NULL) {
		config_perror("invalid specification for isupSrLoadsharingObject");
		return;
	}
	SNMP_FREE(StorageTmp->isupSrRemoteExchangeLabel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSrRemoteExchangeLabel, &StorageTmp->isupSrRemoteExchangeLabelLen);
	if (StorageTmp->isupSrRemoteExchangeLabel == NULL) {
		config_perror("invalid specification for isupSrRemoteExchangeLabel");
		return;
	}
	SNMP_FREE(StorageTmp->isupSrName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSrName, &StorageTmp->isupSrNameLen);
	if (StorageTmp->isupSrName == NULL) {
		config_perror("invalid specification for isupSrName");
		return;
	}
	SNMP_FREE(StorageTmp->isupSrProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSrProfile, &StorageTmp->isupSrProfileLen);
	if (StorageTmp->isupSrProfile == NULL) {
		config_perror("invalid specification for isupSrProfile");
		return;
	}
	SNMP_FREE(StorageTmp->isupSrAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupSrAlarmStatus, &StorageTmp->isupSrAlarmStatusLen);
	if (StorageTmp->isupSrAlarmStatus == NULL) {
		config_perror("invalid specification for isupSrAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupSrRowStatus, &tmpsize);
	isupSrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupSrTable(): store configuraiton file for isupSrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupSrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupSrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupSrTable: storing data...  "));
	refresh_isupSrTable(1);
	(void) tmpsize;
	for (hcindex = isupSrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupSrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupSrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupSrId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSrDest, &StorageTmp->isupSrDestLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSrOptions, &StorageTmp->isupSrOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSrSlsAssignment, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSrAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSrOpState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupSrAsaProfilePointer, &StorageTmp->isupSrAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSrCongestedState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSrCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSrLoadsharingInformation, &StorageTmp->isupSrLoadsharingInformationLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupSrLoadsharingObject, &StorageTmp->isupSrLoadsharingObjectLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSrRemoteExchangeLabel, &StorageTmp->isupSrRemoteExchangeLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSrName, &StorageTmp->isupSrNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSrProfile, &StorageTmp->isupSrProfileLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupSrAlarmStatus, &StorageTmp->isupSrAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupSrRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupRtTable_data *isupRtTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupRtTable table.
 *
 * Creates a new isupRtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupRtTable_data *
isupRtTable_create(void)
{
	struct isupRtTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupRtTable_data);

	DEBUGMSGTL(("isupMIB", "isupRtTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->isupRtTrunkGroupList = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupRtTrunkGroupListLen = 0;
		StorageNew->isupRtTrunkGroupList[StorageNew->isupRtTrunkGroupListLen] = 0;
		StorageNew->isupRtUsedAlgorithm = ISUPRTUSEDALGORITHM_SEQUENTIAL;
		if ((StorageNew->isupRtSelection = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupRtSelectionLen = 0;
		StorageNew->isupRtSelection[StorageNew->isupRtSelectionLen] = 0;
		if ((StorageNew->isupRtProportionList = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupRtProportionListLen = 0;
		StorageNew->isupRtProportionList[StorageNew->isupRtProportionListLen] = 0;
		if ((StorageNew->isupRtPossibilitiesInList = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupRtPossibilitiesInListLen = 0;
		StorageNew->isupRtPossibilitiesInList[StorageNew->isupRtPossibilitiesInListLen] = 0;
		if ((StorageNew->isupRtUserLabel = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupRtUserLabelLen = 0;
		StorageNew->isupRtUserLabel[StorageNew->isupRtUserLabelLen] = 0;
		if (memdup((u_char **) &StorageNew->isupRtProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupRtProcStatusLen = 1;
		if (memdup((u_char **) &StorageNew->isupRtControlStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupRtControlStatusLen = 1;
		StorageNew->isupRtAdminState = 0;
		StorageNew->isupRtOperState = 0;
		StorageNew->isupRtUsageState = ISUPRTUSAGESTATE_IDLE;
		StorageNew->isupRtRowStatus = 0;
		StorageNew->isupRtRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupRtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupRtTable_data *isupRtTable_duplicate(struct isupRtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupRtTable_data *
isupRtTable_duplicate(struct isupRtTable_data *thedata)
{
	struct isupRtTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupRtTable_data);

	DEBUGMSGTL(("isupMIB", "isupRtTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupRtTable_id = thedata->isupRtTable_id;
		StorageNew->isupRtId = thedata->isupRtId;
		if (!(StorageNew->isupRtTrunkGroupList = malloc(thedata->isupRtTrunkGroupListLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupRtTrunkGroupList, thedata->isupRtTrunkGroupList, thedata->isupRtTrunkGroupListLen);
		StorageNew->isupRtTrunkGroupListLen = thedata->isupRtTrunkGroupListLen;
		StorageNew->isupRtTrunkGroupList[StorageNew->isupRtTrunkGroupListLen] = 0;
		StorageNew->isupRtUsedAlgorithm = thedata->isupRtUsedAlgorithm;
		if (!(StorageNew->isupRtSelection = malloc(thedata->isupRtSelectionLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupRtSelection, thedata->isupRtSelection, thedata->isupRtSelectionLen);
		StorageNew->isupRtSelectionLen = thedata->isupRtSelectionLen;
		StorageNew->isupRtSelection[StorageNew->isupRtSelectionLen] = 0;
		if (!(StorageNew->isupRtProportionList = malloc(thedata->isupRtProportionListLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupRtProportionList, thedata->isupRtProportionList, thedata->isupRtProportionListLen);
		StorageNew->isupRtProportionListLen = thedata->isupRtProportionListLen;
		StorageNew->isupRtProportionList[StorageNew->isupRtProportionListLen] = 0;
		if (!(StorageNew->isupRtPossibilitiesInList = malloc(thedata->isupRtPossibilitiesInListLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupRtPossibilitiesInList, thedata->isupRtPossibilitiesInList, thedata->isupRtPossibilitiesInListLen);
		StorageNew->isupRtPossibilitiesInListLen = thedata->isupRtPossibilitiesInListLen;
		StorageNew->isupRtPossibilitiesInList[StorageNew->isupRtPossibilitiesInListLen] = 0;
		if (!(StorageNew->isupRtUserLabel = malloc(thedata->isupRtUserLabelLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupRtUserLabel, thedata->isupRtUserLabel, thedata->isupRtUserLabelLen);
		StorageNew->isupRtUserLabelLen = thedata->isupRtUserLabelLen;
		StorageNew->isupRtUserLabel[StorageNew->isupRtUserLabelLen] = 0;
		if (!(StorageNew->isupRtProcStatus = malloc(thedata->isupRtProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupRtProcStatus, thedata->isupRtProcStatus, thedata->isupRtProcStatusLen);
		StorageNew->isupRtProcStatusLen = thedata->isupRtProcStatusLen;
		StorageNew->isupRtProcStatus[StorageNew->isupRtProcStatusLen] = 0;
		if (!(StorageNew->isupRtControlStatus = malloc(thedata->isupRtControlStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupRtControlStatus, thedata->isupRtControlStatus, thedata->isupRtControlStatusLen);
		StorageNew->isupRtControlStatusLen = thedata->isupRtControlStatusLen;
		StorageNew->isupRtControlStatus[StorageNew->isupRtControlStatusLen] = 0;
		StorageNew->isupRtAdminState = thedata->isupRtAdminState;
		StorageNew->isupRtOperState = thedata->isupRtOperState;
		StorageNew->isupRtUsageState = thedata->isupRtUsageState;
		StorageNew->isupRtRowStatus = thedata->isupRtRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupRtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupRtTable_destroy(struct isupRtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupRtTable_destroy(struct isupRtTable_data **thedata)
{
	struct isupRtTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupRtTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupRtTrunkGroupList);
		StorageDel->isupRtTrunkGroupListLen = 0;
		SNMP_FREE(StorageDel->isupRtSelection);
		StorageDel->isupRtSelectionLen = 0;
		SNMP_FREE(StorageDel->isupRtProportionList);
		StorageDel->isupRtProportionListLen = 0;
		SNMP_FREE(StorageDel->isupRtPossibilitiesInList);
		StorageDel->isupRtPossibilitiesInListLen = 0;
		SNMP_FREE(StorageDel->isupRtUserLabel);
		StorageDel->isupRtUserLabelLen = 0;
		SNMP_FREE(StorageDel->isupRtProcStatus);
		StorageDel->isupRtProcStatusLen = 0;
		SNMP_FREE(StorageDel->isupRtControlStatus);
		StorageDel->isupRtControlStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupRtTable_add(struct isupRtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupRtTable table data set.
 *
 * Adds a table row structure to the isupRtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupRtTable_add(struct isupRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupRtTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupRtId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupRtId, sizeof(thedata->isupRtId));
		header_complex_add_data(&isupRtTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupRtTable_del(struct isupRtTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupRtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupRtTable_del(struct isupRtTable_data *thedata)
{
	struct isupRtTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupRtTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupRtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupRtTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupRtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupRtTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupRtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupRtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupRtTable_data *StorageTmp = isupRtTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupRtTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupRtId, &tmpsize);
	SNMP_FREE(StorageTmp->isupRtTrunkGroupList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupRtTrunkGroupList, &StorageTmp->isupRtTrunkGroupListLen);
	if (StorageTmp->isupRtTrunkGroupList == NULL) {
		config_perror("invalid specification for isupRtTrunkGroupList");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupRtUsedAlgorithm, &tmpsize);
	SNMP_FREE(StorageTmp->isupRtSelection);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupRtSelection, &StorageTmp->isupRtSelectionLen);
	if (StorageTmp->isupRtSelection == NULL) {
		config_perror("invalid specification for isupRtSelection");
		return;
	}
	SNMP_FREE(StorageTmp->isupRtProportionList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupRtProportionList, &StorageTmp->isupRtProportionListLen);
	if (StorageTmp->isupRtProportionList == NULL) {
		config_perror("invalid specification for isupRtProportionList");
		return;
	}
	SNMP_FREE(StorageTmp->isupRtPossibilitiesInList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupRtPossibilitiesInList, &StorageTmp->isupRtPossibilitiesInListLen);
	if (StorageTmp->isupRtPossibilitiesInList == NULL) {
		config_perror("invalid specification for isupRtPossibilitiesInList");
		return;
	}
	SNMP_FREE(StorageTmp->isupRtUserLabel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupRtUserLabel, &StorageTmp->isupRtUserLabelLen);
	if (StorageTmp->isupRtUserLabel == NULL) {
		config_perror("invalid specification for isupRtUserLabel");
		return;
	}
	SNMP_FREE(StorageTmp->isupRtProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupRtProcStatus, &StorageTmp->isupRtProcStatusLen);
	if (StorageTmp->isupRtProcStatus == NULL) {
		config_perror("invalid specification for isupRtProcStatus");
		return;
	}
	SNMP_FREE(StorageTmp->isupRtControlStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupRtControlStatus, &StorageTmp->isupRtControlStatusLen);
	if (StorageTmp->isupRtControlStatus == NULL) {
		config_perror("invalid specification for isupRtControlStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupRtAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupRtOperState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupRtUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupRtRowStatus, &tmpsize);
	isupRtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupRtTable(): store configuraiton file for isupRtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupRtTable: storing data...  "));
	refresh_isupRtTable(1);
	(void) tmpsize;
	for (hcindex = isupRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupRtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupRtTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupRtId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupRtTrunkGroupList, &StorageTmp->isupRtTrunkGroupListLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupRtUsedAlgorithm, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupRtSelection, &StorageTmp->isupRtSelectionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupRtProportionList, &StorageTmp->isupRtProportionListLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupRtPossibilitiesInList, &StorageTmp->isupRtPossibilitiesInListLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupRtUserLabel, &StorageTmp->isupRtUserLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupRtProcStatus, &StorageTmp->isupRtProcStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupRtControlStatus, &StorageTmp->isupRtControlStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupRtAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupRtOperState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupRtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupRtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupRtTgSelectionTable_data *isupRtTgSelectionTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupRtTgSelectionTable table.
 *
 * Creates a new isupRtTgSelectionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupRtTgSelectionTable_data *
isupRtTgSelectionTable_create(void)
{
	struct isupRtTgSelectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupRtTgSelectionTable_data);

	DEBUGMSGTL(("isupMIB", "isupRtTgSelectionTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupRtId = 0;
		StorageNew->isupRtTgSelectionOrdinal = 0;
		StorageNew->isupRtTgSelectionProportion = 0;
		if ((StorageNew->isupRtTgSelectionList = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupRtTgSelectionListLen = 0;
		StorageNew->isupRtTgSelectionList[StorageNew->isupRtTgSelectionListLen] = 0;
		StorageNew->isupRtTgSelectionRowStatus = 0;
		StorageNew->isupRtTgSelectionRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupRtTgSelectionTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupRtTgSelectionTable_data *isupRtTgSelectionTable_duplicate(struct isupRtTgSelectionTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupRtTgSelectionTable_data *
isupRtTgSelectionTable_duplicate(struct isupRtTgSelectionTable_data *thedata)
{
	struct isupRtTgSelectionTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupRtTgSelectionTable_data);

	DEBUGMSGTL(("isupMIB", "isupRtTgSelectionTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupRtTgSelectionTable_id = thedata->isupRtTgSelectionTable_id;
		StorageNew->isupRtId = thedata->isupRtId;
		StorageNew->isupRtTgSelectionIndex = thedata->isupRtTgSelectionIndex;
		StorageNew->isupRtTgSelectionOrdinal = thedata->isupRtTgSelectionOrdinal;
		StorageNew->isupRtTgSelectionProportion = thedata->isupRtTgSelectionProportion;
		if (!(StorageNew->isupRtTgSelectionList = malloc(thedata->isupRtTgSelectionListLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupRtTgSelectionList, thedata->isupRtTgSelectionList, thedata->isupRtTgSelectionListLen);
		StorageNew->isupRtTgSelectionListLen = thedata->isupRtTgSelectionListLen;
		StorageNew->isupRtTgSelectionList[StorageNew->isupRtTgSelectionListLen] = 0;
		StorageNew->isupRtTgSelectionRowStatus = thedata->isupRtTgSelectionRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupRtTgSelectionTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupRtTgSelectionTable_destroy(struct isupRtTgSelectionTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupRtTgSelectionTable_destroy(struct isupRtTgSelectionTable_data **thedata)
{
	struct isupRtTgSelectionTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupRtTgSelectionTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupRtTgSelectionList);
		StorageDel->isupRtTgSelectionListLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupRtTgSelectionTable_add(struct isupRtTgSelectionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupRtTgSelectionTable table data set.
 *
 * Adds a table row structure to the isupRtTgSelectionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupRtTgSelectionTable_add(struct isupRtTgSelectionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupRtTgSelectionTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupRtId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupRtId, sizeof(thedata->isupRtId));
		/* isupRtTgSelectionIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupRtTgSelectionIndex, sizeof(thedata->isupRtTgSelectionIndex));
		header_complex_add_data(&isupRtTgSelectionTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupRtTgSelectionTable_del(struct isupRtTgSelectionTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupRtTgSelectionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupRtTgSelectionTable_del(struct isupRtTgSelectionTable_data *thedata)
{
	struct isupRtTgSelectionTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupRtTgSelectionTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupRtTgSelectionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupRtTgSelectionTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupRtTgSelectionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupRtTgSelectionTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupRtTgSelectionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupRtTgSelectionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupRtTgSelectionTable_data *StorageTmp = isupRtTgSelectionTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupRtTgSelectionTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupRtId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupRtTgSelectionIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupRtTgSelectionOrdinal, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupRtTgSelectionProportion, &tmpsize);
	SNMP_FREE(StorageTmp->isupRtTgSelectionList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupRtTgSelectionList, &StorageTmp->isupRtTgSelectionListLen);
	if (StorageTmp->isupRtTgSelectionList == NULL) {
		config_perror("invalid specification for isupRtTgSelectionList");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupRtTgSelectionRowStatus, &tmpsize);
	isupRtTgSelectionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupRtTgSelectionTable(): store configuraiton file for isupRtTgSelectionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupRtTgSelectionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupRtTgSelectionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupRtTgSelectionTable: storing data...  "));
	refresh_isupRtTgSelectionTable(1);
	(void) tmpsize;
	for (hcindex = isupRtTgSelectionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupRtTgSelectionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupRtTgSelectionTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupRtId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupRtTgSelectionIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupRtTgSelectionOrdinal, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupRtTgSelectionProportion, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupRtTgSelectionList, &StorageTmp->isupRtTgSelectionListLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupRtTgSelectionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupTgTable_data *isupTgTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupTgTable table.
 *
 * Creates a new isupTgTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupTgTable_data *
isupTgTable_create(void)
{
	struct isupTgTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupTgTable_data);

	DEBUGMSGTL(("isupMIB", "isupTgTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupTgNumberOfCircuits = 0;
		if ((StorageNew->isupTgLabelOfFarEndExchange = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupTgLabelOfFarEndExchangeLen = 0;
		StorageNew->isupTgLabelOfFarEndExchange[StorageNew->isupTgLabelOfFarEndExchangeLen] = 0;
		StorageNew->isupTgSignallingCapabilities = 0;
		StorageNew->isupTgInformationTransferCapabilities = ISUPTGINFORMATIONTRANSFERCAPABILITIES_DIGITALUNRESTRICTED64;
		StorageNew->isupTgCircuitDirectionality = ISUPTGCIRCUITDIRECTIONALITY_TWOWAY;
		if (memdup((u_char **) &StorageNew->isupTgTransmissionCharacteristics, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupTgTransmissionCharacteristicsLen = 1;
		if ((StorageNew->isupTgUserLabel = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupTgUserLabelLen = 0;
		StorageNew->isupTgUserLabel[StorageNew->isupTgUserLabelLen] = 0;
		StorageNew->isupTgAdminState = ISUPTGADMINSTATE_LOCKED;
		StorageNew->isupTgAssocSignRouteSetNePart = 0;
		StorageNew->isupTgBoundaryCrossing = ISUPTGBOUNDARYCROSSING_NATIONAL;
		StorageNew->isupTgSearchMethod = 0;
		StorageNew->isupTgPrefTrafficRedirect = 0;
		StorageNew->isupTgSuppressOwnCac = 0;
		StorageNew->isupTgCarrierType = ISUPTGCARRIERTYPE_DIGITAL;
		StorageNew->isupTgDoubleSeizureControl = 0;
		StorageNew->isupTgAlarmCarrier = 0;
		StorageNew->isupTgContCheck = 0;
		StorageNew->isupTgContCheckRatio = 0;
		StorageNew->isupTgPg = 0;
		StorageNew->isupTgStandbyStatus = 0;
		if (memdup((u_char **) &StorageNew->isupTgAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupTgAlarmStatusLen = 1;
		StorageNew->isupTgRowStatus = 0;
		StorageNew->isupTgRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupTgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupTgTable_data *isupTgTable_duplicate(struct isupTgTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupTgTable_data *
isupTgTable_duplicate(struct isupTgTable_data *thedata)
{
	struct isupTgTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupTgTable_data);

	DEBUGMSGTL(("isupMIB", "isupTgTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupTgTable_id = thedata->isupTgTable_id;
		StorageNew->isupTgId = thedata->isupTgId;
		StorageNew->isupTgNumberOfCircuits = thedata->isupTgNumberOfCircuits;
		if (!(StorageNew->isupTgLabelOfFarEndExchange = malloc(thedata->isupTgLabelOfFarEndExchangeLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupTgLabelOfFarEndExchange, thedata->isupTgLabelOfFarEndExchange, thedata->isupTgLabelOfFarEndExchangeLen);
		StorageNew->isupTgLabelOfFarEndExchangeLen = thedata->isupTgLabelOfFarEndExchangeLen;
		StorageNew->isupTgLabelOfFarEndExchange[StorageNew->isupTgLabelOfFarEndExchangeLen] = 0;
		StorageNew->isupTgSignallingCapabilities = thedata->isupTgSignallingCapabilities;
		StorageNew->isupTgInformationTransferCapabilities = thedata->isupTgInformationTransferCapabilities;
		StorageNew->isupTgCircuitDirectionality = thedata->isupTgCircuitDirectionality;
		if (!(StorageNew->isupTgTransmissionCharacteristics = malloc(thedata->isupTgTransmissionCharacteristicsLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupTgTransmissionCharacteristics, thedata->isupTgTransmissionCharacteristics, thedata->isupTgTransmissionCharacteristicsLen);
		StorageNew->isupTgTransmissionCharacteristicsLen = thedata->isupTgTransmissionCharacteristicsLen;
		StorageNew->isupTgTransmissionCharacteristics[StorageNew->isupTgTransmissionCharacteristicsLen] = 0;
		if (!(StorageNew->isupTgUserLabel = malloc(thedata->isupTgUserLabelLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupTgUserLabel, thedata->isupTgUserLabel, thedata->isupTgUserLabelLen);
		StorageNew->isupTgUserLabelLen = thedata->isupTgUserLabelLen;
		StorageNew->isupTgUserLabel[StorageNew->isupTgUserLabelLen] = 0;
		StorageNew->isupTgAdminState = thedata->isupTgAdminState;
		StorageNew->isupTgAssocSignRouteSetNePart = thedata->isupTgAssocSignRouteSetNePart;
		StorageNew->isupTgBoundaryCrossing = thedata->isupTgBoundaryCrossing;
		StorageNew->isupTgSearchMethod = thedata->isupTgSearchMethod;
		StorageNew->isupTgPrefTrafficRedirect = thedata->isupTgPrefTrafficRedirect;
		StorageNew->isupTgSuppressOwnCac = thedata->isupTgSuppressOwnCac;
		StorageNew->isupTgCarrierType = thedata->isupTgCarrierType;
		StorageNew->isupTgDoubleSeizureControl = thedata->isupTgDoubleSeizureControl;
		StorageNew->isupTgAlarmCarrier = thedata->isupTgAlarmCarrier;
		StorageNew->isupTgContCheck = thedata->isupTgContCheck;
		StorageNew->isupTgContCheckRatio = thedata->isupTgContCheckRatio;
		StorageNew->isupTgPg = thedata->isupTgPg;
		StorageNew->isupTgStandbyStatus = thedata->isupTgStandbyStatus;
		if (!(StorageNew->isupTgAlarmStatus = malloc(thedata->isupTgAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupTgAlarmStatus, thedata->isupTgAlarmStatus, thedata->isupTgAlarmStatusLen);
		StorageNew->isupTgAlarmStatusLen = thedata->isupTgAlarmStatusLen;
		StorageNew->isupTgAlarmStatus[StorageNew->isupTgAlarmStatusLen] = 0;
		StorageNew->isupTgRowStatus = thedata->isupTgRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupTgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupTgTable_destroy(struct isupTgTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupTgTable_destroy(struct isupTgTable_data **thedata)
{
	struct isupTgTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupTgTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupTgLabelOfFarEndExchange);
		StorageDel->isupTgLabelOfFarEndExchangeLen = 0;
		SNMP_FREE(StorageDel->isupTgTransmissionCharacteristics);
		StorageDel->isupTgTransmissionCharacteristicsLen = 0;
		SNMP_FREE(StorageDel->isupTgUserLabel);
		StorageDel->isupTgUserLabelLen = 0;
		SNMP_FREE(StorageDel->isupTgAlarmStatus);
		StorageDel->isupTgAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupTgTable_add(struct isupTgTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupTgTable table data set.
 *
 * Adds a table row structure to the isupTgTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupTgTable_add(struct isupTgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupTgTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupTgId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupTgId, sizeof(thedata->isupTgId));
		header_complex_add_data(&isupTgTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupTgTable_del(struct isupTgTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupTgTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupTgTable_del(struct isupTgTable_data *thedata)
{
	struct isupTgTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupTgTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupTgTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupTgTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupTgTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupTgTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupTgTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupTgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupTgTable_data *StorageTmp = isupTgTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupTgTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupTgId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupTgNumberOfCircuits, &tmpsize);
	SNMP_FREE(StorageTmp->isupTgLabelOfFarEndExchange);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupTgLabelOfFarEndExchange, &StorageTmp->isupTgLabelOfFarEndExchangeLen);
	if (StorageTmp->isupTgLabelOfFarEndExchange == NULL) {
		config_perror("invalid specification for isupTgLabelOfFarEndExchange");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgSignallingCapabilities, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgInformationTransferCapabilities, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgCircuitDirectionality, &tmpsize);
	SNMP_FREE(StorageTmp->isupTgTransmissionCharacteristics);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupTgTransmissionCharacteristics, &StorageTmp->isupTgTransmissionCharacteristicsLen);
	if (StorageTmp->isupTgTransmissionCharacteristics == NULL) {
		config_perror("invalid specification for isupTgTransmissionCharacteristics");
		return;
	}
	SNMP_FREE(StorageTmp->isupTgUserLabel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupTgUserLabel, &StorageTmp->isupTgUserLabelLen);
	if (StorageTmp->isupTgUserLabel == NULL) {
		config_perror("invalid specification for isupTgUserLabel");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgAdminState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupTgAssocSignRouteSetNePart, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgBoundaryCrossing, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgSearchMethod, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgPrefTrafficRedirect, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgSuppressOwnCac, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgCarrierType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgDoubleSeizureControl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgAlarmCarrier, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgContCheck, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupTgContCheckRatio, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupTgPg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgStandbyStatus, &tmpsize);
	SNMP_FREE(StorageTmp->isupTgAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupTgAlarmStatus, &StorageTmp->isupTgAlarmStatusLen);
	if (StorageTmp->isupTgAlarmStatus == NULL) {
		config_perror("invalid specification for isupTgAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupTgRowStatus, &tmpsize);
	isupTgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupTgTable(): store configuraiton file for isupTgTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupTgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupTgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupTgTable: storing data...  "));
	refresh_isupTgTable(1);
	(void) tmpsize;
	for (hcindex = isupTgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupTgTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupTgTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupTgId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupTgNumberOfCircuits, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupTgLabelOfFarEndExchange, &StorageTmp->isupTgLabelOfFarEndExchangeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgSignallingCapabilities, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgInformationTransferCapabilities, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgCircuitDirectionality, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupTgTransmissionCharacteristics, &StorageTmp->isupTgTransmissionCharacteristicsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupTgUserLabel, &StorageTmp->isupTgUserLabelLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupTgAssocSignRouteSetNePart, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgBoundaryCrossing, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgSearchMethod, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgPrefTrafficRedirect, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgSuppressOwnCac, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgCarrierType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgDoubleSeizureControl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgAlarmCarrier, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgContCheck, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupTgContCheckRatio, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupTgPg, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgStandbyStatus, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupTgAlarmStatus, &StorageTmp->isupTgAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupTgRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupCgTable_data *isupCgTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupCgTable table.
 *
 * Creates a new isupCgTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupCgTable_data *
isupCgTable_create(void)
{
	struct isupCgTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupCgTable_data);

	DEBUGMSGTL(("isupMIB", "isupCgTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupCgCIC = 0;
		StorageNew->isupCgOperationalState = 0;
		if (memdup((u_char **) &StorageNew->isupCgAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupCgAlarmStatusLen = 1;
		StorageNew->isupCgRangeType = ISUPCGRANGETYPE_EXPLICIT;
		if (memdup((u_char **) &StorageNew->isupCgRangeAndStatus, (u_char *) "\x00\x00\x00\x00", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isupCgRangeAndStatusLen = 4;
		StorageNew->isupCgCarrierType = 0;
		StorageNew->isupCgAlarmCarrier = ISUPCGALARMCARRIER_HARDWARE;
		StorageNew->isupCgContCheck = 0;
		StorageNew->isupCgContCheckRatio = 0;
		StorageNew->isupCgPg = 0;
		StorageNew->isupCgStandbyStatus = 0;
		StorageNew->isupCgRowStatus = 0;
		StorageNew->isupCgRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupCgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupCgTable_data *isupCgTable_duplicate(struct isupCgTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupCgTable_data *
isupCgTable_duplicate(struct isupCgTable_data *thedata)
{
	struct isupCgTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupCgTable_data);

	DEBUGMSGTL(("isupMIB", "isupCgTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupCgTable_id = thedata->isupCgTable_id;
		StorageNew->isupCgId = thedata->isupCgId;
		StorageNew->isupCgCIC = thedata->isupCgCIC;
		StorageNew->isupCgOperationalState = thedata->isupCgOperationalState;
		if (!(StorageNew->isupCgAlarmStatus = malloc(thedata->isupCgAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupCgAlarmStatus, thedata->isupCgAlarmStatus, thedata->isupCgAlarmStatusLen);
		StorageNew->isupCgAlarmStatusLen = thedata->isupCgAlarmStatusLen;
		StorageNew->isupCgAlarmStatus[StorageNew->isupCgAlarmStatusLen] = 0;
		StorageNew->isupCgRangeType = thedata->isupCgRangeType;
		if (!(StorageNew->isupCgRangeAndStatus = malloc(thedata->isupCgRangeAndStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupCgRangeAndStatus, thedata->isupCgRangeAndStatus, thedata->isupCgRangeAndStatusLen);
		StorageNew->isupCgRangeAndStatusLen = thedata->isupCgRangeAndStatusLen;
		StorageNew->isupCgRangeAndStatus[StorageNew->isupCgRangeAndStatusLen] = 0;
		StorageNew->isupCgCarrierType = thedata->isupCgCarrierType;
		StorageNew->isupCgAlarmCarrier = thedata->isupCgAlarmCarrier;
		StorageNew->isupCgContCheck = thedata->isupCgContCheck;
		StorageNew->isupCgContCheckRatio = thedata->isupCgContCheckRatio;
		StorageNew->isupCgPg = thedata->isupCgPg;
		StorageNew->isupCgStandbyStatus = thedata->isupCgStandbyStatus;
		StorageNew->isupCgRowStatus = thedata->isupCgRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupCgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupCgTable_destroy(struct isupCgTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupCgTable_destroy(struct isupCgTable_data **thedata)
{
	struct isupCgTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupCgTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupCgAlarmStatus);
		StorageDel->isupCgAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->isupCgRangeAndStatus);
		StorageDel->isupCgRangeAndStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupCgTable_add(struct isupCgTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupCgTable table data set.
 *
 * Adds a table row structure to the isupCgTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupCgTable_add(struct isupCgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupCgTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupCgId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupCgId, sizeof(thedata->isupCgId));
		header_complex_add_data(&isupCgTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupCgTable_del(struct isupCgTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupCgTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupCgTable_del(struct isupCgTable_data *thedata)
{
	struct isupCgTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupCgTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupCgTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupCgTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupCgTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupCgTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupCgTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupCgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupCgTable_data *StorageTmp = isupCgTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupCgTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupCgId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCgCIC, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCgOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->isupCgAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupCgAlarmStatus, &StorageTmp->isupCgAlarmStatusLen);
	if (StorageTmp->isupCgAlarmStatus == NULL) {
		config_perror("invalid specification for isupCgAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCgRangeType, &tmpsize);
	SNMP_FREE(StorageTmp->isupCgRangeAndStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupCgRangeAndStatus, &StorageTmp->isupCgRangeAndStatusLen);
	if (StorageTmp->isupCgRangeAndStatus == NULL) {
		config_perror("invalid specification for isupCgRangeAndStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCgCarrierType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCgAlarmCarrier, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCgContCheck, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupCgContCheckRatio, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupCgPg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCgStandbyStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCgRowStatus, &tmpsize);
	isupCgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupCgTable(): store configuraiton file for isupCgTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupCgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupCgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupCgTable: storing data...  "));
	refresh_isupCgTable(1);
	(void) tmpsize;
	for (hcindex = isupCgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupCgTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupCgTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupCgId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCgCIC, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCgOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupCgAlarmStatus, &StorageTmp->isupCgAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCgRangeType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupCgRangeAndStatus, &StorageTmp->isupCgRangeAndStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCgCarrierType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCgAlarmCarrier, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCgContCheck, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupCgContCheckRatio, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupCgPg, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCgStandbyStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCgRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isupCtTable_data *isupCtTable_create(void)
 * @brief create a fresh data structure representing a new row in the isupCtTable table.
 *
 * Creates a new isupCtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isupCtTable_data *
isupCtTable_create(void)
{
	struct isupCtTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupCtTable_data);

	DEBUGMSGTL(("isupMIB", "isupCtTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isupCtCg = 0;
		StorageNew->isupCtTg = 0;
		StorageNew->isupCtAdminState = ISUPCTADMINSTATE_LOCKED;
		StorageNew->isupCtUsageState = ISUPCTUSAGESTATE_IDLE;
		if ((StorageNew->isupCtCtpbInstance = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->isupCtCtpbInstanceLen = 2;
		StorageNew->isupCtCircuitNumber = 0;
		if ((StorageNew->isupCtOfficeEquip = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isupCtOfficeEquipLen = 0;
		StorageNew->isupCtOfficeEquip[StorageNew->isupCtOfficeEquipLen] = 0;
		StorageNew->isupCtCIC = 0;
		StorageNew->isupCtRowStatus = 0;
		StorageNew->isupCtRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isupCtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isupCtTable_data *isupCtTable_duplicate(struct isupCtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isupCtTable_data *
isupCtTable_duplicate(struct isupCtTable_data *thedata)
{
	struct isupCtTable_data *StorageNew = SNMP_MALLOC_STRUCT(isupCtTable_data);

	DEBUGMSGTL(("isupMIB", "isupCtTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isupCtTable_id = thedata->isupCtTable_id;
		StorageNew->isupCtId = thedata->isupCtId;
		StorageNew->isupCtCg = thedata->isupCtCg;
		StorageNew->isupCtTg = thedata->isupCtTg;
		StorageNew->isupCtAdminState = thedata->isupCtAdminState;
		StorageNew->isupCtUsageState = thedata->isupCtUsageState;
		if (!(StorageNew->isupCtCtpbInstance = snmp_duplicate_objid(thedata->isupCtCtpbInstance, thedata->isupCtCtpbInstanceLen / sizeof(oid))))
			goto destroy;
		StorageNew->isupCtCtpbInstanceLen = thedata->isupCtCtpbInstanceLen;
		StorageNew->isupCtCircuitNumber = thedata->isupCtCircuitNumber;
		if (!(StorageNew->isupCtOfficeEquip = malloc(thedata->isupCtOfficeEquipLen + 1)))
			goto destroy;
		memcpy(StorageNew->isupCtOfficeEquip, thedata->isupCtOfficeEquip, thedata->isupCtOfficeEquipLen);
		StorageNew->isupCtOfficeEquipLen = thedata->isupCtOfficeEquipLen;
		StorageNew->isupCtOfficeEquip[StorageNew->isupCtOfficeEquipLen] = 0;
		StorageNew->isupCtCIC = thedata->isupCtCIC;
		StorageNew->isupCtRowStatus = thedata->isupCtRowStatus;
	}
      done:
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isupCtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isupCtTable_destroy(struct isupCtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isupCtTable_destroy(struct isupCtTable_data **thedata)
{
	struct isupCtTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupCtTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isupCtCtpbInstance);
		StorageDel->isupCtCtpbInstanceLen = 0;
		SNMP_FREE(StorageDel->isupCtOfficeEquip);
		StorageDel->isupCtOfficeEquipLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupCtTable_add(struct isupCtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isupCtTable table data set.
 *
 * Adds a table row structure to the isupCtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isupCtTable_add(struct isupCtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isupMIB", "isupCtTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isupCtId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isupCtId, sizeof(thedata->isupCtId));
		header_complex_add_data(&isupCtTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isupMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isupCtTable_del(struct isupCtTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isupCtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isupCtTable_del(struct isupCtTable_data *thedata)
{
	struct isupCtTable_data *StorageDel;

	DEBUGMSGTL(("isupMIB", "isupCtTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isupCtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isupCtTableStorage, hciptr);
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isupCtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isupCtTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isupCtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isupCtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isupCtTable_data *StorageTmp = isupCtTable_create();

	DEBUGMSGTL(("isupMIB", "parse_isupCtTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupCtId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupCtCg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupCtTg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCtAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCtUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->isupCtCtpbInstance);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->isupCtCtpbInstance, &StorageTmp->isupCtCtpbInstanceLen);
	if (StorageTmp->isupCtCtpbInstance == NULL) {
		config_perror("invalid specification for isupCtCtpbInstance");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isupCtCircuitNumber, &tmpsize);
	SNMP_FREE(StorageTmp->isupCtOfficeEquip);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isupCtOfficeEquip, &StorageTmp->isupCtOfficeEquipLen);
	if (StorageTmp->isupCtOfficeEquip == NULL) {
		config_perror("invalid specification for isupCtOfficeEquip");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCtCIC, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isupCtRowStatus, &tmpsize);
	isupCtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/*
 * store_isupCtTable(): store configuraiton file for isupCtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isupCtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isupCtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isupMIB", "store_isupCtTable: storing data...  "));
	refresh_isupCtTable(1);
	(void) tmpsize;
	for (hcindex = isupCtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isupCtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isupCtTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupCtId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupCtCg, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupCtTg, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCtAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->isupCtCtpbInstance, &StorageTmp->isupCtCtpbInstanceLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isupCtCircuitNumber, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isupCtOfficeEquip, &StorageTmp->isupCtOfficeEquipLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCtCIC, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isupCtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int activate_isupMsTable_row(struct isupMsTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupMsTable_row(struct isupMsTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupMsTable_row(struct isupMsTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupMsTable_row(struct isupMsTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupPgTable_row(struct isupPgTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupPgTable_row(struct isupPgTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupPgTable_row(struct isupPgTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupPgTable_row(struct isupPgTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupPuTable_row(struct isupPuTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupPuTable_row(struct isupPuTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupPuTable_row(struct isupPuTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupPuTable_row(struct isupPuTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupLgTable_row(struct isupLgTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupLgTable_row(struct isupLgTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupLgTable_row(struct isupLgTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupLgTable_row(struct isupLgTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupMtpTable_row(struct isupMtpTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupMtpTable_row(struct isupMtpTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupMtpTable_row(struct isupMtpTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupMtpTable_row(struct isupMtpTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupNaTable_row(struct isupNaTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupNaTable_row(struct isupNaTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupNaTable_row(struct isupNaTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupNaTable_row(struct isupNaTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupSpTable_row(struct isupSpTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupSpTable_row(struct isupSpTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupSpTable_row(struct isupSpTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupSpTable_row(struct isupSpTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupSrTable_row(struct isupSrTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupSrTable_row(struct isupSrTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupSrTable_row(struct isupSrTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupSrTable_row(struct isupSrTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupRtTable_row(struct isupRtTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupRtTable_row(struct isupRtTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupRtTable_row(struct isupRtTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupRtTable_row(struct isupRtTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupTgTable_row(struct isupTgTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupTgTable_row(struct isupTgTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupTgTable_row(struct isupTgTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupTgTable_row(struct isupTgTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupCgTable_row(struct isupCgTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupCgTable_row(struct isupCgTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupCgTable_row(struct isupCgTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupCgTable_row(struct isupCgTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isupCtTable_row(struct isupCtTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isupCtTable_row(struct isupCtTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isupCtTable_row(struct isupCtTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isupCtTable_row(struct isupCtTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int check_isupMsTable_row(struct isupMsTable_data *StorageTmp, struct isupMsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupMsTable_row(struct isupMsTable_data *StorageTmp, struct isupMsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupMsTable_row(struct isupMsTable_data *StorageTmp, struct isupMsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupMsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupMsTable_row(struct isupMsTable_data *StorageTmp, struct isupMsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupMsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupMsTable_row(struct isupMsTable_data *StorageTmp, struct isupMsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupMsTable_row(struct isupMsTable_data *StorageTmp, struct isupMsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupMsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupMsTable_row(struct isupMsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupMsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupMsTable_data *
refresh_isupMsTable_row(struct isupMsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupMsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupMsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupMsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupMsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupMsTable(int force)
{
	if (!force && isupMsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupMsTable_refresh = 0;
}

/**
 * @fn u_char *var_isupMsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupMsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupMsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupMsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupMsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupMsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupMsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupMsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPMSNAME:	/* Create */
		*write_method = write_isupMsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsNameLen;
		rval = (u_char *) StorageTmp->isupMsName;
		break;
	case (u_char) ISUPMSALARMSTATUS:	/* Create */
		*write_method = write_isupMsAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsAlarmStatusLen;
		rval = (u_char *) StorageTmp->isupMsAlarmStatus;
		break;
	case (u_char) ISUPMSOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMsOperationalState);
		rval = (u_char *) &StorageTmp->isupMsOperationalState;
		break;
	case (u_char) ISUPMSUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMsUsageState);
		rval = (u_char *) &StorageTmp->isupMsUsageState;
		break;
	case (u_char) ISUPMSVENDORNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsVendorNameLen;
		rval = (u_char *) StorageTmp->isupMsVendorName;
		break;
	case (u_char) ISUPMSUSERLABEL:	/* Create */
		*write_method = write_isupMsUserLabel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsUserLabelLen;
		rval = (u_char *) StorageTmp->isupMsUserLabel;
		break;
	case (u_char) ISUPMSVERSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsVersionLen;
		rval = (u_char *) StorageTmp->isupMsVersion;
		break;
	case (u_char) ISUPMSLOCATIONNAME:	/* Create */
		*write_method = write_isupMsLocationName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsLocationNameLen;
		rval = (u_char *) StorageTmp->isupMsLocationName;
		break;
	case (u_char) ISUPMSPRIMARYTIMINGSOURCE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMsPrimaryTimingSource);
		rval = (u_char *) &StorageTmp->isupMsPrimaryTimingSource;
		break;
	case (u_char) ISUPMSPRIMARYTIMINGOBJECT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsPrimaryTimingObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupMsPrimaryTimingObject;
		break;
	case (u_char) ISUPMSSECONDARYTIMINGSOURCE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMsSecondaryTimingSource);
		rval = (u_char *) &StorageTmp->isupMsSecondaryTimingSource;
		break;
	case (u_char) ISUPMSSECONDARYTIMINGOBJECT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsSecondaryTimingObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupMsSecondaryTimingObject;
		break;
	case (u_char) ISUPMSASAPROFILEPOINTER:	/* Create */
		*write_method = write_isupMsAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupMsAsaProfilePointer;
		break;
	case (u_char) ISUPMSMANAGEDELEMENTTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsManagedElementTypeLen;
		rval = (u_char *) StorageTmp->isupMsManagedElementType;
		break;
	case (u_char) ISUPMSMODELCODE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsModelCodeLen;
		rval = (u_char *) StorageTmp->isupMsModelCode;
		break;
	case (u_char) ISUPMSNETWORKELEMENTALIASES:	/* Create */
		*write_method = write_isupMsNetworkElementAliases;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMsNetworkElementAliasesLen;
		rval = (u_char *) StorageTmp->isupMsNetworkElementAliases;
		break;
	case (u_char) ISUPMSROWSTATUS:	/* Create */
		*write_method = write_isupMsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMsRowStatus);
		rval = (u_char *) &StorageTmp->isupMsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupPgTable_row(struct isupPgTable_data *StorageTmp, struct isupPgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupPgTable_row(struct isupPgTable_data *StorageTmp, struct isupPgTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupPgTable_row(struct isupPgTable_data *StorageTmp, struct isupPgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupPgTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupPgTable_row(struct isupPgTable_data *StorageTmp, struct isupPgTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupPgTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupPgTable_row(struct isupPgTable_data *StorageTmp, struct isupPgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupPgTable_row(struct isupPgTable_data *StorageTmp, struct isupPgTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupPgTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupPgTable_row(struct isupPgTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupPgTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupPgTable_data *
refresh_isupPgTable_row(struct isupPgTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupPgTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupPgTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupPgTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupPgTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupPgTable(int force)
{
	if (!force && isupPgTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupPgTable_refresh = 0;
}

/**
 * @fn u_char *var_isupPgTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupPgTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupPgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupPgTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupPgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupPgTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupPgTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupPgTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPPGOPERSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgOperState);
		rval = (u_char *) &StorageTmp->isupPgOperState;
		break;
	case (u_char) ISUPPGAVAILSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupPgAvailStatusLen;
		rval = (u_char *) StorageTmp->isupPgAvailStatus;
		break;
	case (u_char) ISUPPGTYPE:	/* Create */
		*write_method = write_isupPgType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgType);
		rval = (u_char *) &StorageTmp->isupPgType;
		break;
	case (u_char) ISUPPGREVERTIVE:	/* Create */
		*write_method = write_isupPgRevertive;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgRevertive);
		rval = (u_char *) &StorageTmp->isupPgRevertive;
		break;
	case (u_char) ISUPPGSUPPORTEDBYOBJECTLIST:	/* Create */
		*write_method = write_isupPgSupportedByObjectList;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupPgSupportedByObjectListLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupPgSupportedByObjectList;
		break;
	case (u_char) ISUPPGWAITTORESTORETIME:	/* Create */
		*write_method = write_isupPgWaitToRestoreTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgWaitToRestoreTime);
		rval = (u_char *) &StorageTmp->isupPgWaitToRestoreTime;
		break;
	case (u_char) ISUPPGSETTINGWINDOWTIME:	/* Create */
		*write_method = write_isupPgSettingWindowTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgSettingWindowTime);
		rval = (u_char *) &StorageTmp->isupPgSettingWindowTime;
		break;
	case (u_char) ISUPPGRELEASINGWINDOWTIME:	/* Create */
		*write_method = write_isupPgReleasingWindowTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgReleasingWindowTime);
		rval = (u_char *) &StorageTmp->isupPgReleasingWindowTime;
		break;
	case (u_char) ISUPPGHITSCOUNT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgHitsCount);
		rval = (u_char *) &StorageTmp->isupPgHitsCount;
		break;
	case (u_char) ISUPPGSWITCHTYPE:	/* Create */
		*write_method = write_isupPgSwitchType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgSwitchType);
		rval = (u_char *) &StorageTmp->isupPgSwitchType;
		break;
	case (u_char) ISUPPGPROTECTEDUNITS:	/* Create */
		*write_method = write_isupPgProtectedUnits;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupPgProtectedUnitsLen;
		rval = (u_char *) StorageTmp->isupPgProtectedUnits;
		break;
	case (u_char) ISUPPGPROTECTINGUNITS:	/* Create */
		*write_method = write_isupPgProtectingUnits;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupPgProtectingUnitsLen;
		rval = (u_char *) StorageTmp->isupPgProtectingUnits;
		break;
	case (u_char) ISUPPGINVOKEPROTECTION:	/* Create */
		*write_method = write_isupPgInvokeProtection;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgInvokeProtection);
		rval = (u_char *) &StorageTmp->isupPgInvokeProtection;
		break;
	case (u_char) ISUPPGRELEASEPROTECTION:	/* Create */
		*write_method = write_isupPgReleaseProtection;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgReleaseProtection);
		rval = (u_char *) &StorageTmp->isupPgReleaseProtection;
		break;
	case (u_char) ISUPPGROWSTATUS:	/* Create */
		*write_method = write_isupPgRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPgRowStatus);
		rval = (u_char *) &StorageTmp->isupPgRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupPuTable_row(struct isupPuTable_data *StorageTmp, struct isupPuTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupPuTable_row(struct isupPuTable_data *StorageTmp, struct isupPuTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupPuTable_row(struct isupPuTable_data *StorageTmp, struct isupPuTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupPuTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupPuTable_row(struct isupPuTable_data *StorageTmp, struct isupPuTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupPuTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupPuTable_row(struct isupPuTable_data *StorageTmp, struct isupPuTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupPuTable_row(struct isupPuTable_data *StorageTmp, struct isupPuTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupPuTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupPuTable_row(struct isupPuTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupPuTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupPuTable_data *
refresh_isupPuTable_row(struct isupPuTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupPuTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupPuTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupPuTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupPuTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupPuTable(int force)
{
	if (!force && isupPuTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupPuTable_refresh = 0;
}

/**
 * @fn u_char *var_isupPuTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupPuTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupPuTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupPuTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupPuTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupPuTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupPuTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupPuTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPPUPROTECTING:	/* Create */
		*write_method = write_isupPuProtecting;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPuProtecting);
		rval = (u_char *) &StorageTmp->isupPuProtecting;
		break;
	case (u_char) ISUPPURELIABLERESOURCEPOINTER:	/* Create */
		*write_method = write_isupPuReliableResourcePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupPuReliableResourcePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupPuReliableResourcePointer;
		break;
	case (u_char) ISUPPUUNRELIABLERESOURCEPOINTER:	/* Create */
		*write_method = write_isupPuUnreliableResourcePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupPuUnreliableResourcePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupPuUnreliableResourcePointer;
		break;
	case (u_char) ISUPPUPROTECTIONSTATUS:	/* Create */
		*write_method = write_isupPuProtectionStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupPuProtectionStatusLen;
		rval = (u_char *) StorageTmp->isupPuProtectionStatus;
		break;
	case (u_char) ISUPPUSWITCHSTATUS:	/* Create */
		*write_method = write_isupPuSwitchStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPuSwitchStatus);
		rval = (u_char *) &StorageTmp->isupPuSwitchStatus;
		break;
	case (u_char) ISUPPUFROMPROTECTIONUNITNUMBER:	/* Create */
		*write_method = write_isupPuFromProtectionUnitNumber;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPuFromProtectionUnitNumber);
		rval = (u_char *) &StorageTmp->isupPuFromProtectionUnitNumber;
		break;
	case (u_char) ISUPPUTOPROTECTIONUNITNUMBER:	/* Create */
		*write_method = write_isupPuToProtectionUnitNumber;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPuToProtectionUnitNumber);
		rval = (u_char *) &StorageTmp->isupPuToProtectionUnitNumber;
		break;
	case (u_char) ISUPPUAUTOSWITCHREASON:	/* Create */
		*write_method = write_isupPuAutoSwitchReason;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPuAutoSwitchReason);
		rval = (u_char *) &StorageTmp->isupPuAutoSwitchReason;
		break;
	case (u_char) ISUPPULOCKOUTRELEASEFAILED:	/* Create */
		*write_method = write_isupPuLockoutReleaseFailed;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPuLockoutReleaseFailed);
		rval = (u_char *) &StorageTmp->isupPuLockoutReleaseFailed;
		break;
	case (u_char) ISUPPUPRIORITY:	/* Create */
		*write_method = write_isupPuPriority;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPuPriority);
		rval = (u_char *) &StorageTmp->isupPuPriority;
		break;
	case (u_char) ISUPPUROWSTATUS:	/* Create */
		*write_method = write_isupPuRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupPuRowStatus);
		rval = (u_char *) &StorageTmp->isupPuRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupLgTable_row(struct isupLgTable_data *StorageTmp, struct isupLgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupLgTable_row(struct isupLgTable_data *StorageTmp, struct isupLgTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupLgTable_row(struct isupLgTable_data *StorageTmp, struct isupLgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupLgTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupLgTable_row(struct isupLgTable_data *StorageTmp, struct isupLgTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupLgTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupLgTable_row(struct isupLgTable_data *StorageTmp, struct isupLgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupLgTable_row(struct isupLgTable_data *StorageTmp, struct isupLgTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupLgTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupLgTable_row(struct isupLgTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupLgTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupLgTable_data *
refresh_isupLgTable_row(struct isupLgTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupLgTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupLgTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupLgTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupLgTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupLgTable(int force)
{
	if (!force && isupLgTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupLgTable_refresh = 0;
}

/**
 * @fn u_char *var_isupLgTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupLgTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupLgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupLgTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupLgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupLgTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupLgTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupLgTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPLGOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupLgOperationalState);
		rval = (u_char *) &StorageTmp->isupLgOperationalState;
		break;
	case (u_char) ISUPLGADMINISTRATIVESTATE:	/* Create */
		*write_method = write_isupLgAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupLgAdministrativeState);
		rval = (u_char *) &StorageTmp->isupLgAdministrativeState;
		break;
	case (u_char) ISUPLGSNSERVICEPROVIDER:	/* Create */
		*write_method = write_isupLgSnServiceProvider;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupLgSnServiceProviderLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupLgSnServiceProvider;
		break;
	case (u_char) ISUPLGSNSAP:	/* Create */
		*write_method = write_isupLgSnSap;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupLgSnSapLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupLgSnSap;
		break;
	case (u_char) ISUPLGOPERATIONALPROTOCOLS:	/* Create */
		*write_method = write_isupLgOperationalProtocols;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupLgOperationalProtocolsLen;
		rval = (u_char *) StorageTmp->isupLgOperationalProtocols;
		break;
	case (u_char) ISUPLGOPERATIONALSUBSETS:	/* Create */
		*write_method = write_isupLgOperationalSubsets;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupLgOperationalSubsetsLen;
		rval = (u_char *) StorageTmp->isupLgOperationalSubsets;
		break;
	case (u_char) ISUPLGROWSTATUS:	/* Create */
		*write_method = write_isupLgRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupLgRowStatus);
		rval = (u_char *) &StorageTmp->isupLgRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupMtpTable_row(struct isupMtpTable_data *StorageTmp, struct isupMtpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupMtpTable_row(struct isupMtpTable_data *StorageTmp, struct isupMtpTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupMtpTable_row(struct isupMtpTable_data *StorageTmp, struct isupMtpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupMtpTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupMtpTable_row(struct isupMtpTable_data *StorageTmp, struct isupMtpTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupMtpTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupMtpTable_row(struct isupMtpTable_data *StorageTmp, struct isupMtpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupMtpTable_row(struct isupMtpTable_data *StorageTmp, struct isupMtpTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupMtpTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupMtpTable_row(struct isupMtpTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupMtpTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupMtpTable_data *
refresh_isupMtpTable_row(struct isupMtpTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupMtpTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupMtpTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupMtpTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupMtpTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupMtpTable(int force)
{
	if (!force && isupMtpTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupMtpTable_refresh = 0;
}

/**
 * @fn u_char *var_isupMtpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupMtpTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupMtpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupMtpTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupMtpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupMtpTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupMtpTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupMtpTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPMTPADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMtpAddressLen;
		rval = (u_char *) StorageTmp->isupMtpAddress;
		break;
	case (u_char) ISUPMTPUSERPART:	/* Create */
		*write_method = write_isupMtpUserPart;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMtpUserPart);
		rval = (u_char *) &StorageTmp->isupMtpUserPart;
		break;
	case (u_char) ISUPMTPUSERPARTSTATUS:	/* Create */
		*write_method = write_isupMtpUserPartStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMtpUserPartStatus);
		rval = (u_char *) &StorageTmp->isupMtpUserPartStatus;
		break;
	case (u_char) ISUPMTPUSERENTITYNAMES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMtpUserEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupMtpUserEntityNames;
		break;
	case (u_char) ISUPMTPPROVIDERENTITYNAMES:	/* Create */
		*write_method = write_isupMtpProviderEntityNames;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMtpProviderEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupMtpProviderEntityNames;
		break;
	case (u_char) ISUPMTPUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMtpUsageState);
		rval = (u_char *) &StorageTmp->isupMtpUsageState;
		break;
	case (u_char) ISUPMTPASAPROFILEPOINTER:	/* Create */
		*write_method = write_isupMtpAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMtpAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupMtpAsaProfilePointer;
		break;
	case (u_char) ISUPMTPNAME:	/* Create */
		*write_method = write_isupMtpName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupMtpNameLen;
		rval = (u_char *) StorageTmp->isupMtpName;
		break;
	case (u_char) ISUPMTPLONGMESSAGESUPPORTED:	/* Create */
		*write_method = write_isupMtpLongMessageSupported;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMtpLongMessageSupported);
		rval = (u_char *) &StorageTmp->isupMtpLongMessageSupported;
		break;
	case (u_char) ISUPMTPROWSTATUS:	/* Create */
		*write_method = write_isupMtpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupMtpRowStatus);
		rval = (u_char *) &StorageTmp->isupMtpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupNaTable_row(struct isupNaTable_data *StorageTmp, struct isupNaTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupNaTable_row(struct isupNaTable_data *StorageTmp, struct isupNaTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupNaTable_row(struct isupNaTable_data *StorageTmp, struct isupNaTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupNaTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupNaTable_row(struct isupNaTable_data *StorageTmp, struct isupNaTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupNaTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupNaTable_row(struct isupNaTable_data *StorageTmp, struct isupNaTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupNaTable_row(struct isupNaTable_data *StorageTmp, struct isupNaTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupNaTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupNaTable_row(struct isupNaTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupNaTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupNaTable_data *
refresh_isupNaTable_row(struct isupNaTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupNaTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupNaTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupNaTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupNaTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupNaTable(int force)
{
	if (!force && isupNaTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupNaTable_refresh = 0;
}

/**
 * @fn u_char *var_isupNaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupNaTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupNaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupNaTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupNaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupNaTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupNaTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupNaTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPNAPROTOCOLVARIANT:	/* Create */
		*write_method = write_isupNaProtocolVariant;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupNaProtocolVariantLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupNaProtocolVariant;
		break;
	case (u_char) ISUPNAPROTOCOLYEAR:	/* Create */
		*write_method = write_isupNaProtocolYear;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupNaProtocolYear);
		rval = (u_char *) &StorageTmp->isupNaProtocolYear;
		break;
	case (u_char) ISUPNAPROTOCOLOPTIONS:	/* Create */
		*write_method = write_isupNaProtocolOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupNaProtocolOptionsLen;
		rval = (u_char *) StorageTmp->isupNaProtocolOptions;
		break;
	case (u_char) ISUPNAPOINTCODEFORMAT:	/* Create */
		*write_method = write_isupNaPointCodeFormat;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupNaPointCodeFormatLen;
		rval = (u_char *) StorageTmp->isupNaPointCodeFormat;
		break;
	case (u_char) ISUPNASLSLENGTH:	/* Create */
		*write_method = write_isupNaSlsLength;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupNaSlsLength);
		rval = (u_char *) &StorageTmp->isupNaSlsLength;
		break;
	case (u_char) ISUPNASPDEFAULT:	/* Create */
		*write_method = write_isupNaSpDefault;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupNaSpDefaultLen;
		rval = (u_char *) StorageTmp->isupNaSpDefault;
		break;
	case (u_char) ISUPNANAME:	/* Create */
		*write_method = write_isupNaName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupNaNameLen;
		rval = (u_char *) StorageTmp->isupNaName;
		break;
	case (u_char) ISUPNAROWSTATUS:	/* Create */
		*write_method = write_isupNaRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupNaRowStatus);
		rval = (u_char *) &StorageTmp->isupNaRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupSpTable_row(struct isupSpTable_data *StorageTmp, struct isupSpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupSpTable_row(struct isupSpTable_data *StorageTmp, struct isupSpTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupSpTable_row(struct isupSpTable_data *StorageTmp, struct isupSpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupSpTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupSpTable_row(struct isupSpTable_data *StorageTmp, struct isupSpTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupSpTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupSpTable_row(struct isupSpTable_data *StorageTmp, struct isupSpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupSpTable_row(struct isupSpTable_data *StorageTmp, struct isupSpTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupSpTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupSpTable_row(struct isupSpTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupSpTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupSpTable_data *
refresh_isupSpTable_row(struct isupSpTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupSpTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupSpTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupSpTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupSpTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupSpTable(int force)
{
	if (!force && isupSpTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupSpTable_refresh = 0;
}

/**
 * @fn u_char *var_isupSpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupSpTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupSpTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupSpTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupSpTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupSpTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPSPPOINTCODE:	/* Create */
		*write_method = write_isupSpPointCode;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSpPointCodeLen;
		rval = (u_char *) StorageTmp->isupSpPointCode;
		break;
	case (u_char) ISUPSPTYPE:	/* Create */
		*write_method = write_isupSpType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSpType);
		rval = (u_char *) &StorageTmp->isupSpType;
		break;
	case (u_char) ISUPSPPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSpProceduralStatusLen;
		rval = (u_char *) StorageTmp->isupSpProceduralStatus;
		break;
	case (u_char) ISUPSPAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSpAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->isupSpAvailabilityStatus;
		break;
	case (u_char) ISUPSPVERSION:	/* Create */
		*write_method = write_isupSpVersion;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSpVersionLen;
		rval = (u_char *) StorageTmp->isupSpVersion;
		break;
	case (u_char) ISUPSPNAME:	/* Create */
		*write_method = write_isupSpName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSpNameLen;
		rval = (u_char *) StorageTmp->isupSpName;
		break;
	case (u_char) ISUPSPNAPOINTER:	/* Create */
		*write_method = write_isupSpNaPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSpNaPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupSpNaPointer;
		break;
	case (u_char) ISUPSPOPTIONS:	/* Create */
		*write_method = write_isupSpOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSpOptionsLen;
		rval = (u_char *) StorageTmp->isupSpOptions;
		break;
	case (u_char) ISUPSPALARMSTATUS:	/* Create */
		*write_method = write_isupSpAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSpAlarmStatusLen;
		rval = (u_char *) StorageTmp->isupSpAlarmStatus;
		break;
	case (u_char) ISUPSPOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSpOperationalState);
		rval = (u_char *) &StorageTmp->isupSpOperationalState;
		break;
	case (u_char) ISUPSPTOTALREMOTESAPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSpTotalRemoteSAPs);
		rval = (u_char *) &StorageTmp->isupSpTotalRemoteSAPs;
		break;
	case (u_char) ISUPSPADMINISTRATIVESTATE:	/* Create */
		*write_method = write_isupSpAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSpAdministrativeState);
		rval = (u_char *) &StorageTmp->isupSpAdministrativeState;
		break;
	case (u_char) ISUPSPSUPPORTEDPROTOCOLS:	/* Create */
		*write_method = write_isupSpSupportedProtocols;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSpSupportedProtocolsLen;
		rval = (u_char *) StorageTmp->isupSpSupportedProtocols;
		break;
	case (u_char) ISUPSPOPERATIONALSYSTEMTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSpOperationalSystemType);
		rval = (u_char *) &StorageTmp->isupSpOperationalSystemType;
		break;
	case (u_char) ISUPSPACTIVATE:	/* Create */
		*write_method = write_isupSpActivate;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSpActivate);
		rval = (u_char *) &StorageTmp->isupSpActivate;
		break;
	case (u_char) ISUPSPDEACTIVATE:	/* Create */
		*write_method = write_isupSpDeactivate;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSpDeactivate);
		rval = (u_char *) &StorageTmp->isupSpDeactivate;
		break;
	case (u_char) ISUPSPROWSTATUS:	/* Create */
		*write_method = write_isupSpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSpRowStatus);
		rval = (u_char *) &StorageTmp->isupSpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupSrTable_row(struct isupSrTable_data *StorageTmp, struct isupSrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupSrTable_row(struct isupSrTable_data *StorageTmp, struct isupSrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupSrTable_row(struct isupSrTable_data *StorageTmp, struct isupSrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupSrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupSrTable_row(struct isupSrTable_data *StorageTmp, struct isupSrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupSrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupSrTable_row(struct isupSrTable_data *StorageTmp, struct isupSrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupSrTable_row(struct isupSrTable_data *StorageTmp, struct isupSrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupSrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupSrTable_row(struct isupSrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupSrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupSrTable_data *
refresh_isupSrTable_row(struct isupSrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupSrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupSrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupSrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupSrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupSrTable(int force)
{
	if (!force && isupSrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupSrTable_refresh = 0;
}

/**
 * @fn u_char *var_isupSrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupSrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupSrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupSrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupSrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupSrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupSrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupSrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPSRDEST:	/* Create */
		*write_method = write_isupSrDest;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSrDestLen;
		rval = (u_char *) StorageTmp->isupSrDest;
		break;
	case (u_char) ISUPSROPTIONS:	/* Create */
		*write_method = write_isupSrOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSrOptionsLen;
		rval = (u_char *) StorageTmp->isupSrOptions;
		break;
	case (u_char) ISUPSRSLSASSIGNMENT:	/* Create */
		*write_method = write_isupSrSlsAssignment;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSrSlsAssignment);
		rval = (u_char *) &StorageTmp->isupSrSlsAssignment;
		break;
	case (u_char) ISUPSRADMINSTATE:	/* Create */
		*write_method = write_isupSrAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSrAdminState);
		rval = (u_char *) &StorageTmp->isupSrAdminState;
		break;
	case (u_char) ISUPSROPSTATE:	/* Create */
		*write_method = write_isupSrOpState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSrOpState);
		rval = (u_char *) &StorageTmp->isupSrOpState;
		break;
	case (u_char) ISUPSRASAPROFILEPOINTER:	/* Create */
		*write_method = write_isupSrAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSrAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupSrAsaProfilePointer;
		break;
	case (u_char) ISUPSRCONGESTEDSTATE:	/* Create */
		*write_method = write_isupSrCongestedState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSrCongestedState);
		rval = (u_char *) &StorageTmp->isupSrCongestedState;
		break;
	case (u_char) ISUPSRCONGESTIONLEVEL:	/* Create */
		*write_method = write_isupSrCongestionLevel;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSrCongestionLevel);
		rval = (u_char *) &StorageTmp->isupSrCongestionLevel;
		break;
	case (u_char) ISUPSRLOADSHARINGINFORMATION:	/* Create */
		*write_method = write_isupSrLoadsharingInformation;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSrLoadsharingInformationLen;
		rval = (u_char *) StorageTmp->isupSrLoadsharingInformation;
		break;
	case (u_char) ISUPSRLOADSHARINGOBJECT:	/* Create */
		*write_method = write_isupSrLoadsharingObject;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSrLoadsharingObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupSrLoadsharingObject;
		break;
	case (u_char) ISUPSRREMOTEEXCHANGELABEL:	/* Create */
		*write_method = write_isupSrRemoteExchangeLabel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSrRemoteExchangeLabelLen;
		rval = (u_char *) StorageTmp->isupSrRemoteExchangeLabel;
		break;
	case (u_char) ISUPSRNAME:	/* Create */
		*write_method = write_isupSrName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSrNameLen;
		rval = (u_char *) StorageTmp->isupSrName;
		break;
	case (u_char) ISUPSRPROFILE:	/* Create */
		*write_method = write_isupSrProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSrProfileLen;
		rval = (u_char *) StorageTmp->isupSrProfile;
		break;
	case (u_char) ISUPSRALARMSTATUS:	/* Create */
		*write_method = write_isupSrAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupSrAlarmStatusLen;
		rval = (u_char *) StorageTmp->isupSrAlarmStatus;
		break;
	case (u_char) ISUPSRROWSTATUS:	/* Create */
		*write_method = write_isupSrRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupSrRowStatus);
		rval = (u_char *) &StorageTmp->isupSrRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupRtTable_row(struct isupRtTable_data *StorageTmp, struct isupRtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupRtTable_row(struct isupRtTable_data *StorageTmp, struct isupRtTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupRtTable_row(struct isupRtTable_data *StorageTmp, struct isupRtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupRtTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupRtTable_row(struct isupRtTable_data *StorageTmp, struct isupRtTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupRtTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupRtTable_row(struct isupRtTable_data *StorageTmp, struct isupRtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupRtTable_row(struct isupRtTable_data *StorageTmp, struct isupRtTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupRtTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupRtTable_row(struct isupRtTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupRtTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupRtTable_data *
refresh_isupRtTable_row(struct isupRtTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupRtTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupRtTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupRtTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupRtTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupRtTable(int force)
{
	if (!force && isupRtTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupRtTable_refresh = 0;
}

/**
 * @fn u_char *var_isupRtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupRtTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupRtTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupRtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupRtTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupRtTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupRtTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPRTTRUNKGROUPLIST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupRtTrunkGroupListLen;
		rval = (u_char *) StorageTmp->isupRtTrunkGroupList;
		break;
	case (u_char) ISUPRTUSEDALGORITHM:	/* Create */
		*write_method = write_isupRtUsedAlgorithm;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupRtUsedAlgorithm);
		rval = (u_char *) &StorageTmp->isupRtUsedAlgorithm;
		break;
	case (u_char) ISUPRTSELECTION:	/* Create */
		*write_method = write_isupRtSelection;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupRtSelectionLen;
		rval = (u_char *) StorageTmp->isupRtSelection;
		break;
	case (u_char) ISUPRTPROPORTIONLIST:	/* Create */
		*write_method = write_isupRtProportionList;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupRtProportionListLen;
		rval = (u_char *) StorageTmp->isupRtProportionList;
		break;
	case (u_char) ISUPRTPOSSIBILITIESINLIST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupRtPossibilitiesInListLen;
		rval = (u_char *) StorageTmp->isupRtPossibilitiesInList;
		break;
	case (u_char) ISUPRTUSERLABEL:	/* Create */
		*write_method = write_isupRtUserLabel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupRtUserLabelLen;
		rval = (u_char *) StorageTmp->isupRtUserLabel;
		break;
	case (u_char) ISUPRTPROCSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupRtProcStatusLen;
		rval = (u_char *) StorageTmp->isupRtProcStatus;
		break;
	case (u_char) ISUPRTCONTROLSTATUS:	/* Create */
		*write_method = write_isupRtControlStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupRtControlStatusLen;
		rval = (u_char *) StorageTmp->isupRtControlStatus;
		break;
	case (u_char) ISUPRTADMINSTATE:	/* Create */
		*write_method = write_isupRtAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupRtAdminState);
		rval = (u_char *) &StorageTmp->isupRtAdminState;
		break;
	case (u_char) ISUPRTOPERSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupRtOperState);
		rval = (u_char *) &StorageTmp->isupRtOperState;
		break;
	case (u_char) ISUPRTUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupRtUsageState);
		rval = (u_char *) &StorageTmp->isupRtUsageState;
		break;
	case (u_char) ISUPRTROWSTATUS:	/* Create */
		*write_method = write_isupRtRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupRtRowStatus);
		rval = (u_char *) &StorageTmp->isupRtRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp, struct isupRtTgSelectionTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp, struct isupRtTgSelectionTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp, struct isupRtTgSelectionTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupRtTgSelectionTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp, struct isupRtTgSelectionTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupRtTgSelectionTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp, struct isupRtTgSelectionTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp, struct isupRtTgSelectionTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupRtTgSelectionTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupRtTgSelectionTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupRtTgSelectionTable_data *
refresh_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupRtTgSelectionTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupRtTgSelectionTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupRtTgSelectionTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupRtTgSelectionTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupRtTgSelectionTable(int force)
{
	if (!force && isupRtTgSelectionTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupRtTgSelectionTable_refresh = 0;
}

/**
 * @fn u_char *var_isupRtTgSelectionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupRtTgSelectionTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupRtTgSelectionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupRtTgSelectionTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupRtTgSelectionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupRtTgSelectionTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupRtTgSelectionTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupRtTgSelectionTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPRTTGSELECTIONORDINAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupRtTgSelectionOrdinal);
		rval = (u_char *) &StorageTmp->isupRtTgSelectionOrdinal;
		break;
	case (u_char) ISUPRTTGSELECTIONPROPORTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupRtTgSelectionProportion);
		rval = (u_char *) &StorageTmp->isupRtTgSelectionProportion;
		break;
	case (u_char) ISUPRTTGSELECTIONLIST:	/* Create */
		*write_method = write_isupRtTgSelectionList;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupRtTgSelectionListLen;
		rval = (u_char *) StorageTmp->isupRtTgSelectionList;
		break;
	case (u_char) ISUPRTTGSELECTIONROWSTATUS:	/* Create */
		*write_method = write_isupRtTgSelectionRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupRtTgSelectionRowStatus);
		rval = (u_char *) &StorageTmp->isupRtTgSelectionRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupTgTable_row(struct isupTgTable_data *StorageTmp, struct isupTgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupTgTable_row(struct isupTgTable_data *StorageTmp, struct isupTgTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupTgTable_row(struct isupTgTable_data *StorageTmp, struct isupTgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupTgTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupTgTable_row(struct isupTgTable_data *StorageTmp, struct isupTgTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupTgTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupTgTable_row(struct isupTgTable_data *StorageTmp, struct isupTgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupTgTable_row(struct isupTgTable_data *StorageTmp, struct isupTgTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupTgTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupTgTable_row(struct isupTgTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupTgTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupTgTable_data *
refresh_isupTgTable_row(struct isupTgTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupTgTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupTgTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupTgTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupTgTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupTgTable(int force)
{
	if (!force && isupTgTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupTgTable_refresh = 0;
}

/**
 * @fn u_char *var_isupTgTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupTgTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupTgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupTgTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupTgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupTgTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupTgTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupTgTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPTGNUMBEROFCIRCUITS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgNumberOfCircuits);
		rval = (u_char *) &StorageTmp->isupTgNumberOfCircuits;
		break;
	case (u_char) ISUPTGLABELOFFARENDEXCHANGE:	/* Create */
		*write_method = write_isupTgLabelOfFarEndExchange;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupTgLabelOfFarEndExchangeLen;
		rval = (u_char *) StorageTmp->isupTgLabelOfFarEndExchange;
		break;
	case (u_char) ISUPTGSIGNALLINGCAPABILITIES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgSignallingCapabilities);
		rval = (u_char *) &StorageTmp->isupTgSignallingCapabilities;
		break;
	case (u_char) ISUPTGINFORMATIONTRANSFERCAPABILITIES:	/* Create */
		*write_method = write_isupTgInformationTransferCapabilities;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgInformationTransferCapabilities);
		rval = (u_char *) &StorageTmp->isupTgInformationTransferCapabilities;
		break;
	case (u_char) ISUPTGCIRCUITDIRECTIONALITY:	/* Create */
		*write_method = write_isupTgCircuitDirectionality;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgCircuitDirectionality);
		rval = (u_char *) &StorageTmp->isupTgCircuitDirectionality;
		break;
	case (u_char) ISUPTGTRANSMISSIONCHARACTERISTICS:	/* Create */
		*write_method = write_isupTgTransmissionCharacteristics;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupTgTransmissionCharacteristicsLen;
		rval = (u_char *) StorageTmp->isupTgTransmissionCharacteristics;
		break;
	case (u_char) ISUPTGUSERLABEL:	/* Create */
		*write_method = write_isupTgUserLabel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupTgUserLabelLen;
		rval = (u_char *) StorageTmp->isupTgUserLabel;
		break;
	case (u_char) ISUPTGADMINSTATE:	/* Create */
		*write_method = write_isupTgAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgAdminState);
		rval = (u_char *) &StorageTmp->isupTgAdminState;
		break;
	case (u_char) ISUPTGASSOCSIGNROUTESETNEPART:	/* Create */
		*write_method = write_isupTgAssocSignRouteSetNePart;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgAssocSignRouteSetNePart);
		rval = (u_char *) &StorageTmp->isupTgAssocSignRouteSetNePart;
		break;
	case (u_char) ISUPTGBOUNDARYCROSSING:	/* Create */
		*write_method = write_isupTgBoundaryCrossing;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgBoundaryCrossing);
		rval = (u_char *) &StorageTmp->isupTgBoundaryCrossing;
		break;
	case (u_char) ISUPTGSEARCHMETHOD:	/* Create */
		*write_method = write_isupTgSearchMethod;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgSearchMethod);
		rval = (u_char *) &StorageTmp->isupTgSearchMethod;
		break;
	case (u_char) ISUPTGPREFTRAFFICREDIRECT:	/* Create */
		*write_method = write_isupTgPrefTrafficRedirect;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgPrefTrafficRedirect);
		rval = (u_char *) &StorageTmp->isupTgPrefTrafficRedirect;
		break;
	case (u_char) ISUPTGSUPPRESSOWNCAC:	/* Create */
		*write_method = write_isupTgSuppressOwnCac;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgSuppressOwnCac);
		rval = (u_char *) &StorageTmp->isupTgSuppressOwnCac;
		break;
	case (u_char) ISUPTGCARRIERTYPE:	/* Create */
		*write_method = write_isupTgCarrierType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgCarrierType);
		rval = (u_char *) &StorageTmp->isupTgCarrierType;
		break;
	case (u_char) ISUPTGDOUBLESEIZURECONTROL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgDoubleSeizureControl);
		rval = (u_char *) &StorageTmp->isupTgDoubleSeizureControl;
		break;
	case (u_char) ISUPTGALARMCARRIER:	/* Create */
		*write_method = write_isupTgAlarmCarrier;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgAlarmCarrier);
		rval = (u_char *) &StorageTmp->isupTgAlarmCarrier;
		break;
	case (u_char) ISUPTGCONTCHECK:	/* Create */
		*write_method = write_isupTgContCheck;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgContCheck);
		rval = (u_char *) &StorageTmp->isupTgContCheck;
		break;
	case (u_char) ISUPTGCONTCHECKRATIO:	/* Create */
		*write_method = write_isupTgContCheckRatio;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgContCheckRatio);
		rval = (u_char *) &StorageTmp->isupTgContCheckRatio;
		break;
	case (u_char) ISUPTGPG:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgPg);
		rval = (u_char *) &StorageTmp->isupTgPg;
		break;
	case (u_char) ISUPTGSTANDBYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgStandbyStatus);
		rval = (u_char *) &StorageTmp->isupTgStandbyStatus;
		break;
	case (u_char) ISUPTGALARMSTATUS:	/* Create */
		*write_method = write_isupTgAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupTgAlarmStatusLen;
		rval = (u_char *) StorageTmp->isupTgAlarmStatus;
		break;
	case (u_char) ISUPTGROWSTATUS:	/* Create */
		*write_method = write_isupTgRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupTgRowStatus);
		rval = (u_char *) &StorageTmp->isupTgRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupCgTable_row(struct isupCgTable_data *StorageTmp, struct isupCgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupCgTable_row(struct isupCgTable_data *StorageTmp, struct isupCgTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupCgTable_row(struct isupCgTable_data *StorageTmp, struct isupCgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupCgTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupCgTable_row(struct isupCgTable_data *StorageTmp, struct isupCgTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupCgTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupCgTable_row(struct isupCgTable_data *StorageTmp, struct isupCgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupCgTable_row(struct isupCgTable_data *StorageTmp, struct isupCgTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupCgTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupCgTable_row(struct isupCgTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupCgTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupCgTable_data *
refresh_isupCgTable_row(struct isupCgTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupCgTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupCgTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupCgTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupCgTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupCgTable(int force)
{
	if (!force && isupCgTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupCgTable_refresh = 0;
}

/**
 * @fn u_char *var_isupCgTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupCgTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupCgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupCgTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupCgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupCgTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupCgTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupCgTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPCGCIC:	/* Create */
		*write_method = write_isupCgCIC;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgCIC);
		rval = (u_char *) &StorageTmp->isupCgCIC;
		break;
	case (u_char) ISUPCGOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgOperationalState);
		rval = (u_char *) &StorageTmp->isupCgOperationalState;
		break;
	case (u_char) ISUPCGALARMSTATUS:	/* Create */
		*write_method = write_isupCgAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupCgAlarmStatusLen;
		rval = (u_char *) StorageTmp->isupCgAlarmStatus;
		break;
	case (u_char) ISUPCGRANGETYPE:	/* Create */
		*write_method = write_isupCgRangeType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgRangeType);
		rval = (u_char *) &StorageTmp->isupCgRangeType;
		break;
	case (u_char) ISUPCGRANGEANDSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupCgRangeAndStatusLen;
		rval = (u_char *) StorageTmp->isupCgRangeAndStatus;
		break;
	case (u_char) ISUPCGCARRIERTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgCarrierType);
		rval = (u_char *) &StorageTmp->isupCgCarrierType;
		break;
	case (u_char) ISUPCGALARMCARRIER:	/* Create */
		*write_method = write_isupCgAlarmCarrier;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgAlarmCarrier);
		rval = (u_char *) &StorageTmp->isupCgAlarmCarrier;
		break;
	case (u_char) ISUPCGCONTCHECK:	/* Create */
		*write_method = write_isupCgContCheck;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgContCheck);
		rval = (u_char *) &StorageTmp->isupCgContCheck;
		break;
	case (u_char) ISUPCGCONTCHECKRATIO:	/* Create */
		*write_method = write_isupCgContCheckRatio;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgContCheckRatio);
		rval = (u_char *) &StorageTmp->isupCgContCheckRatio;
		break;
	case (u_char) ISUPCGPG:	/* Create */
		*write_method = write_isupCgPg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgPg);
		rval = (u_char *) &StorageTmp->isupCgPg;
		break;
	case (u_char) ISUPCGSTANDBYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgStandbyStatus);
		rval = (u_char *) &StorageTmp->isupCgStandbyStatus;
		break;
	case (u_char) ISUPCGROWSTATUS:	/* Create */
		*write_method = write_isupCgRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCgRowStatus);
		rval = (u_char *) &StorageTmp->isupCgRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isupCtTable_row(struct isupCtTable_data *StorageTmp, struct isupCtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isupCtTable_row(struct isupCtTable_data *StorageTmp, struct isupCtTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isupCtTable_row(struct isupCtTable_data *StorageTmp, struct isupCtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isupCtTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isupCtTable_row(struct isupCtTable_data *StorageTmp, struct isupCtTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isupCtTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isupCtTable_row(struct isupCtTable_data *StorageTmp, struct isupCtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isupCtTable_row(struct isupCtTable_data *StorageTmp, struct isupCtTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isupCtTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isupCtTable_row(struct isupCtTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isupCtTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isupCtTable_data *
refresh_isupCtTable_row(struct isupCtTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isupCtTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isupCtTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isupCtTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isupCtTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isupCtTable(int force)
{
	if (!force && isupCtTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isupCtTable_refresh = 0;
}

/**
 * @fn u_char *var_isupCtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isupCtTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isupMIB above.
 */
u_char *
var_isupCtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isupCtTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isupMIB", "var_isupCtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isupCtTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isupCtTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isupCtTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISUPCTCG:	/* Create */
		*write_method = write_isupCtCg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCtCg);
		rval = (u_char *) &StorageTmp->isupCtCg;
		break;
	case (u_char) ISUPCTTG:	/* Create */
		*write_method = write_isupCtTg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCtTg);
		rval = (u_char *) &StorageTmp->isupCtTg;
		break;
	case (u_char) ISUPCTADMINSTATE:	/* Create */
		*write_method = write_isupCtAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCtAdminState);
		rval = (u_char *) &StorageTmp->isupCtAdminState;
		break;
	case (u_char) ISUPCTUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCtUsageState);
		rval = (u_char *) &StorageTmp->isupCtUsageState;
		break;
	case (u_char) ISUPCTCTPBINSTANCE:	/* Create */
		*write_method = write_isupCtCtpbInstance;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupCtCtpbInstanceLen * sizeof(oid);
		rval = (u_char *) StorageTmp->isupCtCtpbInstance;
		break;
	case (u_char) ISUPCTCIRCUITNUMBER:	/* Create */
		*write_method = write_isupCtCircuitNumber;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCtCircuitNumber);
		rval = (u_char *) &StorageTmp->isupCtCircuitNumber;
		break;
	case (u_char) ISUPCTOFFICEEQUIP:	/* Create */
		*write_method = write_isupCtOfficeEquip;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isupCtOfficeEquipLen;
		rval = (u_char *) StorageTmp->isupCtOfficeEquip;
		break;
	case (u_char) ISUPCTCIC:	/* Create */
		*write_method = write_isupCtCIC;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCtCIC);
		rval = (u_char *) &StorageTmp->isupCtCIC;
		break;
	case (u_char) ISUPCTROWSTATUS:	/* Create */
		*write_method = write_isupCtRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isupCtRowStatus);
		rval = (u_char *) &StorageTmp->isupCtRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_isupMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMsName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			if (StorageTmp->isupMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMsTable_old = isupMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupMsName);
		StorageTmp->isupMsName = string;
		StorageTmp->isupMsNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMsTable_tsts == 0)
				if ((ret = check_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMsTable_sets == 0)
				if ((ret = update_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
			StorageTmp->isupMsTable_rsvs = 0;
			StorageTmp->isupMsTable_tsts = 0;
			StorageTmp->isupMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMsTable_sets == 0)
			revert_isupMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		if (StorageOld->isupMsName != NULL) {
			SNMP_FREE(StorageTmp->isupMsName);
			StorageTmp->isupMsName = StorageOld->isupMsName;
			StorageTmp->isupMsNameLen = StorageOld->isupMsNameLen;
			StorageOld->isupMsName = NULL;
			StorageOld->isupMsNameLen = 0;
		}
		if (--StorageTmp->isupMsTable_rsvs == 0)
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMsAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			if (StorageTmp->isupMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMsTable_old = isupMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupMsAlarmStatus);
		StorageTmp->isupMsAlarmStatus = string;
		StorageTmp->isupMsAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMsTable_tsts == 0)
				if ((ret = check_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMsAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMsTable_sets == 0)
				if ((ret = update_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
			StorageTmp->isupMsTable_rsvs = 0;
			StorageTmp->isupMsTable_tsts = 0;
			StorageTmp->isupMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMsTable_sets == 0)
			revert_isupMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		if (StorageOld->isupMsAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->isupMsAlarmStatus);
			StorageTmp->isupMsAlarmStatus = StorageOld->isupMsAlarmStatus;
			StorageTmp->isupMsAlarmStatusLen = StorageOld->isupMsAlarmStatusLen;
			StorageOld->isupMsAlarmStatus = NULL;
			StorageOld->isupMsAlarmStatusLen = 0;
		}
		if (--StorageTmp->isupMsTable_rsvs == 0)
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMsUserLabel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsUserLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsUserLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			if (StorageTmp->isupMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMsTable_old = isupMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupMsUserLabel);
		StorageTmp->isupMsUserLabel = string;
		StorageTmp->isupMsUserLabelLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMsTable_tsts == 0)
				if ((ret = check_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMsUserLabel for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMsTable_sets == 0)
				if ((ret = update_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
			StorageTmp->isupMsTable_rsvs = 0;
			StorageTmp->isupMsTable_tsts = 0;
			StorageTmp->isupMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMsTable_sets == 0)
			revert_isupMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		if (StorageOld->isupMsUserLabel != NULL) {
			SNMP_FREE(StorageTmp->isupMsUserLabel);
			StorageTmp->isupMsUserLabel = StorageOld->isupMsUserLabel;
			StorageTmp->isupMsUserLabelLen = StorageOld->isupMsUserLabelLen;
			StorageOld->isupMsUserLabel = NULL;
			StorageOld->isupMsUserLabelLen = 0;
		}
		if (--StorageTmp->isupMsTable_rsvs == 0)
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMsLocationName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMsLocationName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMsLocationName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsLocationName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsLocationName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsLocationName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			if (StorageTmp->isupMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMsTable_old = isupMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupMsLocationName);
		StorageTmp->isupMsLocationName = string;
		StorageTmp->isupMsLocationNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMsTable_tsts == 0)
				if ((ret = check_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMsLocationName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMsTable_sets == 0)
				if ((ret = update_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
			StorageTmp->isupMsTable_rsvs = 0;
			StorageTmp->isupMsTable_tsts = 0;
			StorageTmp->isupMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMsTable_sets == 0)
			revert_isupMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		if (StorageOld->isupMsLocationName != NULL) {
			SNMP_FREE(StorageTmp->isupMsLocationName);
			StorageTmp->isupMsLocationName = StorageOld->isupMsLocationName;
			StorageTmp->isupMsLocationNameLen = StorageOld->isupMsLocationNameLen;
			StorageOld->isupMsLocationName = NULL;
			StorageOld->isupMsLocationNameLen = 0;
		}
		if (--StorageTmp->isupMsTable_rsvs == 0)
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMsAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			if (StorageTmp->isupMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMsTable_old = isupMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupMsAsaProfilePointer);
		StorageTmp->isupMsAsaProfilePointer = objid;
		StorageTmp->isupMsAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMsTable_tsts == 0)
				if ((ret = check_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMsAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMsTable_sets == 0)
				if ((ret = update_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
			StorageTmp->isupMsTable_rsvs = 0;
			StorageTmp->isupMsTable_tsts = 0;
			StorageTmp->isupMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMsTable_sets == 0)
			revert_isupMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		if (StorageOld->isupMsAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->isupMsAsaProfilePointer);
			StorageTmp->isupMsAsaProfilePointer = StorageOld->isupMsAsaProfilePointer;
			StorageTmp->isupMsAsaProfilePointerLen = StorageOld->isupMsAsaProfilePointerLen;
			StorageOld->isupMsAsaProfilePointer = NULL;
			StorageOld->isupMsAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->isupMsTable_rsvs == 0)
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMsNetworkElementAliases entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsNetworkElementAliases: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsNetworkElementAliases not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsNetworkElementAliases: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			if (StorageTmp->isupMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMsTable_old = isupMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupMsNetworkElementAliases);
		StorageTmp->isupMsNetworkElementAliases = string;
		StorageTmp->isupMsNetworkElementAliasesLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMsTable_tsts == 0)
				if ((ret = check_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMsNetworkElementAliases for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMsTable_sets == 0)
				if ((ret = update_isupMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
			StorageTmp->isupMsTable_rsvs = 0;
			StorageTmp->isupMsTable_tsts = 0;
			StorageTmp->isupMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMsTable_sets == 0)
			revert_isupMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
			break;
		if (StorageOld->isupMsNetworkElementAliases != NULL) {
			SNMP_FREE(StorageTmp->isupMsNetworkElementAliases);
			StorageTmp->isupMsNetworkElementAliases = StorageOld->isupMsNetworkElementAliases;
			StorageTmp->isupMsNetworkElementAliasesLen = StorageOld->isupMsNetworkElementAliasesLen;
			StorageOld->isupMsNetworkElementAliases = NULL;
			StorageOld->isupMsNetworkElementAliasesLen = 0;
		}
		if (--StorageTmp->isupMsTable_rsvs == 0)
			isupMsTable_destroy(&StorageTmp->isupMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPPGTYPE_PLUS:
		case ISUPPGTYPE_COLON:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		StorageTmp->isupPgType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgType for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		StorageTmp->isupPgType = StorageOld->isupPgType;
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgRevertive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgRevertive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgRevertive entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgRevertive: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgRevertive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgRevertive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgRevertive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		StorageTmp->isupPgRevertive = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgRevertive for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		StorageTmp->isupPgRevertive = StorageOld->isupPgRevertive;
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgSupportedByObjectList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgSupportedByObjectList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgSupportedByObjectList entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSupportedByObjectList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSupportedByObjectList not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSupportedByObjectList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupPgSupportedByObjectList);
		StorageTmp->isupPgSupportedByObjectList = objid;
		StorageTmp->isupPgSupportedByObjectListLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgSupportedByObjectList for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		if (StorageOld->isupPgSupportedByObjectList != NULL) {
			SNMP_FREE(StorageTmp->isupPgSupportedByObjectList);
			StorageTmp->isupPgSupportedByObjectList = StorageOld->isupPgSupportedByObjectList;
			StorageTmp->isupPgSupportedByObjectListLen = StorageOld->isupPgSupportedByObjectListLen;
			StorageOld->isupPgSupportedByObjectList = NULL;
			StorageOld->isupPgSupportedByObjectListLen = 0;
		}
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgWaitToRestoreTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgWaitToRestoreTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgWaitToRestoreTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgWaitToRestoreTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgWaitToRestoreTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgWaitToRestoreTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgWaitToRestoreTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		StorageTmp->isupPgWaitToRestoreTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgWaitToRestoreTime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		StorageTmp->isupPgWaitToRestoreTime = StorageOld->isupPgWaitToRestoreTime;
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgSettingWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgSettingWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgSettingWindowTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSettingWindowTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSettingWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSettingWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSettingWindowTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		StorageTmp->isupPgSettingWindowTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgSettingWindowTime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		StorageTmp->isupPgSettingWindowTime = StorageOld->isupPgSettingWindowTime;
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgReleasingWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgReleasingWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgReleasingWindowTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgReleasingWindowTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgReleasingWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgReleasingWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgReleasingWindowTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		StorageTmp->isupPgReleasingWindowTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgReleasingWindowTime for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		StorageTmp->isupPgReleasingWindowTime = StorageOld->isupPgReleasingWindowTime;
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgSwitchType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgSwitchType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgSwitchType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSwitchType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSwitchType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSwitchType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPPGSWITCHTYPE_MANUAL:
		case ISUPPGSWITCHTYPE_FORCED:
		case ISUPPGSWITCHTYPE_LOCKOUT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgSwitchType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		StorageTmp->isupPgSwitchType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgSwitchType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		StorageTmp->isupPgSwitchType = StorageOld->isupPgSwitchType;
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgProtectedUnits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgProtectedUnits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgProtectedUnits entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgProtectedUnits: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgProtectedUnits not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgProtectedUnits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupPgProtectedUnits);
		StorageTmp->isupPgProtectedUnits = string;
		StorageTmp->isupPgProtectedUnitsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgProtectedUnits for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		if (StorageOld->isupPgProtectedUnits != NULL) {
			SNMP_FREE(StorageTmp->isupPgProtectedUnits);
			StorageTmp->isupPgProtectedUnits = StorageOld->isupPgProtectedUnits;
			StorageTmp->isupPgProtectedUnitsLen = StorageOld->isupPgProtectedUnitsLen;
			StorageOld->isupPgProtectedUnits = NULL;
			StorageOld->isupPgProtectedUnitsLen = 0;
		}
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgProtectingUnits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgProtectingUnits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgProtectingUnits entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgProtectingUnits: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgProtectingUnits not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgProtectingUnits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupPgProtectingUnits);
		StorageTmp->isupPgProtectingUnits = string;
		StorageTmp->isupPgProtectingUnitsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgProtectingUnits for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		if (StorageOld->isupPgProtectingUnits != NULL) {
			SNMP_FREE(StorageTmp->isupPgProtectingUnits);
			StorageTmp->isupPgProtectingUnits = StorageOld->isupPgProtectingUnits;
			StorageTmp->isupPgProtectingUnitsLen = StorageOld->isupPgProtectingUnitsLen;
			StorageOld->isupPgProtectingUnits = NULL;
			StorageOld->isupPgProtectingUnitsLen = 0;
		}
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgInvokeProtection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgInvokeProtection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgInvokeProtection entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgInvokeProtection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgInvokeProtection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgInvokeProtection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPPGINVOKEPROTECTION_SUCCESS:
		case ISUPPGINVOKEPROTECTION_PENDING:
		case ISUPPGINVOKEPROTECTION_FAILURE:
		case ISUPPGINVOKEPROTECTION_TIMEOUT:
		case ISUPPGINVOKEPROTECTION_PREEMPTED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgInvokeProtection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		StorageTmp->isupPgInvokeProtection = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgInvokeProtection for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		StorageTmp->isupPgInvokeProtection = StorageOld->isupPgInvokeProtection;
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgReleaseProtection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPgReleaseProtection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPgReleaseProtection entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgReleaseProtection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgReleaseProtection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgReleaseProtection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPPGRELEASEPROTECTION_SUCCESS:
		case ISUPPGRELEASEPROTECTION_PENDING:
		case ISUPPGRELEASEPROTECTION_FAILURE:
		case ISUPPGRELEASEPROTECTION_TIMEOUT:
		case ISUPPGRELEASEPROTECTION_PREEMPTED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgReleaseProtection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			if (StorageTmp->isupPgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPgTable_rsvs++;
		StorageTmp->isupPgReleaseProtection = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPgTable_tsts == 0)
				if ((ret = check_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPgReleaseProtection for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPgTable_sets == 0)
				if ((ret = update_isupPgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			StorageTmp->isupPgTable_rsvs = 0;
			StorageTmp->isupPgTable_tsts = 0;
			StorageTmp->isupPgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPgTable_sets == 0)
			revert_isupPgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
			break;
		StorageTmp->isupPgReleaseProtection = StorageOld->isupPgReleaseProtection;
		if (--StorageTmp->isupPgTable_rsvs == 0)
			isupPgTable_destroy(&StorageTmp->isupPgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuProtecting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuProtecting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuProtecting entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuProtecting: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuProtecting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuProtecting: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuProtecting: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		StorageTmp->isupPuProtecting = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuProtecting for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		StorageTmp->isupPuProtecting = StorageOld->isupPuProtecting;
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuReliableResourcePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuReliableResourcePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuReliableResourcePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuReliableResourcePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuReliableResourcePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuReliableResourcePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupPuReliableResourcePointer);
		StorageTmp->isupPuReliableResourcePointer = objid;
		StorageTmp->isupPuReliableResourcePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuReliableResourcePointer for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		if (StorageOld->isupPuReliableResourcePointer != NULL) {
			SNMP_FREE(StorageTmp->isupPuReliableResourcePointer);
			StorageTmp->isupPuReliableResourcePointer = StorageOld->isupPuReliableResourcePointer;
			StorageTmp->isupPuReliableResourcePointerLen = StorageOld->isupPuReliableResourcePointerLen;
			StorageOld->isupPuReliableResourcePointer = NULL;
			StorageOld->isupPuReliableResourcePointerLen = 0;
		}
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuUnreliableResourcePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuUnreliableResourcePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuUnreliableResourcePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuUnreliableResourcePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuUnreliableResourcePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuUnreliableResourcePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupPuUnreliableResourcePointer);
		StorageTmp->isupPuUnreliableResourcePointer = objid;
		StorageTmp->isupPuUnreliableResourcePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuUnreliableResourcePointer for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		if (StorageOld->isupPuUnreliableResourcePointer != NULL) {
			SNMP_FREE(StorageTmp->isupPuUnreliableResourcePointer);
			StorageTmp->isupPuUnreliableResourcePointer = StorageOld->isupPuUnreliableResourcePointer;
			StorageTmp->isupPuUnreliableResourcePointerLen = StorageOld->isupPuUnreliableResourcePointerLen;
			StorageOld->isupPuUnreliableResourcePointer = NULL;
			StorageOld->isupPuUnreliableResourcePointerLen = 0;
		}
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuProtectionStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuProtectionStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuProtectionStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuProtectionStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuProtectionStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuProtectionStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuProtectionStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupPuProtectionStatus);
		StorageTmp->isupPuProtectionStatus = string;
		StorageTmp->isupPuProtectionStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuProtectionStatus for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		if (StorageOld->isupPuProtectionStatus != NULL) {
			SNMP_FREE(StorageTmp->isupPuProtectionStatus);
			StorageTmp->isupPuProtectionStatus = StorageOld->isupPuProtectionStatus;
			StorageTmp->isupPuProtectionStatusLen = StorageOld->isupPuProtectionStatusLen;
			StorageOld->isupPuProtectionStatus = NULL;
			StorageOld->isupPuProtectionStatusLen = 0;
		}
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuSwitchStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuSwitchStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuSwitchStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuSwitchStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuSwitchStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuSwitchStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPPUSWITCHSTATUS_PENDING:
		case ISUPPUSWITCHSTATUS_COMPLETED:
		case ISUPPUSWITCHSTATUS_OPERATEFAILED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuSwitchStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		StorageTmp->isupPuSwitchStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuSwitchStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		StorageTmp->isupPuSwitchStatus = StorageOld->isupPuSwitchStatus;
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuFromProtectionUnitNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuFromProtectionUnitNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuFromProtectionUnitNumber entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuFromProtectionUnitNumber: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuFromProtectionUnitNumber not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuFromProtectionUnitNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		StorageTmp->isupPuFromProtectionUnitNumber = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuFromProtectionUnitNumber for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		StorageTmp->isupPuFromProtectionUnitNumber = StorageOld->isupPuFromProtectionUnitNumber;
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuToProtectionUnitNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuToProtectionUnitNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuToProtectionUnitNumber entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuToProtectionUnitNumber: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuToProtectionUnitNumber not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuToProtectionUnitNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		StorageTmp->isupPuToProtectionUnitNumber = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuToProtectionUnitNumber for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		StorageTmp->isupPuToProtectionUnitNumber = StorageOld->isupPuToProtectionUnitNumber;
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuAutoSwitchReason(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuAutoSwitchReason(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuAutoSwitchReason entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuAutoSwitchReason: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuAutoSwitchReason not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuAutoSwitchReason: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPPUAUTOSWITCHREASON_WAITTORESTORE:
		case ISUPPUAUTOSWITCHREASON_RESOURCEDEGRADE:
		case ISUPPUAUTOSWITCHREASON_RESOURCEFAILED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuAutoSwitchReason: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		StorageTmp->isupPuAutoSwitchReason = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuAutoSwitchReason for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		StorageTmp->isupPuAutoSwitchReason = StorageOld->isupPuAutoSwitchReason;
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuLockoutReleaseFailed(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuLockoutReleaseFailed(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuLockoutReleaseFailed entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuLockoutReleaseFailed: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuLockoutReleaseFailed not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuLockoutReleaseFailed: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuLockoutReleaseFailed: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		StorageTmp->isupPuLockoutReleaseFailed = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuLockoutReleaseFailed for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		StorageTmp->isupPuLockoutReleaseFailed = StorageOld->isupPuLockoutReleaseFailed;
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupPuPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupPuPriority entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupPuRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuPriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuPriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			if (StorageTmp->isupPuTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupPuTable_rsvs++;
		StorageTmp->isupPuPriority = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupPuTable_tsts == 0)
				if ((ret = check_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupPuPriority for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupPuTable_sets == 0)
				if ((ret = update_isupPuTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupPuTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			StorageTmp->isupPuTable_rsvs = 0;
			StorageTmp->isupPuTable_tsts = 0;
			StorageTmp->isupPuTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupPuTable_sets == 0)
			revert_isupPuTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
			break;
		StorageTmp->isupPuPriority = StorageOld->isupPuPriority;
		if (--StorageTmp->isupPuTable_rsvs == 0)
			isupPuTable_destroy(&StorageTmp->isupPuTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupLgAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupLgAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupLgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupLgAdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupLgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupLgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPLGADMINISTRATIVESTATE_LOCKED:
		case ISUPLGADMINISTRATIVESTATE_UNLOCKED:
		case ISUPLGADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			if (StorageTmp->isupLgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupLgTable_old = isupLgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupLgTable_rsvs++;
		StorageTmp->isupLgAdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupLgTable_tsts == 0)
				if ((ret = check_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupLgAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupLgTable_sets == 0)
				if ((ret = update_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
			StorageTmp->isupLgTable_rsvs = 0;
			StorageTmp->isupLgTable_tsts = 0;
			StorageTmp->isupLgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupLgTable_sets == 0)
			revert_isupLgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		StorageTmp->isupLgAdministrativeState = StorageOld->isupLgAdministrativeState;
		if (--StorageTmp->isupLgTable_rsvs == 0)
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupLgSnServiceProvider(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupLgSnServiceProvider(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupLgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupLgSnServiceProvider entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupLgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupLgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgSnServiceProvider: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgSnServiceProvider not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgSnServiceProvider: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			if (StorageTmp->isupLgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupLgTable_old = isupLgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupLgTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupLgSnServiceProvider);
		StorageTmp->isupLgSnServiceProvider = objid;
		StorageTmp->isupLgSnServiceProviderLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupLgTable_tsts == 0)
				if ((ret = check_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupLgSnServiceProvider for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupLgTable_sets == 0)
				if ((ret = update_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
			StorageTmp->isupLgTable_rsvs = 0;
			StorageTmp->isupLgTable_tsts = 0;
			StorageTmp->isupLgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupLgTable_sets == 0)
			revert_isupLgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		if (StorageOld->isupLgSnServiceProvider != NULL) {
			SNMP_FREE(StorageTmp->isupLgSnServiceProvider);
			StorageTmp->isupLgSnServiceProvider = StorageOld->isupLgSnServiceProvider;
			StorageTmp->isupLgSnServiceProviderLen = StorageOld->isupLgSnServiceProviderLen;
			StorageOld->isupLgSnServiceProvider = NULL;
			StorageOld->isupLgSnServiceProviderLen = 0;
		}
		if (--StorageTmp->isupLgTable_rsvs == 0)
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupLgSnSap(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupLgSnSap(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupLgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupLgSnSap entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupLgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupLgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgSnSap: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgSnSap not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgSnSap: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			if (StorageTmp->isupLgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupLgTable_old = isupLgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupLgTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupLgSnSap);
		StorageTmp->isupLgSnSap = objid;
		StorageTmp->isupLgSnSapLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupLgTable_tsts == 0)
				if ((ret = check_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupLgSnSap for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupLgTable_sets == 0)
				if ((ret = update_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
			StorageTmp->isupLgTable_rsvs = 0;
			StorageTmp->isupLgTable_tsts = 0;
			StorageTmp->isupLgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupLgTable_sets == 0)
			revert_isupLgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		if (StorageOld->isupLgSnSap != NULL) {
			SNMP_FREE(StorageTmp->isupLgSnSap);
			StorageTmp->isupLgSnSap = StorageOld->isupLgSnSap;
			StorageTmp->isupLgSnSapLen = StorageOld->isupLgSnSapLen;
			StorageOld->isupLgSnSap = NULL;
			StorageOld->isupLgSnSapLen = 0;
		}
		if (--StorageTmp->isupLgTable_rsvs == 0)
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupLgOperationalProtocols(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupLgOperationalProtocols(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupLgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupLgOperationalProtocols entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupLgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupLgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgOperationalProtocols: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgOperationalProtocols not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgOperationalProtocols: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgOperationalProtocols: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			if (StorageTmp->isupLgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupLgTable_old = isupLgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupLgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupLgOperationalProtocols);
		StorageTmp->isupLgOperationalProtocols = string;
		StorageTmp->isupLgOperationalProtocolsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupLgTable_tsts == 0)
				if ((ret = check_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupLgOperationalProtocols for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupLgTable_sets == 0)
				if ((ret = update_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
			StorageTmp->isupLgTable_rsvs = 0;
			StorageTmp->isupLgTable_tsts = 0;
			StorageTmp->isupLgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupLgTable_sets == 0)
			revert_isupLgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		if (StorageOld->isupLgOperationalProtocols != NULL) {
			SNMP_FREE(StorageTmp->isupLgOperationalProtocols);
			StorageTmp->isupLgOperationalProtocols = StorageOld->isupLgOperationalProtocols;
			StorageTmp->isupLgOperationalProtocolsLen = StorageOld->isupLgOperationalProtocolsLen;
			StorageOld->isupLgOperationalProtocols = NULL;
			StorageOld->isupLgOperationalProtocolsLen = 0;
		}
		if (--StorageTmp->isupLgTable_rsvs == 0)
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupLgOperationalSubsets(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupLgOperationalSubsets(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupLgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupLgOperationalSubsets entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupLgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupLgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgOperationalSubsets: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgOperationalSubsets not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgOperationalSubsets: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgOperationalSubsets: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			if (StorageTmp->isupLgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupLgTable_old = isupLgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupLgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupLgOperationalSubsets);
		StorageTmp->isupLgOperationalSubsets = string;
		StorageTmp->isupLgOperationalSubsetsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupLgTable_tsts == 0)
				if ((ret = check_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupLgOperationalSubsets for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupLgTable_sets == 0)
				if ((ret = update_isupLgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupLgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
			StorageTmp->isupLgTable_rsvs = 0;
			StorageTmp->isupLgTable_tsts = 0;
			StorageTmp->isupLgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupLgTable_sets == 0)
			revert_isupLgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
			break;
		if (StorageOld->isupLgOperationalSubsets != NULL) {
			SNMP_FREE(StorageTmp->isupLgOperationalSubsets);
			StorageTmp->isupLgOperationalSubsets = StorageOld->isupLgOperationalSubsets;
			StorageTmp->isupLgOperationalSubsetsLen = StorageOld->isupLgOperationalSubsetsLen;
			StorageOld->isupLgOperationalSubsets = NULL;
			StorageOld->isupLgOperationalSubsetsLen = 0;
		}
		if (--StorageTmp->isupLgTable_rsvs == 0)
			isupLgTable_destroy(&StorageTmp->isupLgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMtpUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMtpUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMtpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMtpUserPart entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMtpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMtpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpUserPart: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpUserPart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpUserPart: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPMTPUSERPART_SNMM:
		case ISUPMTPUSERPART_SNTM:
		case ISUPMTPUSERPART_SNSM:
		case ISUPMTPUSERPART_SCCP:
		case ISUPMTPUSERPART_TUP:
		case ISUPMTPUSERPART_ISUP:
		case ISUPMTPUSERPART_DUP1:
		case ISUPMTPUSERPART_DUP2:
		case ISUPMTPUSERPART_MTUP:
		case ISUPMTPUSERPART_BISUP:
		case ISUPMTPUSERPART_SIUP:
		case ISUPMTPUSERPART_SPNEUP:
		case ISUPMTPUSERPART_STC:
		case ISUPMTPUSERPART_USER13:
		case ISUPMTPUSERPART_USER14:
		case ISUPMTPUSERPART_USER15:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpUserPart: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			if (StorageTmp->isupMtpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMtpTable_old = isupMtpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMtpTable_rsvs++;
		StorageTmp->isupMtpUserPart = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMtpTable_tsts == 0)
				if ((ret = check_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMtpUserPart for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMtpTable_sets == 0)
				if ((ret = update_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
			StorageTmp->isupMtpTable_rsvs = 0;
			StorageTmp->isupMtpTable_tsts = 0;
			StorageTmp->isupMtpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMtpTable_sets == 0)
			revert_isupMtpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		StorageTmp->isupMtpUserPart = StorageOld->isupMtpUserPart;
		if (--StorageTmp->isupMtpTable_rsvs == 0)
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMtpUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMtpUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMtpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMtpUserPartStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMtpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMtpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpUserPartStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpUserPartStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpUserPartStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPMTPUSERPARTSTATUS_UNKNOWN:
		case ISUPMTPUSERPARTSTATUS_INACCESSIBLE:
		case ISUPMTPUSERPARTSTATUS_UNEQUIPPED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpUserPartStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			if (StorageTmp->isupMtpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMtpTable_old = isupMtpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMtpTable_rsvs++;
		StorageTmp->isupMtpUserPartStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMtpTable_tsts == 0)
				if ((ret = check_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMtpUserPartStatus for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMtpTable_sets == 0)
				if ((ret = update_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
			StorageTmp->isupMtpTable_rsvs = 0;
			StorageTmp->isupMtpTable_tsts = 0;
			StorageTmp->isupMtpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMtpTable_sets == 0)
			revert_isupMtpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		StorageTmp->isupMtpUserPartStatus = StorageOld->isupMtpUserPartStatus;
		if (--StorageTmp->isupMtpTable_rsvs == 0)
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMtpProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMtpProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMtpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMtpProviderEntityNames entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMtpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMtpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpProviderEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			if (StorageTmp->isupMtpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMtpTable_old = isupMtpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMtpTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupMtpProviderEntityNames);
		StorageTmp->isupMtpProviderEntityNames = objid;
		StorageTmp->isupMtpProviderEntityNamesLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMtpTable_tsts == 0)
				if ((ret = check_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMtpProviderEntityNames for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMtpTable_sets == 0)
				if ((ret = update_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
			StorageTmp->isupMtpTable_rsvs = 0;
			StorageTmp->isupMtpTable_tsts = 0;
			StorageTmp->isupMtpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMtpTable_sets == 0)
			revert_isupMtpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		if (StorageOld->isupMtpProviderEntityNames != NULL) {
			SNMP_FREE(StorageTmp->isupMtpProviderEntityNames);
			StorageTmp->isupMtpProviderEntityNames = StorageOld->isupMtpProviderEntityNames;
			StorageTmp->isupMtpProviderEntityNamesLen = StorageOld->isupMtpProviderEntityNamesLen;
			StorageOld->isupMtpProviderEntityNames = NULL;
			StorageOld->isupMtpProviderEntityNamesLen = 0;
		}
		if (--StorageTmp->isupMtpTable_rsvs == 0)
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMtpAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMtpAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMtpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMtpAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMtpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMtpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			if (StorageTmp->isupMtpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMtpTable_old = isupMtpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMtpTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupMtpAsaProfilePointer);
		StorageTmp->isupMtpAsaProfilePointer = objid;
		StorageTmp->isupMtpAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMtpTable_tsts == 0)
				if ((ret = check_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMtpAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMtpTable_sets == 0)
				if ((ret = update_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
			StorageTmp->isupMtpTable_rsvs = 0;
			StorageTmp->isupMtpTable_tsts = 0;
			StorageTmp->isupMtpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMtpTable_sets == 0)
			revert_isupMtpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		if (StorageOld->isupMtpAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->isupMtpAsaProfilePointer);
			StorageTmp->isupMtpAsaProfilePointer = StorageOld->isupMtpAsaProfilePointer;
			StorageTmp->isupMtpAsaProfilePointerLen = StorageOld->isupMtpAsaProfilePointerLen;
			StorageOld->isupMtpAsaProfilePointer = NULL;
			StorageOld->isupMtpAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->isupMtpTable_rsvs == 0)
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMtpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMtpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMtpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMtpName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMtpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMtpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			if (StorageTmp->isupMtpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMtpTable_old = isupMtpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMtpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupMtpName);
		StorageTmp->isupMtpName = string;
		StorageTmp->isupMtpNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMtpTable_tsts == 0)
				if ((ret = check_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMtpName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMtpTable_sets == 0)
				if ((ret = update_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
			StorageTmp->isupMtpTable_rsvs = 0;
			StorageTmp->isupMtpTable_tsts = 0;
			StorageTmp->isupMtpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMtpTable_sets == 0)
			revert_isupMtpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		if (StorageOld->isupMtpName != NULL) {
			SNMP_FREE(StorageTmp->isupMtpName);
			StorageTmp->isupMtpName = StorageOld->isupMtpName;
			StorageTmp->isupMtpNameLen = StorageOld->isupMtpNameLen;
			StorageOld->isupMtpName = NULL;
			StorageOld->isupMtpNameLen = 0;
		}
		if (--StorageTmp->isupMtpTable_rsvs == 0)
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMtpLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupMtpLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMtpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupMtpLongMessageSupported entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupMtpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupMtpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpLongMessageSupported: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpLongMessageSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpLongMessageSupported: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpLongMessageSupported: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			if (StorageTmp->isupMtpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupMtpTable_old = isupMtpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupMtpTable_rsvs++;
		StorageTmp->isupMtpLongMessageSupported = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupMtpTable_tsts == 0)
				if ((ret = check_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupMtpLongMessageSupported for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupMtpTable_sets == 0)
				if ((ret = update_isupMtpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupMtpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
			StorageTmp->isupMtpTable_rsvs = 0;
			StorageTmp->isupMtpTable_tsts = 0;
			StorageTmp->isupMtpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupMtpTable_sets == 0)
			revert_isupMtpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
			break;
		StorageTmp->isupMtpLongMessageSupported = StorageOld->isupMtpLongMessageSupported;
		if (--StorageTmp->isupMtpTable_rsvs == 0)
			isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupNaProtocolVariant entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolVariant: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolVariant: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value ss7ProtocolItut */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			if (StorageTmp->isupNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupNaTable_old = isupNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupNaTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupNaProtocolVariant);
		StorageTmp->isupNaProtocolVariant = objid;
		StorageTmp->isupNaProtocolVariantLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupNaTable_tsts == 0)
				if ((ret = check_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupNaProtocolVariant for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupNaTable_sets == 0)
				if ((ret = update_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
			StorageTmp->isupNaTable_rsvs = 0;
			StorageTmp->isupNaTable_tsts = 0;
			StorageTmp->isupNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupNaTable_sets == 0)
			revert_isupNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		if (StorageOld->isupNaProtocolVariant != NULL) {
			SNMP_FREE(StorageTmp->isupNaProtocolVariant);
			StorageTmp->isupNaProtocolVariant = StorageOld->isupNaProtocolVariant;
			StorageTmp->isupNaProtocolVariantLen = StorageOld->isupNaProtocolVariantLen;
			StorageOld->isupNaProtocolVariant = NULL;
			StorageOld->isupNaProtocolVariantLen = 0;
		}
		if (--StorageTmp->isupNaTable_rsvs == 0)
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupNaProtocolYear entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolYear: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolYear not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolYear: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value yCurrent */
		switch (set_value) {
		case ISUPNAPROTOCOLYEAR_YCURRENT:
		case ISUPNAPROTOCOLYEAR_Y1980:
		case ISUPNAPROTOCOLYEAR_Y1984:
		case ISUPNAPROTOCOLYEAR_Y1988:
		case ISUPNAPROTOCOLYEAR_Y1992:
		case ISUPNAPROTOCOLYEAR_Y1996:
		case ISUPNAPROTOCOLYEAR_Y2000:
		case ISUPNAPROTOCOLYEAR_Y2004:
		case ISUPNAPROTOCOLYEAR_Y2008:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolYear: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			if (StorageTmp->isupNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupNaTable_old = isupNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupNaTable_rsvs++;
		StorageTmp->isupNaProtocolYear = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupNaTable_tsts == 0)
				if ((ret = check_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupNaProtocolYear for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupNaTable_sets == 0)
				if ((ret = update_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
			StorageTmp->isupNaTable_rsvs = 0;
			StorageTmp->isupNaTable_tsts = 0;
			StorageTmp->isupNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupNaTable_sets == 0)
			revert_isupNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		StorageTmp->isupNaProtocolYear = StorageOld->isupNaProtocolYear;
		if (--StorageTmp->isupNaTable_rsvs == 0)
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupNaProtocolOptions entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolOptions not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaProtocolOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			if (StorageTmp->isupNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupNaTable_old = isupNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupNaTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupNaProtocolOptions);
		StorageTmp->isupNaProtocolOptions = string;
		StorageTmp->isupNaProtocolOptionsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupNaTable_tsts == 0)
				if ((ret = check_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupNaProtocolOptions for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupNaTable_sets == 0)
				if ((ret = update_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
			StorageTmp->isupNaTable_rsvs = 0;
			StorageTmp->isupNaTable_tsts = 0;
			StorageTmp->isupNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupNaTable_sets == 0)
			revert_isupNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		if (StorageOld->isupNaProtocolOptions != NULL) {
			SNMP_FREE(StorageTmp->isupNaProtocolOptions);
			StorageTmp->isupNaProtocolOptions = StorageOld->isupNaProtocolOptions;
			StorageTmp->isupNaProtocolOptionsLen = StorageOld->isupNaProtocolOptionsLen;
			StorageOld->isupNaProtocolOptions = NULL;
			StorageOld->isupNaProtocolOptionsLen = 0;
		}
		if (--StorageTmp->isupNaTable_rsvs == 0)
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupNaPointCodeFormat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaPointCodeFormat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaPointCodeFormat not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 3..3 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 3)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaPointCodeFormat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x03\x08\x03\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			if (StorageTmp->isupNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupNaTable_old = isupNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupNaTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupNaPointCodeFormat);
		StorageTmp->isupNaPointCodeFormat = string;
		StorageTmp->isupNaPointCodeFormatLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupNaTable_tsts == 0)
				if ((ret = check_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupNaPointCodeFormat for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupNaTable_sets == 0)
				if ((ret = update_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
			StorageTmp->isupNaTable_rsvs = 0;
			StorageTmp->isupNaTable_tsts = 0;
			StorageTmp->isupNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupNaTable_sets == 0)
			revert_isupNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		if (StorageOld->isupNaPointCodeFormat != NULL) {
			SNMP_FREE(StorageTmp->isupNaPointCodeFormat);
			StorageTmp->isupNaPointCodeFormat = StorageOld->isupNaPointCodeFormat;
			StorageTmp->isupNaPointCodeFormatLen = StorageOld->isupNaPointCodeFormatLen;
			StorageOld->isupNaPointCodeFormat = NULL;
			StorageOld->isupNaPointCodeFormatLen = 0;
		}
		if (--StorageTmp->isupNaTable_rsvs == 0)
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupNaSlsLength entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaSlsLength: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaSlsLength not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaSlsLength: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sls4bits */
		switch (set_value) {
		case ISUPNASLSLENGTH_SLS4BITS:
		case ISUPNASLSLENGTH_SLS5BITS:
		case ISUPNASLSLENGTH_SLS8BITS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaSlsLength: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			if (StorageTmp->isupNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupNaTable_old = isupNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupNaTable_rsvs++;
		StorageTmp->isupNaSlsLength = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupNaTable_tsts == 0)
				if ((ret = check_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupNaSlsLength for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupNaTable_sets == 0)
				if ((ret = update_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
			StorageTmp->isupNaTable_rsvs = 0;
			StorageTmp->isupNaTable_tsts = 0;
			StorageTmp->isupNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupNaTable_sets == 0)
			revert_isupNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		StorageTmp->isupNaSlsLength = StorageOld->isupNaSlsLength;
		if (--StorageTmp->isupNaTable_rsvs == 0)
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupNaSpDefault entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaSpDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaSpDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaSpDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			if (StorageTmp->isupNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupNaTable_old = isupNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupNaTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupNaSpDefault);
		StorageTmp->isupNaSpDefault = string;
		StorageTmp->isupNaSpDefaultLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupNaTable_tsts == 0)
				if ((ret = check_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupNaSpDefault for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupNaTable_sets == 0)
				if ((ret = update_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
			StorageTmp->isupNaTable_rsvs = 0;
			StorageTmp->isupNaTable_tsts = 0;
			StorageTmp->isupNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupNaTable_sets == 0)
			revert_isupNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		if (StorageOld->isupNaSpDefault != NULL) {
			SNMP_FREE(StorageTmp->isupNaSpDefault);
			StorageTmp->isupNaSpDefault = StorageOld->isupNaSpDefault;
			StorageTmp->isupNaSpDefaultLen = StorageOld->isupNaSpDefaultLen;
			StorageOld->isupNaSpDefault = NULL;
			StorageOld->isupNaSpDefaultLen = 0;
		}
		if (--StorageTmp->isupNaTable_rsvs == 0)
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupNaName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			if (StorageTmp->isupNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupNaTable_old = isupNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupNaTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupNaName);
		StorageTmp->isupNaName = string;
		StorageTmp->isupNaNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupNaTable_tsts == 0)
				if ((ret = check_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupNaName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupNaTable_sets == 0)
				if ((ret = update_isupNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
			StorageTmp->isupNaTable_rsvs = 0;
			StorageTmp->isupNaTable_tsts = 0;
			StorageTmp->isupNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupNaTable_sets == 0)
			revert_isupNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
			break;
		if (StorageOld->isupNaName != NULL) {
			SNMP_FREE(StorageTmp->isupNaName);
			StorageTmp->isupNaName = StorageOld->isupNaName;
			StorageTmp->isupNaNameLen = StorageOld->isupNaNameLen;
			StorageOld->isupNaName = NULL;
			StorageOld->isupNaNameLen = 0;
		}
		if (--StorageTmp->isupNaTable_rsvs == 0)
			isupNaTable_destroy(&StorageTmp->isupNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpPointCode entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpPointCode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpPointCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x00\x00\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSpPointCode);
		StorageTmp->isupSpPointCode = string;
		StorageTmp->isupSpPointCodeLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpPointCode for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		if (StorageOld->isupSpPointCode != NULL) {
			SNMP_FREE(StorageTmp->isupSpPointCode);
			StorageTmp->isupSpPointCode = StorageOld->isupSpPointCode;
			StorageTmp->isupSpPointCodeLen = StorageOld->isupSpPointCodeLen;
			StorageOld->isupSpPointCode = NULL;
			StorageOld->isupSpPointCodeLen = 0;
		}
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value endOffice */
		switch (set_value) {
		case ISUPSPTYPE_ENDOFFICE:
		case ISUPSPTYPE_ACCESSGATEWAY:
		case ISUPSPTYPE_LOCALTANDEM:
		case ISUPSPTYPE_TOLLTANDEM:
		case ISUPSPTYPE_ACCESSTANDEM:
		case ISUPSPTYPE_INTERNATIONALGATEWAY:
		case ISUPSPTYPE_INTERNATIONALTRANSIT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		StorageTmp->isupSpType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpType for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		StorageTmp->isupSpType = StorageOld->isupSpType;
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpVersion entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"ITU-T Q.764 1999\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSpVersion);
		StorageTmp->isupSpVersion = string;
		StorageTmp->isupSpVersionLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpVersion for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		if (StorageOld->isupSpVersion != NULL) {
			SNMP_FREE(StorageTmp->isupSpVersion);
			StorageTmp->isupSpVersion = StorageOld->isupSpVersion;
			StorageTmp->isupSpVersionLen = StorageOld->isupSpVersionLen;
			StorageOld->isupSpVersion = NULL;
			StorageOld->isupSpVersionLen = 0;
		}
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSpName);
		StorageTmp->isupSpName = string;
		StorageTmp->isupSpNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		if (StorageOld->isupSpName != NULL) {
			SNMP_FREE(StorageTmp->isupSpName);
			StorageTmp->isupSpName = StorageOld->isupSpName;
			StorageTmp->isupSpNameLen = StorageOld->isupSpNameLen;
			StorageOld->isupSpName = NULL;
			StorageOld->isupSpNameLen = 0;
		}
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpNaPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpNaPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpNaPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpNaPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupSpNaPointer);
		StorageTmp->isupSpNaPointer = objid;
		StorageTmp->isupSpNaPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpNaPointer for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		if (StorageOld->isupSpNaPointer != NULL) {
			SNMP_FREE(StorageTmp->isupSpNaPointer);
			StorageTmp->isupSpNaPointer = StorageOld->isupSpNaPointer;
			StorageTmp->isupSpNaPointerLen = StorageOld->isupSpNaPointerLen;
			StorageOld->isupSpNaPointer = NULL;
			StorageOld->isupSpNaPointerLen = 0;
		}
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpOptions entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpOptions not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSpOptions);
		StorageTmp->isupSpOptions = string;
		StorageTmp->isupSpOptionsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpOptions for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		if (StorageOld->isupSpOptions != NULL) {
			SNMP_FREE(StorageTmp->isupSpOptions);
			StorageTmp->isupSpOptions = StorageOld->isupSpOptions;
			StorageTmp->isupSpOptionsLen = StorageOld->isupSpOptionsLen;
			StorageOld->isupSpOptions = NULL;
			StorageOld->isupSpOptionsLen = 0;
		}
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSpAlarmStatus);
		StorageTmp->isupSpAlarmStatus = string;
		StorageTmp->isupSpAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		if (StorageOld->isupSpAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->isupSpAlarmStatus);
			StorageTmp->isupSpAlarmStatus = StorageOld->isupSpAlarmStatus;
			StorageTmp->isupSpAlarmStatusLen = StorageOld->isupSpAlarmStatusLen;
			StorageOld->isupSpAlarmStatus = NULL;
			StorageOld->isupSpAlarmStatusLen = 0;
		}
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpAdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case ISUPSPADMINISTRATIVESTATE_LOCKED:
		case ISUPSPADMINISTRATIVESTATE_UNLOCKED:
		case ISUPSPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		StorageTmp->isupSpAdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		StorageTmp->isupSpAdministrativeState = StorageOld->isupSpAdministrativeState;
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpSupportedProtocols(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpSupportedProtocols(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpSupportedProtocols entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpSupportedProtocols: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpSupportedProtocols not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpSupportedProtocols: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpSupportedProtocols: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSpSupportedProtocols);
		StorageTmp->isupSpSupportedProtocols = string;
		StorageTmp->isupSpSupportedProtocolsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpSupportedProtocols for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		if (StorageOld->isupSpSupportedProtocols != NULL) {
			SNMP_FREE(StorageTmp->isupSpSupportedProtocols);
			StorageTmp->isupSpSupportedProtocols = StorageOld->isupSpSupportedProtocols;
			StorageTmp->isupSpSupportedProtocolsLen = StorageOld->isupSpSupportedProtocolsLen;
			StorageOld->isupSpSupportedProtocols = NULL;
			StorageOld->isupSpSupportedProtocolsLen = 0;
		}
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpActivate entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpActivate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpActivate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPSPACTIVATE_SUCCESS:
		case ISUPSPACTIVATE_PENDING:
		case ISUPSPACTIVATE_FAILURE:
		case ISUPSPACTIVATE_TIMEOUT:
		case ISUPSPACTIVATE_PREEMPTED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpActivate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		StorageTmp->isupSpActivate = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpActivate for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		StorageTmp->isupSpActivate = StorageOld->isupSpActivate;
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpDeactivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSpDeactivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSpDeactivate entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpDeactivate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpDeactivate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpDeactivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPSPDEACTIVATE_SUCCESS:
		case ISUPSPDEACTIVATE_PENDING:
		case ISUPSPDEACTIVATE_FAILURE:
		case ISUPSPDEACTIVATE_TIMEOUT:
		case ISUPSPDEACTIVATE_PREEMPTED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpDeactivate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			if (StorageTmp->isupSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSpTable_rsvs++;
		StorageTmp->isupSpDeactivate = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSpTable_tsts == 0)
				if ((ret = check_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSpDeactivate for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSpTable_sets == 0)
				if ((ret = update_isupSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			StorageTmp->isupSpTable_rsvs = 0;
			StorageTmp->isupSpTable_tsts = 0;
			StorageTmp->isupSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSpTable_sets == 0)
			revert_isupSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
			break;
		StorageTmp->isupSpDeactivate = StorageOld->isupSpDeactivate;
		if (--StorageTmp->isupSpTable_rsvs == 0)
			isupSpTable_destroy(&StorageTmp->isupSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrDest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrDest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrDest entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrDest: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrDest not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrDest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x00\x00\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSrDest);
		StorageTmp->isupSrDest = string;
		StorageTmp->isupSrDestLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrDest for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		if (StorageOld->isupSrDest != NULL) {
			SNMP_FREE(StorageTmp->isupSrDest);
			StorageTmp->isupSrDest = StorageOld->isupSrDest;
			StorageTmp->isupSrDestLen = StorageOld->isupSrDestLen;
			StorageOld->isupSrDest = NULL;
			StorageOld->isupSrDestLen = 0;
		}
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrOptions entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrOptions not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { srSecurity } */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSrOptions);
		StorageTmp->isupSrOptions = string;
		StorageTmp->isupSrOptionsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrOptions for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		if (StorageOld->isupSrOptions != NULL) {
			SNMP_FREE(StorageTmp->isupSrOptions);
			StorageTmp->isupSrOptions = StorageOld->isupSrOptions;
			StorageTmp->isupSrOptionsLen = StorageOld->isupSrOptionsLen;
			StorageOld->isupSrOptions = NULL;
			StorageOld->isupSrOptionsLen = 0;
		}
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrSlsAssignment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrSlsAssignment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrSlsAssignment entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrSlsAssignment: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrSlsAssignment not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrSlsAssignment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value cIC */
		switch (set_value) {
		case ISUPSRSLSASSIGNMENT_CIC:
		case ISUPSRSLSASSIGNMENT_CIRCUITNUMBER:
		case ISUPSRSLSASSIGNMENT_DYNAMIC:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrSlsAssignment: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		StorageTmp->isupSrSlsAssignment = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrSlsAssignment for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		StorageTmp->isupSrSlsAssignment = StorageOld->isupSrSlsAssignment;
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case ISUPSRADMINSTATE_LOCKED:
		case ISUPSRADMINSTATE_UNLOCKED:
		case ISUPSRADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		StorageTmp->isupSrAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		StorageTmp->isupSrAdminState = StorageOld->isupSrAdminState;
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrOpState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrOpState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrOpState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrOpState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrOpState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrOpState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value disabled */
		switch (set_value) {
		case ISUPSROPSTATE_DISABLED:
		case ISUPSROPSTATE_ENABLED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrOpState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		StorageTmp->isupSrOpState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrOpState for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		StorageTmp->isupSrOpState = StorageOld->isupSrOpState;
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupSrAsaProfilePointer);
		StorageTmp->isupSrAsaProfilePointer = objid;
		StorageTmp->isupSrAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		if (StorageOld->isupSrAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->isupSrAsaProfilePointer);
			StorageTmp->isupSrAsaProfilePointer = StorageOld->isupSrAsaProfilePointer;
			StorageTmp->isupSrAsaProfilePointerLen = StorageOld->isupSrAsaProfilePointerLen;
			StorageOld->isupSrAsaProfilePointer = NULL;
			StorageOld->isupSrAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrCongestedState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrCongestedState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrCongestedState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrCongestedState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrCongestedState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrCongestedState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPSRCONGESTEDSTATE_NOTCONGESTED:
		case ISUPSRCONGESTEDSTATE_CONGESTED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrCongestedState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		StorageTmp->isupSrCongestedState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrCongestedState for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		StorageTmp->isupSrCongestedState = StorageOld->isupSrCongestedState;
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrCongestionLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrCongestionLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrCongestionLevel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrCongestionLevel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrCongestionLevel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrCongestionLevel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value none */
		switch (set_value) {
		case ISUPSRCONGESTIONLEVEL_NONE:
		case ISUPSRCONGESTIONLEVEL_CONGESTIONLEVEL1:
		case ISUPSRCONGESTIONLEVEL_CONGESTIONLEVEL2:
		case ISUPSRCONGESTIONLEVEL_CONGESTIONLEVEL3:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrCongestionLevel: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		StorageTmp->isupSrCongestionLevel = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrCongestionLevel for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		StorageTmp->isupSrCongestionLevel = StorageOld->isupSrCongestionLevel;
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrLoadsharingInformation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrLoadsharingInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrLoadsharingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSrLoadsharingInformation);
		StorageTmp->isupSrLoadsharingInformation = string;
		StorageTmp->isupSrLoadsharingInformationLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrLoadsharingInformation for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		if (StorageOld->isupSrLoadsharingInformation != NULL) {
			SNMP_FREE(StorageTmp->isupSrLoadsharingInformation);
			StorageTmp->isupSrLoadsharingInformation = StorageOld->isupSrLoadsharingInformation;
			StorageTmp->isupSrLoadsharingInformationLen = StorageOld->isupSrLoadsharingInformationLen;
			StorageOld->isupSrLoadsharingInformation = NULL;
			StorageOld->isupSrLoadsharingInformationLen = 0;
		}
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrLoadsharingObject entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrLoadsharingObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrLoadsharingObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupSrLoadsharingObject);
		StorageTmp->isupSrLoadsharingObject = objid;
		StorageTmp->isupSrLoadsharingObjectLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrLoadsharingObject for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		if (StorageOld->isupSrLoadsharingObject != NULL) {
			SNMP_FREE(StorageTmp->isupSrLoadsharingObject);
			StorageTmp->isupSrLoadsharingObject = StorageOld->isupSrLoadsharingObject;
			StorageTmp->isupSrLoadsharingObjectLen = StorageOld->isupSrLoadsharingObjectLen;
			StorageOld->isupSrLoadsharingObject = NULL;
			StorageOld->isupSrLoadsharingObjectLen = 0;
		}
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrRemoteExchangeLabel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrRemoteExchangeLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrRemoteExchangeLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrRemoteExchangeLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSrRemoteExchangeLabel);
		StorageTmp->isupSrRemoteExchangeLabel = string;
		StorageTmp->isupSrRemoteExchangeLabelLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrRemoteExchangeLabel for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		if (StorageOld->isupSrRemoteExchangeLabel != NULL) {
			SNMP_FREE(StorageTmp->isupSrRemoteExchangeLabel);
			StorageTmp->isupSrRemoteExchangeLabel = StorageOld->isupSrRemoteExchangeLabel;
			StorageTmp->isupSrRemoteExchangeLabelLen = StorageOld->isupSrRemoteExchangeLabelLen;
			StorageOld->isupSrRemoteExchangeLabel = NULL;
			StorageOld->isupSrRemoteExchangeLabelLen = 0;
		}
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSrName);
		StorageTmp->isupSrName = string;
		StorageTmp->isupSrNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		if (StorageOld->isupSrName != NULL) {
			SNMP_FREE(StorageTmp->isupSrName);
			StorageTmp->isupSrName = StorageOld->isupSrName;
			StorageTmp->isupSrNameLen = StorageOld->isupSrNameLen;
			StorageOld->isupSrName = NULL;
			StorageOld->isupSrNameLen = 0;
		}
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrProfile entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSrProfile);
		StorageTmp->isupSrProfile = string;
		StorageTmp->isupSrProfileLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		if (StorageOld->isupSrProfile != NULL) {
			SNMP_FREE(StorageTmp->isupSrProfile);
			StorageTmp->isupSrProfile = StorageOld->isupSrProfile;
			StorageTmp->isupSrProfileLen = StorageOld->isupSrProfileLen;
			StorageOld->isupSrProfile = NULL;
			StorageOld->isupSrProfileLen = 0;
		}
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupSrAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupSrAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupSrRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			if (StorageTmp->isupSrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupSrTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupSrAlarmStatus);
		StorageTmp->isupSrAlarmStatus = string;
		StorageTmp->isupSrAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupSrTable_tsts == 0)
				if ((ret = check_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupSrAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupSrTable_sets == 0)
				if ((ret = update_isupSrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupSrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			StorageTmp->isupSrTable_rsvs = 0;
			StorageTmp->isupSrTable_tsts = 0;
			StorageTmp->isupSrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupSrTable_sets == 0)
			revert_isupSrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
			break;
		if (StorageOld->isupSrAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->isupSrAlarmStatus);
			StorageTmp->isupSrAlarmStatus = StorageOld->isupSrAlarmStatus;
			StorageTmp->isupSrAlarmStatusLen = StorageOld->isupSrAlarmStatusLen;
			StorageOld->isupSrAlarmStatus = NULL;
			StorageOld->isupSrAlarmStatusLen = 0;
		}
		if (--StorageTmp->isupSrTable_rsvs == 0)
			isupSrTable_destroy(&StorageTmp->isupSrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupRtUsedAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupRtUsedAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupRtUsedAlgorithm entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtUsedAlgorithm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtUsedAlgorithm not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtUsedAlgorithm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sequential */
		switch (set_value) {
		case ISUPRTUSEDALGORITHM_SEQUENTIAL:
		case ISUPRTUSEDALGORITHM_CYCLIC:
		case ISUPRTUSEDALGORITHM_PROPORTIONALBIDDING:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtUsedAlgorithm: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			if (StorageTmp->isupRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupRtTable_old = isupRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupRtTable_rsvs++;
		StorageTmp->isupRtUsedAlgorithm = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupRtTable_tsts == 0)
				if ((ret = check_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupRtUsedAlgorithm for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupRtTable_sets == 0)
				if ((ret = update_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
			StorageTmp->isupRtTable_rsvs = 0;
			StorageTmp->isupRtTable_tsts = 0;
			StorageTmp->isupRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupRtTable_sets == 0)
			revert_isupRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		StorageTmp->isupRtUsedAlgorithm = StorageOld->isupRtUsedAlgorithm;
		if (--StorageTmp->isupRtTable_rsvs == 0)
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupRtSelection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupRtSelection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupRtSelection entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtSelection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtSelection not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..256 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 256))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtSelection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			if (StorageTmp->isupRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupRtTable_old = isupRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupRtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupRtSelection);
		StorageTmp->isupRtSelection = string;
		StorageTmp->isupRtSelectionLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupRtTable_tsts == 0)
				if ((ret = check_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupRtSelection for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupRtTable_sets == 0)
				if ((ret = update_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
			StorageTmp->isupRtTable_rsvs = 0;
			StorageTmp->isupRtTable_tsts = 0;
			StorageTmp->isupRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupRtTable_sets == 0)
			revert_isupRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		if (StorageOld->isupRtSelection != NULL) {
			SNMP_FREE(StorageTmp->isupRtSelection);
			StorageTmp->isupRtSelection = StorageOld->isupRtSelection;
			StorageTmp->isupRtSelectionLen = StorageOld->isupRtSelectionLen;
			StorageOld->isupRtSelection = NULL;
			StorageOld->isupRtSelectionLen = 0;
		}
		if (--StorageTmp->isupRtTable_rsvs == 0)
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupRtProportionList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupRtProportionList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupRtProportionList entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtProportionList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtProportionList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtProportionList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			if (StorageTmp->isupRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupRtTable_old = isupRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupRtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupRtProportionList);
		StorageTmp->isupRtProportionList = string;
		StorageTmp->isupRtProportionListLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupRtTable_tsts == 0)
				if ((ret = check_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupRtProportionList for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupRtTable_sets == 0)
				if ((ret = update_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
			StorageTmp->isupRtTable_rsvs = 0;
			StorageTmp->isupRtTable_tsts = 0;
			StorageTmp->isupRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupRtTable_sets == 0)
			revert_isupRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		if (StorageOld->isupRtProportionList != NULL) {
			SNMP_FREE(StorageTmp->isupRtProportionList);
			StorageTmp->isupRtProportionList = StorageOld->isupRtProportionList;
			StorageTmp->isupRtProportionListLen = StorageOld->isupRtProportionListLen;
			StorageOld->isupRtProportionList = NULL;
			StorageOld->isupRtProportionListLen = 0;
		}
		if (--StorageTmp->isupRtTable_rsvs == 0)
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupRtUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupRtUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupRtUserLabel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtUserLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtUserLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			if (StorageTmp->isupRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupRtTable_old = isupRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupRtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupRtUserLabel);
		StorageTmp->isupRtUserLabel = string;
		StorageTmp->isupRtUserLabelLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupRtTable_tsts == 0)
				if ((ret = check_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupRtUserLabel for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupRtTable_sets == 0)
				if ((ret = update_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
			StorageTmp->isupRtTable_rsvs = 0;
			StorageTmp->isupRtTable_tsts = 0;
			StorageTmp->isupRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupRtTable_sets == 0)
			revert_isupRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		if (StorageOld->isupRtUserLabel != NULL) {
			SNMP_FREE(StorageTmp->isupRtUserLabel);
			StorageTmp->isupRtUserLabel = StorageOld->isupRtUserLabel;
			StorageTmp->isupRtUserLabelLen = StorageOld->isupRtUserLabelLen;
			StorageOld->isupRtUserLabel = NULL;
			StorageOld->isupRtUserLabelLen = 0;
		}
		if (--StorageTmp->isupRtTable_rsvs == 0)
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupRtControlStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupRtControlStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupRtControlStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtControlStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtControlStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtControlStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtControlStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			if (StorageTmp->isupRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupRtTable_old = isupRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupRtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupRtControlStatus);
		StorageTmp->isupRtControlStatus = string;
		StorageTmp->isupRtControlStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupRtTable_tsts == 0)
				if ((ret = check_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupRtControlStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupRtTable_sets == 0)
				if ((ret = update_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
			StorageTmp->isupRtTable_rsvs = 0;
			StorageTmp->isupRtTable_tsts = 0;
			StorageTmp->isupRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupRtTable_sets == 0)
			revert_isupRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		if (StorageOld->isupRtControlStatus != NULL) {
			SNMP_FREE(StorageTmp->isupRtControlStatus);
			StorageTmp->isupRtControlStatus = StorageOld->isupRtControlStatus;
			StorageTmp->isupRtControlStatusLen = StorageOld->isupRtControlStatusLen;
			StorageOld->isupRtControlStatus = NULL;
			StorageOld->isupRtControlStatusLen = 0;
		}
		if (--StorageTmp->isupRtTable_rsvs == 0)
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupRtAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupRtAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupRtAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPRTADMINSTATE_LOCKED:
		case ISUPRTADMINSTATE_UNLOCKED:
		case ISUPRTADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			if (StorageTmp->isupRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupRtTable_old = isupRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupRtTable_rsvs++;
		StorageTmp->isupRtAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupRtTable_tsts == 0)
				if ((ret = check_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupRtAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupRtTable_sets == 0)
				if ((ret = update_isupRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
			StorageTmp->isupRtTable_rsvs = 0;
			StorageTmp->isupRtTable_tsts = 0;
			StorageTmp->isupRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupRtTable_sets == 0)
			revert_isupRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
			break;
		StorageTmp->isupRtAdminState = StorageOld->isupRtAdminState;
		if (--StorageTmp->isupRtTable_rsvs == 0)
			isupRtTable_destroy(&StorageTmp->isupRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupRtTgSelectionList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupRtTgSelectionList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupRtTgSelectionTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupRtTgSelectionList entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupRtTgSelectionTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupRtTgSelectionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtTgSelectionList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtTgSelectionList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..256 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 256))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtTgSelectionList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old) == NULL)
			if (StorageTmp->isupRtTgSelectionTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old = isupRtTgSelectionTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupRtTgSelectionTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupRtTgSelectionList);
		StorageTmp->isupRtTgSelectionList = string;
		StorageTmp->isupRtTgSelectionListLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupRtTgSelectionTable_tsts == 0)
				if ((ret = check_isupRtTgSelectionTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTgSelectionTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupRtTgSelectionList for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupRtTgSelectionTable_sets == 0)
				if ((ret = update_isupRtTgSelectionTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupRtTgSelectionTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old) != NULL) {
			isupRtTgSelectionTable_destroy(&StorageTmp->isupRtTgSelectionTable_old);
			StorageTmp->isupRtTgSelectionTable_rsvs = 0;
			StorageTmp->isupRtTgSelectionTable_tsts = 0;
			StorageTmp->isupRtTgSelectionTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupRtTgSelectionTable_sets == 0)
			revert_isupRtTgSelectionTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old) == NULL)
			break;
		if (StorageOld->isupRtTgSelectionList != NULL) {
			SNMP_FREE(StorageTmp->isupRtTgSelectionList);
			StorageTmp->isupRtTgSelectionList = StorageOld->isupRtTgSelectionList;
			StorageTmp->isupRtTgSelectionListLen = StorageOld->isupRtTgSelectionListLen;
			StorageOld->isupRtTgSelectionList = NULL;
			StorageOld->isupRtTgSelectionListLen = 0;
		}
		if (--StorageTmp->isupRtTgSelectionTable_rsvs == 0)
			isupRtTgSelectionTable_destroy(&StorageTmp->isupRtTgSelectionTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgLabelOfFarEndExchange(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgLabelOfFarEndExchange(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgLabelOfFarEndExchange entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgLabelOfFarEndExchange: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgLabelOfFarEndExchange not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgLabelOfFarEndExchange: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupTgLabelOfFarEndExchange);
		StorageTmp->isupTgLabelOfFarEndExchange = string;
		StorageTmp->isupTgLabelOfFarEndExchangeLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgLabelOfFarEndExchange for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		if (StorageOld->isupTgLabelOfFarEndExchange != NULL) {
			SNMP_FREE(StorageTmp->isupTgLabelOfFarEndExchange);
			StorageTmp->isupTgLabelOfFarEndExchange = StorageOld->isupTgLabelOfFarEndExchange;
			StorageTmp->isupTgLabelOfFarEndExchangeLen = StorageOld->isupTgLabelOfFarEndExchangeLen;
			StorageOld->isupTgLabelOfFarEndExchange = NULL;
			StorageOld->isupTgLabelOfFarEndExchangeLen = 0;
		}
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgInformationTransferCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgInformationTransferCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgInformationTransferCapabilities entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgInformationTransferCapabilities: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgInformationTransferCapabilities not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgInformationTransferCapabilities: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value digitalUnrestricted64 */
		switch (set_value) {
		case ISUPTGINFORMATIONTRANSFERCAPABILITIES_SPEECH:
		case ISUPTGINFORMATIONTRANSFERCAPABILITIES_AUDIO3PT1:
		case ISUPTGINFORMATIONTRANSFERCAPABILITIES_AUDIO7:
		case ISUPTGINFORMATIONTRANSFERCAPABILITIES_AUDIOCOMB:
		case ISUPTGINFORMATIONTRANSFERCAPABILITIES_DIGITALRESTRICTED56:
		case ISUPTGINFORMATIONTRANSFERCAPABILITIES_DIGITALUNRESTRICTED64:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgInformationTransferCapabilities: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgInformationTransferCapabilities = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgInformationTransferCapabilities for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgInformationTransferCapabilities = StorageOld->isupTgInformationTransferCapabilities;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgCircuitDirectionality(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgCircuitDirectionality(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgCircuitDirectionality entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgCircuitDirectionality: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgCircuitDirectionality not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgCircuitDirectionality: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value twoway */
		switch (set_value) {
		case ISUPTGCIRCUITDIRECTIONALITY_ONEWAYOUT:
		case ISUPTGCIRCUITDIRECTIONALITY_ONEWAYIN:
		case ISUPTGCIRCUITDIRECTIONALITY_TWOWAY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgCircuitDirectionality: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgCircuitDirectionality = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgCircuitDirectionality for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgCircuitDirectionality = StorageOld->isupTgCircuitDirectionality;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgTransmissionCharacteristics(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgTransmissionCharacteristics(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgTransmissionCharacteristics entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgTransmissionCharacteristics: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgTransmissionCharacteristics not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgTransmissionCharacteristics: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgTransmissionCharacteristics: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupTgTransmissionCharacteristics);
		StorageTmp->isupTgTransmissionCharacteristics = string;
		StorageTmp->isupTgTransmissionCharacteristicsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgTransmissionCharacteristics for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		if (StorageOld->isupTgTransmissionCharacteristics != NULL) {
			SNMP_FREE(StorageTmp->isupTgTransmissionCharacteristics);
			StorageTmp->isupTgTransmissionCharacteristics = StorageOld->isupTgTransmissionCharacteristics;
			StorageTmp->isupTgTransmissionCharacteristicsLen = StorageOld->isupTgTransmissionCharacteristicsLen;
			StorageOld->isupTgTransmissionCharacteristics = NULL;
			StorageOld->isupTgTransmissionCharacteristicsLen = 0;
		}
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgUserLabel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgUserLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgUserLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupTgUserLabel);
		StorageTmp->isupTgUserLabel = string;
		StorageTmp->isupTgUserLabelLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgUserLabel for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		if (StorageOld->isupTgUserLabel != NULL) {
			SNMP_FREE(StorageTmp->isupTgUserLabel);
			StorageTmp->isupTgUserLabel = StorageOld->isupTgUserLabel;
			StorageTmp->isupTgUserLabelLen = StorageOld->isupTgUserLabelLen;
			StorageOld->isupTgUserLabel = NULL;
			StorageOld->isupTgUserLabelLen = 0;
		}
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case ISUPTGADMINSTATE_LOCKED:
		case ISUPTGADMINSTATE_UNLOCKED:
		case ISUPTGADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgAdminState = StorageOld->isupTgAdminState;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgAssocSignRouteSetNePart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgAssocSignRouteSetNePart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgAssocSignRouteSetNePart entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAssocSignRouteSetNePart: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAssocSignRouteSetNePart not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAssocSignRouteSetNePart: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgAssocSignRouteSetNePart = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgAssocSignRouteSetNePart for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgAssocSignRouteSetNePart = StorageOld->isupTgAssocSignRouteSetNePart;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgBoundaryCrossing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgBoundaryCrossing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgBoundaryCrossing entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgBoundaryCrossing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgBoundaryCrossing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgBoundaryCrossing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value national */
		switch (set_value) {
		case ISUPTGBOUNDARYCROSSING_NATIONAL:
		case ISUPTGBOUNDARYCROSSING_INTERNATIONAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgBoundaryCrossing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgBoundaryCrossing = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgBoundaryCrossing for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgBoundaryCrossing = StorageOld->isupTgBoundaryCrossing;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgSearchMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgSearchMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgSearchMethod entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgSearchMethod: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgSearchMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgSearchMethod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPTGSEARCHMETHOD_FIFOEVENELSELIFOODD:
		case ISUPTGSEARCHMETHOD_FIFOODDELSELIFOEVEN:
		case ISUPTGSEARCHMETHOD_FIFOEVENGRPELSELIFOODDGRP:
		case ISUPTGSEARCHMETHOD_FIFOODDGRPELSELIFOEVENGRP:
		case ISUPTGSEARCHMETHOD_FIFO:
		case ISUPTGSEARCHMETHOD_FORWARDSEQUENTIAL:
		case ISUPTGSEARCHMETHOD_BACKWARDSEQUENTIAL:
		case ISUPTGSEARCHMETHOD_FORWARDODDELSEBACKWARDEVEN:
		case ISUPTGSEARCHMETHOD_FORWARDEVENELSEBACKWARDODD:
		case ISUPTGSEARCHMETHOD_FORWARDCYCLIC:
		case ISUPTGSEARCHMETHOD_BACKWARDCYCLIC:
		case ISUPTGSEARCHMETHOD_RANDOM:
		case ISUPTGSEARCHMETHOD_LIFO:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgSearchMethod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgSearchMethod = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgSearchMethod for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgSearchMethod = StorageOld->isupTgSearchMethod;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgPrefTrafficRedirect(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgPrefTrafficRedirect(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgPrefTrafficRedirect entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgPrefTrafficRedirect: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgPrefTrafficRedirect not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgPrefTrafficRedirect: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPTGPREFTRAFFICREDIRECT_INCOMING:
		case ISUPTGPREFTRAFFICREDIRECT_OUTGOING:
		case ISUPTGPREFTRAFFICREDIRECT_OUTGOINGFIRSTCHOICE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgPrefTrafficRedirect: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgPrefTrafficRedirect = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgPrefTrafficRedirect for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgPrefTrafficRedirect = StorageOld->isupTgPrefTrafficRedirect;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgSuppressOwnCac(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgSuppressOwnCac(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgSuppressOwnCac entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgSuppressOwnCac: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgSuppressOwnCac not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgSuppressOwnCac: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgSuppressOwnCac: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgSuppressOwnCac = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgSuppressOwnCac for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgSuppressOwnCac = StorageOld->isupTgSuppressOwnCac;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgCarrierType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgCarrierType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgCarrierType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgCarrierType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgCarrierType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgCarrierType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value digital */
		switch (set_value) {
		case ISUPTGCARRIERTYPE_UNKNOWN:
		case ISUPTGCARRIERTYPE_ANALOG:
		case ISUPTGCARRIERTYPE_DIGITAL:
		case ISUPTGCARRIERTYPE_MIXED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgCarrierType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgCarrierType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgCarrierType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgCarrierType = StorageOld->isupTgCarrierType;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgAlarmCarrier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgAlarmCarrier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgAlarmCarrier entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAlarmCarrier: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAlarmCarrier not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAlarmCarrier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPTGALARMCARRIER_UNKNOWN:
		case ISUPTGALARMCARRIER_HARDWARE:
		case ISUPTGALARMCARRIER_SOFTWAREWITHOUTRELEASE:
		case ISUPTGALARMCARRIER_SOFTWAREIMMEDIATERELEASE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAlarmCarrier: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgAlarmCarrier = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgAlarmCarrier for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgAlarmCarrier = StorageOld->isupTgAlarmCarrier;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgContCheck(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgContCheck(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgContCheck entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgContCheck: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgContCheck not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgContCheck: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPTGCONTCHECK_UNKNOWN:
		case ISUPTGCONTCHECK_NONE:
		case ISUPTGCONTCHECK_STATISTICAL:
		case ISUPTGCONTCHECK_PERCALL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgContCheck: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgContCheck = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgContCheck for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgContCheck = StorageOld->isupTgContCheck;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgContCheckRatio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgContCheckRatio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgContCheckRatio entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgContCheckRatio: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgContCheckRatio not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgContCheckRatio: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1000 */
		if ((0 > set_value || set_value > 1000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgContCheckRatio: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		StorageTmp->isupTgContCheckRatio = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgContCheckRatio for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		StorageTmp->isupTgContCheckRatio = StorageOld->isupTgContCheckRatio;
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupTgAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupTgAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupTgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			if (StorageTmp->isupTgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupTgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupTgAlarmStatus);
		StorageTmp->isupTgAlarmStatus = string;
		StorageTmp->isupTgAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupTgTable_tsts == 0)
				if ((ret = check_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupTgAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupTgTable_sets == 0)
				if ((ret = update_isupTgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupTgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			StorageTmp->isupTgTable_rsvs = 0;
			StorageTmp->isupTgTable_tsts = 0;
			StorageTmp->isupTgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupTgTable_sets == 0)
			revert_isupTgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
			break;
		if (StorageOld->isupTgAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->isupTgAlarmStatus);
			StorageTmp->isupTgAlarmStatus = StorageOld->isupTgAlarmStatus;
			StorageTmp->isupTgAlarmStatusLen = StorageOld->isupTgAlarmStatusLen;
			StorageOld->isupTgAlarmStatus = NULL;
			StorageOld->isupTgAlarmStatusLen = 0;
		}
		if (--StorageTmp->isupTgTable_rsvs == 0)
			isupTgTable_destroy(&StorageTmp->isupTgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCgCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCgCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCgCIC entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgCIC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgCIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgCIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgCIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			if (StorageTmp->isupCgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCgTable_old = isupCgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCgTable_rsvs++;
		StorageTmp->isupCgCIC = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCgTable_tsts == 0)
				if ((ret = check_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCgCIC for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCgTable_sets == 0)
				if ((ret = update_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
			StorageTmp->isupCgTable_rsvs = 0;
			StorageTmp->isupCgTable_tsts = 0;
			StorageTmp->isupCgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCgTable_sets == 0)
			revert_isupCgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		StorageTmp->isupCgCIC = StorageOld->isupCgCIC;
		if (--StorageTmp->isupCgTable_rsvs == 0)
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCgAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCgAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCgAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			if (StorageTmp->isupCgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCgTable_old = isupCgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupCgAlarmStatus);
		StorageTmp->isupCgAlarmStatus = string;
		StorageTmp->isupCgAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCgTable_tsts == 0)
				if ((ret = check_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCgAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCgTable_sets == 0)
				if ((ret = update_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
			StorageTmp->isupCgTable_rsvs = 0;
			StorageTmp->isupCgTable_tsts = 0;
			StorageTmp->isupCgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCgTable_sets == 0)
			revert_isupCgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		if (StorageOld->isupCgAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->isupCgAlarmStatus);
			StorageTmp->isupCgAlarmStatus = StorageOld->isupCgAlarmStatus;
			StorageTmp->isupCgAlarmStatusLen = StorageOld->isupCgAlarmStatusLen;
			StorageOld->isupCgAlarmStatus = NULL;
			StorageOld->isupCgAlarmStatusLen = 0;
		}
		if (--StorageTmp->isupCgTable_rsvs == 0)
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCgRangeType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCgRangeType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCgRangeType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgRangeType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgRangeType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgRangeType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value explicit */
		switch (set_value) {
		case ISUPCGRANGETYPE_EXPLICIT:
		case ISUPCGRANGETYPE_PREDETERMINED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgRangeType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			if (StorageTmp->isupCgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCgTable_old = isupCgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCgTable_rsvs++;
		StorageTmp->isupCgRangeType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCgTable_tsts == 0)
				if ((ret = check_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCgRangeType for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCgTable_sets == 0)
				if ((ret = update_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
			StorageTmp->isupCgTable_rsvs = 0;
			StorageTmp->isupCgTable_tsts = 0;
			StorageTmp->isupCgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCgTable_sets == 0)
			revert_isupCgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		StorageTmp->isupCgRangeType = StorageOld->isupCgRangeType;
		if (--StorageTmp->isupCgTable_rsvs == 0)
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCgAlarmCarrier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCgAlarmCarrier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCgAlarmCarrier entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgAlarmCarrier: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgAlarmCarrier not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgAlarmCarrier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value hardware */
		switch (set_value) {
		case ISUPCGALARMCARRIER_UNKNOWN:
		case ISUPCGALARMCARRIER_HARDWARE:
		case ISUPCGALARMCARRIER_SOFTWAREWITHOUTRELEASE:
		case ISUPCGALARMCARRIER_SOFTWAREIMMEDIATERELEASE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgAlarmCarrier: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			if (StorageTmp->isupCgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCgTable_old = isupCgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCgTable_rsvs++;
		StorageTmp->isupCgAlarmCarrier = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCgTable_tsts == 0)
				if ((ret = check_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCgAlarmCarrier for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCgTable_sets == 0)
				if ((ret = update_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
			StorageTmp->isupCgTable_rsvs = 0;
			StorageTmp->isupCgTable_tsts = 0;
			StorageTmp->isupCgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCgTable_sets == 0)
			revert_isupCgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		StorageTmp->isupCgAlarmCarrier = StorageOld->isupCgAlarmCarrier;
		if (--StorageTmp->isupCgTable_rsvs == 0)
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCgContCheck(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCgContCheck(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCgContCheck entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgContCheck: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgContCheck not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgContCheck: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISUPCGCONTCHECK_UNKNOWN:
		case ISUPCGCONTCHECK_NONE:
		case ISUPCGCONTCHECK_STATISTICAL:
		case ISUPCGCONTCHECK_PERCALL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgContCheck: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			if (StorageTmp->isupCgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCgTable_old = isupCgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCgTable_rsvs++;
		StorageTmp->isupCgContCheck = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCgTable_tsts == 0)
				if ((ret = check_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCgContCheck for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCgTable_sets == 0)
				if ((ret = update_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
			StorageTmp->isupCgTable_rsvs = 0;
			StorageTmp->isupCgTable_tsts = 0;
			StorageTmp->isupCgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCgTable_sets == 0)
			revert_isupCgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		StorageTmp->isupCgContCheck = StorageOld->isupCgContCheck;
		if (--StorageTmp->isupCgTable_rsvs == 0)
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCgContCheckRatio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCgContCheckRatio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCgContCheckRatio entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgContCheckRatio: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgContCheckRatio not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgContCheckRatio: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..1000 */
		if ((0 > set_value || set_value > 1000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgContCheckRatio: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			if (StorageTmp->isupCgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCgTable_old = isupCgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCgTable_rsvs++;
		StorageTmp->isupCgContCheckRatio = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCgTable_tsts == 0)
				if ((ret = check_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCgContCheckRatio for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCgTable_sets == 0)
				if ((ret = update_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
			StorageTmp->isupCgTable_rsvs = 0;
			StorageTmp->isupCgTable_tsts = 0;
			StorageTmp->isupCgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCgTable_sets == 0)
			revert_isupCgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		StorageTmp->isupCgContCheckRatio = StorageOld->isupCgContCheckRatio;
		if (--StorageTmp->isupCgTable_rsvs == 0)
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCgPg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCgPg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCgPg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgPg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgPg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgPg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			if (StorageTmp->isupCgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCgTable_old = isupCgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCgTable_rsvs++;
		StorageTmp->isupCgPg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCgTable_tsts == 0)
				if ((ret = check_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCgPg for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCgTable_sets == 0)
				if ((ret = update_isupCgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
			StorageTmp->isupCgTable_rsvs = 0;
			StorageTmp->isupCgTable_tsts = 0;
			StorageTmp->isupCgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCgTable_sets == 0)
			revert_isupCgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
			break;
		StorageTmp->isupCgPg = StorageOld->isupCgPg;
		if (--StorageTmp->isupCgTable_rsvs == 0)
			isupCgTable_destroy(&StorageTmp->isupCgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCtCg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCtCg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCtCg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			if (StorageTmp->isupCtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCtTable_old = isupCtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCtTable_rsvs++;
		StorageTmp->isupCtCg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCtTable_tsts == 0)
				if ((ret = check_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCtCg for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCtTable_sets == 0)
				if ((ret = update_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
			StorageTmp->isupCtTable_rsvs = 0;
			StorageTmp->isupCtTable_tsts = 0;
			StorageTmp->isupCtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCtTable_sets == 0)
			revert_isupCtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		StorageTmp->isupCtCg = StorageOld->isupCtCg;
		if (--StorageTmp->isupCtTable_rsvs == 0)
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCtTg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCtTg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCtTg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtTg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtTg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtTg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			if (StorageTmp->isupCtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCtTable_old = isupCtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCtTable_rsvs++;
		StorageTmp->isupCtTg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCtTable_tsts == 0)
				if ((ret = check_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCtTg for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCtTable_sets == 0)
				if ((ret = update_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
			StorageTmp->isupCtTable_rsvs = 0;
			StorageTmp->isupCtTable_tsts = 0;
			StorageTmp->isupCtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCtTable_sets == 0)
			revert_isupCtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		StorageTmp->isupCtTg = StorageOld->isupCtTg;
		if (--StorageTmp->isupCtTable_rsvs == 0)
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCtAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCtAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCtAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case ISUPCTADMINSTATE_LOCKED:
		case ISUPCTADMINSTATE_UNLOCKED:
		case ISUPCTADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			if (StorageTmp->isupCtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCtTable_old = isupCtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCtTable_rsvs++;
		StorageTmp->isupCtAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCtTable_tsts == 0)
				if ((ret = check_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCtAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCtTable_sets == 0)
				if ((ret = update_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
			StorageTmp->isupCtTable_rsvs = 0;
			StorageTmp->isupCtTable_tsts = 0;
			StorageTmp->isupCtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCtTable_sets == 0)
			revert_isupCtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		StorageTmp->isupCtAdminState = StorageOld->isupCtAdminState;
		if (--StorageTmp->isupCtTable_rsvs == 0)
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCtCtpbInstance(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCtCtpbInstance(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCtCtpbInstance entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCtpbInstance: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCtpbInstance not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCtpbInstance: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			if (StorageTmp->isupCtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCtTable_old = isupCtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCtTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->isupCtCtpbInstance);
		StorageTmp->isupCtCtpbInstance = objid;
		StorageTmp->isupCtCtpbInstanceLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCtTable_tsts == 0)
				if ((ret = check_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCtCtpbInstance for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCtTable_sets == 0)
				if ((ret = update_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
			StorageTmp->isupCtTable_rsvs = 0;
			StorageTmp->isupCtTable_tsts = 0;
			StorageTmp->isupCtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCtTable_sets == 0)
			revert_isupCtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		if (StorageOld->isupCtCtpbInstance != NULL) {
			SNMP_FREE(StorageTmp->isupCtCtpbInstance);
			StorageTmp->isupCtCtpbInstance = StorageOld->isupCtCtpbInstance;
			StorageTmp->isupCtCtpbInstanceLen = StorageOld->isupCtCtpbInstanceLen;
			StorageOld->isupCtCtpbInstance = NULL;
			StorageOld->isupCtCtpbInstanceLen = 0;
		}
		if (--StorageTmp->isupCtTable_rsvs == 0)
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCtCircuitNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCtCircuitNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCtCircuitNumber entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCircuitNumber: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCircuitNumber not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCircuitNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			if (StorageTmp->isupCtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCtTable_old = isupCtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCtTable_rsvs++;
		StorageTmp->isupCtCircuitNumber = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCtTable_tsts == 0)
				if ((ret = check_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCtCircuitNumber for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCtTable_sets == 0)
				if ((ret = update_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
			StorageTmp->isupCtTable_rsvs = 0;
			StorageTmp->isupCtTable_tsts = 0;
			StorageTmp->isupCtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCtTable_sets == 0)
			revert_isupCtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		StorageTmp->isupCtCircuitNumber = StorageOld->isupCtCircuitNumber;
		if (--StorageTmp->isupCtTable_rsvs == 0)
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCtOfficeEquip(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCtOfficeEquip(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCtOfficeEquip entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtOfficeEquip: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtOfficeEquip not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtOfficeEquip: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			if (StorageTmp->isupCtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCtTable_old = isupCtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isupCtOfficeEquip);
		StorageTmp->isupCtOfficeEquip = string;
		StorageTmp->isupCtOfficeEquipLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCtTable_tsts == 0)
				if ((ret = check_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCtOfficeEquip for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCtTable_sets == 0)
				if ((ret = update_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
			StorageTmp->isupCtTable_rsvs = 0;
			StorageTmp->isupCtTable_tsts = 0;
			StorageTmp->isupCtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCtTable_sets == 0)
			revert_isupCtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		if (StorageOld->isupCtOfficeEquip != NULL) {
			SNMP_FREE(StorageTmp->isupCtOfficeEquip);
			StorageTmp->isupCtOfficeEquip = StorageOld->isupCtOfficeEquip;
			StorageTmp->isupCtOfficeEquipLen = StorageOld->isupCtOfficeEquipLen;
			StorageOld->isupCtOfficeEquip = NULL;
			StorageOld->isupCtOfficeEquipLen = 0;
		}
		if (--StorageTmp->isupCtTable_rsvs == 0)
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCtCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isupCtCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isupMIB", "write_isupCtCIC entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isupCtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isupCtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCIC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtCIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			if (StorageTmp->isupCtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isupCtTable_old = isupCtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isupCtTable_rsvs++;
		StorageTmp->isupCtCIC = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isupCtTable_tsts == 0)
				if ((ret = check_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isupCtCIC for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isupCtTable_sets == 0)
				if ((ret = update_isupCtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isupCtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
			StorageTmp->isupCtTable_rsvs = 0;
			StorageTmp->isupCtTable_tsts = 0;
			StorageTmp->isupCtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isupCtTable_sets == 0)
			revert_isupCtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
			break;
		StorageTmp->isupCtCIC = StorageOld->isupCtCIC;
		if (--StorageTmp->isupCtTable_rsvs == 0)
			isupCtTable_destroy(&StorageTmp->isupCtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupMsTable_row(struct isupMsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupMsTable_row(struct isupMsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupMsTable_row(struct isupMsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupMsTable_row(struct isupMsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupPgTable_row(struct isupPgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupPgTable_row(struct isupPgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupPgTable_row(struct isupPgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupPgTable_row(struct isupPgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupPuTable_row(struct isupPuTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupPuTable_row(struct isupPuTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupPuTable_row(struct isupPuTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupPuTable_row(struct isupPuTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupLgTable_row(struct isupLgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupLgTable_row(struct isupLgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupLgTable_row(struct isupLgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupLgTable_row(struct isupLgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupMtpTable_row(struct isupMtpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupMtpTable_row(struct isupMtpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupMtpTable_row(struct isupMtpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupMtpTable_row(struct isupMtpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupNaTable_row(struct isupNaTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupNaTable_row(struct isupNaTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupNaTable_row(struct isupNaTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupNaTable_row(struct isupNaTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupSpTable_row(struct isupSpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupSpTable_row(struct isupSpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupSpTable_row(struct isupSpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupSpTable_row(struct isupSpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupSrTable_row(struct isupSrTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupSrTable_row(struct isupSrTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupSrTable_row(struct isupSrTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupSrTable_row(struct isupSrTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupRtTable_row(struct isupRtTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupRtTable_row(struct isupRtTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupRtTable_row(struct isupRtTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupRtTable_row(struct isupRtTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupRtTgSelectionTable_row(struct isupRtTgSelectionTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupTgTable_row(struct isupTgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupTgTable_row(struct isupTgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupTgTable_row(struct isupTgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupTgTable_row(struct isupTgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupCgTable_row(struct isupCgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupCgTable_row(struct isupCgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupCgTable_row(struct isupCgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupCgTable_row(struct isupCgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isupCtTable_row(struct isupCtTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isupCtTable_row(struct isupCtTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isupCtTable_row(struct isupCtTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isupCtTable_row(struct isupCtTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupMsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupMsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupMsRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupMsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupMsTable_rsvs = 1;
			vp = vars;
			StorageNew->isupMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupMsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupMsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupMsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
				if (StorageTmp->isupMsTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupMsTable_old = isupMsTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupMsTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupMsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupMsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupMsTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupMsRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupMsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupMsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupMsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupMsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupMsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupMsRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupMsTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupMsRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupMsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupMsRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupMsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupMsTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupMsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupMsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupMsRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupMsTable_old) != NULL) {
				isupMsTable_destroy(&StorageTmp->isupMsTable_old);
				StorageTmp->isupMsTable_rsvs = 0;
				StorageTmp->isupMsTable_tsts = 0;
				StorageTmp->isupMsTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupMsTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupMsTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupMsRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupMsTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupMsRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupMsTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupMsTable_del(StorageNew);
				isupMsTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupMsTable_old) == NULL)
				break;
			if (--StorageTmp->isupMsTable_rsvs == 0)
				isupMsTable_destroy(&StorageTmp->isupMsTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupMsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupPgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupPgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupPgRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupPgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPgRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupPgId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupPgId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupPgId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupPgTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupPgTable_rsvs = 1;
			vp = vars;
			StorageNew->isupPgId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupPgTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupPgRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupPgTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
				if (StorageTmp->isupPgTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupPgTable_old = isupPgTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupPgTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupPgTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupPgTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupPgTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupPgRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupPgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupPgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupPgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupPgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupPgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupPgRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupPgTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupPgRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupPgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupPgRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupPgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupPgTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupPgRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupPgRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupPgRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupPgTable_old) != NULL) {
				isupPgTable_destroy(&StorageTmp->isupPgTable_old);
				StorageTmp->isupPgTable_rsvs = 0;
				StorageTmp->isupPgTable_tsts = 0;
				StorageTmp->isupPgTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupPgTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupPgTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupPgRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupPgTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupPgRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupPgTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupPgTable_del(StorageNew);
				isupPgTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupPgTable_old) == NULL)
				break;
			if (--StorageTmp->isupPgTable_rsvs == 0)
				isupPgTable_destroy(&StorageTmp->isupPgTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupPgTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupPuRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupPuRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupPuTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupPuTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupPuRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupPuTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupPuRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupPgId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isupPuId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupPgId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupPgId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isupPuId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupPuId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 0..255 */
			if ((0 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 255)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupPuId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupPuTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupPuTable_rsvs = 1;
			vp = vars;
			StorageNew->isupPgId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isupPuId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupPuTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupPuRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupPuTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
				if (StorageTmp->isupPuTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupPuTable_old = isupPuTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupPuTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupPuTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupPuTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupPuTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupPuRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupPuTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupPuRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupPuTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupPuRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupPuTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupPuRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupPuTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupPuRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupPuTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupPuRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupPuTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupPuTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupPuRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupPuRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupPuRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupPuTable_old) != NULL) {
				isupPuTable_destroy(&StorageTmp->isupPuTable_old);
				StorageTmp->isupPuTable_rsvs = 0;
				StorageTmp->isupPuTable_tsts = 0;
				StorageTmp->isupPuTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupPuTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupPuTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupPuRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupPuTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupPuRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupPuTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupPuTable_del(StorageNew);
				isupPuTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupPuTable_old) == NULL)
				break;
			if (--StorageTmp->isupPuTable_rsvs == 0)
				isupPuTable_destroy(&StorageTmp->isupPuTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupPuTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupLgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupLgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupLgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupLgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupLgRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupLgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupLgRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupLgId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupLgId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupLgId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupLgTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupLgTable_rsvs = 1;
			vp = vars;
			StorageNew->isupLgId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupLgTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupLgRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupLgTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
				if (StorageTmp->isupLgTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupLgTable_old = isupLgTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupLgTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupLgTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupLgTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupLgTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupLgRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupLgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupLgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupLgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupLgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupLgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupLgRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupLgTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupLgRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupLgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupLgRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupLgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupLgTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupLgRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupLgRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupLgRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupLgTable_old) != NULL) {
				isupLgTable_destroy(&StorageTmp->isupLgTable_old);
				StorageTmp->isupLgTable_rsvs = 0;
				StorageTmp->isupLgTable_tsts = 0;
				StorageTmp->isupLgTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupLgTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupLgTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupLgRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupLgTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupLgRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupLgTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupLgTable_del(StorageNew);
				isupLgTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupLgTable_old) == NULL)
				break;
			if (--StorageTmp->isupLgTable_rsvs == 0)
				isupLgTable_destroy(&StorageTmp->isupLgTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupLgTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupMtpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupMtpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupMtpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupMtpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupMtpRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupMtpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupMtpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isupSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isupMtpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isupSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isupMtpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupMtpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupMtpTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupMtpTable_rsvs = 1;
			vp = vars;
			StorageNew->isupMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isupSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isupMtpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupMtpTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupMtpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupMtpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
				if (StorageTmp->isupMtpTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupMtpTable_old = isupMtpTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupMtpTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupMtpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupMtpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupMtpTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupMtpRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupMtpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupMtpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupMtpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupMtpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupMtpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupMtpRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupMtpTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupMtpRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupMtpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupMtpRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupMtpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupMtpTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupMtpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupMtpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupMtpRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupMtpTable_old) != NULL) {
				isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
				StorageTmp->isupMtpTable_rsvs = 0;
				StorageTmp->isupMtpTable_tsts = 0;
				StorageTmp->isupMtpTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupMtpTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupMtpTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupMtpRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupMtpTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupMtpRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupMtpTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupMtpTable_del(StorageNew);
				isupMtpTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupMtpTable_old) == NULL)
				break;
			if (--StorageTmp->isupMtpTable_rsvs == 0)
				isupMtpTable_destroy(&StorageTmp->isupMtpTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupMtpTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupNaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupNaRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupNaRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupNaId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupNaId */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupNaId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..255 */
			if ((1 > (long) *vp->val.integer || (long) *vp->val.integer > 255)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupNaId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupNaTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupNaTable_rsvs = 1;
			vp = vars;
			StorageNew->isupNaId = (long) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupNaTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupNaRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupNaTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
				if (StorageTmp->isupNaTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupNaTable_old = isupNaTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupNaTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupNaTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupNaTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupNaTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupNaRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupNaTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupNaRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupNaTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupNaRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupNaTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupNaRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupNaTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupNaRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupNaTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupNaRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupNaTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupNaTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupNaRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupNaRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupNaRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupNaTable_old) != NULL) {
				isupNaTable_destroy(&StorageTmp->isupNaTable_old);
				StorageTmp->isupNaTable_rsvs = 0;
				StorageTmp->isupNaTable_tsts = 0;
				StorageTmp->isupNaTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupNaTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupNaTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupNaRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupNaTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupNaRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupNaTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupNaTable_del(StorageNew);
				isupNaTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupNaTable_old) == NULL)
				break;
			if (--StorageTmp->isupNaTable_rsvs == 0)
				isupNaTable_destroy(&StorageTmp->isupNaTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupNaTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupSpRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isupSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isupSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupSpTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupSpTable_rsvs = 1;
			vp = vars;
			StorageNew->isupMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isupSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupSpTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupSpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupSpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
				if (StorageTmp->isupSpTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupSpTable_old = isupSpTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupSpTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupSpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupSpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupSpTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupSpRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupSpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupSpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupSpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupSpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupSpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupSpRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupSpTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupSpRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupSpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupSpRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupSpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupSpTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupSpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupSpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupSpRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupSpTable_old) != NULL) {
				isupSpTable_destroy(&StorageTmp->isupSpTable_old);
				StorageTmp->isupSpTable_rsvs = 0;
				StorageTmp->isupSpTable_tsts = 0;
				StorageTmp->isupSpTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupSpTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupSpTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupSpRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupSpTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupSpRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupSpTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupSpTable_del(StorageNew);
				isupSpTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupSpTable_old) == NULL)
				break;
			if (--StorageTmp->isupSpTable_rsvs == 0)
				isupSpTable_destroy(&StorageTmp->isupSpTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupSpTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupSrRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupSrRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupSrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupSrTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupSrRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupSrTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupSrRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isupSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isupSrId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isupSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isupSrId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupSrId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupSrTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupSrTable_rsvs = 1;
			vp = vars;
			StorageNew->isupMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isupSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isupSrId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupSrTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupSrRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupSrTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
				if (StorageTmp->isupSrTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupSrTable_old = isupSrTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupSrTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupSrTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupSrTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupSrTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupSrRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupSrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupSrRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupSrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupSrRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupSrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupSrRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupSrTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupSrRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupSrTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupSrRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupSrTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupSrTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupSrRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupSrRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupSrRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupSrTable_old) != NULL) {
				isupSrTable_destroy(&StorageTmp->isupSrTable_old);
				StorageTmp->isupSrTable_rsvs = 0;
				StorageTmp->isupSrTable_tsts = 0;
				StorageTmp->isupSrTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupSrTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupSrTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupSrRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupSrTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupSrRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupSrTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupSrTable_del(StorageNew);
				isupSrTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupSrTable_old) == NULL)
				break;
			if (--StorageTmp->isupSrTable_rsvs == 0)
				isupSrTable_destroy(&StorageTmp->isupSrTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupSrTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupRtRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupRtId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupRtId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupRtId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupRtTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupRtTable_rsvs = 1;
			vp = vars;
			StorageNew->isupRtId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupRtTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupRtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupRtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
				if (StorageTmp->isupRtTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupRtTable_old = isupRtTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupRtTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupRtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupRtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupRtTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupRtRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupRtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupRtRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupRtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupRtRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupRtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupRtRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupRtTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupRtRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupRtTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupRtRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupRtTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupRtTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupRtRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupRtRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupRtRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupRtTable_old) != NULL) {
				isupRtTable_destroy(&StorageTmp->isupRtTable_old);
				StorageTmp->isupRtTable_rsvs = 0;
				StorageTmp->isupRtTable_tsts = 0;
				StorageTmp->isupRtTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupRtTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupRtTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupRtRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupRtTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupRtRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupRtTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupRtTable_del(StorageNew);
				isupRtTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupRtTable_old) == NULL)
				break;
			if (--StorageTmp->isupRtTable_rsvs == 0)
				isupRtTable_destroy(&StorageTmp->isupRtTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupRtTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupRtTgSelectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupRtTgSelectionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupRtTgSelectionTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupRtTgSelectionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupRtTgSelectionRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupRtTgSelectionTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtTgSelectionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupRtTgSelectionRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupRtId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isupRtTgSelectionIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupRtId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupRtId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isupRtTgSelectionIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupRtTgSelectionIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupRtTgSelectionTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupRtTgSelectionTable_rsvs = 1;
			vp = vars;
			StorageNew->isupRtId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isupRtTgSelectionIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupRtTgSelectionTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupRtTgSelectionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupRtTgSelectionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old) == NULL)
				if (StorageTmp->isupRtTgSelectionTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old = isupRtTgSelectionTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupRtTgSelectionTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupRtTgSelectionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupRtTgSelectionTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupRtTgSelectionTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupRtTgSelectionRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupRtTgSelectionTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupRtTgSelectionRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupRtTgSelectionTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupRtTgSelectionRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupRtTgSelectionTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupRtTgSelectionRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupRtTgSelectionTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupRtTgSelectionRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupRtTgSelectionTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupRtTgSelectionRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupRtTgSelectionTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupRtTgSelectionTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupRtTgSelectionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupRtTgSelectionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupRtTgSelectionRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old) != NULL) {
				isupRtTgSelectionTable_destroy(&StorageTmp->isupRtTgSelectionTable_old);
				StorageTmp->isupRtTgSelectionTable_rsvs = 0;
				StorageTmp->isupRtTgSelectionTable_tsts = 0;
				StorageTmp->isupRtTgSelectionTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupRtTgSelectionTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupRtTgSelectionTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupRtTgSelectionRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupRtTgSelectionTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupRtTgSelectionRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupRtTgSelectionTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupRtTgSelectionTable_del(StorageNew);
				isupRtTgSelectionTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupRtTgSelectionTable_old) == NULL)
				break;
			if (--StorageTmp->isupRtTgSelectionTable_rsvs == 0)
				isupRtTgSelectionTable_destroy(&StorageTmp->isupRtTgSelectionTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupRtTgSelectionTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupTgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupTgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupTgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupTgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupTgRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupTgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupTgRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupTgId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupTgId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupTgId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupTgTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupTgTable_rsvs = 1;
			vp = vars;
			StorageNew->isupTgId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupTgTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupTgRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupTgTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
				if (StorageTmp->isupTgTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupTgTable_old = isupTgTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupTgTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupTgTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupTgTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupTgTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupTgRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupTgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupTgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupTgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupTgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupTgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupTgRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupTgTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupTgRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupTgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupTgRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupTgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupTgTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupTgRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupTgRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupTgRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupTgTable_old) != NULL) {
				isupTgTable_destroy(&StorageTmp->isupTgTable_old);
				StorageTmp->isupTgTable_rsvs = 0;
				StorageTmp->isupTgTable_tsts = 0;
				StorageTmp->isupTgTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupTgTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupTgTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupTgRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupTgTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupTgRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupTgTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupTgTable_del(StorageNew);
				isupTgTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupTgTable_old) == NULL)
				break;
			if (--StorageTmp->isupTgTable_rsvs == 0)
				isupTgTable_destroy(&StorageTmp->isupTgTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupTgTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupCgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupCgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupCgRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupCgTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCgRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupCgId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupCgId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupCgId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupCgTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupCgTable_rsvs = 1;
			vp = vars;
			StorageNew->isupCgId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupCgTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupCgRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupCgTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
				if (StorageTmp->isupCgTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupCgTable_old = isupCgTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupCgTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupCgTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupCgTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupCgTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupCgRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupCgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupCgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupCgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupCgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupCgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupCgRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupCgTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupCgRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupCgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupCgRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupCgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupCgTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupCgRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupCgRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupCgRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupCgTable_old) != NULL) {
				isupCgTable_destroy(&StorageTmp->isupCgTable_old);
				StorageTmp->isupCgTable_rsvs = 0;
				StorageTmp->isupCgTable_tsts = 0;
				StorageTmp->isupCgTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupCgTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupCgTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupCgRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupCgTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupCgRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupCgTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupCgTable_del(StorageNew);
				isupCgTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupCgTable_old) == NULL)
				break;
			if (--StorageTmp->isupCgTable_rsvs == 0)
				isupCgTable_destroy(&StorageTmp->isupCgTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupCgTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isupCtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isupCtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isupCtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isupCtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isupMIB", "write_isupCtRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(isupCtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isupCtRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isupCtId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isupCtId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isupCtId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isupCtTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isupCtTable_rsvs = 1;
			vp = vars;
			StorageNew->isupCtId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isupCtTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isupCtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isupCtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
				if (StorageTmp->isupCtTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isupCtTable_old = isupCtTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isupCtTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isupCtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isupCtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isupCtTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isupCtRowStatus != RS_ACTIVE)
				if ((ret = can_act_isupCtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isupCtRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupCtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isupCtRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_isupCtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isupCtRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isupCtTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isupCtRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isupCtTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isupCtRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isupCtTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isupCtTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isupCtRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isupCtRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isupCtRowStatus = set_value;
			if ((StorageOld = StorageTmp->isupCtTable_old) != NULL) {
				isupCtTable_destroy(&StorageTmp->isupCtTable_old);
				StorageTmp->isupCtTable_rsvs = 0;
				StorageTmp->isupCtTable_tsts = 0;
				StorageTmp->isupCtTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isupCtTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isupCtTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isupCtRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isupCtTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isupCtRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_isupCtTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isupCtTable_del(StorageNew);
				isupCtTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isupCtTable_old) == NULL)
				break;
			if (--StorageTmp->isupCtTable_rsvs == 0)
				isupCtTable_destroy(&StorageTmp->isupCtTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isupCtTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn void isupMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
isupMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("isupMIB", "isupMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (isupMIBold_signal_handler != NULL)
		(*isupMIBold_signal_handler) (sig);
	DEBUGMSGTL(("isupMIB", "done.\n"));
}

/**
 * @fn void isupMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
isupMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("isupMIB", "isupMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("isupMIB", "done.\n"));
	return;
}
