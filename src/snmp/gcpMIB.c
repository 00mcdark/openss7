/*****************************************************************************

 @(#) src/snmp/gcpMIB.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2019  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] __attribute__((unused)) = "src/snmp/gcpMIB.c (" PACKAGE_ENVR ") " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NETSNMP_MEMDUP
#include "ucd_memdup.h"
#endif
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "gcpMIB.h"
#define MASTER 1
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "gcpMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int gcpMIB_refresh = 1;
volatile int gcpMsTable_refresh = 1;
volatile int gcpMgTable_refresh = 1;
volatile int gcpMgcTable_refresh = 1;
volatile int gcpLinkageTable_refresh = 1;
volatile int gcpUdpProfileTable_refresh = 1;
volatile int gcpTcpProfileTable_refresh = 1;
volatile int gcpSctpProfileTable_refresh = 1;
volatile int gcpProtGroupTable_refresh = 1;
volatile int gcpSbolTable_refresh = 1;
volatile int gcpProtUnitTable_refresh = 1;
volatile int gcpRealmTable_refresh = 1;
volatile int gcpInterfaceTable_refresh = 1;
volatile int gcpAddressTable_refresh = 1;

/*
 * gcpMIB_variables_oid: object identifier for gcpMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid gcpMIB_variables_oid[9] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600 };
oid gcpMsTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 1, 1, 1 };
oid gcpMgTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 2, 1, 1 };
oid gcpMgcTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 3, 1, 1 };
oid gcpLinkageTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 4, 1, 1 };
oid gcpUdpProfileTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 5, 1, 1 };
oid gcpTcpProfileTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 6, 1, 1 };
oid gcpSctpProfileTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 7, 1, 1 };
oid gcpProtGroupTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 8, 1, 1 };
oid gcpSbolTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 8, 2, 1 };
oid gcpProtUnitTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 9, 1, 1 };
oid gcpRealmTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 10, 1, 1 };
oid gcpInterfaceTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 11, 1, 1 };
oid gcpAddressTable_variables_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 3, 12, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid gcpProtectionSwitchReport_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 0, 1 };
oid gcpMgFailure_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 0, 2 };
oid gcpMgcFailure_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 0, 3 };
oid gcpLinkageFailure_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 0, 4 };
oid gcpInactivityTimeout_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 0, 5 };
oid gcpMgColdStart_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 0, 6 };
oid gcpOnOccEvent_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 0, 7 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid gcpOldProtectionStatus_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 1 };
oid gcpOldRequestSource_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 2 };
oid gcpOldSwitchStatus_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 3 };
oid gcpOldSwitchDirection_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 4 };
oid gcpOldRelatedUnit_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 5 };
oid gcpOldAutoSwitchReason_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 6 };
oid gcpNewProtectionStatus_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 7 };
oid gcpNewRequestSource_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 8 };
oid gcpNewSwitchStatus_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 9 };
oid gcpNewSwitchDirection_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 10 };
oid gcpNewRelatedUnit_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 11 };
oid gcpNewAutoSwitchReason_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 1, 12 };

/*
 * Other oids defined in this MIB.
 */
oid gcpProtocolSgcp_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 1 };
oid gcpProtocolIdcp_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 2 };
oid gcpProtocolMgcp_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 3 };
oid gcpProtocolMegaco_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 4 };
oid gcpProtocolMegacoV1_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 4, 1 };
oid gcpProtocolMegacoV2_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 4, 2 };
oid gcpProtocolMegacoV3_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 4, 3 };
oid gcpProtocolH248_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 5 };
oid gcpProtocolH248v1_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 5, 1 };
oid gcpProtocolH248v2_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 5, 2 };
oid gcpProtocolH248v3_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 5, 3 };
oid gcpProtocolCbc_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 6 };
oid gcpProtocolBgc_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 4, 1, 7 };
oid gcpNotificationGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 5, 1 };
oid gcpObjectGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 5, 2 };
oid gcpSctpObjectGroup_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 5, 3 };
oid gcpFullCompliance_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 600, 6, 1 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 gcpMIB_variables: tree for gcpMIB
 * This variable defines function callbacks and type return information for the gcpMIB mib section
 */
struct variable7 gcpMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   GCPDEFAULTMGCOIDENT   1
	{ (u_char) GCPDEFAULTMGCOIDENT, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 1, 1} },
#define   GCPDEFAULTMGCOEXECUTIONTIME  2
	{ (u_char) GCPDEFAULTMGCOEXECUTIONTIME, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 1, 2} },
#define   GCPDEFAULTMGCOPROVRESPTIMER  3
	{ (u_char) GCPDEFAULTMGCOPROVRESPTIMER, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 1, 3} },
#define   GCPDEFAULTMGCPPENDINGLIMIT  4
	{ (u_char) GCPDEFAULTMGCPPENDINGLIMIT, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 1, 4} },
#define   GCPDEFAULTMGCOLONGTIMER  5
	{ (u_char) GCPDEFAULTMGCOLONGTIMER, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 1, 5} },
#define   GCPDEFAULTMGCORTOINIT  6
	{ (u_char) GCPDEFAULTMGCORTOINIT, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 1, 6} },
#define   GCPDEFAULTMGCORTOMIN  7
	{ (u_char) GCPDEFAULTMGCORTOMIN, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 1, 7} },
#define   GCPDEFAULTMGCORTOMAX  8
	{ (u_char) GCPDEFAULTMGCORTOMAX, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 1, 8} },
#define   GCPDEFAULTUDPCHECKSUM  9
	{ (u_char) GCPDEFAULTUDPCHECKSUM, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 2, 1} },
#define   GCPDEFAULTTCPNODELAY  10
	{ (u_char) GCPDEFAULTTCPNODELAY, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 3, 1} },
#define   GCPDEFAULTTCPMAXSEG   11
	{ (u_char) GCPDEFAULTTCPMAXSEG, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 3, 2} },
#define   GCPDEFAULTTCPKEEPALIVE  12
	{ (u_char) GCPDEFAULTTCPKEEPALIVE, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 3, 3} },
#define   GCPDEFAULTTCPKEEPIDLE  13
	{ (u_char) GCPDEFAULTTCPKEEPIDLE, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 3, 4} },
#define   GCPDEFAULTTCPKEEPALIVEITVL  14
	{ (u_char) GCPDEFAULTTCPKEEPALIVEITVL, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 3, 5} },
#define   GCPDEFAULTTCPKEEPCOUNT  15
	{ (u_char) GCPDEFAULTTCPKEEPCOUNT, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 3, 6} },
#define   GCPDEFAULTTCPSYNRETRANS  16
	{ (u_char) GCPDEFAULTTCPSYNRETRANS, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 3, 7} },
#define   GCPDEFAULTTCPWINDOWCLAMP  17
	{ (u_char) GCPDEFAULTTCPWINDOWCLAMP, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 3, 8} },
#define   GCPDEFAULTSCTPNODELAY  18
	{ (u_char) GCPDEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 1} },
#define   GCPDEFAULTSCTPMAXSEG  19
	{ (u_char) GCPDEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 2} },
#define   GCPDEFAULTSCTPHEARTBEATITVL  20
	{ (u_char) GCPDEFAULTSCTPHEARTBEATITVL, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 3} },
#define   GCPDEFAULTSCTPHEARBEAT  21
	{ (u_char) GCPDEFAULTSCTPHEARBEAT, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 4} },
#define   GCPDEFAULTSCTPRTOINITIAL  22
	{ (u_char) GCPDEFAULTSCTPRTOINITIAL, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 5} },
#define   GCPDEFAULTSCTPRTOMIN  23
	{ (u_char) GCPDEFAULTSCTPRTOMIN, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 6} },
#define   GCPDEFAULTSCTPRTOMAX  24
	{ (u_char) GCPDEFAULTSCTPRTOMAX, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 7} },
#define   GCPDEFAULTSCTPPATHMAXRETRANS  25
	{ (u_char) GCPDEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 8} },
#define   GCPDEFAULTSCTPCOOKIELIFE  26
	{ (u_char) GCPDEFAULTSCTPCOOKIELIFE, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 9} },
#define   GCPDEFAULTSCTPCOOKIEINC  27
	{ (u_char) GCPDEFAULTSCTPCOOKIEINC, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 10} },
#define   GCPDEFAULTSCTPMAXINITRETRIES  28
	{ (u_char) GCPDEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 11} },
#define   GCPDEFAULTSCTPMAXBURST  29
	{ (u_char) GCPDEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 12} },
#define   GCPDEFAULTSCTPASSOCMAXRETRANS  30
	{ (u_char) GCPDEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 13} },
#define   GCPDEFAULTSCTPSACKDELAY  31
	{ (u_char) GCPDEFAULTSCTPSACKDELAY, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 14} },
#define   GCPDEFAULTSCTPLIFETIME  32
	{ (u_char) GCPDEFAULTSCTPLIFETIME, ASN_INTEGER, RWRITE, var_gcpMIB, 4, { 2, 1, 4, 15} },
#define   GCPMSNAME             33
	{ (u_char) GCPMSNAME, ASN_OCTET_STR, RWRITE, var_gcpMsTable, 5, { 3, 1, 1, 1, 2} },
#define   GCPMSALARMSTATUS      34
	{ (u_char) GCPMSALARMSTATUS, ASN_OCTET_STR, RWRITE, var_gcpMsTable, 5, { 3, 1, 1, 1, 3} },
#define   GCPMSOPERATIONALSTATE  35
	{ (u_char) GCPMSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_gcpMsTable, 5, { 3, 1, 1, 1, 4} },
#define   GCPMSUSAGESTATE       36
	{ (u_char) GCPMSUSAGESTATE, ASN_INTEGER, RONLY, var_gcpMsTable, 5, { 3, 1, 1, 1, 5} },
#define   GCPMSMANAGEDELEMENTTYPE  37
	{ (u_char) GCPMSMANAGEDELEMENTTYPE, ASN_OCTET_STR, RONLY, var_gcpMsTable, 5, { 3, 1, 1, 1, 6} },
#define   GCPMSMODELCODE        38
	{ (u_char) GCPMSMODELCODE, ASN_OCTET_STR, RONLY, var_gcpMsTable, 5, { 3, 1, 1, 1, 7} },
#define   GCPMSVENDORNAME       39
	{ (u_char) GCPMSVENDORNAME, ASN_OCTET_STR, RONLY, var_gcpMsTable, 5, { 3, 1, 1, 1, 8} },
#define   GCPMSUSERLABEL        40
	{ (u_char) GCPMSUSERLABEL, ASN_OCTET_STR, RWRITE, var_gcpMsTable, 5, { 3, 1, 1, 1, 9} },
#define   GCPMSVERSION          41
	{ (u_char) GCPMSVERSION, ASN_OCTET_STR, RONLY, var_gcpMsTable, 5, { 3, 1, 1, 1, 10} },
#define   GCPMSASAPROFILEPOINTER  42
	{ (u_char) GCPMSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_gcpMsTable, 5, { 3, 1, 1, 1, 11} },
#define   GCPMSNETWORKELEMENTALIASES  43
	{ (u_char) GCPMSNETWORKELEMENTALIASES, ASN_OCTET_STR, RWRITE, var_gcpMsTable, 5, { 3, 1, 1, 1, 12} },
#define   GCPMSROWSTATUS        44
	{ (u_char) GCPMSROWSTATUS, ASN_INTEGER, RWRITE, var_gcpMsTable, 5, { 3, 1, 1, 1, 13} },
#define   GCPMGLOCATION         45
	{ (u_char) GCPMGLOCATION, ASN_INTEGER, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 2} },
#define   GCPMGNAME             46
	{ (u_char) GCPMGNAME, ASN_OCTET_STR, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 3} },
#define   GCPMGDOMAINNAME       47
	{ (u_char) GCPMGDOMAINNAME, ASN_OCTET_STR, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 4} },
#define   GCPMGDEVICENAME       48
	{ (u_char) GCPMGDEVICENAME, ASN_OCTET_STR, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 5} },
#define   GCPMGMTPADDRESS       49
	{ (u_char) GCPMGMTPADDRESS, ASN_OCTET_STR, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 6} },
#define   GCPMGADMINSTATE       50
	{ (u_char) GCPMGADMINSTATE, ASN_INTEGER, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 7} },
#define   GCPMGOPERSTATE        51
	{ (u_char) GCPMGOPERSTATE, ASN_INTEGER, RONLY, var_gcpMgTable, 5, { 3, 2, 1, 1, 8} },
#define   GCPMGALARMSTATUS      52
	{ (u_char) GCPMGALARMSTATUS, ASN_OCTET_STR, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 9} },
#define   GCPMGASAPROFILEPOINTER  53
	{ (u_char) GCPMGASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 10} },
#define   GCPMGUSAGESTATE       54
	{ (u_char) GCPMGUSAGESTATE, ASN_INTEGER, RONLY, var_gcpMgTable, 5, { 3, 2, 1, 1, 11} },
#define   GCPMGAVAILSTATUS      55
	{ (u_char) GCPMGAVAILSTATUS, ASN_OCTET_STR, RONLY, var_gcpMgTable, 5, { 3, 2, 1, 1, 12} },
#define   GCPMGPROCSTATUS       56
	{ (u_char) GCPMGPROCSTATUS, ASN_OCTET_STR, RONLY, var_gcpMgTable, 5, { 3, 2, 1, 1, 13} },
#define   GCPMGPG               57
	{ (u_char) GCPMGPG, ASN_UNSIGNED, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 14} },
#define   GCPMGSTANDBYSTATUS    58
	{ (u_char) GCPMGSTANDBYSTATUS, ASN_INTEGER, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 15} },
#define   GCPMGROWSTATUS        59
	{ (u_char) GCPMGROWSTATUS, ASN_INTEGER, RWRITE, var_gcpMgTable, 5, { 3, 2, 1, 1, 16} },
#define   GCPMGCLOCATION        60
	{ (u_char) GCPMGCLOCATION, ASN_INTEGER, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 2} },
#define   GCPMGCNAME            61
	{ (u_char) GCPMGCNAME, ASN_OCTET_STR, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 3} },
#define   GCPMGCDOMAINNAME      62
	{ (u_char) GCPMGCDOMAINNAME, ASN_OCTET_STR, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 4} },
#define   GCPMGCDEVICENAME      63
	{ (u_char) GCPMGCDEVICENAME, ASN_OCTET_STR, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 5} },
#define   GCPMGCMTPADDRESS      64
	{ (u_char) GCPMGCMTPADDRESS, ASN_OCTET_STR, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 6} },
#define   GCPMGCADMINSTATE      65
	{ (u_char) GCPMGCADMINSTATE, ASN_INTEGER, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 7} },
#define   GCPMGCOPERSTATE       66
	{ (u_char) GCPMGCOPERSTATE, ASN_INTEGER, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 8} },
#define   GCPMGCALARMSTATUS     67
	{ (u_char) GCPMGCALARMSTATUS, ASN_OCTET_STR, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 9} },
#define   GCPMGCASAPROFILEPOINTER  68
	{ (u_char) GCPMGCASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 10} },
#define   GCPMGCUSAGESTATE      69
	{ (u_char) GCPMGCUSAGESTATE, ASN_INTEGER, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 11} },
#define   GCPMGCAVAILSTATUS     70
	{ (u_char) GCPMGCAVAILSTATUS, ASN_OCTET_STR, RONLY, var_gcpMgcTable, 5, { 3, 3, 1, 1, 12} },
#define   GCPMGCPROCSTATUS      71
	{ (u_char) GCPMGCPROCSTATUS, ASN_OCTET_STR, RONLY, var_gcpMgcTable, 5, { 3, 3, 1, 1, 13} },
#define   GCPMGCPG              72
	{ (u_char) GCPMGCPG, ASN_UNSIGNED, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 14} },
#define   GCPMGCSTANDBYSTATUS   73
	{ (u_char) GCPMGCSTANDBYSTATUS, ASN_INTEGER, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 15} },
#define   GCPMGCROWSTATUS       74
	{ (u_char) GCPMGCROWSTATUS, ASN_INTEGER, RWRITE, var_gcpMgcTable, 5, { 3, 3, 1, 1, 16} },
#define   GCPLINKAGETYPE        75
	{ (u_char) GCPLINKAGETYPE, ASN_INTEGER, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 1} },
#define   GCPLINKAGEMGCMASTER   76
	{ (u_char) GCPLINKAGEMGCMASTER, ASN_INTEGER, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 2} },
#define   GCPLINKAGEMGCADDRESS  77
	{ (u_char) GCPLINKAGEMGCADDRESS, ASN_OCTET_STR, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 3} },
#define   GCPLINKAGEMGADDRESS   78
	{ (u_char) GCPLINKAGEMGADDRESS, ASN_OCTET_STR, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 4} },
#define   GCPLINKAGEMGCIDENT    79
	{ (u_char) GCPLINKAGEMGCIDENT, ASN_INTEGER, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 5} },
#define   GCPLINKAGEMGIDENT     80
	{ (u_char) GCPLINKAGEMGIDENT, ASN_INTEGER, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 6} },
#define   GCPLINKAGEPROFILE     81
	{ (u_char) GCPLINKAGEPROFILE, ASN_OBJECT_ID, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 7} },
#define   GCPLINKAGEPROTOCOL    82
	{ (u_char) GCPLINKAGEPROTOCOL, ASN_OBJECT_ID, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 8} },
#define   GCPLINKAGEENCODING    83
	{ (u_char) GCPLINKAGEENCODING, ASN_INTEGER, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 9} },
#define   GCPLINKAGEAUTHACCESS  84
	{ (u_char) GCPLINKAGEAUTHACCESS, ASN_OCTET_STR, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 10} },
#define   GCPLINKAGEADMINSTATE  85
	{ (u_char) GCPLINKAGEADMINSTATE, ASN_INTEGER, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 11} },
#define   GCPLINKAGEOPERSTATE   86
	{ (u_char) GCPLINKAGEOPERSTATE, ASN_INTEGER, RONLY, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 12} },
#define   GCPLINKAGEPROCSTATUS  87
	{ (u_char) GCPLINKAGEPROCSTATUS, ASN_OCTET_STR, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 13} },
#define   GCPLINKAGEAVAILSTATUS  88
	{ (u_char) GCPLINKAGEAVAILSTATUS, ASN_OCTET_STR, RONLY, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 14} },
#define   GCPLINKAGEAUTHENTICATION  89
	{ (u_char) GCPLINKAGEAUTHENTICATION, ASN_INTEGER, RONLY, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 15} },
#define   GCPLINKAGEMIT         90
	{ (u_char) GCPLINKAGEMIT, ASN_INTEGER, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 16} },
#define   GCPLINKAGEROWSTATUS   91
	{ (u_char) GCPLINKAGEROWSTATUS, ASN_INTEGER, RWRITE, var_gcpLinkageTable, 5, { 3, 4, 1, 1, 17} },
#define   GCPUDPCHECKSUM        92
	{ (u_char) GCPUDPCHECKSUM, ASN_INTEGER, RWRITE, var_gcpUdpProfileTable, 5, { 3, 5, 1, 1, 2} },
#define   GCPUDPROWSTATUS       93
	{ (u_char) GCPUDPROWSTATUS, ASN_INTEGER, RWRITE, var_gcpUdpProfileTable, 5, { 3, 5, 1, 1, 3} },
#define   GCPTCPNODELAY         94
	{ (u_char) GCPTCPNODELAY, ASN_INTEGER, RWRITE, var_gcpTcpProfileTable, 5, { 3, 6, 1, 1, 2} },
#define   GCPTCPMAXSEG          95
	{ (u_char) GCPTCPMAXSEG, ASN_UNSIGNED, RWRITE, var_gcpTcpProfileTable, 5, { 3, 6, 1, 1, 3} },
#define   GCPTCPKEEPALIVE       96
	{ (u_char) GCPTCPKEEPALIVE, ASN_INTEGER, RWRITE, var_gcpTcpProfileTable, 5, { 3, 6, 1, 1, 4} },
#define   GCPTCPKEEPIDLE        97
	{ (u_char) GCPTCPKEEPIDLE, ASN_INTEGER, RWRITE, var_gcpTcpProfileTable, 5, { 3, 6, 1, 1, 5} },
#define   GCPTCPKEEPALIVEITVL   98
	{ (u_char) GCPTCPKEEPALIVEITVL, ASN_INTEGER, RWRITE, var_gcpTcpProfileTable, 5, { 3, 6, 1, 1, 6} },
#define   GCPTCPKEEPCOUNT       99
	{ (u_char) GCPTCPKEEPCOUNT, ASN_UNSIGNED, RWRITE, var_gcpTcpProfileTable, 5, { 3, 6, 1, 1, 7} },
#define   GCPTCPSYNRETRANS      100
	{ (u_char) GCPTCPSYNRETRANS, ASN_UNSIGNED, RWRITE, var_gcpTcpProfileTable, 5, { 3, 6, 1, 1, 8} },
#define   GCPTCPWINDOWCLAMP     101
	{ (u_char) GCPTCPWINDOWCLAMP, ASN_UNSIGNED, RWRITE, var_gcpTcpProfileTable, 5, { 3, 6, 1, 1, 9} },
#define   GCPTCPROWSTATUS       102
	{ (u_char) GCPTCPROWSTATUS, ASN_INTEGER, RWRITE, var_gcpTcpProfileTable, 5, { 3, 6, 1, 1, 10} },
#define   GCPSCTPNODELAY        103
	{ (u_char) GCPSCTPNODELAY, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 2} },
#define   GCPSCTPMAXSEG         104
	{ (u_char) GCPSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 3} },
#define   GCPSCTPHEARTBEATITVL  105
	{ (u_char) GCPSCTPHEARTBEATITVL, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 4} },
#define   GCPSCTPHEARBEAT       106
	{ (u_char) GCPSCTPHEARBEAT, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 5} },
#define   GCPSCTPRTOINITIAL     107
	{ (u_char) GCPSCTPRTOINITIAL, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 6} },
#define   GCPSCTPRTOMIN         108
	{ (u_char) GCPSCTPRTOMIN, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 7} },
#define   GCPSCTPRTOMAX         109
	{ (u_char) GCPSCTPRTOMAX, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 8} },
#define   GCPSCTPPATHMAXRETRANS  110
	{ (u_char) GCPSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 9} },
#define   GCPSCTPCOOKIELIFE     111
	{ (u_char) GCPSCTPCOOKIELIFE, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 10} },
#define   GCPSCTPCOOKIEINC      112
	{ (u_char) GCPSCTPCOOKIEINC, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 11} },
#define   GCPSCTPMAXINITRETRIES  113
	{ (u_char) GCPSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 12} },
#define   GCPSCTPMAXBURST       114
	{ (u_char) GCPSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 13} },
#define   GCPSCTPASSOCMAXRETRANS  115
	{ (u_char) GCPSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 14} },
#define   GCPSCTPSACKDELAY      116
	{ (u_char) GCPSCTPSACKDELAY, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 15} },
#define   GCPSCTPLIFETIME       117
	{ (u_char) GCPSCTPLIFETIME, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 16} },
#define   GCPSCTPROWSTATUS      118
	{ (u_char) GCPSCTPROWSTATUS, ASN_INTEGER, RWRITE, var_gcpSctpProfileTable, 5, { 3, 7, 1, 1, 17} },
#define   GCPPROTGROUPOPERSTATE  119
	{ (u_char) GCPPROTGROUPOPERSTATE, ASN_INTEGER, RONLY, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 2} },
#define   GCPPROTGROUPAVAILSTATUS  120
	{ (u_char) GCPPROTGROUPAVAILSTATUS, ASN_OCTET_STR, RONLY, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 3} },
#define   GCPPROTGROUPTYPE      121
	{ (u_char) GCPPROTGROUPTYPE, ASN_INTEGER, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 4} },
#define   GCPPROTGROUPREVERTIVE  122
	{ (u_char) GCPPROTGROUPREVERTIVE, ASN_INTEGER, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 5} },
#define   GCPPROTGROUPSBOLNUMBER  123
	{ (u_char) GCPPROTGROUPSBOLNUMBER, ASN_UNSIGNED, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 6} },
#define   GCPPROTGROUPWAITTORESTORETIME  124
	{ (u_char) GCPPROTGROUPWAITTORESTORETIME, ASN_INTEGER, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 7} },
#define   GCPPROTGROUPSETTINGWINDOWTIME  125
	{ (u_char) GCPPROTGROUPSETTINGWINDOWTIME, ASN_INTEGER, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 8} },
#define   GCPPROTGROUPRELEASEINGWINDOWTIME  126
	{ (u_char) GCPPROTGROUPRELEASEINGWINDOWTIME, ASN_INTEGER, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 9} },
#define   GCPPROTGROUPHITSCOUNT  127
	{ (u_char) GCPPROTGROUPHITSCOUNT, ASN_UNSIGNED, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 10} },
#define   GCPPROTGROUPSWITCHTYPE  128
	{ (u_char) GCPPROTGROUPSWITCHTYPE, ASN_INTEGER, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 11} },
#define   GCPPROTGROUPPROTECTEDUNITS  129
	{ (u_char) GCPPROTGROUPPROTECTEDUNITS, ASN_OCTET_STR, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 12} },
#define   GCPPROTGROUPPROTECTINGUNITS  130
	{ (u_char) GCPPROTGROUPPROTECTINGUNITS, ASN_OCTET_STR, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 13} },
#define   GCPPROTGROUPINVOKEPROTECTION  131
	{ (u_char) GCPPROTGROUPINVOKEPROTECTION, ASN_INTEGER, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 14} },
#define   GCPPROTGROUPRELEASEPROTECTION  132
	{ (u_char) GCPPROTGROUPRELEASEPROTECTION, ASN_INTEGER, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 15} },
#define   GCPPROTGROUPROWSTATUS  133
	{ (u_char) GCPPROTGROUPROWSTATUS, ASN_INTEGER, RWRITE, var_gcpProtGroupTable, 5, { 3, 8, 1, 1, 16} },
#define   GCPSBOLOBJECT         134
	{ (u_char) GCPSBOLOBJECT, ASN_OBJECT_ID, RWRITE, var_gcpSbolTable, 5, { 3, 8, 2, 1, 2} },
#define   GCPSBOLSTATUS         135
	{ (u_char) GCPSBOLSTATUS, ASN_INTEGER, RWRITE, var_gcpSbolTable, 5, { 3, 8, 2, 1, 3} },
#define   GCPPROTUNITPROTECTING  136
	{ (u_char) GCPPROTUNITPROTECTING, ASN_INTEGER, RWRITE, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 2} },
#define   GCPPROTUNITRELIABLERESOURCEPOINTER  137
	{ (u_char) GCPPROTUNITRELIABLERESOURCEPOINTER, ASN_OBJECT_ID, RWRITE, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 3} },
#define   GCPPROTUNITUNRELIABLERESOURCEPOINTER  138
	{ (u_char) GCPPROTUNITUNRELIABLERESOURCEPOINTER, ASN_OBJECT_ID, RWRITE, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 4} },
#define   GCPPROTUNITPROTECTIONSTATUS  139
	{ (u_char) GCPPROTUNITPROTECTIONSTATUS, ASN_OCTET_STR, RWRITE, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 5} },
#define   GCPPROTUNITREQUESTSOURCE  140
	{ (u_char) GCPPROTUNITREQUESTSOURCE, ASN_INTEGER, RWRITE, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 6} },
#define   GCPPROTUNITSWITCHSTATUS  141
	{ (u_char) GCPPROTUNITSWITCHSTATUS, ASN_INTEGER, RONLY, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 7} },
#define   GCPPROTUNITSWITCHDIRECTION  142
	{ (u_char) GCPPROTUNITSWITCHDIRECTION, ASN_INTEGER, RONLY, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 8} },
#define   GCPPROTUNITRELATEDUNIT  143
	{ (u_char) GCPPROTUNITRELATEDUNIT, ASN_UNSIGNED, RONLY, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 9} },
#define   GCPPROTUNITAUTOSWITCHREASON  144
	{ (u_char) GCPPROTUNITAUTOSWITCHREASON, ASN_INTEGER, RONLY, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 10} },
#define   GCPPROTUNITLOCKOUTRELEASEFAILED  145
	{ (u_char) GCPPROTUNITLOCKOUTRELEASEFAILED, ASN_INTEGER, RONLY, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 11} },
#define   GCPPROTUNITPRIORITY   146
	{ (u_char) GCPPROTUNITPRIORITY, ASN_UNSIGNED, RWRITE, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 12} },
#define   GCPPROTUNITROWSTATUS  147
	{ (u_char) GCPPROTUNITROWSTATUS, ASN_INTEGER, RWRITE, var_gcpProtUnitTable, 5, { 3, 9, 1, 1, 13} },
#define   GCPREALMSTRING        148
	{ (u_char) GCPREALMSTRING, ASN_OCTET_STR, RWRITE, var_gcpRealmTable, 5, { 3, 10, 1, 1, 2} },
#define   GCPREALMTERMSMAX      149
	{ (u_char) GCPREALMTERMSMAX, ASN_UNSIGNED, RONLY, var_gcpRealmTable, 5, { 3, 10, 1, 1, 3} },
#define   GCPREALMTERMSCURRENT  150
	{ (u_char) GCPREALMTERMSCURRENT, ASN_GAUGE, RONLY, var_gcpRealmTable, 5, { 3, 10, 1, 1, 4} },
#define   GCPREALMTERMSHIWAT    151
	{ (u_char) GCPREALMTERMSHIWAT, ASN_GAUGE, RWRITE, var_gcpRealmTable, 5, { 3, 10, 1, 1, 5} },
#define   GCPREALMTERMSLOWAT    152
	{ (u_char) GCPREALMTERMSLOWAT, ASN_GAUGE, RWRITE, var_gcpRealmTable, 5, { 3, 10, 1, 1, 6} },
#define   GCPREALMROWSTATUS     153
	{ (u_char) GCPREALMROWSTATUS, ASN_INTEGER, RWRITE, var_gcpRealmTable, 5, { 3, 10, 1, 1, 7} },
#define   GCPINTERFACEIFINDEX   154
	{ (u_char) GCPINTERFACEIFINDEX, ASN_UNSIGNED, RWRITE, var_gcpInterfaceTable, 5, { 3, 11, 1, 1, 2} },
#define   GCPINTERFACEMGID      155
	{ (u_char) GCPINTERFACEMGID, ASN_UNSIGNED, RWRITE, var_gcpInterfaceTable, 5, { 3, 11, 1, 1, 3} },
#define   GCPINTERFACETYPE      156
	{ (u_char) GCPINTERFACETYPE, ASN_INTEGER, RWRITE, var_gcpInterfaceTable, 5, { 3, 11, 1, 1, 4} },
#define   GCPINTERFACEREALM     157
	{ (u_char) GCPINTERFACEREALM, ASN_UNSIGNED, RWRITE, var_gcpInterfaceTable, 5, { 3, 11, 1, 1, 5} },
#define   GCPINTERFACETERMID    158
	{ (u_char) GCPINTERFACETERMID, ASN_OCTET_STR, RWRITE, var_gcpInterfaceTable, 5, { 3, 11, 1, 1, 6} },
#define   GCPINTERFACETERMPATH  159
	{ (u_char) GCPINTERFACETERMPATH, ASN_OCTET_STR, RWRITE, var_gcpInterfaceTable, 5, { 3, 11, 1, 1, 7} },
#define   GCPINTERFACEROWSTATUS  160
	{ (u_char) GCPINTERFACEROWSTATUS, ASN_INTEGER, RWRITE, var_gcpInterfaceTable, 5, { 3, 11, 1, 1, 8} },
#define   GCPADDRESSINTERFACE   161
	{ (u_char) GCPADDRESSINTERFACE, ASN_UNSIGNED, RWRITE, var_gcpAddressTable, 5, { 3, 12, 1, 1, 3} },
#define   GCPADDRESSTYPE        162
	{ (u_char) GCPADDRESSTYPE, ASN_INTEGER, RWRITE, var_gcpAddressTable, 5, { 3, 12, 1, 1, 4} },
#define   GCPADDRESSADDR        163
	{ (u_char) GCPADDRESSADDR, ASN_OCTET_STR, RWRITE, var_gcpAddressTable, 5, { 3, 12, 1, 1, 5} },
#define   GCPADDRESSPORTRANGES  164
	{ (u_char) GCPADDRESSPORTRANGES, ASN_OCTET_STR, RWRITE, var_gcpAddressTable, 5, { 3, 12, 1, 1, 6} },
#define   GCPADDRESSROWSTATUS   165
	{ (u_char) GCPADDRESSROWSTATUS, ASN_INTEGER, RWRITE, var_gcpAddressTable, 5, { 3, 12, 1, 1, 7} },
};

/* (L = length of the oidsuffix) */
struct gcpMIB_data *gcpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *gcpMsTableStorage = NULL;
struct header_complex_index *gcpMgTableStorage = NULL;
struct header_complex_index *gcpMgcTableStorage = NULL;
struct header_complex_index *gcpLinkageTableStorage = NULL;
struct header_complex_index *gcpUdpProfileTableStorage = NULL;
struct header_complex_index *gcpTcpProfileTableStorage = NULL;
struct header_complex_index *gcpSctpProfileTableStorage = NULL;
struct header_complex_index *gcpProtGroupTableStorage = NULL;
struct header_complex_index *gcpSbolTableStorage = NULL;
struct header_complex_index *gcpProtUnitTableStorage = NULL;
struct header_complex_index *gcpRealmTableStorage = NULL;
struct header_complex_index *gcpInterfaceTableStorage = NULL;
struct header_complex_index *gcpAddressTableStorage = NULL;

void (*gcpMIBold_signal_handler)(int) = NULL;	/* save old signal handler just in case */
void gcpMIB_loop_handler(int);
void gcpMIB_fd_handler(int, void *);

/**
 * @fn void init_gcpMIB(void)
 * @brief gcpMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (gcpMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_gcpMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("gcpMIB", "init_gcpMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("gcpMIB", gcpMIB_variables, variable7, gcpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_gcpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("gcpMIB", parse_gcpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpMsTable", parse_gcpMsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpMgTable", parse_gcpMgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpMgcTable", parse_gcpMgcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpLinkageTable", parse_gcpLinkageTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpUdpProfileTable", parse_gcpUdpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpTcpProfileTable", parse_gcpTcpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpSctpProfileTable", parse_gcpSctpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpProtGroupTable", parse_gcpProtGroupTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpSbolTable", parse_gcpSbolTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpProtUnitTable", parse_gcpProtUnitTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpRealmTable", parse_gcpRealmTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpInterfaceTable", parse_gcpInterfaceTable, NULL, "HELP STRING");
	snmpd_register_config_handler("gcpAddressTable", parse_gcpAddressTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpMsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpMgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpMgcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpLinkageTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpUdpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpTcpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpSctpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpProtGroupTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpSbolTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpProtUnitTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpRealmTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpInterfaceTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_gcpAddressTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, gcpMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, gcpMIB_fd_handler, (void *) 1);
	}
	gcpMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &gcpMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/**
 * @fn void deinit_gcpMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (gcpMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_gcpMIB(void)
{
	DEBUGMSGTL(("gcpMIB", "deinit_gcpMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = gcpMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(gcpMIB_variables_oid, sizeof(gcpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("gcpMIB");
	snmpd_unregister_config_handler("gcpMsTable");
	snmpd_unregister_config_handler("gcpMgTable");
	snmpd_unregister_config_handler("gcpMgcTable");
	snmpd_unregister_config_handler("gcpLinkageTable");
	snmpd_unregister_config_handler("gcpUdpProfileTable");
	snmpd_unregister_config_handler("gcpTcpProfileTable");
	snmpd_unregister_config_handler("gcpSctpProfileTable");
	snmpd_unregister_config_handler("gcpProtGroupTable");
	snmpd_unregister_config_handler("gcpSbolTable");
	snmpd_unregister_config_handler("gcpProtUnitTable");
	snmpd_unregister_config_handler("gcpRealmTable");
	snmpd_unregister_config_handler("gcpInterfaceTable");
	snmpd_unregister_config_handler("gcpAddressTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

int
term_gcpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("gcpMIB", "term_gcpMIB: terminating...  "));
	deinit_gcpMIB();
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct gcpMIB_data *gcpMIB_create(void)
 * @brief create a fresh data structure representing scalars in gcpMIB.
 *
 * Creates a new gcpMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in gcpMIB.
 */
struct gcpMIB_data *
gcpMIB_create(void)
{
	struct gcpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(gcpMIB_data);

	DEBUGMSGTL(("gcpMIB", "gcpMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->gcpDefaultMgcoIdent = GCPDEFAULTMGCOIDENT_IPADDRESS;
		StorageNew->gcpDefaultMgcoExecutionTime = 400;
		StorageNew->gcpDefaultMgcoProvRespTimer = 400;
		StorageNew->gcpDefaultMgcpPendingLimit = 5;
		StorageNew->gcpDefaultMgcoLongTimer = 0;
		StorageNew->gcpDefaultMgcoRtoInit = 100;
		StorageNew->gcpDefaultMgcoRtoMin = 0;
		StorageNew->gcpDefaultMgcoRtoMax = 400;
		StorageNew->gcpDefaultUdpChecksum = 0;
		StorageNew->gcpDefaultTcpNoDelay = TV_FALSE;
		StorageNew->gcpDefaultTcpMaxseg = 65536;
		StorageNew->gcpDefaultTcpKeepAlive = TV_FALSE;
		StorageNew->gcpDefaultTcpKeepIdle = 72000;
		StorageNew->gcpDefaultTcpKeepAliveItvl = 1200;
		StorageNew->gcpDefaultTcpKeepCount = 9;
		StorageNew->gcpDefaultTcpSynRetrans = 5;
		StorageNew->gcpDefaultTcpWindowClamp = 65536;
		StorageNew->gcpDefaultSctpNoDelay = TV_TRUE;
		StorageNew->gcpDefaultSctpMaxseg = 65536;
		StorageNew->gcpDefaultSctpHeartbeatItvl = 6000;
		StorageNew->gcpDefaultSctpHearbeat = TV_TRUE;
		StorageNew->gcpDefaultSctpRtoInitial = 300;
		StorageNew->gcpDefaultSctpRtoMin = 100;
		StorageNew->gcpDefaultSctpRtoMax = 6000;
		StorageNew->gcpDefaultSctpPathMaxRetrans = 5;
		StorageNew->gcpDefaultSctpCookieLife = 6000;
		StorageNew->gcpDefaultSctpCookieInc = 100;
		StorageNew->gcpDefaultSctpMaxInitRetries = 8;
		StorageNew->gcpDefaultSctpMaxBurst = 4;
		StorageNew->gcpDefaultSctpAssocMaxRetrans = 10;
		StorageNew->gcpDefaultSctpSackDelay = 20;
		StorageNew->gcpDefaultSctpLifetime = 0;

	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpMIB_data *gcpMIB_duplicate(struct gcpMIB_data *thedata)
 * @param thedata the mib structure to duplicate
 * @brief duplicate a mib structure for the mib
 *
 * Duplicates the specified mib structure @param thedata and returns a pointer to the newly
 * allocated mib structure on success, or NULL on failure.
 */
struct gcpMIB_data *
gcpMIB_duplicate(struct gcpMIB_data *thedata)
{
	struct gcpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(gcpMIB_data);

	DEBUGMSGTL(("gcpMIB", "gcpMIB_duplicate: duplicating mib... "));
	if (StorageNew != NULL) {
		StorageNew->gcpDefaultMgcoIdent = thedata->gcpDefaultMgcoIdent;
		StorageNew->gcpDefaultMgcoExecutionTime = thedata->gcpDefaultMgcoExecutionTime;
		StorageNew->gcpDefaultMgcoProvRespTimer = thedata->gcpDefaultMgcoProvRespTimer;
		StorageNew->gcpDefaultMgcpPendingLimit = thedata->gcpDefaultMgcpPendingLimit;
		StorageNew->gcpDefaultMgcoLongTimer = thedata->gcpDefaultMgcoLongTimer;
		StorageNew->gcpDefaultMgcoRtoInit = thedata->gcpDefaultMgcoRtoInit;
		StorageNew->gcpDefaultMgcoRtoMin = thedata->gcpDefaultMgcoRtoMin;
		StorageNew->gcpDefaultMgcoRtoMax = thedata->gcpDefaultMgcoRtoMax;
		StorageNew->gcpDefaultUdpChecksum = thedata->gcpDefaultUdpChecksum;
		StorageNew->gcpDefaultTcpNoDelay = thedata->gcpDefaultTcpNoDelay;
		StorageNew->gcpDefaultTcpMaxseg = thedata->gcpDefaultTcpMaxseg;
		StorageNew->gcpDefaultTcpKeepAlive = thedata->gcpDefaultTcpKeepAlive;
		StorageNew->gcpDefaultTcpKeepIdle = thedata->gcpDefaultTcpKeepIdle;
		StorageNew->gcpDefaultTcpKeepAliveItvl = thedata->gcpDefaultTcpKeepAliveItvl;
		StorageNew->gcpDefaultTcpKeepCount = thedata->gcpDefaultTcpKeepCount;
		StorageNew->gcpDefaultTcpSynRetrans = thedata->gcpDefaultTcpSynRetrans;
		StorageNew->gcpDefaultTcpWindowClamp = thedata->gcpDefaultTcpWindowClamp;
		StorageNew->gcpDefaultSctpNoDelay = thedata->gcpDefaultSctpNoDelay;
		StorageNew->gcpDefaultSctpMaxseg = thedata->gcpDefaultSctpMaxseg;
		StorageNew->gcpDefaultSctpHeartbeatItvl = thedata->gcpDefaultSctpHeartbeatItvl;
		StorageNew->gcpDefaultSctpHearbeat = thedata->gcpDefaultSctpHearbeat;
		StorageNew->gcpDefaultSctpRtoInitial = thedata->gcpDefaultSctpRtoInitial;
		StorageNew->gcpDefaultSctpRtoMin = thedata->gcpDefaultSctpRtoMin;
		StorageNew->gcpDefaultSctpRtoMax = thedata->gcpDefaultSctpRtoMax;
		StorageNew->gcpDefaultSctpPathMaxRetrans = thedata->gcpDefaultSctpPathMaxRetrans;
		StorageNew->gcpDefaultSctpCookieLife = thedata->gcpDefaultSctpCookieLife;
		StorageNew->gcpDefaultSctpCookieInc = thedata->gcpDefaultSctpCookieInc;
		StorageNew->gcpDefaultSctpMaxInitRetries = thedata->gcpDefaultSctpMaxInitRetries;
		StorageNew->gcpDefaultSctpMaxBurst = thedata->gcpDefaultSctpMaxBurst;
		StorageNew->gcpDefaultSctpAssocMaxRetrans = thedata->gcpDefaultSctpAssocMaxRetrans;
		StorageNew->gcpDefaultSctpSackDelay = thedata->gcpDefaultSctpSackDelay;
		StorageNew->gcpDefaultSctpLifetime = thedata->gcpDefaultSctpLifetime;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpMIB_destroy(struct gcpMIB_data **thedata)
 * @param thedata pointer to the data structure in gcpMIB.
 * @brief delete a scalars structure from gcpMIB.
 *
 * Frees scalars that were previously removed from gcpMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpMIB_destroy(struct gcpMIB_data **thedata)
{
	struct gcpMIB_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpMIB_add(struct gcpMIB_data *thedata)
 * @param thedata the structure representing gcpMIB scalars.
 * @brief adds node to the gcpMIB scalar data set.
 *
 * Adds a scalar structure to the gcpMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
gcpMIB_add(struct gcpMIB_data *thedata)
{
	DEBUGMSGTL(("gcpMIB", "gcpMIB_add: adding data...  "));
	if (thedata)
		gcpMIBStorage = thedata;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpMIB entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_gcpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpMIB_data *StorageTmp = gcpMIB_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultMgcoIdent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultMgcoExecutionTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultMgcoProvRespTimer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultMgcpPendingLimit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultMgcoLongTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultMgcoRtoInit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultMgcoRtoMin, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultMgcoRtoMax, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultUdpChecksum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultTcpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultTcpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultTcpKeepAlive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultTcpKeepIdle, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultTcpKeepAliveItvl, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultTcpKeepCount, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultTcpSynRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultTcpWindowClamp, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpHearbeat, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpDefaultSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpDefaultSctpLifetime, &tmpsize);
	gcpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_gcpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpMIB_data *StorageTmp;

	DEBUGMSGTL(("gcpMIB", "store_gcpMIB: storing data...  "));
	refresh_gcpMIB(1);
	if ((StorageTmp = gcpMIBStorage) == NULL) {
		DEBUGMSGTL(("gcpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "gcpMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultMgcoIdent, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultMgcoExecutionTime, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultMgcoProvRespTimer, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultMgcpPendingLimit, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultMgcoLongTimer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultMgcoRtoInit, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultMgcoRtoMin, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultMgcoRtoMax, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultUdpChecksum, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultTcpNoDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultTcpMaxseg, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultTcpKeepAlive, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultTcpKeepIdle, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultTcpKeepAliveItvl, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultTcpKeepCount, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultTcpSynRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultTcpWindowClamp, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpNoDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultSctpMaxseg, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpHeartbeatItvl, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpHearbeat, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpRtoInitial, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpRtoMin, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpRtoMax, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultSctpPathMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpCookieLife, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpCookieInc, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultSctpMaxInitRetries, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultSctpMaxBurst, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpDefaultSctpAssocMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpSackDelay, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpDefaultSctpLifetime, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_gcpMIB(struct gcpMIB_data *StorageTmp, struct gcpMIB_data *StorageOld)
 * @param StorageTmp the data as updated
 * @param StorageOld the data previous to update
 *
 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
 * made for setting values that were not in the varbinds.
 */
int
check_gcpMIB(struct gcpMIB_data *StorageTmp, struct gcpMIB_data *StorageOld)
{
	/* XXX: provide code to check the scalars for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpMIB(struct gcpMIB_data *StorageTmp, struct gcpMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase)
 *
 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
 * consistency already checked (see check_gcpMIB()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the mib were applied: the values in StorageTmp are the new values.
 */
int
update_gcpMIB(struct gcpMIB_data *StorageTmp, struct gcpMIB_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpMIB_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn revert_gcpMIB(struct 
 * @fn void revert_gcpMIB(struct gcpMIB_data *StorageTmp, struct gcpMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase)
 */
void
revert_gcpMIB(struct gcpMIB_data *StorageTmp, struct gcpMIB_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpMIB(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of gcpMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_gcpMIB(int force)
{
	if (gcpMIBStorage == NULL) {
		struct gcpMIB_data *StorageNew;

		if ((StorageNew = gcpMIB_create()) == NULL)
			return;
		gcpMIBStorage = StorageNew;
		gcpMIB_refresh = 1;
	}
	if (!force && gcpMIB_refresh == 0)
		return;
	DEBUGMSGTL(("gcpMIB", "refresh_gcpMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	gcpMIB_refresh = 0;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/**
 * @fn u_char * var_gcpMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in gcpMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_gcpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_gcpMIB(0);
	if ((StorageTmp = gcpMIBStorage) == NULL) {
		DEBUGMSGTL(("gcpMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPDEFAULTMGCOIDENT:	/* ReadWrite */
		*write_method = write_gcpDefaultMgcoIdent;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultMgcoIdent);
		rval = (u_char *) &StorageTmp->gcpDefaultMgcoIdent;
		break;
	case (u_char) GCPDEFAULTMGCOEXECUTIONTIME:	/* ReadWrite */
		*write_method = write_gcpDefaultMgcoExecutionTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultMgcoExecutionTime);
		rval = (u_char *) &StorageTmp->gcpDefaultMgcoExecutionTime;
		break;
	case (u_char) GCPDEFAULTMGCOPROVRESPTIMER:	/* ReadWrite */
		*write_method = write_gcpDefaultMgcoProvRespTimer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultMgcoProvRespTimer);
		rval = (u_char *) &StorageTmp->gcpDefaultMgcoProvRespTimer;
		break;
	case (u_char) GCPDEFAULTMGCPPENDINGLIMIT:	/* ReadWrite */
		*write_method = write_gcpDefaultMgcpPendingLimit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultMgcpPendingLimit);
		rval = (u_char *) &StorageTmp->gcpDefaultMgcpPendingLimit;
		break;
	case (u_char) GCPDEFAULTMGCOLONGTIMER:	/* ReadWrite */
		*write_method = write_gcpDefaultMgcoLongTimer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultMgcoLongTimer);
		rval = (u_char *) &StorageTmp->gcpDefaultMgcoLongTimer;
		break;
	case (u_char) GCPDEFAULTMGCORTOINIT:	/* ReadWrite */
		*write_method = write_gcpDefaultMgcoRtoInit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultMgcoRtoInit);
		rval = (u_char *) &StorageTmp->gcpDefaultMgcoRtoInit;
		break;
	case (u_char) GCPDEFAULTMGCORTOMIN:	/* ReadWrite */
		*write_method = write_gcpDefaultMgcoRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultMgcoRtoMin);
		rval = (u_char *) &StorageTmp->gcpDefaultMgcoRtoMin;
		break;
	case (u_char) GCPDEFAULTMGCORTOMAX:	/* ReadWrite */
		*write_method = write_gcpDefaultMgcoRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultMgcoRtoMax);
		rval = (u_char *) &StorageTmp->gcpDefaultMgcoRtoMax;
		break;
	case (u_char) GCPDEFAULTUDPCHECKSUM:	/* ReadWrite */
		*write_method = write_gcpDefaultUdpChecksum;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultUdpChecksum);
		rval = (u_char *) &StorageTmp->gcpDefaultUdpChecksum;
		break;
	case (u_char) GCPDEFAULTTCPNODELAY:	/* ReadWrite */
		*write_method = write_gcpDefaultTcpNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultTcpNoDelay);
		rval = (u_char *) &StorageTmp->gcpDefaultTcpNoDelay;
		break;
	case (u_char) GCPDEFAULTTCPMAXSEG:	/* ReadWrite */
		*write_method = write_gcpDefaultTcpMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultTcpMaxseg);
		rval = (u_char *) &StorageTmp->gcpDefaultTcpMaxseg;
		break;
	case (u_char) GCPDEFAULTTCPKEEPALIVE:	/* ReadWrite */
		*write_method = write_gcpDefaultTcpKeepAlive;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultTcpKeepAlive);
		rval = (u_char *) &StorageTmp->gcpDefaultTcpKeepAlive;
		break;
	case (u_char) GCPDEFAULTTCPKEEPIDLE:	/* ReadWrite */
		*write_method = write_gcpDefaultTcpKeepIdle;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultTcpKeepIdle);
		rval = (u_char *) &StorageTmp->gcpDefaultTcpKeepIdle;
		break;
	case (u_char) GCPDEFAULTTCPKEEPALIVEITVL:	/* ReadWrite */
		*write_method = write_gcpDefaultTcpKeepAliveItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultTcpKeepAliveItvl);
		rval = (u_char *) &StorageTmp->gcpDefaultTcpKeepAliveItvl;
		break;
	case (u_char) GCPDEFAULTTCPKEEPCOUNT:	/* ReadWrite */
		*write_method = write_gcpDefaultTcpKeepCount;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultTcpKeepCount);
		rval = (u_char *) &StorageTmp->gcpDefaultTcpKeepCount;
		break;
	case (u_char) GCPDEFAULTTCPSYNRETRANS:	/* ReadWrite */
		*write_method = write_gcpDefaultTcpSynRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultTcpSynRetrans);
		rval = (u_char *) &StorageTmp->gcpDefaultTcpSynRetrans;
		break;
	case (u_char) GCPDEFAULTTCPWINDOWCLAMP:	/* ReadWrite */
		*write_method = write_gcpDefaultTcpWindowClamp;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultTcpWindowClamp);
		rval = (u_char *) &StorageTmp->gcpDefaultTcpWindowClamp;
		break;
	case (u_char) GCPDEFAULTSCTPNODELAY:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpNoDelay);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpNoDelay;
		break;
	case (u_char) GCPDEFAULTSCTPMAXSEG:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpMaxseg);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpMaxseg;
		break;
	case (u_char) GCPDEFAULTSCTPHEARTBEATITVL:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpHeartbeatItvl);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpHeartbeatItvl;
		break;
	case (u_char) GCPDEFAULTSCTPHEARBEAT:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpHearbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpHearbeat);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpHearbeat;
		break;
	case (u_char) GCPDEFAULTSCTPRTOINITIAL:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpRtoInitial);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpRtoInitial;
		break;
	case (u_char) GCPDEFAULTSCTPRTOMIN:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpRtoMin);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpRtoMin;
		break;
	case (u_char) GCPDEFAULTSCTPRTOMAX:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpRtoMax);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpRtoMax;
		break;
	case (u_char) GCPDEFAULTSCTPPATHMAXRETRANS:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpPathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpPathMaxRetrans);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpPathMaxRetrans;
		break;
	case (u_char) GCPDEFAULTSCTPCOOKIELIFE:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpCookieLife);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpCookieLife;
		break;
	case (u_char) GCPDEFAULTSCTPCOOKIEINC:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpCookieInc);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpCookieInc;
		break;
	case (u_char) GCPDEFAULTSCTPMAXINITRETRIES:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpMaxInitRetries);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpMaxInitRetries;
		break;
	case (u_char) GCPDEFAULTSCTPMAXBURST:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpMaxBurst);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpMaxBurst;
		break;
	case (u_char) GCPDEFAULTSCTPASSOCMAXRETRANS:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpAssocMaxRetrans;
		break;
	case (u_char) GCPDEFAULTSCTPSACKDELAY:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpSackDelay);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpSackDelay;
		break;
	case (u_char) GCPDEFAULTSCTPLIFETIME:	/* ReadWrite */
		*write_method = write_gcpDefaultSctpLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpDefaultSctpLifetime);
		rval = (u_char *) &StorageTmp->gcpDefaultSctpLifetime;
		break;
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("gcpMIB", "found.\n"));
	else
		DEBUGMSGTL(("gcpMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct gcpMsTable_data *gcpMsTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpMsTable table.
 *
 * Creates a new gcpMsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpMsTable_data *
gcpMsTable_create(void)
{
	struct gcpMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpMsTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpMsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->gcpMsName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMsNameLen = 0;
		StorageNew->gcpMsName[StorageNew->gcpMsNameLen] = 0;
		if (memdup((u_char **) &StorageNew->gcpMsAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpMsAlarmStatusLen = 1;
		StorageNew->gcpMsOperationalState = 0;
		StorageNew->gcpMsUsageState = 0;
		if ((StorageNew->gcpMsManagedElementType = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMsManagedElementTypeLen = 0;
		StorageNew->gcpMsManagedElementType[StorageNew->gcpMsManagedElementTypeLen] = 0;
		if ((StorageNew->gcpMsModelCode = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMsModelCodeLen = 0;
		StorageNew->gcpMsModelCode[StorageNew->gcpMsModelCodeLen] = 0;
		if ((StorageNew->gcpMsVendorName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMsVendorNameLen = 0;
		StorageNew->gcpMsVendorName[StorageNew->gcpMsVendorNameLen] = 0;
		if ((StorageNew->gcpMsUserLabel = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMsUserLabelLen = 0;
		StorageNew->gcpMsUserLabel[StorageNew->gcpMsUserLabelLen] = 0;
		if ((StorageNew->gcpMsVersion = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMsVersionLen = 0;
		StorageNew->gcpMsVersion[StorageNew->gcpMsVersionLen] = 0;
		if ((StorageNew->gcpMsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->gcpMsAsaProfilePointerLen = 2;
		if ((StorageNew->gcpMsNetworkElementAliases = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMsNetworkElementAliasesLen = 0;
		StorageNew->gcpMsNetworkElementAliases[StorageNew->gcpMsNetworkElementAliasesLen] = 0;
		StorageNew->gcpMsRowStatus = 0;
		StorageNew->gcpMsRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpMsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpMsTable_data *gcpMsTable_duplicate(struct gcpMsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpMsTable_data *
gcpMsTable_duplicate(struct gcpMsTable_data *thedata)
{
	struct gcpMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpMsTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpMsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpMsTable_id = thedata->gcpMsTable_id;
		StorageNew->gcpMsId = thedata->gcpMsId;
		if (!(StorageNew->gcpMsName = malloc(thedata->gcpMsNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMsName, thedata->gcpMsName, thedata->gcpMsNameLen);
		StorageNew->gcpMsNameLen = thedata->gcpMsNameLen;
		StorageNew->gcpMsName[StorageNew->gcpMsNameLen] = 0;
		if (!(StorageNew->gcpMsAlarmStatus = malloc(thedata->gcpMsAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMsAlarmStatus, thedata->gcpMsAlarmStatus, thedata->gcpMsAlarmStatusLen);
		StorageNew->gcpMsAlarmStatusLen = thedata->gcpMsAlarmStatusLen;
		StorageNew->gcpMsAlarmStatus[StorageNew->gcpMsAlarmStatusLen] = 0;
		StorageNew->gcpMsOperationalState = thedata->gcpMsOperationalState;
		StorageNew->gcpMsUsageState = thedata->gcpMsUsageState;
		if (!(StorageNew->gcpMsManagedElementType = malloc(thedata->gcpMsManagedElementTypeLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMsManagedElementType, thedata->gcpMsManagedElementType, thedata->gcpMsManagedElementTypeLen);
		StorageNew->gcpMsManagedElementTypeLen = thedata->gcpMsManagedElementTypeLen;
		StorageNew->gcpMsManagedElementType[StorageNew->gcpMsManagedElementTypeLen] = 0;
		if (!(StorageNew->gcpMsModelCode = malloc(thedata->gcpMsModelCodeLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMsModelCode, thedata->gcpMsModelCode, thedata->gcpMsModelCodeLen);
		StorageNew->gcpMsModelCodeLen = thedata->gcpMsModelCodeLen;
		StorageNew->gcpMsModelCode[StorageNew->gcpMsModelCodeLen] = 0;
		if (!(StorageNew->gcpMsVendorName = malloc(thedata->gcpMsVendorNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMsVendorName, thedata->gcpMsVendorName, thedata->gcpMsVendorNameLen);
		StorageNew->gcpMsVendorNameLen = thedata->gcpMsVendorNameLen;
		StorageNew->gcpMsVendorName[StorageNew->gcpMsVendorNameLen] = 0;
		if (!(StorageNew->gcpMsUserLabel = malloc(thedata->gcpMsUserLabelLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMsUserLabel, thedata->gcpMsUserLabel, thedata->gcpMsUserLabelLen);
		StorageNew->gcpMsUserLabelLen = thedata->gcpMsUserLabelLen;
		StorageNew->gcpMsUserLabel[StorageNew->gcpMsUserLabelLen] = 0;
		if (!(StorageNew->gcpMsVersion = malloc(thedata->gcpMsVersionLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMsVersion, thedata->gcpMsVersion, thedata->gcpMsVersionLen);
		StorageNew->gcpMsVersionLen = thedata->gcpMsVersionLen;
		StorageNew->gcpMsVersion[StorageNew->gcpMsVersionLen] = 0;
		if (!(StorageNew->gcpMsAsaProfilePointer = snmp_duplicate_objid(thedata->gcpMsAsaProfilePointer, thedata->gcpMsAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->gcpMsAsaProfilePointerLen = thedata->gcpMsAsaProfilePointerLen;
		if (!(StorageNew->gcpMsNetworkElementAliases = malloc(thedata->gcpMsNetworkElementAliasesLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMsNetworkElementAliases, thedata->gcpMsNetworkElementAliases, thedata->gcpMsNetworkElementAliasesLen);
		StorageNew->gcpMsNetworkElementAliasesLen = thedata->gcpMsNetworkElementAliasesLen;
		StorageNew->gcpMsNetworkElementAliases[StorageNew->gcpMsNetworkElementAliasesLen] = 0;
		StorageNew->gcpMsRowStatus = thedata->gcpMsRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpMsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpMsTable_destroy(struct gcpMsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpMsTable_destroy(struct gcpMsTable_data **thedata)
{
	struct gcpMsTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpMsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpMsName);
		StorageDel->gcpMsNameLen = 0;
		SNMP_FREE(StorageDel->gcpMsAlarmStatus);
		StorageDel->gcpMsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->gcpMsManagedElementType);
		StorageDel->gcpMsManagedElementTypeLen = 0;
		SNMP_FREE(StorageDel->gcpMsModelCode);
		StorageDel->gcpMsModelCodeLen = 0;
		SNMP_FREE(StorageDel->gcpMsVendorName);
		StorageDel->gcpMsVendorNameLen = 0;
		SNMP_FREE(StorageDel->gcpMsUserLabel);
		StorageDel->gcpMsUserLabelLen = 0;
		SNMP_FREE(StorageDel->gcpMsVersion);
		StorageDel->gcpMsVersionLen = 0;
		SNMP_FREE(StorageDel->gcpMsAsaProfilePointer);
		StorageDel->gcpMsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->gcpMsNetworkElementAliases);
		StorageDel->gcpMsNetworkElementAliasesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpMsTable_add(struct gcpMsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpMsTable table data set.
 *
 * Adds a table row structure to the gcpMsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpMsTable_add(struct gcpMsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpMsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMsId, sizeof(thedata->gcpMsId));
		header_complex_add_data(&gcpMsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpMsTable_del(struct gcpMsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpMsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpMsTable_del(struct gcpMsTable_data *thedata)
{
	struct gcpMsTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpMsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpMsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpMsTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpMsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpMsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpMsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpMsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpMsTable_data *StorageTmp = gcpMsTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpMsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMsId, &tmpsize);
	SNMP_FREE(StorageTmp->gcpMsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMsName, &StorageTmp->gcpMsNameLen);
	if (StorageTmp->gcpMsName == NULL) {
		config_perror("invalid specification for gcpMsName");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMsAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMsAlarmStatus, &StorageTmp->gcpMsAlarmStatusLen);
	if (StorageTmp->gcpMsAlarmStatus == NULL) {
		config_perror("invalid specification for gcpMsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMsUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->gcpMsManagedElementType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMsManagedElementType, &StorageTmp->gcpMsManagedElementTypeLen);
	if (StorageTmp->gcpMsManagedElementType == NULL) {
		config_perror("invalid specification for gcpMsManagedElementType");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMsModelCode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMsModelCode, &StorageTmp->gcpMsModelCodeLen);
	if (StorageTmp->gcpMsModelCode == NULL) {
		config_perror("invalid specification for gcpMsModelCode");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMsVendorName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMsVendorName, &StorageTmp->gcpMsVendorNameLen);
	if (StorageTmp->gcpMsVendorName == NULL) {
		config_perror("invalid specification for gcpMsVendorName");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMsUserLabel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMsUserLabel, &StorageTmp->gcpMsUserLabelLen);
	if (StorageTmp->gcpMsUserLabel == NULL) {
		config_perror("invalid specification for gcpMsUserLabel");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMsVersion);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMsVersion, &StorageTmp->gcpMsVersionLen);
	if (StorageTmp->gcpMsVersion == NULL) {
		config_perror("invalid specification for gcpMsVersion");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMsAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->gcpMsAsaProfilePointer, &StorageTmp->gcpMsAsaProfilePointerLen);
	if (StorageTmp->gcpMsAsaProfilePointer == NULL) {
		config_perror("invalid specification for gcpMsAsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMsNetworkElementAliases);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMsNetworkElementAliases, &StorageTmp->gcpMsNetworkElementAliasesLen);
	if (StorageTmp->gcpMsNetworkElementAliases == NULL) {
		config_perror("invalid specification for gcpMsNetworkElementAliases");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMsRowStatus, &tmpsize);
	gcpMsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpMsTable(): store configuraiton file for gcpMsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpMsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpMsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpMsTable: storing data...  "));
	refresh_gcpMsTable(1);
	(void) tmpsize;
	for (hcindex = gcpMsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpMsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpMsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMsName, &StorageTmp->gcpMsNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMsAlarmStatus, &StorageTmp->gcpMsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMsManagedElementType, &StorageTmp->gcpMsManagedElementTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMsModelCode, &StorageTmp->gcpMsModelCodeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMsVendorName, &StorageTmp->gcpMsVendorNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMsUserLabel, &StorageTmp->gcpMsUserLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMsVersion, &StorageTmp->gcpMsVersionLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->gcpMsAsaProfilePointer, &StorageTmp->gcpMsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMsNetworkElementAliases, &StorageTmp->gcpMsNetworkElementAliasesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpMgTable_data *gcpMgTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpMgTable table.
 *
 * Creates a new gcpMgTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpMgTable_data *
gcpMgTable_create(void)
{
	struct gcpMgTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpMgTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpMgTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpMsId = 0;
		StorageNew->gcpMgLocation = 0;
		if ((StorageNew->gcpMgName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMgNameLen = 0;
		StorageNew->gcpMgName[StorageNew->gcpMgNameLen] = 0;
		if ((StorageNew->gcpMgDomainName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMgDomainNameLen = 0;
		StorageNew->gcpMgDomainName[StorageNew->gcpMgDomainNameLen] = 0;
		if ((StorageNew->gcpMgDeviceName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMgDeviceNameLen = 0;
		StorageNew->gcpMgDeviceName[StorageNew->gcpMgDeviceNameLen] = 0;
		if ((StorageNew->gcpMgMtpAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMgMtpAddressLen = 0;
		StorageNew->gcpMgMtpAddress[StorageNew->gcpMgMtpAddressLen] = 0;
		StorageNew->gcpMgAdminState = 0;
		StorageNew->gcpMgOperState = 0;
		if (memdup((u_char **) &StorageNew->gcpMgAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpMgAlarmStatusLen = 1;
		if ((StorageNew->gcpMgAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->gcpMgAsaProfilePointerLen = 2;
		StorageNew->gcpMgUsageState = 0;
		if (memdup((u_char **) &StorageNew->gcpMgAvailStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpMgAvailStatusLen = 2;
		if (memdup((u_char **) &StorageNew->gcpMgProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpMgProcStatusLen = 1;
		StorageNew->gcpMgPg = 0;
		StorageNew->gcpMgStandbyStatus = 0;
		StorageNew->gcpMgRowStatus = 0;
		StorageNew->gcpMgRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpMgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpMgTable_data *gcpMgTable_duplicate(struct gcpMgTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpMgTable_data *
gcpMgTable_duplicate(struct gcpMgTable_data *thedata)
{
	struct gcpMgTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpMgTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpMgTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpMgTable_id = thedata->gcpMgTable_id;
		StorageNew->gcpMsId = thedata->gcpMsId;
		StorageNew->gcpMgId = thedata->gcpMgId;
		StorageNew->gcpMgLocation = thedata->gcpMgLocation;
		if (!(StorageNew->gcpMgName = malloc(thedata->gcpMgNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgName, thedata->gcpMgName, thedata->gcpMgNameLen);
		StorageNew->gcpMgNameLen = thedata->gcpMgNameLen;
		StorageNew->gcpMgName[StorageNew->gcpMgNameLen] = 0;
		if (!(StorageNew->gcpMgDomainName = malloc(thedata->gcpMgDomainNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgDomainName, thedata->gcpMgDomainName, thedata->gcpMgDomainNameLen);
		StorageNew->gcpMgDomainNameLen = thedata->gcpMgDomainNameLen;
		StorageNew->gcpMgDomainName[StorageNew->gcpMgDomainNameLen] = 0;
		if (!(StorageNew->gcpMgDeviceName = malloc(thedata->gcpMgDeviceNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgDeviceName, thedata->gcpMgDeviceName, thedata->gcpMgDeviceNameLen);
		StorageNew->gcpMgDeviceNameLen = thedata->gcpMgDeviceNameLen;
		StorageNew->gcpMgDeviceName[StorageNew->gcpMgDeviceNameLen] = 0;
		if (!(StorageNew->gcpMgMtpAddress = malloc(thedata->gcpMgMtpAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgMtpAddress, thedata->gcpMgMtpAddress, thedata->gcpMgMtpAddressLen);
		StorageNew->gcpMgMtpAddressLen = thedata->gcpMgMtpAddressLen;
		StorageNew->gcpMgMtpAddress[StorageNew->gcpMgMtpAddressLen] = 0;
		StorageNew->gcpMgAdminState = thedata->gcpMgAdminState;
		StorageNew->gcpMgOperState = thedata->gcpMgOperState;
		if (!(StorageNew->gcpMgAlarmStatus = malloc(thedata->gcpMgAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgAlarmStatus, thedata->gcpMgAlarmStatus, thedata->gcpMgAlarmStatusLen);
		StorageNew->gcpMgAlarmStatusLen = thedata->gcpMgAlarmStatusLen;
		StorageNew->gcpMgAlarmStatus[StorageNew->gcpMgAlarmStatusLen] = 0;
		if (!(StorageNew->gcpMgAsaProfilePointer = snmp_duplicate_objid(thedata->gcpMgAsaProfilePointer, thedata->gcpMgAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->gcpMgAsaProfilePointerLen = thedata->gcpMgAsaProfilePointerLen;
		StorageNew->gcpMgUsageState = thedata->gcpMgUsageState;
		if (!(StorageNew->gcpMgAvailStatus = malloc(thedata->gcpMgAvailStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgAvailStatus, thedata->gcpMgAvailStatus, thedata->gcpMgAvailStatusLen);
		StorageNew->gcpMgAvailStatusLen = thedata->gcpMgAvailStatusLen;
		StorageNew->gcpMgAvailStatus[StorageNew->gcpMgAvailStatusLen] = 0;
		if (!(StorageNew->gcpMgProcStatus = malloc(thedata->gcpMgProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgProcStatus, thedata->gcpMgProcStatus, thedata->gcpMgProcStatusLen);
		StorageNew->gcpMgProcStatusLen = thedata->gcpMgProcStatusLen;
		StorageNew->gcpMgProcStatus[StorageNew->gcpMgProcStatusLen] = 0;
		StorageNew->gcpMgPg = thedata->gcpMgPg;
		StorageNew->gcpMgStandbyStatus = thedata->gcpMgStandbyStatus;
		StorageNew->gcpMgRowStatus = thedata->gcpMgRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpMgTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpMgTable_destroy(struct gcpMgTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpMgTable_destroy(struct gcpMgTable_data **thedata)
{
	struct gcpMgTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpMgTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpMgName);
		StorageDel->gcpMgNameLen = 0;
		SNMP_FREE(StorageDel->gcpMgDomainName);
		StorageDel->gcpMgDomainNameLen = 0;
		SNMP_FREE(StorageDel->gcpMgDeviceName);
		StorageDel->gcpMgDeviceNameLen = 0;
		SNMP_FREE(StorageDel->gcpMgMtpAddress);
		StorageDel->gcpMgMtpAddressLen = 0;
		SNMP_FREE(StorageDel->gcpMgAlarmStatus);
		StorageDel->gcpMgAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->gcpMgAsaProfilePointer);
		StorageDel->gcpMgAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->gcpMgAvailStatus);
		StorageDel->gcpMgAvailStatusLen = 0;
		SNMP_FREE(StorageDel->gcpMgProcStatus);
		StorageDel->gcpMgProcStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpMgTable_add(struct gcpMgTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpMgTable table data set.
 *
 * Adds a table row structure to the gcpMgTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpMgTable_add(struct gcpMgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpMgTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMsId, sizeof(thedata->gcpMsId));
		/* gcpMgId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMgId, sizeof(thedata->gcpMgId));
		header_complex_add_data(&gcpMgTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpMgTable_del(struct gcpMgTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpMgTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpMgTable_del(struct gcpMgTable_data *thedata)
{
	struct gcpMgTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpMgTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpMgTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpMgTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpMgTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpMgTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpMgTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpMgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpMgTable_data *StorageTmp = gcpMgTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpMgTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMgId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgLocation, &tmpsize);
	SNMP_FREE(StorageTmp->gcpMgName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgName, &StorageTmp->gcpMgNameLen);
	if (StorageTmp->gcpMgName == NULL) {
		config_perror("invalid specification for gcpMgName");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgDomainName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgDomainName, &StorageTmp->gcpMgDomainNameLen);
	if (StorageTmp->gcpMgDomainName == NULL) {
		config_perror("invalid specification for gcpMgDomainName");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgDeviceName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgDeviceName, &StorageTmp->gcpMgDeviceNameLen);
	if (StorageTmp->gcpMgDeviceName == NULL) {
		config_perror("invalid specification for gcpMgDeviceName");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgMtpAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgMtpAddress, &StorageTmp->gcpMgMtpAddressLen);
	if (StorageTmp->gcpMgMtpAddress == NULL) {
		config_perror("invalid specification for gcpMgMtpAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgOperState, &tmpsize);
	SNMP_FREE(StorageTmp->gcpMgAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgAlarmStatus, &StorageTmp->gcpMgAlarmStatusLen);
	if (StorageTmp->gcpMgAlarmStatus == NULL) {
		config_perror("invalid specification for gcpMgAlarmStatus");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->gcpMgAsaProfilePointer, &StorageTmp->gcpMgAsaProfilePointerLen);
	if (StorageTmp->gcpMgAsaProfilePointer == NULL) {
		config_perror("invalid specification for gcpMgAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->gcpMgAvailStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgAvailStatus, &StorageTmp->gcpMgAvailStatusLen);
	if (StorageTmp->gcpMgAvailStatus == NULL) {
		config_perror("invalid specification for gcpMgAvailStatus");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgProcStatus, &StorageTmp->gcpMgProcStatusLen);
	if (StorageTmp->gcpMgProcStatus == NULL) {
		config_perror("invalid specification for gcpMgProcStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMgPg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgStandbyStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgRowStatus, &tmpsize);
	gcpMgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpMgTable(): store configuraiton file for gcpMgTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpMgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpMgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpMgTable: storing data...  "));
	refresh_gcpMgTable(1);
	(void) tmpsize;
	for (hcindex = gcpMgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpMgTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpMgTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMgId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgLocation, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgName, &StorageTmp->gcpMgNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgDomainName, &StorageTmp->gcpMgDomainNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgDeviceName, &StorageTmp->gcpMgDeviceNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgMtpAddress, &StorageTmp->gcpMgMtpAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgOperState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgAlarmStatus, &StorageTmp->gcpMgAlarmStatusLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->gcpMgAsaProfilePointer, &StorageTmp->gcpMgAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgAvailStatus, &StorageTmp->gcpMgAvailStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgProcStatus, &StorageTmp->gcpMgProcStatusLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMgPg, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgStandbyStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpMgcTable_data *gcpMgcTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpMgcTable table.
 *
 * Creates a new gcpMgcTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpMgcTable_data *
gcpMgcTable_create(void)
{
	struct gcpMgcTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpMgcTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpMgcTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpMsId = 0;
		StorageNew->gcpMgcLocation = 0;
		if ((StorageNew->gcpMgcName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMgcNameLen = 0;
		StorageNew->gcpMgcName[StorageNew->gcpMgcNameLen] = 0;
		if ((StorageNew->gcpMgcDomainName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMgcDomainNameLen = 0;
		StorageNew->gcpMgcDomainName[StorageNew->gcpMgcDomainNameLen] = 0;
		if ((StorageNew->gcpMgcDeviceName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMgcDeviceNameLen = 0;
		StorageNew->gcpMgcDeviceName[StorageNew->gcpMgcDeviceNameLen] = 0;
		if ((StorageNew->gcpMgcMtpAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpMgcMtpAddressLen = 0;
		StorageNew->gcpMgcMtpAddress[StorageNew->gcpMgcMtpAddressLen] = 0;
		StorageNew->gcpMgcAdminState = 0;
		StorageNew->gcpMgcOperState = 0;
		if (memdup((u_char **) &StorageNew->gcpMgcAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpMgcAlarmStatusLen = 1;
		if ((StorageNew->gcpMgcAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->gcpMgcAsaProfilePointerLen = 2;
		StorageNew->gcpMgcUsageState = 0;
		if (memdup((u_char **) &StorageNew->gcpMgcAvailStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpMgcAvailStatusLen = 2;
		if (memdup((u_char **) &StorageNew->gcpMgcProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpMgcProcStatusLen = 1;
		StorageNew->gcpMgcPg = 0;
		StorageNew->gcpMgcStandbyStatus = 0;
		StorageNew->gcpMgcRowStatus = 0;
		StorageNew->gcpMgcRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpMgcTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpMgcTable_data *gcpMgcTable_duplicate(struct gcpMgcTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpMgcTable_data *
gcpMgcTable_duplicate(struct gcpMgcTable_data *thedata)
{
	struct gcpMgcTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpMgcTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpMgcTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpMgcTable_id = thedata->gcpMgcTable_id;
		StorageNew->gcpMsId = thedata->gcpMsId;
		StorageNew->gcpMgcId = thedata->gcpMgcId;
		StorageNew->gcpMgcLocation = thedata->gcpMgcLocation;
		if (!(StorageNew->gcpMgcName = malloc(thedata->gcpMgcNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgcName, thedata->gcpMgcName, thedata->gcpMgcNameLen);
		StorageNew->gcpMgcNameLen = thedata->gcpMgcNameLen;
		StorageNew->gcpMgcName[StorageNew->gcpMgcNameLen] = 0;
		if (!(StorageNew->gcpMgcDomainName = malloc(thedata->gcpMgcDomainNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgcDomainName, thedata->gcpMgcDomainName, thedata->gcpMgcDomainNameLen);
		StorageNew->gcpMgcDomainNameLen = thedata->gcpMgcDomainNameLen;
		StorageNew->gcpMgcDomainName[StorageNew->gcpMgcDomainNameLen] = 0;
		if (!(StorageNew->gcpMgcDeviceName = malloc(thedata->gcpMgcDeviceNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgcDeviceName, thedata->gcpMgcDeviceName, thedata->gcpMgcDeviceNameLen);
		StorageNew->gcpMgcDeviceNameLen = thedata->gcpMgcDeviceNameLen;
		StorageNew->gcpMgcDeviceName[StorageNew->gcpMgcDeviceNameLen] = 0;
		if (!(StorageNew->gcpMgcMtpAddress = malloc(thedata->gcpMgcMtpAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgcMtpAddress, thedata->gcpMgcMtpAddress, thedata->gcpMgcMtpAddressLen);
		StorageNew->gcpMgcMtpAddressLen = thedata->gcpMgcMtpAddressLen;
		StorageNew->gcpMgcMtpAddress[StorageNew->gcpMgcMtpAddressLen] = 0;
		StorageNew->gcpMgcAdminState = thedata->gcpMgcAdminState;
		StorageNew->gcpMgcOperState = thedata->gcpMgcOperState;
		if (!(StorageNew->gcpMgcAlarmStatus = malloc(thedata->gcpMgcAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgcAlarmStatus, thedata->gcpMgcAlarmStatus, thedata->gcpMgcAlarmStatusLen);
		StorageNew->gcpMgcAlarmStatusLen = thedata->gcpMgcAlarmStatusLen;
		StorageNew->gcpMgcAlarmStatus[StorageNew->gcpMgcAlarmStatusLen] = 0;
		if (!(StorageNew->gcpMgcAsaProfilePointer = snmp_duplicate_objid(thedata->gcpMgcAsaProfilePointer, thedata->gcpMgcAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->gcpMgcAsaProfilePointerLen = thedata->gcpMgcAsaProfilePointerLen;
		StorageNew->gcpMgcUsageState = thedata->gcpMgcUsageState;
		if (!(StorageNew->gcpMgcAvailStatus = malloc(thedata->gcpMgcAvailStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgcAvailStatus, thedata->gcpMgcAvailStatus, thedata->gcpMgcAvailStatusLen);
		StorageNew->gcpMgcAvailStatusLen = thedata->gcpMgcAvailStatusLen;
		StorageNew->gcpMgcAvailStatus[StorageNew->gcpMgcAvailStatusLen] = 0;
		if (!(StorageNew->gcpMgcProcStatus = malloc(thedata->gcpMgcProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpMgcProcStatus, thedata->gcpMgcProcStatus, thedata->gcpMgcProcStatusLen);
		StorageNew->gcpMgcProcStatusLen = thedata->gcpMgcProcStatusLen;
		StorageNew->gcpMgcProcStatus[StorageNew->gcpMgcProcStatusLen] = 0;
		StorageNew->gcpMgcPg = thedata->gcpMgcPg;
		StorageNew->gcpMgcStandbyStatus = thedata->gcpMgcStandbyStatus;
		StorageNew->gcpMgcRowStatus = thedata->gcpMgcRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpMgcTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpMgcTable_destroy(struct gcpMgcTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpMgcTable_destroy(struct gcpMgcTable_data **thedata)
{
	struct gcpMgcTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpMgcTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpMgcName);
		StorageDel->gcpMgcNameLen = 0;
		SNMP_FREE(StorageDel->gcpMgcDomainName);
		StorageDel->gcpMgcDomainNameLen = 0;
		SNMP_FREE(StorageDel->gcpMgcDeviceName);
		StorageDel->gcpMgcDeviceNameLen = 0;
		SNMP_FREE(StorageDel->gcpMgcMtpAddress);
		StorageDel->gcpMgcMtpAddressLen = 0;
		SNMP_FREE(StorageDel->gcpMgcAlarmStatus);
		StorageDel->gcpMgcAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->gcpMgcAsaProfilePointer);
		StorageDel->gcpMgcAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->gcpMgcAvailStatus);
		StorageDel->gcpMgcAvailStatusLen = 0;
		SNMP_FREE(StorageDel->gcpMgcProcStatus);
		StorageDel->gcpMgcProcStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpMgcTable_add(struct gcpMgcTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpMgcTable table data set.
 *
 * Adds a table row structure to the gcpMgcTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpMgcTable_add(struct gcpMgcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpMgcTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMsId, sizeof(thedata->gcpMsId));
		/* gcpMgcId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMgcId, sizeof(thedata->gcpMgcId));
		header_complex_add_data(&gcpMgcTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpMgcTable_del(struct gcpMgcTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpMgcTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpMgcTable_del(struct gcpMgcTable_data *thedata)
{
	struct gcpMgcTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpMgcTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpMgcTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpMgcTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpMgcTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpMgcTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpMgcTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpMgcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpMgcTable_data *StorageTmp = gcpMgcTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpMgcTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMgcId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgcLocation, &tmpsize);
	SNMP_FREE(StorageTmp->gcpMgcName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgcName, &StorageTmp->gcpMgcNameLen);
	if (StorageTmp->gcpMgcName == NULL) {
		config_perror("invalid specification for gcpMgcName");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgcDomainName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgcDomainName, &StorageTmp->gcpMgcDomainNameLen);
	if (StorageTmp->gcpMgcDomainName == NULL) {
		config_perror("invalid specification for gcpMgcDomainName");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgcDeviceName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgcDeviceName, &StorageTmp->gcpMgcDeviceNameLen);
	if (StorageTmp->gcpMgcDeviceName == NULL) {
		config_perror("invalid specification for gcpMgcDeviceName");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgcMtpAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgcMtpAddress, &StorageTmp->gcpMgcMtpAddressLen);
	if (StorageTmp->gcpMgcMtpAddress == NULL) {
		config_perror("invalid specification for gcpMgcMtpAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgcAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgcOperState, &tmpsize);
	SNMP_FREE(StorageTmp->gcpMgcAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgcAlarmStatus, &StorageTmp->gcpMgcAlarmStatusLen);
	if (StorageTmp->gcpMgcAlarmStatus == NULL) {
		config_perror("invalid specification for gcpMgcAlarmStatus");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgcAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->gcpMgcAsaProfilePointer, &StorageTmp->gcpMgcAsaProfilePointerLen);
	if (StorageTmp->gcpMgcAsaProfilePointer == NULL) {
		config_perror("invalid specification for gcpMgcAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgcUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->gcpMgcAvailStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgcAvailStatus, &StorageTmp->gcpMgcAvailStatusLen);
	if (StorageTmp->gcpMgcAvailStatus == NULL) {
		config_perror("invalid specification for gcpMgcAvailStatus");
		return;
	}
	SNMP_FREE(StorageTmp->gcpMgcProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpMgcProcStatus, &StorageTmp->gcpMgcProcStatusLen);
	if (StorageTmp->gcpMgcProcStatus == NULL) {
		config_perror("invalid specification for gcpMgcProcStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMgcPg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgcStandbyStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpMgcRowStatus, &tmpsize);
	gcpMgcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpMgcTable(): store configuraiton file for gcpMgcTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpMgcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpMgcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpMgcTable: storing data...  "));
	refresh_gcpMgcTable(1);
	(void) tmpsize;
	for (hcindex = gcpMgcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpMgcTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpMgcTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMgcId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgcLocation, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgcName, &StorageTmp->gcpMgcNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgcDomainName, &StorageTmp->gcpMgcDomainNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgcDeviceName, &StorageTmp->gcpMgcDeviceNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgcMtpAddress, &StorageTmp->gcpMgcMtpAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgcAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgcOperState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgcAlarmStatus, &StorageTmp->gcpMgcAlarmStatusLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->gcpMgcAsaProfilePointer, &StorageTmp->gcpMgcAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgcUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgcAvailStatus, &StorageTmp->gcpMgcAvailStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpMgcProcStatus, &StorageTmp->gcpMgcProcStatusLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMgcPg, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgcStandbyStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpMgcRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpLinkageTable_data *gcpLinkageTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpLinkageTable table.
 *
 * Creates a new gcpLinkageTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpLinkageTable_data *
gcpLinkageTable_create(void)
{
	struct gcpLinkageTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpLinkageTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpLinkageTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpMsId = 0;
		StorageNew->gcpMgId = 0;
		StorageNew->gcpMsId = 0;
		StorageNew->gcpMgcId = 0;
		StorageNew->gcpLinkageType = 0;
		StorageNew->gcpLinkageMgcMaster = GCPLINKAGEMGCMASTER_MASTER;
		if ((StorageNew->gcpLinkageMgcAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpLinkageMgcAddressLen = 0;
		StorageNew->gcpLinkageMgcAddress[StorageNew->gcpLinkageMgcAddressLen] = 0;
		if ((StorageNew->gcpLinkageMgAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpLinkageMgAddressLen = 0;
		StorageNew->gcpLinkageMgAddress[StorageNew->gcpLinkageMgAddressLen] = 0;
		StorageNew->gcpLinkageMgcIdent = 0;
		StorageNew->gcpLinkageMgIdent = 0;
		if ((StorageNew->gcpLinkageProfile = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->gcpLinkageProfileLen = 2;
		if ((StorageNew->gcpLinkageProtocol = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->gcpLinkageProtocolLen = 2;
		StorageNew->gcpLinkageEncoding = 0;
		if (memdup((u_char **) &StorageNew->gcpLinkageAuthAccess, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpLinkageAuthAccessLen = 1;
		StorageNew->gcpLinkageAdminState = 0;
		StorageNew->gcpLinkageOperState = 0;
		if (memdup((u_char **) &StorageNew->gcpLinkageProcStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpLinkageProcStatusLen = 1;
		if (memdup((u_char **) &StorageNew->gcpLinkageAvailStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpLinkageAvailStatusLen = 2;
		StorageNew->gcpLinkageAuthentication = 0;
		StorageNew->gcpLinkageMit = 0;
		StorageNew->gcpLinkageRowStatus = 0;
		StorageNew->gcpLinkageRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpLinkageTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpLinkageTable_data *gcpLinkageTable_duplicate(struct gcpLinkageTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpLinkageTable_data *
gcpLinkageTable_duplicate(struct gcpLinkageTable_data *thedata)
{
	struct gcpLinkageTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpLinkageTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpLinkageTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpLinkageTable_id = thedata->gcpLinkageTable_id;
		StorageNew->gcpMsId = thedata->gcpMsId;
		StorageNew->gcpMgId = thedata->gcpMgId;
		StorageNew->gcpMsId = thedata->gcpMsId;
		StorageNew->gcpMgcId = thedata->gcpMgcId;
		StorageNew->gcpLinkageType = thedata->gcpLinkageType;
		StorageNew->gcpLinkageMgcMaster = thedata->gcpLinkageMgcMaster;
		if (!(StorageNew->gcpLinkageMgcAddress = malloc(thedata->gcpLinkageMgcAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpLinkageMgcAddress, thedata->gcpLinkageMgcAddress, thedata->gcpLinkageMgcAddressLen);
		StorageNew->gcpLinkageMgcAddressLen = thedata->gcpLinkageMgcAddressLen;
		StorageNew->gcpLinkageMgcAddress[StorageNew->gcpLinkageMgcAddressLen] = 0;
		if (!(StorageNew->gcpLinkageMgAddress = malloc(thedata->gcpLinkageMgAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpLinkageMgAddress, thedata->gcpLinkageMgAddress, thedata->gcpLinkageMgAddressLen);
		StorageNew->gcpLinkageMgAddressLen = thedata->gcpLinkageMgAddressLen;
		StorageNew->gcpLinkageMgAddress[StorageNew->gcpLinkageMgAddressLen] = 0;
		StorageNew->gcpLinkageMgcIdent = thedata->gcpLinkageMgcIdent;
		StorageNew->gcpLinkageMgIdent = thedata->gcpLinkageMgIdent;
		if (!(StorageNew->gcpLinkageProfile = snmp_duplicate_objid(thedata->gcpLinkageProfile, thedata->gcpLinkageProfileLen / sizeof(oid))))
			goto destroy;
		StorageNew->gcpLinkageProfileLen = thedata->gcpLinkageProfileLen;
		if (!(StorageNew->gcpLinkageProtocol = snmp_duplicate_objid(thedata->gcpLinkageProtocol, thedata->gcpLinkageProtocolLen / sizeof(oid))))
			goto destroy;
		StorageNew->gcpLinkageProtocolLen = thedata->gcpLinkageProtocolLen;
		StorageNew->gcpLinkageEncoding = thedata->gcpLinkageEncoding;
		if (!(StorageNew->gcpLinkageAuthAccess = malloc(thedata->gcpLinkageAuthAccessLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpLinkageAuthAccess, thedata->gcpLinkageAuthAccess, thedata->gcpLinkageAuthAccessLen);
		StorageNew->gcpLinkageAuthAccessLen = thedata->gcpLinkageAuthAccessLen;
		StorageNew->gcpLinkageAuthAccess[StorageNew->gcpLinkageAuthAccessLen] = 0;
		StorageNew->gcpLinkageAdminState = thedata->gcpLinkageAdminState;
		StorageNew->gcpLinkageOperState = thedata->gcpLinkageOperState;
		if (!(StorageNew->gcpLinkageProcStatus = malloc(thedata->gcpLinkageProcStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpLinkageProcStatus, thedata->gcpLinkageProcStatus, thedata->gcpLinkageProcStatusLen);
		StorageNew->gcpLinkageProcStatusLen = thedata->gcpLinkageProcStatusLen;
		StorageNew->gcpLinkageProcStatus[StorageNew->gcpLinkageProcStatusLen] = 0;
		if (!(StorageNew->gcpLinkageAvailStatus = malloc(thedata->gcpLinkageAvailStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpLinkageAvailStatus, thedata->gcpLinkageAvailStatus, thedata->gcpLinkageAvailStatusLen);
		StorageNew->gcpLinkageAvailStatusLen = thedata->gcpLinkageAvailStatusLen;
		StorageNew->gcpLinkageAvailStatus[StorageNew->gcpLinkageAvailStatusLen] = 0;
		StorageNew->gcpLinkageAuthentication = thedata->gcpLinkageAuthentication;
		StorageNew->gcpLinkageMit = thedata->gcpLinkageMit;
		StorageNew->gcpLinkageRowStatus = thedata->gcpLinkageRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpLinkageTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpLinkageTable_destroy(struct gcpLinkageTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpLinkageTable_destroy(struct gcpLinkageTable_data **thedata)
{
	struct gcpLinkageTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpLinkageTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpLinkageMgcAddress);
		StorageDel->gcpLinkageMgcAddressLen = 0;
		SNMP_FREE(StorageDel->gcpLinkageMgAddress);
		StorageDel->gcpLinkageMgAddressLen = 0;
		SNMP_FREE(StorageDel->gcpLinkageProfile);
		StorageDel->gcpLinkageProfileLen = 0;
		SNMP_FREE(StorageDel->gcpLinkageProtocol);
		StorageDel->gcpLinkageProtocolLen = 0;
		SNMP_FREE(StorageDel->gcpLinkageAuthAccess);
		StorageDel->gcpLinkageAuthAccessLen = 0;
		SNMP_FREE(StorageDel->gcpLinkageProcStatus);
		StorageDel->gcpLinkageProcStatusLen = 0;
		SNMP_FREE(StorageDel->gcpLinkageAvailStatus);
		StorageDel->gcpLinkageAvailStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpLinkageTable_add(struct gcpLinkageTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpLinkageTable table data set.
 *
 * Adds a table row structure to the gcpLinkageTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpLinkageTable_add(struct gcpLinkageTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpLinkageTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMsId, sizeof(thedata->gcpMsId));
		/* gcpMgId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMgId, sizeof(thedata->gcpMgId));
		/* gcpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMsId, sizeof(thedata->gcpMsId));
		/* gcpMgcId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMgcId, sizeof(thedata->gcpMgcId));
		header_complex_add_data(&gcpLinkageTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpLinkageTable_del(struct gcpLinkageTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpLinkageTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpLinkageTable_del(struct gcpLinkageTable_data *thedata)
{
	struct gcpLinkageTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpLinkageTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpLinkageTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpLinkageTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpLinkageTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpLinkageTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpLinkageTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpLinkageTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpLinkageTable_data *StorageTmp = gcpLinkageTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpLinkageTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMgId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMgcId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageMgcMaster, &tmpsize);
	SNMP_FREE(StorageTmp->gcpLinkageMgcAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpLinkageMgcAddress, &StorageTmp->gcpLinkageMgcAddressLen);
	if (StorageTmp->gcpLinkageMgcAddress == NULL) {
		config_perror("invalid specification for gcpLinkageMgcAddress");
		return;
	}
	SNMP_FREE(StorageTmp->gcpLinkageMgAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpLinkageMgAddress, &StorageTmp->gcpLinkageMgAddressLen);
	if (StorageTmp->gcpLinkageMgAddress == NULL) {
		config_perror("invalid specification for gcpLinkageMgAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageMgcIdent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageMgIdent, &tmpsize);
	SNMP_FREE(StorageTmp->gcpLinkageProfile);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->gcpLinkageProfile, &StorageTmp->gcpLinkageProfileLen);
	if (StorageTmp->gcpLinkageProfile == NULL) {
		config_perror("invalid specification for gcpLinkageProfile");
		return;
	}
	SNMP_FREE(StorageTmp->gcpLinkageProtocol);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->gcpLinkageProtocol, &StorageTmp->gcpLinkageProtocolLen);
	if (StorageTmp->gcpLinkageProtocol == NULL) {
		config_perror("invalid specification for gcpLinkageProtocol");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageEncoding, &tmpsize);
	SNMP_FREE(StorageTmp->gcpLinkageAuthAccess);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpLinkageAuthAccess, &StorageTmp->gcpLinkageAuthAccessLen);
	if (StorageTmp->gcpLinkageAuthAccess == NULL) {
		config_perror("invalid specification for gcpLinkageAuthAccess");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageOperState, &tmpsize);
	SNMP_FREE(StorageTmp->gcpLinkageProcStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpLinkageProcStatus, &StorageTmp->gcpLinkageProcStatusLen);
	if (StorageTmp->gcpLinkageProcStatus == NULL) {
		config_perror("invalid specification for gcpLinkageProcStatus");
		return;
	}
	SNMP_FREE(StorageTmp->gcpLinkageAvailStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpLinkageAvailStatus, &StorageTmp->gcpLinkageAvailStatusLen);
	if (StorageTmp->gcpLinkageAvailStatus == NULL) {
		config_perror("invalid specification for gcpLinkageAvailStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageAuthentication, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageMit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpLinkageRowStatus, &tmpsize);
	gcpLinkageTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpLinkageTable(): store configuraiton file for gcpLinkageTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpLinkageTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpLinkageTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpLinkageTable: storing data...  "));
	refresh_gcpLinkageTable(1);
	(void) tmpsize;
	for (hcindex = gcpLinkageTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpLinkageTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpLinkageTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMgId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMgcId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageMgcMaster, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpLinkageMgcAddress, &StorageTmp->gcpLinkageMgcAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpLinkageMgAddress, &StorageTmp->gcpLinkageMgAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageMgcIdent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageMgIdent, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->gcpLinkageProfile, &StorageTmp->gcpLinkageProfileLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->gcpLinkageProtocol, &StorageTmp->gcpLinkageProtocolLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageEncoding, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpLinkageAuthAccess, &StorageTmp->gcpLinkageAuthAccessLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageOperState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpLinkageProcStatus, &StorageTmp->gcpLinkageProcStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpLinkageAvailStatus, &StorageTmp->gcpLinkageAvailStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageAuthentication, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageMit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpLinkageRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpUdpProfileTable_data *gcpUdpProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpUdpProfileTable table.
 *
 * Creates a new gcpUdpProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpUdpProfileTable_data *
gcpUdpProfileTable_create(void)
{
	struct gcpUdpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpUdpProfileTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpUdpProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpUdpChecksum = 0;
		StorageNew->gcpUdpRowStatus = 0;
		StorageNew->gcpUdpRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpUdpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpUdpProfileTable_data *gcpUdpProfileTable_duplicate(struct gcpUdpProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpUdpProfileTable_data *
gcpUdpProfileTable_duplicate(struct gcpUdpProfileTable_data *thedata)
{
	struct gcpUdpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpUdpProfileTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpUdpProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpUdpProfileTable_id = thedata->gcpUdpProfileTable_id;
		if (!(StorageNew->gcpUdpProfileId = malloc(thedata->gcpUdpProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpUdpProfileId, thedata->gcpUdpProfileId, thedata->gcpUdpProfileIdLen);
		StorageNew->gcpUdpProfileIdLen = thedata->gcpUdpProfileIdLen;
		StorageNew->gcpUdpProfileId[StorageNew->gcpUdpProfileIdLen] = 0;
		StorageNew->gcpUdpChecksum = thedata->gcpUdpChecksum;
		StorageNew->gcpUdpRowStatus = thedata->gcpUdpRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpUdpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpUdpProfileTable_destroy(struct gcpUdpProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpUdpProfileTable_destroy(struct gcpUdpProfileTable_data **thedata)
{
	struct gcpUdpProfileTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpUdpProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpUdpProfileId);
		StorageDel->gcpUdpProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpUdpProfileTable_add(struct gcpUdpProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpUdpProfileTable table data set.
 *
 * Adds a table row structure to the gcpUdpProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpUdpProfileTable_add(struct gcpUdpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpUdpProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpUdpProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->gcpUdpProfileId, thedata->gcpUdpProfileIdLen);
		header_complex_add_data(&gcpUdpProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpUdpProfileTable_del(struct gcpUdpProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpUdpProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpUdpProfileTable_del(struct gcpUdpProfileTable_data *thedata)
{
	struct gcpUdpProfileTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpUdpProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpUdpProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpUdpProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpUdpProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpUdpProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpUdpProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpUdpProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpUdpProfileTable_data *StorageTmp = gcpUdpProfileTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpUdpProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->gcpUdpProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpUdpProfileId, &StorageTmp->gcpUdpProfileIdLen);
	if (StorageTmp->gcpUdpProfileId == NULL) {
		config_perror("invalid specification for gcpUdpProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpUdpChecksum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpUdpRowStatus, &tmpsize);
	gcpUdpProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpUdpProfileTable(): store configuraiton file for gcpUdpProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpUdpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpUdpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpUdpProfileTable: storing data...  "));
	refresh_gcpUdpProfileTable(1);
	(void) tmpsize;
	for (hcindex = gcpUdpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpUdpProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpUdpProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpUdpProfileId, &StorageTmp->gcpUdpProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpUdpChecksum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpUdpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpTcpProfileTable_data *gcpTcpProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpTcpProfileTable table.
 *
 * Creates a new gcpTcpProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpTcpProfileTable_data *
gcpTcpProfileTable_create(void)
{
	struct gcpTcpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpTcpProfileTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpTcpProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpTcpNoDelay = 0;
		StorageNew->gcpTcpMaxseg = 0;
		StorageNew->gcpTcpKeepAlive = 0;
		StorageNew->gcpTcpKeepIdle = 0;
		StorageNew->gcpTcpKeepAliveItvl = 0;
		StorageNew->gcpTcpKeepCount = 0;
		StorageNew->gcpTcpSynRetrans = 0;
		StorageNew->gcpTcpWindowClamp = 0;
		StorageNew->gcpTcpRowStatus = 0;
		StorageNew->gcpTcpRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpTcpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpTcpProfileTable_data *gcpTcpProfileTable_duplicate(struct gcpTcpProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpTcpProfileTable_data *
gcpTcpProfileTable_duplicate(struct gcpTcpProfileTable_data *thedata)
{
	struct gcpTcpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpTcpProfileTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpTcpProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpTcpProfileTable_id = thedata->gcpTcpProfileTable_id;
		if (!(StorageNew->gcpTcpProfileId = malloc(thedata->gcpTcpProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpTcpProfileId, thedata->gcpTcpProfileId, thedata->gcpTcpProfileIdLen);
		StorageNew->gcpTcpProfileIdLen = thedata->gcpTcpProfileIdLen;
		StorageNew->gcpTcpProfileId[StorageNew->gcpTcpProfileIdLen] = 0;
		StorageNew->gcpTcpNoDelay = thedata->gcpTcpNoDelay;
		StorageNew->gcpTcpMaxseg = thedata->gcpTcpMaxseg;
		StorageNew->gcpTcpKeepAlive = thedata->gcpTcpKeepAlive;
		StorageNew->gcpTcpKeepIdle = thedata->gcpTcpKeepIdle;
		StorageNew->gcpTcpKeepAliveItvl = thedata->gcpTcpKeepAliveItvl;
		StorageNew->gcpTcpKeepCount = thedata->gcpTcpKeepCount;
		StorageNew->gcpTcpSynRetrans = thedata->gcpTcpSynRetrans;
		StorageNew->gcpTcpWindowClamp = thedata->gcpTcpWindowClamp;
		StorageNew->gcpTcpRowStatus = thedata->gcpTcpRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpTcpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpTcpProfileTable_destroy(struct gcpTcpProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpTcpProfileTable_destroy(struct gcpTcpProfileTable_data **thedata)
{
	struct gcpTcpProfileTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpTcpProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpTcpProfileId);
		StorageDel->gcpTcpProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpTcpProfileTable_add(struct gcpTcpProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpTcpProfileTable table data set.
 *
 * Adds a table row structure to the gcpTcpProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpTcpProfileTable_add(struct gcpTcpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpTcpProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpTcpProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->gcpTcpProfileId, thedata->gcpTcpProfileIdLen);
		header_complex_add_data(&gcpTcpProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpTcpProfileTable_del(struct gcpTcpProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpTcpProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpTcpProfileTable_del(struct gcpTcpProfileTable_data *thedata)
{
	struct gcpTcpProfileTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpTcpProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpTcpProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpTcpProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpTcpProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpTcpProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpTcpProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpTcpProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpTcpProfileTable_data *StorageTmp = gcpTcpProfileTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpTcpProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->gcpTcpProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpTcpProfileId, &StorageTmp->gcpTcpProfileIdLen);
	if (StorageTmp->gcpTcpProfileId == NULL) {
		config_perror("invalid specification for gcpTcpProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpTcpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpTcpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpTcpKeepAlive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpTcpKeepIdle, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpTcpKeepAliveItvl, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpTcpKeepCount, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpTcpSynRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpTcpWindowClamp, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpTcpRowStatus, &tmpsize);
	gcpTcpProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpTcpProfileTable(): store configuraiton file for gcpTcpProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpTcpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpTcpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpTcpProfileTable: storing data...  "));
	refresh_gcpTcpProfileTable(1);
	(void) tmpsize;
	for (hcindex = gcpTcpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpTcpProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpTcpProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpTcpProfileId, &StorageTmp->gcpTcpProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpTcpNoDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpTcpMaxseg, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpTcpKeepAlive, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpTcpKeepIdle, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpTcpKeepAliveItvl, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpTcpKeepCount, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpTcpSynRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpTcpWindowClamp, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpTcpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpSctpProfileTable_data *gcpSctpProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpSctpProfileTable table.
 *
 * Creates a new gcpSctpProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpSctpProfileTable_data *
gcpSctpProfileTable_create(void)
{
	struct gcpSctpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpSctpProfileTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpSctpProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpSctpNoDelay = 0;
		StorageNew->gcpSctpMaxseg = 0;
		StorageNew->gcpSctpHeartbeatItvl = 0;
		StorageNew->gcpSctpHearbeat = 0;
		StorageNew->gcpSctpRtoInitial = 0;
		StorageNew->gcpSctpRtoMin = 0;
		StorageNew->gcpSctpRtoMax = 0;
		StorageNew->gcpSctpPathMaxRetrans = 0;
		StorageNew->gcpSctpCookieLife = 0;
		StorageNew->gcpSctpCookieInc = 0;
		StorageNew->gcpSctpMaxInitRetries = 0;
		StorageNew->gcpSctpMaxBurst = 0;
		StorageNew->gcpSctpAssocMaxRetrans = 0;
		StorageNew->gcpSctpSackDelay = 0;
		StorageNew->gcpSctpLifetime = 0;
		StorageNew->gcpSctpRowStatus = 0;
		StorageNew->gcpSctpRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpSctpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpSctpProfileTable_data *gcpSctpProfileTable_duplicate(struct gcpSctpProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpSctpProfileTable_data *
gcpSctpProfileTable_duplicate(struct gcpSctpProfileTable_data *thedata)
{
	struct gcpSctpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpSctpProfileTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpSctpProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpSctpProfileTable_id = thedata->gcpSctpProfileTable_id;
		if (!(StorageNew->gcpSctpProfileId = malloc(thedata->gcpSctpProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpSctpProfileId, thedata->gcpSctpProfileId, thedata->gcpSctpProfileIdLen);
		StorageNew->gcpSctpProfileIdLen = thedata->gcpSctpProfileIdLen;
		StorageNew->gcpSctpProfileId[StorageNew->gcpSctpProfileIdLen] = 0;
		StorageNew->gcpSctpNoDelay = thedata->gcpSctpNoDelay;
		StorageNew->gcpSctpMaxseg = thedata->gcpSctpMaxseg;
		StorageNew->gcpSctpHeartbeatItvl = thedata->gcpSctpHeartbeatItvl;
		StorageNew->gcpSctpHearbeat = thedata->gcpSctpHearbeat;
		StorageNew->gcpSctpRtoInitial = thedata->gcpSctpRtoInitial;
		StorageNew->gcpSctpRtoMin = thedata->gcpSctpRtoMin;
		StorageNew->gcpSctpRtoMax = thedata->gcpSctpRtoMax;
		StorageNew->gcpSctpPathMaxRetrans = thedata->gcpSctpPathMaxRetrans;
		StorageNew->gcpSctpCookieLife = thedata->gcpSctpCookieLife;
		StorageNew->gcpSctpCookieInc = thedata->gcpSctpCookieInc;
		StorageNew->gcpSctpMaxInitRetries = thedata->gcpSctpMaxInitRetries;
		StorageNew->gcpSctpMaxBurst = thedata->gcpSctpMaxBurst;
		StorageNew->gcpSctpAssocMaxRetrans = thedata->gcpSctpAssocMaxRetrans;
		StorageNew->gcpSctpSackDelay = thedata->gcpSctpSackDelay;
		StorageNew->gcpSctpLifetime = thedata->gcpSctpLifetime;
		StorageNew->gcpSctpRowStatus = thedata->gcpSctpRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpSctpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpSctpProfileTable_destroy(struct gcpSctpProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpSctpProfileTable_destroy(struct gcpSctpProfileTable_data **thedata)
{
	struct gcpSctpProfileTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpSctpProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpSctpProfileId);
		StorageDel->gcpSctpProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpSctpProfileTable_add(struct gcpSctpProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpSctpProfileTable table data set.
 *
 * Adds a table row structure to the gcpSctpProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpSctpProfileTable_add(struct gcpSctpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpSctpProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpSctpProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->gcpSctpProfileId, thedata->gcpSctpProfileIdLen);
		header_complex_add_data(&gcpSctpProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpSctpProfileTable_del(struct gcpSctpProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpSctpProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpSctpProfileTable_del(struct gcpSctpProfileTable_data *thedata)
{
	struct gcpSctpProfileTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpSctpProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpSctpProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpSctpProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpSctpProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpSctpProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpSctpProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpSctpProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpSctpProfileTable_data *StorageTmp = gcpSctpProfileTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpSctpProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->gcpSctpProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpSctpProfileId, &StorageTmp->gcpSctpProfileIdLen);
	if (StorageTmp->gcpSctpProfileId == NULL) {
		config_perror("invalid specification for gcpSctpProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpHearbeat, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSctpRowStatus, &tmpsize);
	gcpSctpProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpSctpProfileTable(): store configuraiton file for gcpSctpProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpSctpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpSctpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpSctpProfileTable: storing data...  "));
	refresh_gcpSctpProfileTable(1);
	(void) tmpsize;
	for (hcindex = gcpSctpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpSctpProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpSctpProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpSctpProfileId, &StorageTmp->gcpSctpProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpNoDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpSctpMaxseg, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpHeartbeatItvl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpHearbeat, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpRtoInitial, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpRtoMax, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpSctpPathMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpCookieLife, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpCookieInc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpSctpMaxInitRetries, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpSctpMaxBurst, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpSctpAssocMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpSackDelay, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSctpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpProtGroupTable_data *gcpProtGroupTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpProtGroupTable table.
 *
 * Creates a new gcpProtGroupTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpProtGroupTable_data *
gcpProtGroupTable_create(void)
{
	struct gcpProtGroupTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpProtGroupTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpProtGroupTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpProtGroupOperState = 0;
		if (memdup((u_char **) &StorageNew->gcpProtGroupAvailStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpProtGroupAvailStatusLen = 2;
		StorageNew->gcpProtGroupType = 0;
		StorageNew->gcpProtGroupRevertive = 0;
		StorageNew->gcpProtGroupSBOLNumber = 0;
		StorageNew->gcpProtGroupWaitToRestoreTime = 0;
		StorageNew->gcpProtGroupSettingWindowTime = 0;
		StorageNew->gcpProtGroupReleaseingWindowTime = 0;
		StorageNew->gcpProtGroupHitsCount = 0;
		StorageNew->gcpProtGroupSwitchType = 0;
		if ((StorageNew->gcpProtGroupProtectedUnits = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpProtGroupProtectedUnitsLen = 0;
		StorageNew->gcpProtGroupProtectedUnits[StorageNew->gcpProtGroupProtectedUnitsLen] = 0;
		if ((StorageNew->gcpProtGroupProtectingUnits = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpProtGroupProtectingUnitsLen = 0;
		StorageNew->gcpProtGroupProtectingUnits[StorageNew->gcpProtGroupProtectingUnitsLen] = 0;
		StorageNew->gcpProtGroupInvokeProtection = 0;
		StorageNew->gcpProtGroupReleaseProtection = 0;
		StorageNew->gcpProtGroupRowStatus = 0;
		StorageNew->gcpProtGroupRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpProtGroupTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpProtGroupTable_data *gcpProtGroupTable_duplicate(struct gcpProtGroupTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpProtGroupTable_data *
gcpProtGroupTable_duplicate(struct gcpProtGroupTable_data *thedata)
{
	struct gcpProtGroupTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpProtGroupTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpProtGroupTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpProtGroupTable_id = thedata->gcpProtGroupTable_id;
		StorageNew->gcpProtGroupId = thedata->gcpProtGroupId;
		StorageNew->gcpProtGroupOperState = thedata->gcpProtGroupOperState;
		if (!(StorageNew->gcpProtGroupAvailStatus = malloc(thedata->gcpProtGroupAvailStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpProtGroupAvailStatus, thedata->gcpProtGroupAvailStatus, thedata->gcpProtGroupAvailStatusLen);
		StorageNew->gcpProtGroupAvailStatusLen = thedata->gcpProtGroupAvailStatusLen;
		StorageNew->gcpProtGroupAvailStatus[StorageNew->gcpProtGroupAvailStatusLen] = 0;
		StorageNew->gcpProtGroupType = thedata->gcpProtGroupType;
		StorageNew->gcpProtGroupRevertive = thedata->gcpProtGroupRevertive;
		StorageNew->gcpProtGroupSBOLNumber = thedata->gcpProtGroupSBOLNumber;
		StorageNew->gcpProtGroupWaitToRestoreTime = thedata->gcpProtGroupWaitToRestoreTime;
		StorageNew->gcpProtGroupSettingWindowTime = thedata->gcpProtGroupSettingWindowTime;
		StorageNew->gcpProtGroupReleaseingWindowTime = thedata->gcpProtGroupReleaseingWindowTime;
		StorageNew->gcpProtGroupHitsCount = thedata->gcpProtGroupHitsCount;
		StorageNew->gcpProtGroupSwitchType = thedata->gcpProtGroupSwitchType;
		if (!(StorageNew->gcpProtGroupProtectedUnits = malloc(thedata->gcpProtGroupProtectedUnitsLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpProtGroupProtectedUnits, thedata->gcpProtGroupProtectedUnits, thedata->gcpProtGroupProtectedUnitsLen);
		StorageNew->gcpProtGroupProtectedUnitsLen = thedata->gcpProtGroupProtectedUnitsLen;
		StorageNew->gcpProtGroupProtectedUnits[StorageNew->gcpProtGroupProtectedUnitsLen] = 0;
		if (!(StorageNew->gcpProtGroupProtectingUnits = malloc(thedata->gcpProtGroupProtectingUnitsLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpProtGroupProtectingUnits, thedata->gcpProtGroupProtectingUnits, thedata->gcpProtGroupProtectingUnitsLen);
		StorageNew->gcpProtGroupProtectingUnitsLen = thedata->gcpProtGroupProtectingUnitsLen;
		StorageNew->gcpProtGroupProtectingUnits[StorageNew->gcpProtGroupProtectingUnitsLen] = 0;
		StorageNew->gcpProtGroupInvokeProtection = thedata->gcpProtGroupInvokeProtection;
		StorageNew->gcpProtGroupReleaseProtection = thedata->gcpProtGroupReleaseProtection;
		StorageNew->gcpProtGroupRowStatus = thedata->gcpProtGroupRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpProtGroupTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpProtGroupTable_destroy(struct gcpProtGroupTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpProtGroupTable_destroy(struct gcpProtGroupTable_data **thedata)
{
	struct gcpProtGroupTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpProtGroupTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpProtGroupAvailStatus);
		StorageDel->gcpProtGroupAvailStatusLen = 0;
		SNMP_FREE(StorageDel->gcpProtGroupProtectedUnits);
		StorageDel->gcpProtGroupProtectedUnitsLen = 0;
		SNMP_FREE(StorageDel->gcpProtGroupProtectingUnits);
		StorageDel->gcpProtGroupProtectingUnitsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpProtGroupTable_add(struct gcpProtGroupTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpProtGroupTable table data set.
 *
 * Adds a table row structure to the gcpProtGroupTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpProtGroupTable_add(struct gcpProtGroupTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpProtGroupTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpProtGroupId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpProtGroupId, sizeof(thedata->gcpProtGroupId));
		header_complex_add_data(&gcpProtGroupTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpProtGroupTable_del(struct gcpProtGroupTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpProtGroupTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpProtGroupTable_del(struct gcpProtGroupTable_data *thedata)
{
	struct gcpProtGroupTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpProtGroupTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpProtGroupTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpProtGroupTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpProtGroupTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpProtGroupTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpProtGroupTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpProtGroupTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpProtGroupTable_data *StorageTmp = gcpProtGroupTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpProtGroupTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpProtGroupId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupOperState, &tmpsize);
	SNMP_FREE(StorageTmp->gcpProtGroupAvailStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpProtGroupAvailStatus, &StorageTmp->gcpProtGroupAvailStatusLen);
	if (StorageTmp->gcpProtGroupAvailStatus == NULL) {
		config_perror("invalid specification for gcpProtGroupAvailStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupRevertive, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpProtGroupSBOLNumber, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupWaitToRestoreTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupSettingWindowTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupReleaseingWindowTime, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpProtGroupHitsCount, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupSwitchType, &tmpsize);
	SNMP_FREE(StorageTmp->gcpProtGroupProtectedUnits);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpProtGroupProtectedUnits, &StorageTmp->gcpProtGroupProtectedUnitsLen);
	if (StorageTmp->gcpProtGroupProtectedUnits == NULL) {
		config_perror("invalid specification for gcpProtGroupProtectedUnits");
		return;
	}
	SNMP_FREE(StorageTmp->gcpProtGroupProtectingUnits);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpProtGroupProtectingUnits, &StorageTmp->gcpProtGroupProtectingUnitsLen);
	if (StorageTmp->gcpProtGroupProtectingUnits == NULL) {
		config_perror("invalid specification for gcpProtGroupProtectingUnits");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupInvokeProtection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupReleaseProtection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtGroupRowStatus, &tmpsize);
	gcpProtGroupTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpProtGroupTable(): store configuraiton file for gcpProtGroupTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpProtGroupTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpProtGroupTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpProtGroupTable: storing data...  "));
	refresh_gcpProtGroupTable(1);
	(void) tmpsize;
	for (hcindex = gcpProtGroupTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpProtGroupTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpProtGroupTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpProtGroupId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupOperState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpProtGroupAvailStatus, &StorageTmp->gcpProtGroupAvailStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupRevertive, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpProtGroupSBOLNumber, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupWaitToRestoreTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupSettingWindowTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupReleaseingWindowTime, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpProtGroupHitsCount, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupSwitchType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpProtGroupProtectedUnits, &StorageTmp->gcpProtGroupProtectedUnitsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpProtGroupProtectingUnits, &StorageTmp->gcpProtGroupProtectingUnitsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupInvokeProtection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupReleaseProtection, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtGroupRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpSbolTable_data *gcpSbolTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpSbolTable table.
 *
 * Creates a new gcpSbolTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpSbolTable_data *
gcpSbolTable_create(void)
{
	struct gcpSbolTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpSbolTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpSbolTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpProtGroupId = 0;
		if ((StorageNew->gcpSbolObject = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->gcpSbolObjectLen = 2;
		StorageNew->gcpSbolStatus = 0;
		StorageNew->gcpSbolStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpSbolTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpSbolTable_data *gcpSbolTable_duplicate(struct gcpSbolTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpSbolTable_data *
gcpSbolTable_duplicate(struct gcpSbolTable_data *thedata)
{
	struct gcpSbolTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpSbolTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpSbolTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpSbolTable_id = thedata->gcpSbolTable_id;
		StorageNew->gcpProtGroupId = thedata->gcpProtGroupId;
		StorageNew->gcpSbolId = thedata->gcpSbolId;
		if (!(StorageNew->gcpSbolObject = snmp_duplicate_objid(thedata->gcpSbolObject, thedata->gcpSbolObjectLen / sizeof(oid))))
			goto destroy;
		StorageNew->gcpSbolObjectLen = thedata->gcpSbolObjectLen;
		StorageNew->gcpSbolStatus = thedata->gcpSbolStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpSbolTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpSbolTable_destroy(struct gcpSbolTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpSbolTable_destroy(struct gcpSbolTable_data **thedata)
{
	struct gcpSbolTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpSbolTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpSbolObject);
		StorageDel->gcpSbolObjectLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpSbolTable_add(struct gcpSbolTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpSbolTable table data set.
 *
 * Adds a table row structure to the gcpSbolTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpSbolTable_add(struct gcpSbolTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpSbolTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpProtGroupId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpProtGroupId, sizeof(thedata->gcpProtGroupId));
		/* gcpSbolId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpSbolId, sizeof(thedata->gcpSbolId));
		header_complex_add_data(&gcpSbolTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpSbolTable_del(struct gcpSbolTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpSbolTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpSbolTable_del(struct gcpSbolTable_data *thedata)
{
	struct gcpSbolTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpSbolTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpSbolTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpSbolTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpSbolTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpSbolTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpSbolTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpSbolTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpSbolTable_data *StorageTmp = gcpSbolTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpSbolTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpProtGroupId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpSbolId, &tmpsize);
	SNMP_FREE(StorageTmp->gcpSbolObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->gcpSbolObject, &StorageTmp->gcpSbolObjectLen);
	if (StorageTmp->gcpSbolObject == NULL) {
		config_perror("invalid specification for gcpSbolObject");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpSbolStatus, &tmpsize);
	gcpSbolTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpSbolTable(): store configuraiton file for gcpSbolTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpSbolTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpSbolTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpSbolTable: storing data...  "));
	refresh_gcpSbolTable(1);
	(void) tmpsize;
	for (hcindex = gcpSbolTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpSbolTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpSbolTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpProtGroupId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpSbolId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->gcpSbolObject, &StorageTmp->gcpSbolObjectLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpSbolStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpProtUnitTable_data *gcpProtUnitTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpProtUnitTable table.
 *
 * Creates a new gcpProtUnitTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpProtUnitTable_data *
gcpProtUnitTable_create(void)
{
	struct gcpProtUnitTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpProtUnitTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpProtUnitTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpProtUnitProtecting = 0;
		if ((StorageNew->gcpProtUnitReliableResourcePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->gcpProtUnitReliableResourcePointerLen = 2;
		if ((StorageNew->gcpProtUnitUnreliableResourcePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->gcpProtUnitUnreliableResourcePointerLen = 2;
		if (memdup((u_char **) &StorageNew->gcpProtUnitProtectionStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
			StorageNew->gcpProtUnitProtectionStatusLen = 2;
		StorageNew->gcpProtUnitRequestSource = 0;
		StorageNew->gcpProtUnitSwitchStatus = 0;
		StorageNew->gcpProtUnitSwitchDirection = 0;
		StorageNew->gcpProtUnitRelatedUnit = 0;
		StorageNew->gcpProtUnitAutoSwitchReason = 0;
		StorageNew->gcpProtUnitLockoutReleaseFailed = 0;
		StorageNew->gcpProtUnitPriority = 0;
		StorageNew->gcpProtUnitRowStatus = 0;
		StorageNew->gcpProtUnitRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpProtUnitTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpProtUnitTable_data *gcpProtUnitTable_duplicate(struct gcpProtUnitTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpProtUnitTable_data *
gcpProtUnitTable_duplicate(struct gcpProtUnitTable_data *thedata)
{
	struct gcpProtUnitTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpProtUnitTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpProtUnitTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpProtUnitTable_id = thedata->gcpProtUnitTable_id;
		StorageNew->gcpProtUnitId = thedata->gcpProtUnitId;
		StorageNew->gcpProtUnitProtecting = thedata->gcpProtUnitProtecting;
		if (!(StorageNew->gcpProtUnitReliableResourcePointer = snmp_duplicate_objid(thedata->gcpProtUnitReliableResourcePointer, thedata->gcpProtUnitReliableResourcePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->gcpProtUnitReliableResourcePointerLen = thedata->gcpProtUnitReliableResourcePointerLen;
		if (!
		    (StorageNew->gcpProtUnitUnreliableResourcePointer =
		     snmp_duplicate_objid(thedata->gcpProtUnitUnreliableResourcePointer, thedata->gcpProtUnitUnreliableResourcePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->gcpProtUnitUnreliableResourcePointerLen = thedata->gcpProtUnitUnreliableResourcePointerLen;
		if (!(StorageNew->gcpProtUnitProtectionStatus = malloc(thedata->gcpProtUnitProtectionStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpProtUnitProtectionStatus, thedata->gcpProtUnitProtectionStatus, thedata->gcpProtUnitProtectionStatusLen);
		StorageNew->gcpProtUnitProtectionStatusLen = thedata->gcpProtUnitProtectionStatusLen;
		StorageNew->gcpProtUnitProtectionStatus[StorageNew->gcpProtUnitProtectionStatusLen] = 0;
		StorageNew->gcpProtUnitRequestSource = thedata->gcpProtUnitRequestSource;
		StorageNew->gcpProtUnitSwitchStatus = thedata->gcpProtUnitSwitchStatus;
		StorageNew->gcpProtUnitSwitchDirection = thedata->gcpProtUnitSwitchDirection;
		StorageNew->gcpProtUnitRelatedUnit = thedata->gcpProtUnitRelatedUnit;
		StorageNew->gcpProtUnitAutoSwitchReason = thedata->gcpProtUnitAutoSwitchReason;
		StorageNew->gcpProtUnitLockoutReleaseFailed = thedata->gcpProtUnitLockoutReleaseFailed;
		StorageNew->gcpProtUnitPriority = thedata->gcpProtUnitPriority;
		StorageNew->gcpProtUnitRowStatus = thedata->gcpProtUnitRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpProtUnitTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpProtUnitTable_destroy(struct gcpProtUnitTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpProtUnitTable_destroy(struct gcpProtUnitTable_data **thedata)
{
	struct gcpProtUnitTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpProtUnitTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpProtUnitReliableResourcePointer);
		StorageDel->gcpProtUnitReliableResourcePointerLen = 0;
		SNMP_FREE(StorageDel->gcpProtUnitUnreliableResourcePointer);
		StorageDel->gcpProtUnitUnreliableResourcePointerLen = 0;
		SNMP_FREE(StorageDel->gcpProtUnitProtectionStatus);
		StorageDel->gcpProtUnitProtectionStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpProtUnitTable_add(struct gcpProtUnitTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpProtUnitTable table data set.
 *
 * Adds a table row structure to the gcpProtUnitTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpProtUnitTable_add(struct gcpProtUnitTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpProtUnitTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpProtUnitId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpProtUnitId, sizeof(thedata->gcpProtUnitId));
		header_complex_add_data(&gcpProtUnitTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpProtUnitTable_del(struct gcpProtUnitTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpProtUnitTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpProtUnitTable_del(struct gcpProtUnitTable_data *thedata)
{
	struct gcpProtUnitTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpProtUnitTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpProtUnitTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpProtUnitTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpProtUnitTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpProtUnitTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpProtUnitTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpProtUnitTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpProtUnitTable_data *StorageTmp = gcpProtUnitTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpProtUnitTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpProtUnitId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtUnitProtecting, &tmpsize);
	SNMP_FREE(StorageTmp->gcpProtUnitReliableResourcePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->gcpProtUnitReliableResourcePointer, &StorageTmp->gcpProtUnitReliableResourcePointerLen);
	if (StorageTmp->gcpProtUnitReliableResourcePointer == NULL) {
		config_perror("invalid specification for gcpProtUnitReliableResourcePointer");
		return;
	}
	SNMP_FREE(StorageTmp->gcpProtUnitUnreliableResourcePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->gcpProtUnitUnreliableResourcePointer, &StorageTmp->gcpProtUnitUnreliableResourcePointerLen);
	if (StorageTmp->gcpProtUnitUnreliableResourcePointer == NULL) {
		config_perror("invalid specification for gcpProtUnitUnreliableResourcePointer");
		return;
	}
	SNMP_FREE(StorageTmp->gcpProtUnitProtectionStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpProtUnitProtectionStatus, &StorageTmp->gcpProtUnitProtectionStatusLen);
	if (StorageTmp->gcpProtUnitProtectionStatus == NULL) {
		config_perror("invalid specification for gcpProtUnitProtectionStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtUnitRequestSource, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtUnitSwitchStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtUnitSwitchDirection, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpProtUnitRelatedUnit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtUnitAutoSwitchReason, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtUnitLockoutReleaseFailed, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpProtUnitPriority, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpProtUnitRowStatus, &tmpsize);
	gcpProtUnitTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpProtUnitTable(): store configuraiton file for gcpProtUnitTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpProtUnitTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpProtUnitTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpProtUnitTable: storing data...  "));
	refresh_gcpProtUnitTable(1);
	(void) tmpsize;
	for (hcindex = gcpProtUnitTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpProtUnitTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpProtUnitTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpProtUnitId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtUnitProtecting, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->gcpProtUnitReliableResourcePointer, &StorageTmp->gcpProtUnitReliableResourcePointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->gcpProtUnitUnreliableResourcePointer, &StorageTmp->gcpProtUnitUnreliableResourcePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpProtUnitProtectionStatus, &StorageTmp->gcpProtUnitProtectionStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtUnitRequestSource, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtUnitSwitchStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtUnitSwitchDirection, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpProtUnitRelatedUnit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtUnitAutoSwitchReason, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtUnitLockoutReleaseFailed, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpProtUnitPriority, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpProtUnitRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpRealmTable_data *gcpRealmTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpRealmTable table.
 *
 * Creates a new gcpRealmTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpRealmTable_data *
gcpRealmTable_create(void)
{
	struct gcpRealmTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpRealmTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpRealmTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpMsId = 0;
		StorageNew->gcpMgId = 0;
		if ((StorageNew->gcpRealmString = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpRealmStringLen = 0;
		StorageNew->gcpRealmString[StorageNew->gcpRealmStringLen] = 0;
		StorageNew->gcpRealmTermsMax = 0;
		StorageNew->gcpRealmTermsCurrent = 0;
		StorageNew->gcpRealmTermsHiWat = 0;
		StorageNew->gcpRealmTermsLoWat = 4294967295;
		StorageNew->gcpRealmRowStatus = 0;
		StorageNew->gcpRealmRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpRealmTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpRealmTable_data *gcpRealmTable_duplicate(struct gcpRealmTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpRealmTable_data *
gcpRealmTable_duplicate(struct gcpRealmTable_data *thedata)
{
	struct gcpRealmTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpRealmTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpRealmTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpRealmTable_id = thedata->gcpRealmTable_id;
		StorageNew->gcpMsId = thedata->gcpMsId;
		StorageNew->gcpMgId = thedata->gcpMgId;
		StorageNew->gcpRealmId = thedata->gcpRealmId;
		if (!(StorageNew->gcpRealmString = malloc(thedata->gcpRealmStringLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpRealmString, thedata->gcpRealmString, thedata->gcpRealmStringLen);
		StorageNew->gcpRealmStringLen = thedata->gcpRealmStringLen;
		StorageNew->gcpRealmString[StorageNew->gcpRealmStringLen] = 0;
		StorageNew->gcpRealmTermsMax = thedata->gcpRealmTermsMax;
		StorageNew->gcpRealmTermsCurrent = thedata->gcpRealmTermsCurrent;
		StorageNew->gcpRealmTermsHiWat = thedata->gcpRealmTermsHiWat;
		StorageNew->gcpRealmTermsLoWat = thedata->gcpRealmTermsLoWat;
		StorageNew->gcpRealmRowStatus = thedata->gcpRealmRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpRealmTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpRealmTable_destroy(struct gcpRealmTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpRealmTable_destroy(struct gcpRealmTable_data **thedata)
{
	struct gcpRealmTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpRealmTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpRealmString);
		StorageDel->gcpRealmStringLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpRealmTable_add(struct gcpRealmTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpRealmTable table data set.
 *
 * Adds a table row structure to the gcpRealmTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpRealmTable_add(struct gcpRealmTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpRealmTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMsId, sizeof(thedata->gcpMsId));
		/* gcpMgId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMgId, sizeof(thedata->gcpMgId));
		/* gcpRealmId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpRealmId, sizeof(thedata->gcpRealmId));
		header_complex_add_data(&gcpRealmTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpRealmTable_del(struct gcpRealmTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpRealmTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpRealmTable_del(struct gcpRealmTable_data *thedata)
{
	struct gcpRealmTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpRealmTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpRealmTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpRealmTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpRealmTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpRealmTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpRealmTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpRealmTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpRealmTable_data *StorageTmp = gcpRealmTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpRealmTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMgId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpRealmId, &tmpsize);
	SNMP_FREE(StorageTmp->gcpRealmString);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpRealmString, &StorageTmp->gcpRealmStringLen);
	if (StorageTmp->gcpRealmString == NULL) {
		config_perror("invalid specification for gcpRealmString");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpRealmTermsMax, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->gcpRealmTermsCurrent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->gcpRealmTermsHiWat, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->gcpRealmTermsLoWat, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpRealmRowStatus, &tmpsize);
	gcpRealmTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpRealmTable(): store configuraiton file for gcpRealmTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpRealmTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpRealmTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpRealmTable: storing data...  "));
	refresh_gcpRealmTable(1);
	(void) tmpsize;
	for (hcindex = gcpRealmTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpRealmTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpRealmTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMgId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpRealmId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpRealmString, &StorageTmp->gcpRealmStringLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpRealmTermsMax, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->gcpRealmTermsCurrent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->gcpRealmTermsHiWat, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->gcpRealmTermsLoWat, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpRealmRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpInterfaceTable_data *gcpInterfaceTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpInterfaceTable table.
 *
 * Creates a new gcpInterfaceTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpInterfaceTable_data *
gcpInterfaceTable_create(void)
{
	struct gcpInterfaceTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpInterfaceTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpInterfaceTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpMsId = 0;
		StorageNew->gcpInterfaceIfindex = 0;
		StorageNew->gcpInterfaceMgId = 0;
		StorageNew->gcpInterfaceType = 0;
		StorageNew->gcpInterfaceRealm = 0;
		if ((StorageNew->gcpInterfaceTermId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpInterfaceTermIdLen = 0;
		StorageNew->gcpInterfaceTermId[StorageNew->gcpInterfaceTermIdLen] = 0;
		if ((StorageNew->gcpInterfaceTermPath = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpInterfaceTermPathLen = 0;
		StorageNew->gcpInterfaceTermPath[StorageNew->gcpInterfaceTermPathLen] = 0;
		StorageNew->gcpInterfaceRowStatus = 0;
		StorageNew->gcpInterfaceRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpInterfaceTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpInterfaceTable_data *gcpInterfaceTable_duplicate(struct gcpInterfaceTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpInterfaceTable_data *
gcpInterfaceTable_duplicate(struct gcpInterfaceTable_data *thedata)
{
	struct gcpInterfaceTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpInterfaceTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpInterfaceTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpInterfaceTable_id = thedata->gcpInterfaceTable_id;
		StorageNew->gcpMsId = thedata->gcpMsId;
		StorageNew->gcpInterfaceId = thedata->gcpInterfaceId;
		StorageNew->gcpInterfaceIfindex = thedata->gcpInterfaceIfindex;
		StorageNew->gcpInterfaceMgId = thedata->gcpInterfaceMgId;
		StorageNew->gcpInterfaceType = thedata->gcpInterfaceType;
		StorageNew->gcpInterfaceRealm = thedata->gcpInterfaceRealm;
		if (!(StorageNew->gcpInterfaceTermId = malloc(thedata->gcpInterfaceTermIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpInterfaceTermId, thedata->gcpInterfaceTermId, thedata->gcpInterfaceTermIdLen);
		StorageNew->gcpInterfaceTermIdLen = thedata->gcpInterfaceTermIdLen;
		StorageNew->gcpInterfaceTermId[StorageNew->gcpInterfaceTermIdLen] = 0;
		if (!(StorageNew->gcpInterfaceTermPath = malloc(thedata->gcpInterfaceTermPathLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpInterfaceTermPath, thedata->gcpInterfaceTermPath, thedata->gcpInterfaceTermPathLen);
		StorageNew->gcpInterfaceTermPathLen = thedata->gcpInterfaceTermPathLen;
		StorageNew->gcpInterfaceTermPath[StorageNew->gcpInterfaceTermPathLen] = 0;
		StorageNew->gcpInterfaceRowStatus = thedata->gcpInterfaceRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpInterfaceTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpInterfaceTable_destroy(struct gcpInterfaceTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpInterfaceTable_destroy(struct gcpInterfaceTable_data **thedata)
{
	struct gcpInterfaceTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpInterfaceTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpInterfaceTermId);
		StorageDel->gcpInterfaceTermIdLen = 0;
		SNMP_FREE(StorageDel->gcpInterfaceTermPath);
		StorageDel->gcpInterfaceTermPathLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpInterfaceTable_add(struct gcpInterfaceTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpInterfaceTable table data set.
 *
 * Adds a table row structure to the gcpInterfaceTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpInterfaceTable_add(struct gcpInterfaceTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpInterfaceTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMsId, sizeof(thedata->gcpMsId));
		/* gcpInterfaceId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpInterfaceId, sizeof(thedata->gcpInterfaceId));
		header_complex_add_data(&gcpInterfaceTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpInterfaceTable_del(struct gcpInterfaceTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpInterfaceTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpInterfaceTable_del(struct gcpInterfaceTable_data *thedata)
{
	struct gcpInterfaceTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpInterfaceTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpInterfaceTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpInterfaceTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpInterfaceTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpInterfaceTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpInterfaceTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpInterfaceTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpInterfaceTable_data *StorageTmp = gcpInterfaceTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpInterfaceTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpInterfaceId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpInterfaceIfindex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpInterfaceMgId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpInterfaceType, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpInterfaceRealm, &tmpsize);
	SNMP_FREE(StorageTmp->gcpInterfaceTermId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpInterfaceTermId, &StorageTmp->gcpInterfaceTermIdLen);
	if (StorageTmp->gcpInterfaceTermId == NULL) {
		config_perror("invalid specification for gcpInterfaceTermId");
		return;
	}
	SNMP_FREE(StorageTmp->gcpInterfaceTermPath);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpInterfaceTermPath, &StorageTmp->gcpInterfaceTermPathLen);
	if (StorageTmp->gcpInterfaceTermPath == NULL) {
		config_perror("invalid specification for gcpInterfaceTermPath");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpInterfaceRowStatus, &tmpsize);
	gcpInterfaceTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpInterfaceTable(): store configuraiton file for gcpInterfaceTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpInterfaceTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpInterfaceTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpInterfaceTable: storing data...  "));
	refresh_gcpInterfaceTable(1);
	(void) tmpsize;
	for (hcindex = gcpInterfaceTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpInterfaceTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpInterfaceTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpInterfaceId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpInterfaceIfindex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpInterfaceMgId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpInterfaceType, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpInterfaceRealm, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpInterfaceTermId, &StorageTmp->gcpInterfaceTermIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpInterfaceTermPath, &StorageTmp->gcpInterfaceTermPathLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpInterfaceRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct gcpAddressTable_data *gcpAddressTable_create(void)
 * @brief create a fresh data structure representing a new row in the gcpAddressTable table.
 *
 * Creates a new gcpAddressTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct gcpAddressTable_data *
gcpAddressTable_create(void)
{
	struct gcpAddressTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpAddressTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpAddressTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->gcpMsId = 0;
		StorageNew->gcpMgId = 0;
		StorageNew->gcpRealmId = 0;
		StorageNew->gcpInterfaceId = 0;
		StorageNew->gcpAddressInterface = 0;
		StorageNew->gcpAddressType = 0;
		if ((StorageNew->gcpAddressAddr = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpAddressAddrLen = 0;
		StorageNew->gcpAddressAddr[StorageNew->gcpAddressAddrLen] = 0;
		if ((StorageNew->gcpAddressPortRanges = malloc(1)) == NULL)
			goto nomem;
		StorageNew->gcpAddressPortRangesLen = 0;
		StorageNew->gcpAddressPortRanges[StorageNew->gcpAddressPortRangesLen] = 0;
		StorageNew->gcpAddressRowStatus = 0;
		StorageNew->gcpAddressRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	gcpAddressTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct gcpAddressTable_data *gcpAddressTable_duplicate(struct gcpAddressTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct gcpAddressTable_data *
gcpAddressTable_duplicate(struct gcpAddressTable_data *thedata)
{
	struct gcpAddressTable_data *StorageNew = SNMP_MALLOC_STRUCT(gcpAddressTable_data);

	DEBUGMSGTL(("gcpMIB", "gcpAddressTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->gcpAddressTable_id = thedata->gcpAddressTable_id;
		StorageNew->gcpMsId = thedata->gcpMsId;
		StorageNew->gcpMgId = thedata->gcpMgId;
		StorageNew->gcpRealmId = thedata->gcpRealmId;
		StorageNew->gcpInterfaceId = thedata->gcpInterfaceId;
		StorageNew->gcpAddressId = thedata->gcpAddressId;
		StorageNew->gcpAddressInterface = thedata->gcpAddressInterface;
		StorageNew->gcpAddressType = thedata->gcpAddressType;
		if (!(StorageNew->gcpAddressAddr = malloc(thedata->gcpAddressAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpAddressAddr, thedata->gcpAddressAddr, thedata->gcpAddressAddrLen);
		StorageNew->gcpAddressAddrLen = thedata->gcpAddressAddrLen;
		StorageNew->gcpAddressAddr[StorageNew->gcpAddressAddrLen] = 0;
		if (!(StorageNew->gcpAddressPortRanges = malloc(thedata->gcpAddressPortRangesLen + 1)))
			goto destroy;
		memcpy(StorageNew->gcpAddressPortRanges, thedata->gcpAddressPortRanges, thedata->gcpAddressPortRangesLen);
		StorageNew->gcpAddressPortRangesLen = thedata->gcpAddressPortRangesLen;
		StorageNew->gcpAddressPortRanges[StorageNew->gcpAddressPortRangesLen] = 0;
		StorageNew->gcpAddressRowStatus = thedata->gcpAddressRowStatus;
	}
      done:
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	gcpAddressTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int gcpAddressTable_destroy(struct gcpAddressTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
gcpAddressTable_destroy(struct gcpAddressTable_data **thedata)
{
	struct gcpAddressTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpAddressTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->gcpAddressAddr);
		StorageDel->gcpAddressAddrLen = 0;
		SNMP_FREE(StorageDel->gcpAddressPortRanges);
		StorageDel->gcpAddressPortRangesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpAddressTable_add(struct gcpAddressTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the gcpAddressTable table data set.
 *
 * Adds a table row structure to the gcpAddressTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
gcpAddressTable_add(struct gcpAddressTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("gcpMIB", "gcpAddressTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* gcpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMsId, sizeof(thedata->gcpMsId));
		/* gcpMgId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpMgId, sizeof(thedata->gcpMgId));
		/* gcpRealmId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpRealmId, sizeof(thedata->gcpRealmId));
		/* gcpInterfaceId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpInterfaceId, sizeof(thedata->gcpInterfaceId));
		/* gcpAddressId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->gcpAddressId, sizeof(thedata->gcpAddressId));
		header_complex_add_data(&gcpAddressTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("gcpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int gcpAddressTable_del(struct gcpAddressTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the gcpAddressTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
gcpAddressTable_del(struct gcpAddressTable_data *thedata)
{
	struct gcpAddressTable_data *StorageDel;

	DEBUGMSGTL(("gcpMIB", "gcpAddressTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(gcpAddressTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&gcpAddressTableStorage, hciptr);
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_gcpAddressTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for gcpAddressTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case gcpAddressTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_gcpAddressTable(const char *token, char *line)
{
	size_t tmpsize;
	struct gcpAddressTable_data *StorageTmp = gcpAddressTable_create();

	DEBUGMSGTL(("gcpMIB", "parse_gcpAddressTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpMgId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpRealmId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpInterfaceId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpAddressId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->gcpAddressInterface, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpAddressType, &tmpsize);
	SNMP_FREE(StorageTmp->gcpAddressAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpAddressAddr, &StorageTmp->gcpAddressAddrLen);
	if (StorageTmp->gcpAddressAddr == NULL) {
		config_perror("invalid specification for gcpAddressAddr");
		return;
	}
	SNMP_FREE(StorageTmp->gcpAddressPortRanges);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->gcpAddressPortRanges, &StorageTmp->gcpAddressPortRangesLen);
	if (StorageTmp->gcpAddressPortRanges == NULL) {
		config_perror("invalid specification for gcpAddressPortRanges");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->gcpAddressRowStatus, &tmpsize);
	gcpAddressTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/*
 * store_gcpAddressTable(): store configuraiton file for gcpAddressTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_gcpAddressTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct gcpAddressTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("gcpMIB", "store_gcpAddressTable: storing data...  "));
	refresh_gcpAddressTable(1);
	(void) tmpsize;
	for (hcindex = gcpAddressTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct gcpAddressTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "gcpAddressTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpMgId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpRealmId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpInterfaceId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpAddressId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->gcpAddressInterface, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpAddressType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpAddressAddr, &StorageTmp->gcpAddressAddrLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->gcpAddressPortRanges, &StorageTmp->gcpAddressPortRangesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->gcpAddressRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int activate_gcpMsTable_row(struct gcpMsTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpMsTable_row(struct gcpMsTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpMsTable_row(struct gcpMsTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpMsTable_row(struct gcpMsTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpMgTable_row(struct gcpMgTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpMgTable_row(struct gcpMgTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpMgTable_row(struct gcpMgTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpMgTable_row(struct gcpMgTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int check_gcpMsTable_row(struct gcpMsTable_data *StorageTmp, struct gcpMsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpMsTable_row(struct gcpMsTable_data *StorageTmp, struct gcpMsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpMsTable_row(struct gcpMsTable_data *StorageTmp, struct gcpMsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpMsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpMsTable_row(struct gcpMsTable_data *StorageTmp, struct gcpMsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpMsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpMsTable_row(struct gcpMsTable_data *StorageTmp, struct gcpMsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpMsTable_row(struct gcpMsTable_data *StorageTmp, struct gcpMsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpMsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpMsTable_row(struct gcpMsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpMsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpMsTable_data *
refresh_gcpMsTable_row(struct gcpMsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpMsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpMsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpMsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpMsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpMsTable(int force)
{
	if (!force && gcpMsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpMsTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpMsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpMsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpMsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpMsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpMsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpMsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpMsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpMsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPMSNAME:	/* Create */
		*write_method = write_gcpMsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMsNameLen;
		rval = (u_char *) StorageTmp->gcpMsName;
		break;
	case (u_char) GCPMSALARMSTATUS:	/* Create */
		*write_method = write_gcpMsAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMsAlarmStatusLen;
		rval = (u_char *) StorageTmp->gcpMsAlarmStatus;
		break;
	case (u_char) GCPMSOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMsOperationalState);
		rval = (u_char *) &StorageTmp->gcpMsOperationalState;
		break;
	case (u_char) GCPMSUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMsUsageState);
		rval = (u_char *) &StorageTmp->gcpMsUsageState;
		break;
	case (u_char) GCPMSMANAGEDELEMENTTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMsManagedElementTypeLen;
		rval = (u_char *) StorageTmp->gcpMsManagedElementType;
		break;
	case (u_char) GCPMSMODELCODE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMsModelCodeLen;
		rval = (u_char *) StorageTmp->gcpMsModelCode;
		break;
	case (u_char) GCPMSVENDORNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMsVendorNameLen;
		rval = (u_char *) StorageTmp->gcpMsVendorName;
		break;
	case (u_char) GCPMSUSERLABEL:	/* Create */
		*write_method = write_gcpMsUserLabel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMsUserLabelLen;
		rval = (u_char *) StorageTmp->gcpMsUserLabel;
		break;
	case (u_char) GCPMSVERSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMsVersionLen;
		rval = (u_char *) StorageTmp->gcpMsVersion;
		break;
	case (u_char) GCPMSASAPROFILEPOINTER:	/* Create */
		*write_method = write_gcpMsAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMsAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->gcpMsAsaProfilePointer;
		break;
	case (u_char) GCPMSNETWORKELEMENTALIASES:	/* Create */
		*write_method = write_gcpMsNetworkElementAliases;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMsNetworkElementAliasesLen;
		rval = (u_char *) StorageTmp->gcpMsNetworkElementAliases;
		break;
	case (u_char) GCPMSROWSTATUS:	/* Create */
		*write_method = write_gcpMsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMsRowStatus);
		rval = (u_char *) &StorageTmp->gcpMsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpMgTable_row(struct gcpMgTable_data *StorageTmp, struct gcpMgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpMgTable_row(struct gcpMgTable_data *StorageTmp, struct gcpMgTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpMgTable_row(struct gcpMgTable_data *StorageTmp, struct gcpMgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpMgTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpMgTable_row(struct gcpMgTable_data *StorageTmp, struct gcpMgTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpMgTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpMgTable_row(struct gcpMgTable_data *StorageTmp, struct gcpMgTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpMgTable_row(struct gcpMgTable_data *StorageTmp, struct gcpMgTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpMgTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpMgTable_row(struct gcpMgTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpMgTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpMgTable_data *
refresh_gcpMgTable_row(struct gcpMgTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpMgTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpMgTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpMgTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpMgTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpMgTable(int force)
{
	if (!force && gcpMgTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpMgTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpMgTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpMgTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpMgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpMgTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpMgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpMgTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpMgTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpMgTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPMGLOCATION:	/* Create */
		*write_method = write_gcpMgLocation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgLocation);
		rval = (u_char *) &StorageTmp->gcpMgLocation;
		break;
	case (u_char) GCPMGNAME:	/* Create */
		*write_method = write_gcpMgName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgNameLen;
		rval = (u_char *) StorageTmp->gcpMgName;
		break;
	case (u_char) GCPMGDOMAINNAME:	/* Create */
		*write_method = write_gcpMgDomainName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgDomainNameLen;
		rval = (u_char *) StorageTmp->gcpMgDomainName;
		break;
	case (u_char) GCPMGDEVICENAME:	/* Create */
		*write_method = write_gcpMgDeviceName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgDeviceNameLen;
		rval = (u_char *) StorageTmp->gcpMgDeviceName;
		break;
	case (u_char) GCPMGMTPADDRESS:	/* Create */
		*write_method = write_gcpMgMtpAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgMtpAddressLen;
		rval = (u_char *) StorageTmp->gcpMgMtpAddress;
		break;
	case (u_char) GCPMGADMINSTATE:	/* Create */
		*write_method = write_gcpMgAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgAdminState);
		rval = (u_char *) &StorageTmp->gcpMgAdminState;
		break;
	case (u_char) GCPMGOPERSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgOperState);
		rval = (u_char *) &StorageTmp->gcpMgOperState;
		break;
	case (u_char) GCPMGALARMSTATUS:	/* Create */
		*write_method = write_gcpMgAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgAlarmStatusLen;
		rval = (u_char *) StorageTmp->gcpMgAlarmStatus;
		break;
	case (u_char) GCPMGASAPROFILEPOINTER:	/* Create */
		*write_method = write_gcpMgAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->gcpMgAsaProfilePointer;
		break;
	case (u_char) GCPMGUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgUsageState);
		rval = (u_char *) &StorageTmp->gcpMgUsageState;
		break;
	case (u_char) GCPMGAVAILSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgAvailStatusLen;
		rval = (u_char *) StorageTmp->gcpMgAvailStatus;
		break;
	case (u_char) GCPMGPROCSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgProcStatusLen;
		rval = (u_char *) StorageTmp->gcpMgProcStatus;
		break;
	case (u_char) GCPMGPG:	/* Create */
		*write_method = write_gcpMgPg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgPg);
		rval = (u_char *) &StorageTmp->gcpMgPg;
		break;
	case (u_char) GCPMGSTANDBYSTATUS:	/* Create */
		*write_method = write_gcpMgStandbyStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgStandbyStatus);
		rval = (u_char *) &StorageTmp->gcpMgStandbyStatus;
		break;
	case (u_char) GCPMGROWSTATUS:	/* Create */
		*write_method = write_gcpMgRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgRowStatus);
		rval = (u_char *) &StorageTmp->gcpMgRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp, struct gcpMgcTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp, struct gcpMgcTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp, struct gcpMgcTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpMgcTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp, struct gcpMgcTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpMgcTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp, struct gcpMgcTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp, struct gcpMgcTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpMgcTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpMgcTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpMgcTable_data *
refresh_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpMgcTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpMgcTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpMgcTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpMgcTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpMgcTable(int force)
{
	if (!force && gcpMgcTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpMgcTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpMgcTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpMgcTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpMgcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpMgcTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpMgcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpMgcTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpMgcTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpMgcTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPMGCLOCATION:	/* Create */
		*write_method = write_gcpMgcLocation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgcLocation);
		rval = (u_char *) &StorageTmp->gcpMgcLocation;
		break;
	case (u_char) GCPMGCNAME:	/* Create */
		*write_method = write_gcpMgcName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgcNameLen;
		rval = (u_char *) StorageTmp->gcpMgcName;
		break;
	case (u_char) GCPMGCDOMAINNAME:	/* Create */
		*write_method = write_gcpMgcDomainName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgcDomainNameLen;
		rval = (u_char *) StorageTmp->gcpMgcDomainName;
		break;
	case (u_char) GCPMGCDEVICENAME:	/* Create */
		*write_method = write_gcpMgcDeviceName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgcDeviceNameLen;
		rval = (u_char *) StorageTmp->gcpMgcDeviceName;
		break;
	case (u_char) GCPMGCMTPADDRESS:	/* Create */
		*write_method = write_gcpMgcMtpAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgcMtpAddressLen;
		rval = (u_char *) StorageTmp->gcpMgcMtpAddress;
		break;
	case (u_char) GCPMGCADMINSTATE:	/* Create */
		*write_method = write_gcpMgcAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgcAdminState);
		rval = (u_char *) &StorageTmp->gcpMgcAdminState;
		break;
	case (u_char) GCPMGCOPERSTATE:	/* Create */
		*write_method = write_gcpMgcOperState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgcOperState);
		rval = (u_char *) &StorageTmp->gcpMgcOperState;
		break;
	case (u_char) GCPMGCALARMSTATUS:	/* Create */
		*write_method = write_gcpMgcAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgcAlarmStatusLen;
		rval = (u_char *) StorageTmp->gcpMgcAlarmStatus;
		break;
	case (u_char) GCPMGCASAPROFILEPOINTER:	/* Create */
		*write_method = write_gcpMgcAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgcAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->gcpMgcAsaProfilePointer;
		break;
	case (u_char) GCPMGCUSAGESTATE:	/* Create */
		*write_method = write_gcpMgcUsageState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgcUsageState);
		rval = (u_char *) &StorageTmp->gcpMgcUsageState;
		break;
	case (u_char) GCPMGCAVAILSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgcAvailStatusLen;
		rval = (u_char *) StorageTmp->gcpMgcAvailStatus;
		break;
	case (u_char) GCPMGCPROCSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpMgcProcStatusLen;
		rval = (u_char *) StorageTmp->gcpMgcProcStatus;
		break;
	case (u_char) GCPMGCPG:	/* Create */
		*write_method = write_gcpMgcPg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgcPg);
		rval = (u_char *) &StorageTmp->gcpMgcPg;
		break;
	case (u_char) GCPMGCSTANDBYSTATUS:	/* Create */
		*write_method = write_gcpMgcStandbyStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgcStandbyStatus);
		rval = (u_char *) &StorageTmp->gcpMgcStandbyStatus;
		break;
	case (u_char) GCPMGCROWSTATUS:	/* Create */
		*write_method = write_gcpMgcRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpMgcRowStatus);
		rval = (u_char *) &StorageTmp->gcpMgcRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp, struct gcpLinkageTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp, struct gcpLinkageTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp, struct gcpLinkageTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpLinkageTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp, struct gcpLinkageTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpLinkageTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp, struct gcpLinkageTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp, struct gcpLinkageTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpLinkageTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpLinkageTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpLinkageTable_data *
refresh_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpLinkageTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpLinkageTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpLinkageTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpLinkageTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpLinkageTable(int force)
{
	if (!force && gcpLinkageTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpLinkageTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpLinkageTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpLinkageTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpLinkageTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpLinkageTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpLinkageTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpLinkageTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpLinkageTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpLinkageTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPLINKAGETYPE:	/* Create */
		*write_method = write_gcpLinkageType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageType);
		rval = (u_char *) &StorageTmp->gcpLinkageType;
		break;
	case (u_char) GCPLINKAGEMGCMASTER:	/* Create */
		*write_method = write_gcpLinkageMgcMaster;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageMgcMaster);
		rval = (u_char *) &StorageTmp->gcpLinkageMgcMaster;
		break;
	case (u_char) GCPLINKAGEMGCADDRESS:	/* Create */
		*write_method = write_gcpLinkageMgcAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpLinkageMgcAddressLen;
		rval = (u_char *) StorageTmp->gcpLinkageMgcAddress;
		break;
	case (u_char) GCPLINKAGEMGADDRESS:	/* Create */
		*write_method = write_gcpLinkageMgAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpLinkageMgAddressLen;
		rval = (u_char *) StorageTmp->gcpLinkageMgAddress;
		break;
	case (u_char) GCPLINKAGEMGCIDENT:	/* Create */
		*write_method = write_gcpLinkageMgcIdent;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageMgcIdent);
		rval = (u_char *) &StorageTmp->gcpLinkageMgcIdent;
		break;
	case (u_char) GCPLINKAGEMGIDENT:	/* Create */
		*write_method = write_gcpLinkageMgIdent;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageMgIdent);
		rval = (u_char *) &StorageTmp->gcpLinkageMgIdent;
		break;
	case (u_char) GCPLINKAGEPROFILE:	/* Create */
		*write_method = write_gcpLinkageProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpLinkageProfileLen * sizeof(oid);
		rval = (u_char *) StorageTmp->gcpLinkageProfile;
		break;
	case (u_char) GCPLINKAGEPROTOCOL:	/* Create */
		*write_method = write_gcpLinkageProtocol;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpLinkageProtocolLen * sizeof(oid);
		rval = (u_char *) StorageTmp->gcpLinkageProtocol;
		break;
	case (u_char) GCPLINKAGEENCODING:	/* Create */
		*write_method = write_gcpLinkageEncoding;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageEncoding);
		rval = (u_char *) &StorageTmp->gcpLinkageEncoding;
		break;
	case (u_char) GCPLINKAGEAUTHACCESS:	/* Create */
		*write_method = write_gcpLinkageAuthAccess;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpLinkageAuthAccessLen;
		rval = (u_char *) StorageTmp->gcpLinkageAuthAccess;
		break;
	case (u_char) GCPLINKAGEADMINSTATE:	/* Create */
		*write_method = write_gcpLinkageAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageAdminState);
		rval = (u_char *) &StorageTmp->gcpLinkageAdminState;
		break;
	case (u_char) GCPLINKAGEOPERSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageOperState);
		rval = (u_char *) &StorageTmp->gcpLinkageOperState;
		break;
	case (u_char) GCPLINKAGEPROCSTATUS:	/* Create */
		*write_method = write_gcpLinkageProcStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpLinkageProcStatusLen;
		rval = (u_char *) StorageTmp->gcpLinkageProcStatus;
		break;
	case (u_char) GCPLINKAGEAVAILSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpLinkageAvailStatusLen;
		rval = (u_char *) StorageTmp->gcpLinkageAvailStatus;
		break;
	case (u_char) GCPLINKAGEAUTHENTICATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageAuthentication);
		rval = (u_char *) &StorageTmp->gcpLinkageAuthentication;
		break;
	case (u_char) GCPLINKAGEMIT:	/* Create */
		*write_method = write_gcpLinkageMit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageMit);
		rval = (u_char *) &StorageTmp->gcpLinkageMit;
		break;
	case (u_char) GCPLINKAGEROWSTATUS:	/* Create */
		*write_method = write_gcpLinkageRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpLinkageRowStatus);
		rval = (u_char *) &StorageTmp->gcpLinkageRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp, struct gcpUdpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp, struct gcpUdpProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp, struct gcpUdpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpUdpProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp, struct gcpUdpProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpUdpProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp, struct gcpUdpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp, struct gcpUdpProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpUdpProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpUdpProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpUdpProfileTable_data *
refresh_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpUdpProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpUdpProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpUdpProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpUdpProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpUdpProfileTable(int force)
{
	if (!force && gcpUdpProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpUdpProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpUdpProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpUdpProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpUdpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpUdpProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpUdpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpUdpProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpUdpProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpUdpProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPUDPCHECKSUM:	/* Create */
		*write_method = write_gcpUdpChecksum;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpUdpChecksum);
		rval = (u_char *) &StorageTmp->gcpUdpChecksum;
		break;
	case (u_char) GCPUDPROWSTATUS:	/* Create */
		*write_method = write_gcpUdpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpUdpRowStatus);
		rval = (u_char *) &StorageTmp->gcpUdpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp, struct gcpTcpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp, struct gcpTcpProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp, struct gcpTcpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpTcpProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp, struct gcpTcpProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpTcpProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp, struct gcpTcpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp, struct gcpTcpProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpTcpProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpTcpProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpTcpProfileTable_data *
refresh_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpTcpProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpTcpProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpTcpProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpTcpProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpTcpProfileTable(int force)
{
	if (!force && gcpTcpProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpTcpProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpTcpProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpTcpProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpTcpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpTcpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpTcpProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpTcpProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpTcpProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPTCPNODELAY:	/* Create */
		*write_method = write_gcpTcpNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpTcpNoDelay);
		rval = (u_char *) &StorageTmp->gcpTcpNoDelay;
		break;
	case (u_char) GCPTCPMAXSEG:	/* Create */
		*write_method = write_gcpTcpMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpTcpMaxseg);
		rval = (u_char *) &StorageTmp->gcpTcpMaxseg;
		break;
	case (u_char) GCPTCPKEEPALIVE:	/* Create */
		*write_method = write_gcpTcpKeepAlive;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpTcpKeepAlive);
		rval = (u_char *) &StorageTmp->gcpTcpKeepAlive;
		break;
	case (u_char) GCPTCPKEEPIDLE:	/* Create */
		*write_method = write_gcpTcpKeepIdle;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpTcpKeepIdle);
		rval = (u_char *) &StorageTmp->gcpTcpKeepIdle;
		break;
	case (u_char) GCPTCPKEEPALIVEITVL:	/* Create */
		*write_method = write_gcpTcpKeepAliveItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpTcpKeepAliveItvl);
		rval = (u_char *) &StorageTmp->gcpTcpKeepAliveItvl;
		break;
	case (u_char) GCPTCPKEEPCOUNT:	/* Create */
		*write_method = write_gcpTcpKeepCount;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpTcpKeepCount);
		rval = (u_char *) &StorageTmp->gcpTcpKeepCount;
		break;
	case (u_char) GCPTCPSYNRETRANS:	/* Create */
		*write_method = write_gcpTcpSynRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpTcpSynRetrans);
		rval = (u_char *) &StorageTmp->gcpTcpSynRetrans;
		break;
	case (u_char) GCPTCPWINDOWCLAMP:	/* Create */
		*write_method = write_gcpTcpWindowClamp;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpTcpWindowClamp);
		rval = (u_char *) &StorageTmp->gcpTcpWindowClamp;
		break;
	case (u_char) GCPTCPROWSTATUS:	/* Create */
		*write_method = write_gcpTcpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpTcpRowStatus);
		rval = (u_char *) &StorageTmp->gcpTcpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp, struct gcpSctpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp, struct gcpSctpProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp, struct gcpSctpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpSctpProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp, struct gcpSctpProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpSctpProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp, struct gcpSctpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp, struct gcpSctpProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpSctpProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpSctpProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpSctpProfileTable_data *
refresh_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpSctpProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpSctpProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpSctpProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpSctpProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpSctpProfileTable(int force)
{
	if (!force && gcpSctpProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpSctpProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpSctpProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpSctpProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpSctpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpSctpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpSctpProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpSctpProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpSctpProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPSCTPNODELAY:	/* Create */
		*write_method = write_gcpSctpNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpNoDelay);
		rval = (u_char *) &StorageTmp->gcpSctpNoDelay;
		break;
	case (u_char) GCPSCTPMAXSEG:	/* Create */
		*write_method = write_gcpSctpMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpMaxseg);
		rval = (u_char *) &StorageTmp->gcpSctpMaxseg;
		break;
	case (u_char) GCPSCTPHEARTBEATITVL:	/* Create */
		*write_method = write_gcpSctpHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpHeartbeatItvl);
		rval = (u_char *) &StorageTmp->gcpSctpHeartbeatItvl;
		break;
	case (u_char) GCPSCTPHEARBEAT:	/* Create */
		*write_method = write_gcpSctpHearbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpHearbeat);
		rval = (u_char *) &StorageTmp->gcpSctpHearbeat;
		break;
	case (u_char) GCPSCTPRTOINITIAL:	/* Create */
		*write_method = write_gcpSctpRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpRtoInitial);
		rval = (u_char *) &StorageTmp->gcpSctpRtoInitial;
		break;
	case (u_char) GCPSCTPRTOMIN:	/* Create */
		*write_method = write_gcpSctpRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpRtoMin);
		rval = (u_char *) &StorageTmp->gcpSctpRtoMin;
		break;
	case (u_char) GCPSCTPRTOMAX:	/* Create */
		*write_method = write_gcpSctpRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpRtoMax);
		rval = (u_char *) &StorageTmp->gcpSctpRtoMax;
		break;
	case (u_char) GCPSCTPPATHMAXRETRANS:	/* Create */
		*write_method = write_gcpSctpPathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpPathMaxRetrans);
		rval = (u_char *) &StorageTmp->gcpSctpPathMaxRetrans;
		break;
	case (u_char) GCPSCTPCOOKIELIFE:	/* Create */
		*write_method = write_gcpSctpCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpCookieLife);
		rval = (u_char *) &StorageTmp->gcpSctpCookieLife;
		break;
	case (u_char) GCPSCTPCOOKIEINC:	/* Create */
		*write_method = write_gcpSctpCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpCookieInc);
		rval = (u_char *) &StorageTmp->gcpSctpCookieInc;
		break;
	case (u_char) GCPSCTPMAXINITRETRIES:	/* Create */
		*write_method = write_gcpSctpMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpMaxInitRetries);
		rval = (u_char *) &StorageTmp->gcpSctpMaxInitRetries;
		break;
	case (u_char) GCPSCTPMAXBURST:	/* Create */
		*write_method = write_gcpSctpMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpMaxBurst);
		rval = (u_char *) &StorageTmp->gcpSctpMaxBurst;
		break;
	case (u_char) GCPSCTPASSOCMAXRETRANS:	/* Create */
		*write_method = write_gcpSctpAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->gcpSctpAssocMaxRetrans;
		break;
	case (u_char) GCPSCTPSACKDELAY:	/* Create */
		*write_method = write_gcpSctpSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpSackDelay);
		rval = (u_char *) &StorageTmp->gcpSctpSackDelay;
		break;
	case (u_char) GCPSCTPLIFETIME:	/* Create */
		*write_method = write_gcpSctpLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpLifetime);
		rval = (u_char *) &StorageTmp->gcpSctpLifetime;
		break;
	case (u_char) GCPSCTPROWSTATUS:	/* Create */
		*write_method = write_gcpSctpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSctpRowStatus);
		rval = (u_char *) &StorageTmp->gcpSctpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp, struct gcpProtGroupTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp, struct gcpProtGroupTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp, struct gcpProtGroupTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpProtGroupTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp, struct gcpProtGroupTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpProtGroupTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp, struct gcpProtGroupTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp, struct gcpProtGroupTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpProtGroupTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpProtGroupTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpProtGroupTable_data *
refresh_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpProtGroupTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpProtGroupTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpProtGroupTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpProtGroupTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpProtGroupTable(int force)
{
	if (!force && gcpProtGroupTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpProtGroupTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpProtGroupTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpProtGroupTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpProtGroupTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpProtGroupTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpProtGroupTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpProtGroupTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpProtGroupTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPPROTGROUPOPERSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupOperState);
		rval = (u_char *) &StorageTmp->gcpProtGroupOperState;
		break;
	case (u_char) GCPPROTGROUPAVAILSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpProtGroupAvailStatusLen;
		rval = (u_char *) StorageTmp->gcpProtGroupAvailStatus;
		break;
	case (u_char) GCPPROTGROUPTYPE:	/* Create */
		*write_method = write_gcpProtGroupType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupType);
		rval = (u_char *) &StorageTmp->gcpProtGroupType;
		break;
	case (u_char) GCPPROTGROUPREVERTIVE:	/* Create */
		*write_method = write_gcpProtGroupRevertive;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupRevertive);
		rval = (u_char *) &StorageTmp->gcpProtGroupRevertive;
		break;
	case (u_char) GCPPROTGROUPSBOLNUMBER:	/* Create */
		*write_method = write_gcpProtGroupSBOLNumber;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupSBOLNumber);
		rval = (u_char *) &StorageTmp->gcpProtGroupSBOLNumber;
		break;
	case (u_char) GCPPROTGROUPWAITTORESTORETIME:	/* Create */
		*write_method = write_gcpProtGroupWaitToRestoreTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupWaitToRestoreTime);
		rval = (u_char *) &StorageTmp->gcpProtGroupWaitToRestoreTime;
		break;
	case (u_char) GCPPROTGROUPSETTINGWINDOWTIME:	/* Create */
		*write_method = write_gcpProtGroupSettingWindowTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupSettingWindowTime);
		rval = (u_char *) &StorageTmp->gcpProtGroupSettingWindowTime;
		break;
	case (u_char) GCPPROTGROUPRELEASEINGWINDOWTIME:	/* Create */
		*write_method = write_gcpProtGroupReleaseingWindowTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupReleaseingWindowTime);
		rval = (u_char *) &StorageTmp->gcpProtGroupReleaseingWindowTime;
		break;
	case (u_char) GCPPROTGROUPHITSCOUNT:	/* Create */
		*write_method = write_gcpProtGroupHitsCount;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupHitsCount);
		rval = (u_char *) &StorageTmp->gcpProtGroupHitsCount;
		break;
	case (u_char) GCPPROTGROUPSWITCHTYPE:	/* Create */
		*write_method = write_gcpProtGroupSwitchType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupSwitchType);
		rval = (u_char *) &StorageTmp->gcpProtGroupSwitchType;
		break;
	case (u_char) GCPPROTGROUPPROTECTEDUNITS:	/* Create */
		*write_method = write_gcpProtGroupProtectedUnits;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpProtGroupProtectedUnitsLen;
		rval = (u_char *) StorageTmp->gcpProtGroupProtectedUnits;
		break;
	case (u_char) GCPPROTGROUPPROTECTINGUNITS:	/* Create */
		*write_method = write_gcpProtGroupProtectingUnits;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpProtGroupProtectingUnitsLen;
		rval = (u_char *) StorageTmp->gcpProtGroupProtectingUnits;
		break;
	case (u_char) GCPPROTGROUPINVOKEPROTECTION:	/* Create */
		*write_method = write_gcpProtGroupInvokeProtection;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupInvokeProtection);
		rval = (u_char *) &StorageTmp->gcpProtGroupInvokeProtection;
		break;
	case (u_char) GCPPROTGROUPRELEASEPROTECTION:	/* Create */
		*write_method = write_gcpProtGroupReleaseProtection;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupReleaseProtection);
		rval = (u_char *) &StorageTmp->gcpProtGroupReleaseProtection;
		break;
	case (u_char) GCPPROTGROUPROWSTATUS:	/* Create */
		*write_method = write_gcpProtGroupRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtGroupRowStatus);
		rval = (u_char *) &StorageTmp->gcpProtGroupRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp, struct gcpSbolTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp, struct gcpSbolTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp, struct gcpSbolTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpSbolTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp, struct gcpSbolTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpSbolTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp, struct gcpSbolTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp, struct gcpSbolTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpSbolTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpSbolTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpSbolTable_data *
refresh_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpSbolTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpSbolTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpSbolTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpSbolTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpSbolTable(int force)
{
	if (!force && gcpSbolTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpSbolTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpSbolTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpSbolTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpSbolTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpSbolTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpSbolTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpSbolTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpSbolTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpSbolTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPSBOLOBJECT:	/* Create */
		*write_method = write_gcpSbolObject;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpSbolObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->gcpSbolObject;
		break;
	case (u_char) GCPSBOLSTATUS:	/* Create */
		*write_method = write_gcpSbolStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpSbolStatus);
		rval = (u_char *) &StorageTmp->gcpSbolStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp, struct gcpProtUnitTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp, struct gcpProtUnitTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp, struct gcpProtUnitTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpProtUnitTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp, struct gcpProtUnitTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpProtUnitTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp, struct gcpProtUnitTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp, struct gcpProtUnitTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpProtUnitTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpProtUnitTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpProtUnitTable_data *
refresh_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpProtUnitTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpProtUnitTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpProtUnitTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpProtUnitTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpProtUnitTable(int force)
{
	if (!force && gcpProtUnitTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpProtUnitTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpProtUnitTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpProtUnitTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpProtUnitTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpProtUnitTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpProtUnitTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpProtUnitTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpProtUnitTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpProtUnitTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPPROTUNITPROTECTING:	/* Create */
		*write_method = write_gcpProtUnitProtecting;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtUnitProtecting);
		rval = (u_char *) &StorageTmp->gcpProtUnitProtecting;
		break;
	case (u_char) GCPPROTUNITRELIABLERESOURCEPOINTER:	/* Create */
		*write_method = write_gcpProtUnitReliableResourcePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpProtUnitReliableResourcePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->gcpProtUnitReliableResourcePointer;
		break;
	case (u_char) GCPPROTUNITUNRELIABLERESOURCEPOINTER:	/* Create */
		*write_method = write_gcpProtUnitUnreliableResourcePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpProtUnitUnreliableResourcePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->gcpProtUnitUnreliableResourcePointer;
		break;
	case (u_char) GCPPROTUNITPROTECTIONSTATUS:	/* Create */
		*write_method = write_gcpProtUnitProtectionStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpProtUnitProtectionStatusLen;
		rval = (u_char *) StorageTmp->gcpProtUnitProtectionStatus;
		break;
	case (u_char) GCPPROTUNITREQUESTSOURCE:	/* Create */
		*write_method = write_gcpProtUnitRequestSource;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtUnitRequestSource);
		rval = (u_char *) &StorageTmp->gcpProtUnitRequestSource;
		break;
	case (u_char) GCPPROTUNITSWITCHSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtUnitSwitchStatus);
		rval = (u_char *) &StorageTmp->gcpProtUnitSwitchStatus;
		break;
	case (u_char) GCPPROTUNITSWITCHDIRECTION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtUnitSwitchDirection);
		rval = (u_char *) &StorageTmp->gcpProtUnitSwitchDirection;
		break;
	case (u_char) GCPPROTUNITRELATEDUNIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtUnitRelatedUnit);
		rval = (u_char *) &StorageTmp->gcpProtUnitRelatedUnit;
		break;
	case (u_char) GCPPROTUNITAUTOSWITCHREASON:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtUnitAutoSwitchReason);
		rval = (u_char *) &StorageTmp->gcpProtUnitAutoSwitchReason;
		break;
	case (u_char) GCPPROTUNITLOCKOUTRELEASEFAILED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtUnitLockoutReleaseFailed);
		rval = (u_char *) &StorageTmp->gcpProtUnitLockoutReleaseFailed;
		break;
	case (u_char) GCPPROTUNITPRIORITY:	/* Create */
		*write_method = write_gcpProtUnitPriority;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtUnitPriority);
		rval = (u_char *) &StorageTmp->gcpProtUnitPriority;
		break;
	case (u_char) GCPPROTUNITROWSTATUS:	/* Create */
		*write_method = write_gcpProtUnitRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpProtUnitRowStatus);
		rval = (u_char *) &StorageTmp->gcpProtUnitRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp, struct gcpRealmTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp, struct gcpRealmTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp, struct gcpRealmTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpRealmTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp, struct gcpRealmTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpRealmTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp, struct gcpRealmTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp, struct gcpRealmTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpRealmTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpRealmTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpRealmTable_data *
refresh_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpRealmTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpRealmTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpRealmTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpRealmTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpRealmTable(int force)
{
	if (!force && gcpRealmTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpRealmTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpRealmTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpRealmTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpRealmTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpRealmTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpRealmTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpRealmTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpRealmTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpRealmTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPREALMSTRING:	/* Create */
		*write_method = write_gcpRealmString;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpRealmStringLen;
		rval = (u_char *) StorageTmp->gcpRealmString;
		break;
	case (u_char) GCPREALMTERMSMAX:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpRealmTermsMax);
		rval = (u_char *) &StorageTmp->gcpRealmTermsMax;
		break;
	case (u_char) GCPREALMTERMSCURRENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpRealmTermsCurrent);
		rval = (u_char *) &StorageTmp->gcpRealmTermsCurrent;
		break;
	case (u_char) GCPREALMTERMSHIWAT:	/* Create */
		*write_method = write_gcpRealmTermsHiWat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpRealmTermsHiWat);
		rval = (u_char *) &StorageTmp->gcpRealmTermsHiWat;
		break;
	case (u_char) GCPREALMTERMSLOWAT:	/* Create */
		*write_method = write_gcpRealmTermsLoWat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpRealmTermsLoWat);
		rval = (u_char *) &StorageTmp->gcpRealmTermsLoWat;
		break;
	case (u_char) GCPREALMROWSTATUS:	/* Create */
		*write_method = write_gcpRealmRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpRealmRowStatus);
		rval = (u_char *) &StorageTmp->gcpRealmRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp, struct gcpInterfaceTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp, struct gcpInterfaceTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp, struct gcpInterfaceTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpInterfaceTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp, struct gcpInterfaceTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpInterfaceTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp, struct gcpInterfaceTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp, struct gcpInterfaceTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpInterfaceTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpInterfaceTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpInterfaceTable_data *
refresh_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpInterfaceTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpInterfaceTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpInterfaceTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpInterfaceTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpInterfaceTable(int force)
{
	if (!force && gcpInterfaceTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpInterfaceTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpInterfaceTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpInterfaceTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpInterfaceTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpInterfaceTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpInterfaceTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpInterfaceTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpInterfaceTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpInterfaceTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPINTERFACEIFINDEX:	/* Create */
		*write_method = write_gcpInterfaceIfindex;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpInterfaceIfindex);
		rval = (u_char *) &StorageTmp->gcpInterfaceIfindex;
		break;
	case (u_char) GCPINTERFACEMGID:	/* Create */
		*write_method = write_gcpInterfaceMgId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpInterfaceMgId);
		rval = (u_char *) &StorageTmp->gcpInterfaceMgId;
		break;
	case (u_char) GCPINTERFACETYPE:	/* Create */
		*write_method = write_gcpInterfaceType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpInterfaceType);
		rval = (u_char *) &StorageTmp->gcpInterfaceType;
		break;
	case (u_char) GCPINTERFACEREALM:	/* Create */
		*write_method = write_gcpInterfaceRealm;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpInterfaceRealm);
		rval = (u_char *) &StorageTmp->gcpInterfaceRealm;
		break;
	case (u_char) GCPINTERFACETERMID:	/* Create */
		*write_method = write_gcpInterfaceTermId;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpInterfaceTermIdLen;
		rval = (u_char *) StorageTmp->gcpInterfaceTermId;
		break;
	case (u_char) GCPINTERFACETERMPATH:	/* Create */
		*write_method = write_gcpInterfaceTermPath;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpInterfaceTermPathLen;
		rval = (u_char *) StorageTmp->gcpInterfaceTermPath;
		break;
	case (u_char) GCPINTERFACEROWSTATUS:	/* Create */
		*write_method = write_gcpInterfaceRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpInterfaceRowStatus);
		rval = (u_char *) &StorageTmp->gcpInterfaceRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp, struct gcpAddressTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp, struct gcpAddressTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp, struct gcpAddressTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_gcpAddressTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp, struct gcpAddressTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	gcpAddressTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp, struct gcpAddressTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp, struct gcpAddressTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_gcpAddressTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the gcpAddressTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct gcpAddressTable_data *
refresh_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->gcpAddressTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->gcpAddressTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_gcpAddressTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the gcpAddressTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_gcpAddressTable(int force)
{
	if (!force && gcpAddressTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	gcpAddressTable_refresh = 0;
}

/**
 * @fn u_char *var_gcpAddressTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in gcpAddressTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_gcpMIB above.
 */
u_char *
var_gcpAddressTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct gcpAddressTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("gcpMIB", "var_gcpAddressTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_gcpAddressTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(gcpAddressTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_gcpAddressTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) GCPADDRESSINTERFACE:	/* Create */
		*write_method = write_gcpAddressInterface;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpAddressInterface);
		rval = (u_char *) &StorageTmp->gcpAddressInterface;
		break;
	case (u_char) GCPADDRESSTYPE:	/* Create */
		*write_method = write_gcpAddressType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpAddressType);
		rval = (u_char *) &StorageTmp->gcpAddressType;
		break;
	case (u_char) GCPADDRESSADDR:	/* Create */
		*write_method = write_gcpAddressAddr;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpAddressAddrLen;
		rval = (u_char *) StorageTmp->gcpAddressAddr;
		break;
	case (u_char) GCPADDRESSPORTRANGES:	/* Create */
		*write_method = write_gcpAddressPortRanges;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->gcpAddressPortRangesLen;
		rval = (u_char *) StorageTmp->gcpAddressPortRanges;
		break;
	case (u_char) GCPADDRESSROWSTATUS:	/* Create */
		*write_method = write_gcpAddressRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->gcpAddressRowStatus);
		rval = (u_char *) &StorageTmp->gcpAddressRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_gcpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMsName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMsTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			if (StorageTmp->gcpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMsTable_old = gcpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMsName);
		StorageTmp->gcpMsName = string;
		StorageTmp->gcpMsNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMsTable_tsts == 0)
				if ((ret = check_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMsTable_sets == 0)
				if ((ret = update_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
			StorageTmp->gcpMsTable_rsvs = 0;
			StorageTmp->gcpMsTable_tsts = 0;
			StorageTmp->gcpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMsTable_sets == 0)
			revert_gcpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		if (StorageOld->gcpMsName != NULL) {
			SNMP_FREE(StorageTmp->gcpMsName);
			StorageTmp->gcpMsName = StorageOld->gcpMsName;
			StorageTmp->gcpMsNameLen = StorageOld->gcpMsNameLen;
			StorageOld->gcpMsName = NULL;
			StorageOld->gcpMsNameLen = 0;
		}
		if (--StorageTmp->gcpMsTable_rsvs == 0)
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMsAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMsTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			if (StorageTmp->gcpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMsTable_old = gcpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMsAlarmStatus);
		StorageTmp->gcpMsAlarmStatus = string;
		StorageTmp->gcpMsAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMsTable_tsts == 0)
				if ((ret = check_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMsAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMsTable_sets == 0)
				if ((ret = update_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
			StorageTmp->gcpMsTable_rsvs = 0;
			StorageTmp->gcpMsTable_tsts = 0;
			StorageTmp->gcpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMsTable_sets == 0)
			revert_gcpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		if (StorageOld->gcpMsAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->gcpMsAlarmStatus);
			StorageTmp->gcpMsAlarmStatus = StorageOld->gcpMsAlarmStatus;
			StorageTmp->gcpMsAlarmStatusLen = StorageOld->gcpMsAlarmStatusLen;
			StorageOld->gcpMsAlarmStatus = NULL;
			StorageOld->gcpMsAlarmStatusLen = 0;
		}
		if (--StorageTmp->gcpMsTable_rsvs == 0)
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMsUserLabel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMsTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsUserLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsUserLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			if (StorageTmp->gcpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMsTable_old = gcpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMsUserLabel);
		StorageTmp->gcpMsUserLabel = string;
		StorageTmp->gcpMsUserLabelLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMsTable_tsts == 0)
				if ((ret = check_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMsUserLabel for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMsTable_sets == 0)
				if ((ret = update_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
			StorageTmp->gcpMsTable_rsvs = 0;
			StorageTmp->gcpMsTable_tsts = 0;
			StorageTmp->gcpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMsTable_sets == 0)
			revert_gcpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		if (StorageOld->gcpMsUserLabel != NULL) {
			SNMP_FREE(StorageTmp->gcpMsUserLabel);
			StorageTmp->gcpMsUserLabel = StorageOld->gcpMsUserLabel;
			StorageTmp->gcpMsUserLabelLen = StorageOld->gcpMsUserLabelLen;
			StorageOld->gcpMsUserLabel = NULL;
			StorageOld->gcpMsUserLabelLen = 0;
		}
		if (--StorageTmp->gcpMsTable_rsvs == 0)
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMsAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMsTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			if (StorageTmp->gcpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMsTable_old = gcpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->gcpMsAsaProfilePointer);
		StorageTmp->gcpMsAsaProfilePointer = objid;
		StorageTmp->gcpMsAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMsTable_tsts == 0)
				if ((ret = check_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMsAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMsTable_sets == 0)
				if ((ret = update_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
			StorageTmp->gcpMsTable_rsvs = 0;
			StorageTmp->gcpMsTable_tsts = 0;
			StorageTmp->gcpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMsTable_sets == 0)
			revert_gcpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		if (StorageOld->gcpMsAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->gcpMsAsaProfilePointer);
			StorageTmp->gcpMsAsaProfilePointer = StorageOld->gcpMsAsaProfilePointer;
			StorageTmp->gcpMsAsaProfilePointerLen = StorageOld->gcpMsAsaProfilePointerLen;
			StorageOld->gcpMsAsaProfilePointer = NULL;
			StorageOld->gcpMsAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->gcpMsTable_rsvs == 0)
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMsNetworkElementAliases entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMsTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsNetworkElementAliases: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsNetworkElementAliases not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsNetworkElementAliases: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			if (StorageTmp->gcpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMsTable_old = gcpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMsNetworkElementAliases);
		StorageTmp->gcpMsNetworkElementAliases = string;
		StorageTmp->gcpMsNetworkElementAliasesLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMsTable_tsts == 0)
				if ((ret = check_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMsNetworkElementAliases for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMsTable_sets == 0)
				if ((ret = update_gcpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
			StorageTmp->gcpMsTable_rsvs = 0;
			StorageTmp->gcpMsTable_tsts = 0;
			StorageTmp->gcpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMsTable_sets == 0)
			revert_gcpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
			break;
		if (StorageOld->gcpMsNetworkElementAliases != NULL) {
			SNMP_FREE(StorageTmp->gcpMsNetworkElementAliases);
			StorageTmp->gcpMsNetworkElementAliases = StorageOld->gcpMsNetworkElementAliases;
			StorageTmp->gcpMsNetworkElementAliasesLen = StorageOld->gcpMsNetworkElementAliasesLen;
			StorageOld->gcpMsNetworkElementAliases = NULL;
			StorageOld->gcpMsNetworkElementAliasesLen = 0;
		}
		if (--StorageTmp->gcpMsTable_rsvs == 0)
			gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgLocation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgLocation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgLocation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgLocation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgLocation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgLocation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPMGLOCATION_INTERNAL:
		case GCPMGLOCATION_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgLocation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		StorageTmp->gcpMgLocation = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgLocation for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		StorageTmp->gcpMgLocation = StorageOld->gcpMgLocation;
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgName);
		StorageTmp->gcpMgName = string;
		StorageTmp->gcpMgNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		if (StorageOld->gcpMgName != NULL) {
			SNMP_FREE(StorageTmp->gcpMgName);
			StorageTmp->gcpMgName = StorageOld->gcpMgName;
			StorageTmp->gcpMgNameLen = StorageOld->gcpMgNameLen;
			StorageOld->gcpMgName = NULL;
			StorageOld->gcpMgNameLen = 0;
		}
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgDomainName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgDomainName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgDomainName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgDomainName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgDomainName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgDomainName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgDomainName);
		StorageTmp->gcpMgDomainName = string;
		StorageTmp->gcpMgDomainNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgDomainName for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		if (StorageOld->gcpMgDomainName != NULL) {
			SNMP_FREE(StorageTmp->gcpMgDomainName);
			StorageTmp->gcpMgDomainName = StorageOld->gcpMgDomainName;
			StorageTmp->gcpMgDomainNameLen = StorageOld->gcpMgDomainNameLen;
			StorageOld->gcpMgDomainName = NULL;
			StorageOld->gcpMgDomainNameLen = 0;
		}
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgDeviceName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgDeviceName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgDeviceName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgDeviceName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgDeviceName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgDeviceName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgDeviceName);
		StorageTmp->gcpMgDeviceName = string;
		StorageTmp->gcpMgDeviceNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgDeviceName for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		if (StorageOld->gcpMgDeviceName != NULL) {
			SNMP_FREE(StorageTmp->gcpMgDeviceName);
			StorageTmp->gcpMgDeviceName = StorageOld->gcpMgDeviceName;
			StorageTmp->gcpMgDeviceNameLen = StorageOld->gcpMgDeviceNameLen;
			StorageOld->gcpMgDeviceName = NULL;
			StorageOld->gcpMgDeviceNameLen = 0;
		}
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgMtpAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgMtpAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgMtpAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgMtpAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgMtpAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgMtpAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgMtpAddress);
		StorageTmp->gcpMgMtpAddress = string;
		StorageTmp->gcpMgMtpAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgMtpAddress for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		if (StorageOld->gcpMgMtpAddress != NULL) {
			SNMP_FREE(StorageTmp->gcpMgMtpAddress);
			StorageTmp->gcpMgMtpAddress = StorageOld->gcpMgMtpAddress;
			StorageTmp->gcpMgMtpAddressLen = StorageOld->gcpMgMtpAddressLen;
			StorageOld->gcpMgMtpAddress = NULL;
			StorageOld->gcpMgMtpAddressLen = 0;
		}
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPMGADMINSTATE_LOCKED:
		case GCPMGADMINSTATE_UNLOCKED:
		case GCPMGADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		StorageTmp->gcpMgAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		StorageTmp->gcpMgAdminState = StorageOld->gcpMgAdminState;
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgAlarmStatus);
		StorageTmp->gcpMgAlarmStatus = string;
		StorageTmp->gcpMgAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		if (StorageOld->gcpMgAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->gcpMgAlarmStatus);
			StorageTmp->gcpMgAlarmStatus = StorageOld->gcpMgAlarmStatus;
			StorageTmp->gcpMgAlarmStatusLen = StorageOld->gcpMgAlarmStatusLen;
			StorageOld->gcpMgAlarmStatus = NULL;
			StorageOld->gcpMgAlarmStatusLen = 0;
		}
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->gcpMgAsaProfilePointer);
		StorageTmp->gcpMgAsaProfilePointer = objid;
		StorageTmp->gcpMgAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		if (StorageOld->gcpMgAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->gcpMgAsaProfilePointer);
			StorageTmp->gcpMgAsaProfilePointer = StorageOld->gcpMgAsaProfilePointer;
			StorageTmp->gcpMgAsaProfilePointerLen = StorageOld->gcpMgAsaProfilePointerLen;
			StorageOld->gcpMgAsaProfilePointer = NULL;
			StorageOld->gcpMgAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgPg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgPg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgPg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgPg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgPg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgPg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		StorageTmp->gcpMgPg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgPg for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		StorageTmp->gcpMgPg = StorageOld->gcpMgPg;
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgStandbyStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgStandbyStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgStandbyStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgStandbyStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgStandbyStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgStandbyStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPMGSTANDBYSTATUS_HOTSTANDBY:
		case GCPMGSTANDBYSTATUS_COLDSTANDBY:
		case GCPMGSTANDBYSTATUS_PROVIDINGSERVICE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgStandbyStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			if (StorageTmp->gcpMgTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgTable_rsvs++;
		StorageTmp->gcpMgStandbyStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgTable_tsts == 0)
				if ((ret = check_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgStandbyStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgTable_sets == 0)
				if ((ret = update_gcpMgTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			StorageTmp->gcpMgTable_rsvs = 0;
			StorageTmp->gcpMgTable_tsts = 0;
			StorageTmp->gcpMgTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgTable_sets == 0)
			revert_gcpMgTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
			break;
		StorageTmp->gcpMgStandbyStatus = StorageOld->gcpMgStandbyStatus;
		if (--StorageTmp->gcpMgTable_rsvs == 0)
			gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcLocation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcLocation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcLocation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcLocation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcLocation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcLocation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPMGCLOCATION_INTERNAL:
		case GCPMGCLOCATION_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcLocation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		StorageTmp->gcpMgcLocation = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcLocation for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		StorageTmp->gcpMgcLocation = StorageOld->gcpMgcLocation;
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgcName);
		StorageTmp->gcpMgcName = string;
		StorageTmp->gcpMgcNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		if (StorageOld->gcpMgcName != NULL) {
			SNMP_FREE(StorageTmp->gcpMgcName);
			StorageTmp->gcpMgcName = StorageOld->gcpMgcName;
			StorageTmp->gcpMgcNameLen = StorageOld->gcpMgcNameLen;
			StorageOld->gcpMgcName = NULL;
			StorageOld->gcpMgcNameLen = 0;
		}
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcDomainName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcDomainName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcDomainName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcDomainName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcDomainName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcDomainName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgcDomainName);
		StorageTmp->gcpMgcDomainName = string;
		StorageTmp->gcpMgcDomainNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcDomainName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		if (StorageOld->gcpMgcDomainName != NULL) {
			SNMP_FREE(StorageTmp->gcpMgcDomainName);
			StorageTmp->gcpMgcDomainName = StorageOld->gcpMgcDomainName;
			StorageTmp->gcpMgcDomainNameLen = StorageOld->gcpMgcDomainNameLen;
			StorageOld->gcpMgcDomainName = NULL;
			StorageOld->gcpMgcDomainNameLen = 0;
		}
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcDeviceName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcDeviceName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcDeviceName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcDeviceName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcDeviceName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcDeviceName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgcDeviceName);
		StorageTmp->gcpMgcDeviceName = string;
		StorageTmp->gcpMgcDeviceNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcDeviceName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		if (StorageOld->gcpMgcDeviceName != NULL) {
			SNMP_FREE(StorageTmp->gcpMgcDeviceName);
			StorageTmp->gcpMgcDeviceName = StorageOld->gcpMgcDeviceName;
			StorageTmp->gcpMgcDeviceNameLen = StorageOld->gcpMgcDeviceNameLen;
			StorageOld->gcpMgcDeviceName = NULL;
			StorageOld->gcpMgcDeviceNameLen = 0;
		}
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcMtpAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcMtpAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcMtpAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcMtpAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcMtpAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcMtpAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgcMtpAddress);
		StorageTmp->gcpMgcMtpAddress = string;
		StorageTmp->gcpMgcMtpAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcMtpAddress for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		if (StorageOld->gcpMgcMtpAddress != NULL) {
			SNMP_FREE(StorageTmp->gcpMgcMtpAddress);
			StorageTmp->gcpMgcMtpAddress = StorageOld->gcpMgcMtpAddress;
			StorageTmp->gcpMgcMtpAddressLen = StorageOld->gcpMgcMtpAddressLen;
			StorageOld->gcpMgcMtpAddress = NULL;
			StorageOld->gcpMgcMtpAddressLen = 0;
		}
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPMGCADMINSTATE_LOCKED:
		case GCPMGCADMINSTATE_UNLOCKED:
		case GCPMGCADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		StorageTmp->gcpMgcAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		StorageTmp->gcpMgcAdminState = StorageOld->gcpMgcAdminState;
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcOperState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcOperState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcOperState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcOperState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcOperState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcOperState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPMGCOPERSTATE_DISABLED:
		case GCPMGCOPERSTATE_ENABLED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcOperState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		StorageTmp->gcpMgcOperState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcOperState for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		StorageTmp->gcpMgcOperState = StorageOld->gcpMgcOperState;
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpMgcAlarmStatus);
		StorageTmp->gcpMgcAlarmStatus = string;
		StorageTmp->gcpMgcAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		if (StorageOld->gcpMgcAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->gcpMgcAlarmStatus);
			StorageTmp->gcpMgcAlarmStatus = StorageOld->gcpMgcAlarmStatus;
			StorageTmp->gcpMgcAlarmStatusLen = StorageOld->gcpMgcAlarmStatusLen;
			StorageOld->gcpMgcAlarmStatus = NULL;
			StorageOld->gcpMgcAlarmStatusLen = 0;
		}
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->gcpMgcAsaProfilePointer);
		StorageTmp->gcpMgcAsaProfilePointer = objid;
		StorageTmp->gcpMgcAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		if (StorageOld->gcpMgcAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->gcpMgcAsaProfilePointer);
			StorageTmp->gcpMgcAsaProfilePointer = StorageOld->gcpMgcAsaProfilePointer;
			StorageTmp->gcpMgcAsaProfilePointerLen = StorageOld->gcpMgcAsaProfilePointerLen;
			StorageOld->gcpMgcAsaProfilePointer = NULL;
			StorageOld->gcpMgcAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcUsageState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcUsageState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcUsageState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcUsageState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcUsageState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcUsageState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPMGCUSAGESTATE_IDLE:
		case GCPMGCUSAGESTATE_ACTIVE:
		case GCPMGCUSAGESTATE_BUSY:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcUsageState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		StorageTmp->gcpMgcUsageState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcUsageState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		StorageTmp->gcpMgcUsageState = StorageOld->gcpMgcUsageState;
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcPg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcPg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcPg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcPg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcPg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcPg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		StorageTmp->gcpMgcPg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcPg for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		StorageTmp->gcpMgcPg = StorageOld->gcpMgcPg;
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcStandbyStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpMgcStandbyStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcStandbyStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpMgcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcStandbyStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcStandbyStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcStandbyStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPMGCSTANDBYSTATUS_HOTSTANDBY:
		case GCPMGCSTANDBYSTATUS_COLDSTANDBY:
		case GCPMGCSTANDBYSTATUS_PROVIDINGSERVICE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcStandbyStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			if (StorageTmp->gcpMgcTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMgcTable_rsvs++;
		StorageTmp->gcpMgcStandbyStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpMgcTable_tsts == 0)
				if ((ret = check_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpMgcStandbyStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMgcTable_sets == 0)
				if ((ret = update_gcpMgcTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMgcTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			StorageTmp->gcpMgcTable_rsvs = 0;
			StorageTmp->gcpMgcTable_tsts = 0;
			StorageTmp->gcpMgcTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMgcTable_sets == 0)
			revert_gcpMgcTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
			break;
		StorageTmp->gcpMgcStandbyStatus = StorageOld->gcpMgcStandbyStatus;
		if (--StorageTmp->gcpMgcTable_rsvs == 0)
			gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPLINKAGETYPE_UNKNOWN:
		case GCPLINKAGETYPE_UDPIPV4:
		case GCPLINKAGETYPE_UDPIPV6:
		case GCPLINKAGETYPE_UDPIPV4Z:
		case GCPLINKAGETYPE_UDPIPV6Z:
		case GCPLINKAGETYPE_TCPIPV4:
		case GCPLINKAGETYPE_TCPIPV6:
		case GCPLINKAGETYPE_TCPIPV4Z:
		case GCPLINKAGETYPE_TCPIPV6Z:
		case GCPLINKAGETYPE_SCTPIPV4:
		case GCPLINKAGETYPE_SCTPIPV6:
		case GCPLINKAGETYPE_SCTPIPV4Z:
		case GCPLINKAGETYPE_SCTPIPV6Z:
		case GCPLINKAGETYPE_LOCAL:
		case GCPLINKAGETYPE_UDPDNS:
		case GCPLINKAGETYPE_TCPDNS:
		case GCPLINKAGETYPE_SCTPDNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		StorageTmp->gcpLinkageType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageType for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		StorageTmp->gcpLinkageType = StorageOld->gcpLinkageType;
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageMgcMaster(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageMgcMaster(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageMgcMaster entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcMaster: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcMaster not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcMaster: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value master */
		switch (set_value) {
		case GCPLINKAGEMGCMASTER_MASTER:
		case GCPLINKAGEMGCMASTER_SLAVE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcMaster: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		StorageTmp->gcpLinkageMgcMaster = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageMgcMaster for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		StorageTmp->gcpLinkageMgcMaster = StorageOld->gcpLinkageMgcMaster;
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageMgcAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageMgcAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageMgcAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpLinkageMgcAddress);
		StorageTmp->gcpLinkageMgcAddress = string;
		StorageTmp->gcpLinkageMgcAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageMgcAddress for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		if (StorageOld->gcpLinkageMgcAddress != NULL) {
			SNMP_FREE(StorageTmp->gcpLinkageMgcAddress);
			StorageTmp->gcpLinkageMgcAddress = StorageOld->gcpLinkageMgcAddress;
			StorageTmp->gcpLinkageMgcAddressLen = StorageOld->gcpLinkageMgcAddressLen;
			StorageOld->gcpLinkageMgcAddress = NULL;
			StorageOld->gcpLinkageMgcAddressLen = 0;
		}
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageMgAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageMgAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageMgAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpLinkageMgAddress);
		StorageTmp->gcpLinkageMgAddress = string;
		StorageTmp->gcpLinkageMgAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageMgAddress for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		if (StorageOld->gcpLinkageMgAddress != NULL) {
			SNMP_FREE(StorageTmp->gcpLinkageMgAddress);
			StorageTmp->gcpLinkageMgAddress = StorageOld->gcpLinkageMgAddress;
			StorageTmp->gcpLinkageMgAddressLen = StorageOld->gcpLinkageMgAddressLen;
			StorageOld->gcpLinkageMgAddress = NULL;
			StorageOld->gcpLinkageMgAddressLen = 0;
		}
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageMgcIdent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageMgcIdent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageMgcIdent entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcIdent: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcIdent not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcIdent: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPLINKAGEMGCIDENT_IPADDRESS:
		case GCPLINKAGEMGCIDENT_DOMAINNAME:
		case GCPLINKAGEMGCIDENT_DEVICENAME:
		case GCPLINKAGEMGCIDENT_MTPADDRESS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgcIdent: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		StorageTmp->gcpLinkageMgcIdent = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageMgcIdent for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		StorageTmp->gcpLinkageMgcIdent = StorageOld->gcpLinkageMgcIdent;
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageMgIdent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageMgIdent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageMgIdent entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgIdent: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgIdent not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgIdent: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPLINKAGEMGIDENT_IPADDRESS:
		case GCPLINKAGEMGIDENT_DOMAINNAME:
		case GCPLINKAGEMGIDENT_DEVICENAME:
		case GCPLINKAGEMGIDENT_MTPADDRESS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMgIdent: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		StorageTmp->gcpLinkageMgIdent = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageMgIdent for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		StorageTmp->gcpLinkageMgIdent = StorageOld->gcpLinkageMgIdent;
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageProfile entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->gcpLinkageProfile);
		StorageTmp->gcpLinkageProfile = objid;
		StorageTmp->gcpLinkageProfileLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageProfile for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		if (StorageOld->gcpLinkageProfile != NULL) {
			SNMP_FREE(StorageTmp->gcpLinkageProfile);
			StorageTmp->gcpLinkageProfile = StorageOld->gcpLinkageProfile;
			StorageTmp->gcpLinkageProfileLen = StorageOld->gcpLinkageProfileLen;
			StorageOld->gcpLinkageProfile = NULL;
			StorageOld->gcpLinkageProfileLen = 0;
		}
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageProtocol(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageProtocol(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageProtocol entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProtocol: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProtocol not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProtocol: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->gcpLinkageProtocol);
		StorageTmp->gcpLinkageProtocol = objid;
		StorageTmp->gcpLinkageProtocolLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageProtocol for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		if (StorageOld->gcpLinkageProtocol != NULL) {
			SNMP_FREE(StorageTmp->gcpLinkageProtocol);
			StorageTmp->gcpLinkageProtocol = StorageOld->gcpLinkageProtocol;
			StorageTmp->gcpLinkageProtocolLen = StorageOld->gcpLinkageProtocolLen;
			StorageOld->gcpLinkageProtocol = NULL;
			StorageOld->gcpLinkageProtocolLen = 0;
		}
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageEncoding(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageEncoding(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageEncoding entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageEncoding: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageEncoding not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageEncoding: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPLINKAGEENCODING_UNSPECIFIED:
		case GCPLINKAGEENCODING_BINARY:
		case GCPLINKAGEENCODING_TEXT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageEncoding: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		StorageTmp->gcpLinkageEncoding = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageEncoding for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		StorageTmp->gcpLinkageEncoding = StorageOld->gcpLinkageEncoding;
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageAuthAccess(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageAuthAccess(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageAuthAccess entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageAuthAccess: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageAuthAccess not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageAuthAccess: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageAuthAccess: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpLinkageAuthAccess);
		StorageTmp->gcpLinkageAuthAccess = string;
		StorageTmp->gcpLinkageAuthAccessLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageAuthAccess for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		if (StorageOld->gcpLinkageAuthAccess != NULL) {
			SNMP_FREE(StorageTmp->gcpLinkageAuthAccess);
			StorageTmp->gcpLinkageAuthAccess = StorageOld->gcpLinkageAuthAccess;
			StorageTmp->gcpLinkageAuthAccessLen = StorageOld->gcpLinkageAuthAccessLen;
			StorageOld->gcpLinkageAuthAccess = NULL;
			StorageOld->gcpLinkageAuthAccessLen = 0;
		}
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPLINKAGEADMINSTATE_LOCKED:
		case GCPLINKAGEADMINSTATE_UNLOCKED:
		case GCPLINKAGEADMINSTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		StorageTmp->gcpLinkageAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		StorageTmp->gcpLinkageAdminState = StorageOld->gcpLinkageAdminState;
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageProcStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageProcStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageProcStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProcStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProcStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProcStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageProcStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpLinkageProcStatus);
		StorageTmp->gcpLinkageProcStatus = string;
		StorageTmp->gcpLinkageProcStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageProcStatus for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		if (StorageOld->gcpLinkageProcStatus != NULL) {
			SNMP_FREE(StorageTmp->gcpLinkageProcStatus);
			StorageTmp->gcpLinkageProcStatus = StorageOld->gcpLinkageProcStatus;
			StorageTmp->gcpLinkageProcStatusLen = StorageOld->gcpLinkageProcStatusLen;
			StorageOld->gcpLinkageProcStatus = NULL;
			StorageOld->gcpLinkageProcStatusLen = 0;
		}
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageMit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpLinkageMit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageMit entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageMit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			if (StorageTmp->gcpLinkageTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpLinkageTable_rsvs++;
		StorageTmp->gcpLinkageMit = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpLinkageTable_tsts == 0)
				if ((ret = check_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpLinkageMit for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpLinkageTable_sets == 0)
				if ((ret = update_gcpLinkageTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpLinkageTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			StorageTmp->gcpLinkageTable_rsvs = 0;
			StorageTmp->gcpLinkageTable_tsts = 0;
			StorageTmp->gcpLinkageTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpLinkageTable_sets == 0)
			revert_gcpLinkageTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
			break;
		StorageTmp->gcpLinkageMit = StorageOld->gcpLinkageMit;
		if (--StorageTmp->gcpLinkageTable_rsvs == 0)
			gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpUdpChecksum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpUdpChecksum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpUdpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpUdpChecksum entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpUdpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpUdpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpUdpChecksum: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpUdpChecksum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpUdpChecksum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpUdpChecksum: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpUdpProfileTable_old) == NULL)
			if (StorageTmp->gcpUdpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpUdpProfileTable_old = gcpUdpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpUdpProfileTable_rsvs++;
		StorageTmp->gcpUdpChecksum = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpUdpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpUdpProfileTable_tsts == 0)
				if ((ret = check_gcpUdpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpUdpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpUdpChecksum for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpUdpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpUdpProfileTable_sets == 0)
				if ((ret = update_gcpUdpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpUdpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpUdpProfileTable_old) != NULL) {
			gcpUdpProfileTable_destroy(&StorageTmp->gcpUdpProfileTable_old);
			StorageTmp->gcpUdpProfileTable_rsvs = 0;
			StorageTmp->gcpUdpProfileTable_tsts = 0;
			StorageTmp->gcpUdpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpUdpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpUdpProfileTable_sets == 0)
			revert_gcpUdpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpUdpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpUdpChecksum = StorageOld->gcpUdpChecksum;
		if (--StorageTmp->gcpUdpProfileTable_rsvs == 0)
			gcpUdpProfileTable_destroy(&StorageTmp->gcpUdpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpTcpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpTcpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpTcpNoDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpTcpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpTcpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpNoDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			if (StorageTmp->gcpTcpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpTcpProfileTable_old = gcpTcpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpTcpProfileTable_rsvs++;
		StorageTmp->gcpTcpNoDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpTcpProfileTable_tsts == 0)
				if ((ret = check_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpTcpNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpTcpProfileTable_sets == 0)
				if ((ret = update_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
			StorageTmp->gcpTcpProfileTable_rsvs = 0;
			StorageTmp->gcpTcpProfileTable_tsts = 0;
			StorageTmp->gcpTcpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpTcpProfileTable_sets == 0)
			revert_gcpTcpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpTcpNoDelay = StorageOld->gcpTcpNoDelay;
		if (--StorageTmp->gcpTcpProfileTable_rsvs == 0)
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpTcpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpTcpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpTcpMaxseg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpTcpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpTcpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpMaxseg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 536..65536 */
		if ((536 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			if (StorageTmp->gcpTcpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpTcpProfileTable_old = gcpTcpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpTcpProfileTable_rsvs++;
		StorageTmp->gcpTcpMaxseg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpTcpProfileTable_tsts == 0)
				if ((ret = check_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpTcpMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpTcpProfileTable_sets == 0)
				if ((ret = update_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
			StorageTmp->gcpTcpProfileTable_rsvs = 0;
			StorageTmp->gcpTcpProfileTable_tsts = 0;
			StorageTmp->gcpTcpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpTcpProfileTable_sets == 0)
			revert_gcpTcpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpTcpMaxseg = StorageOld->gcpTcpMaxseg;
		if (--StorageTmp->gcpTcpProfileTable_rsvs == 0)
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpTcpKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpTcpKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpTcpKeepAlive entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpTcpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpTcpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepAlive: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepAlive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepAlive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepAlive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			if (StorageTmp->gcpTcpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpTcpProfileTable_old = gcpTcpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpTcpProfileTable_rsvs++;
		StorageTmp->gcpTcpKeepAlive = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpTcpProfileTable_tsts == 0)
				if ((ret = check_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpTcpKeepAlive for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpTcpProfileTable_sets == 0)
				if ((ret = update_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
			StorageTmp->gcpTcpProfileTable_rsvs = 0;
			StorageTmp->gcpTcpProfileTable_tsts = 0;
			StorageTmp->gcpTcpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpTcpProfileTable_sets == 0)
			revert_gcpTcpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpTcpKeepAlive = StorageOld->gcpTcpKeepAlive;
		if (--StorageTmp->gcpTcpProfileTable_rsvs == 0)
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpTcpKeepIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpTcpKeepIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpTcpKeepIdle entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpTcpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpTcpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepIdle: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepIdle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepIdle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepIdle: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			if (StorageTmp->gcpTcpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpTcpProfileTable_old = gcpTcpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpTcpProfileTable_rsvs++;
		StorageTmp->gcpTcpKeepIdle = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpTcpProfileTable_tsts == 0)
				if ((ret = check_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpTcpKeepIdle for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpTcpProfileTable_sets == 0)
				if ((ret = update_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
			StorageTmp->gcpTcpProfileTable_rsvs = 0;
			StorageTmp->gcpTcpProfileTable_tsts = 0;
			StorageTmp->gcpTcpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpTcpProfileTable_sets == 0)
			revert_gcpTcpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpTcpKeepIdle = StorageOld->gcpTcpKeepIdle;
		if (--StorageTmp->gcpTcpProfileTable_rsvs == 0)
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpTcpKeepAliveItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpTcpKeepAliveItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpTcpKeepAliveItvl entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpTcpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpTcpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepAliveItvl: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepAliveItvl not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepAliveItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepAliveItvl: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			if (StorageTmp->gcpTcpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpTcpProfileTable_old = gcpTcpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpTcpProfileTable_rsvs++;
		StorageTmp->gcpTcpKeepAliveItvl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpTcpProfileTable_tsts == 0)
				if ((ret = check_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpTcpKeepAliveItvl for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpTcpProfileTable_sets == 0)
				if ((ret = update_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
			StorageTmp->gcpTcpProfileTable_rsvs = 0;
			StorageTmp->gcpTcpProfileTable_tsts = 0;
			StorageTmp->gcpTcpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpTcpProfileTable_sets == 0)
			revert_gcpTcpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpTcpKeepAliveItvl = StorageOld->gcpTcpKeepAliveItvl;
		if (--StorageTmp->gcpTcpProfileTable_rsvs == 0)
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpTcpKeepCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpTcpKeepCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpTcpKeepCount entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpTcpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpTcpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepCount not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpKeepCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			if (StorageTmp->gcpTcpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpTcpProfileTable_old = gcpTcpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpTcpProfileTable_rsvs++;
		StorageTmp->gcpTcpKeepCount = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpTcpProfileTable_tsts == 0)
				if ((ret = check_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpTcpKeepCount for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpTcpProfileTable_sets == 0)
				if ((ret = update_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
			StorageTmp->gcpTcpProfileTable_rsvs = 0;
			StorageTmp->gcpTcpProfileTable_tsts = 0;
			StorageTmp->gcpTcpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpTcpProfileTable_sets == 0)
			revert_gcpTcpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpTcpKeepCount = StorageOld->gcpTcpKeepCount;
		if (--StorageTmp->gcpTcpProfileTable_rsvs == 0)
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpTcpSynRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpTcpSynRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpTcpSynRetrans entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpTcpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpTcpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpSynRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpSynRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpSynRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..255 */
		if ((0 > set_value || set_value > 255)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpSynRetrans: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			if (StorageTmp->gcpTcpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpTcpProfileTable_old = gcpTcpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpTcpProfileTable_rsvs++;
		StorageTmp->gcpTcpSynRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpTcpProfileTable_tsts == 0)
				if ((ret = check_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpTcpSynRetrans for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpTcpProfileTable_sets == 0)
				if ((ret = update_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
			StorageTmp->gcpTcpProfileTable_rsvs = 0;
			StorageTmp->gcpTcpProfileTable_tsts = 0;
			StorageTmp->gcpTcpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpTcpProfileTable_sets == 0)
			revert_gcpTcpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpTcpSynRetrans = StorageOld->gcpTcpSynRetrans;
		if (--StorageTmp->gcpTcpProfileTable_rsvs == 0)
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpTcpWindowClamp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpTcpWindowClamp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpTcpWindowClamp entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpTcpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpTcpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpWindowClamp: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpWindowClamp not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpWindowClamp: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 536..65536 */
		if ((536 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpWindowClamp: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			if (StorageTmp->gcpTcpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpTcpProfileTable_old = gcpTcpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpTcpProfileTable_rsvs++;
		StorageTmp->gcpTcpWindowClamp = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpTcpProfileTable_tsts == 0)
				if ((ret = check_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpTcpWindowClamp for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpTcpProfileTable_sets == 0)
				if ((ret = update_gcpTcpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpTcpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
			StorageTmp->gcpTcpProfileTable_rsvs = 0;
			StorageTmp->gcpTcpProfileTable_tsts = 0;
			StorageTmp->gcpTcpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpTcpProfileTable_sets == 0)
			revert_gcpTcpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpTcpWindowClamp = StorageOld->gcpTcpWindowClamp;
		if (--StorageTmp->gcpTcpProfileTable_rsvs == 0)
			gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpNoDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpNoDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpNoDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpNoDelay = StorageOld->gcpSctpNoDelay;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpMaxseg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxseg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 536..65536 */
		if ((536 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpMaxseg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpMaxseg = StorageOld->gcpSctpMaxseg;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpHeartbeatItvl entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpHeartbeatItvl: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpHeartbeatItvl not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpHeartbeatItvl: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpHeartbeatItvl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpHeartbeatItvl for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpHeartbeatItvl = StorageOld->gcpSctpHeartbeatItvl;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpHearbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpHearbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpHearbeat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpHearbeat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpHearbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpHearbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpHearbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpHearbeat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpHearbeat for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpHearbeat = StorageOld->gcpSctpHearbeat;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpRtoInitial entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoInitial: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoInitial not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoInitial: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpRtoInitial = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpRtoInitial for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpRtoInitial = StorageOld->gcpSctpRtoInitial;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpRtoMin entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoMin: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoMin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpRtoMin = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpRtoMin = StorageOld->gcpSctpRtoMin;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpRtoMax entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoMax: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoMax not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRtoMax: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpRtoMax = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpRtoMax = StorageOld->gcpSctpRtoMax;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpPathMaxRetrans entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpPathMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpPathMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpPathMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpPathMaxRetrans = StorageOld->gcpSctpPathMaxRetrans;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpCookieLife entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpCookieLife: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpCookieLife not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpCookieLife: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpCookieLife = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpCookieLife for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpCookieLife = StorageOld->gcpSctpCookieLife;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpCookieInc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpCookieInc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpCookieInc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpCookieInc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpCookieInc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpCookieInc for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpCookieInc = StorageOld->gcpSctpCookieInc;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpMaxInitRetries entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxInitRetries: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpMaxInitRetries = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpMaxInitRetries for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpMaxInitRetries = StorageOld->gcpSctpMaxInitRetries;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpMaxBurst entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxBurst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpMaxBurst = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpMaxBurst for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpMaxBurst = StorageOld->gcpSctpMaxBurst;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpAssocMaxRetrans entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpAssocMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpAssocMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpAssocMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpAssocMaxRetrans = StorageOld->gcpSctpAssocMaxRetrans;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpSackDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpSackDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpSackDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpSackDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpSackDelay for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpSackDelay = StorageOld->gcpSctpSackDelay;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpLifetime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpLifetime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSctpProfileTable_rsvs++;
		StorageTmp->gcpSctpLifetime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSctpProfileTable_tsts == 0)
				if ((ret = check_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSctpLifetime for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSctpProfileTable_sets == 0)
				if ((ret = update_gcpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			StorageTmp->gcpSctpProfileTable_rsvs = 0;
			StorageTmp->gcpSctpProfileTable_tsts = 0;
			StorageTmp->gcpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSctpProfileTable_sets == 0)
			revert_gcpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->gcpSctpLifetime = StorageOld->gcpSctpLifetime;
		if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
			gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPPROTGROUPTYPE_PLUS:
		case GCPPROTGROUPTYPE_COLON:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupType = StorageOld->gcpProtGroupType;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupRevertive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupRevertive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupRevertive entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupRevertive: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupRevertive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupRevertive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupRevertive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupRevertive = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupRevertive for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupRevertive = StorageOld->gcpProtGroupRevertive;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupSBOLNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupSBOLNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupSBOLNumber entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSBOLNumber: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSBOLNumber not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSBOLNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupSBOLNumber = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupSBOLNumber for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupSBOLNumber = StorageOld->gcpProtGroupSBOLNumber;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupWaitToRestoreTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupWaitToRestoreTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupWaitToRestoreTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupWaitToRestoreTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupWaitToRestoreTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupWaitToRestoreTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupWaitToRestoreTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupWaitToRestoreTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupWaitToRestoreTime for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupWaitToRestoreTime = StorageOld->gcpProtGroupWaitToRestoreTime;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupSettingWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupSettingWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupSettingWindowTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSettingWindowTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSettingWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSettingWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSettingWindowTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupSettingWindowTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupSettingWindowTime for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupSettingWindowTime = StorageOld->gcpProtGroupSettingWindowTime;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupReleaseingWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupReleaseingWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupReleaseingWindowTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupReleaseingWindowTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupReleaseingWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupReleaseingWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupReleaseingWindowTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupReleaseingWindowTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupReleaseingWindowTime for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupReleaseingWindowTime = StorageOld->gcpProtGroupReleaseingWindowTime;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupHitsCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupHitsCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupHitsCount entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupHitsCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupHitsCount not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupHitsCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupHitsCount = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupHitsCount for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupHitsCount = StorageOld->gcpProtGroupHitsCount;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupSwitchType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupSwitchType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupSwitchType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSwitchType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSwitchType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSwitchType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPPROTGROUPSWITCHTYPE_MANUAL:
		case GCPPROTGROUPSWITCHTYPE_FORCED:
		case GCPPROTGROUPSWITCHTYPE_LOCKOUT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupSwitchType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupSwitchType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupSwitchType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupSwitchType = StorageOld->gcpProtGroupSwitchType;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupProtectedUnits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupProtectedUnits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupProtectedUnits entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupProtectedUnits: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupProtectedUnits not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupProtectedUnits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpProtGroupProtectedUnits);
		StorageTmp->gcpProtGroupProtectedUnits = string;
		StorageTmp->gcpProtGroupProtectedUnitsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupProtectedUnits for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		if (StorageOld->gcpProtGroupProtectedUnits != NULL) {
			SNMP_FREE(StorageTmp->gcpProtGroupProtectedUnits);
			StorageTmp->gcpProtGroupProtectedUnits = StorageOld->gcpProtGroupProtectedUnits;
			StorageTmp->gcpProtGroupProtectedUnitsLen = StorageOld->gcpProtGroupProtectedUnitsLen;
			StorageOld->gcpProtGroupProtectedUnits = NULL;
			StorageOld->gcpProtGroupProtectedUnitsLen = 0;
		}
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupProtectingUnits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupProtectingUnits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupProtectingUnits entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupProtectingUnits: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupProtectingUnits not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupProtectingUnits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpProtGroupProtectingUnits);
		StorageTmp->gcpProtGroupProtectingUnits = string;
		StorageTmp->gcpProtGroupProtectingUnitsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupProtectingUnits for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		if (StorageOld->gcpProtGroupProtectingUnits != NULL) {
			SNMP_FREE(StorageTmp->gcpProtGroupProtectingUnits);
			StorageTmp->gcpProtGroupProtectingUnits = StorageOld->gcpProtGroupProtectingUnits;
			StorageTmp->gcpProtGroupProtectingUnitsLen = StorageOld->gcpProtGroupProtectingUnitsLen;
			StorageOld->gcpProtGroupProtectingUnits = NULL;
			StorageOld->gcpProtGroupProtectingUnitsLen = 0;
		}
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupInvokeProtection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupInvokeProtection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupInvokeProtection entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupInvokeProtection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupInvokeProtection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupInvokeProtection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPPROTGROUPINVOKEPROTECTION_SUCCESS:
		case GCPPROTGROUPINVOKEPROTECTION_PENDING:
		case GCPPROTGROUPINVOKEPROTECTION_FAILURE:
		case GCPPROTGROUPINVOKEPROTECTION_TIMEOUT:
		case GCPPROTGROUPINVOKEPROTECTION_PREEMPTED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupInvokeProtection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupInvokeProtection = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupInvokeProtection for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupInvokeProtection = StorageOld->gcpProtGroupInvokeProtection;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupReleaseProtection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtGroupReleaseProtection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupReleaseProtection entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtGroupRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupReleaseProtection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupReleaseProtection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupReleaseProtection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPPROTGROUPRELEASEPROTECTION_SUCCESS:
		case GCPPROTGROUPRELEASEPROTECTION_PENDING:
		case GCPPROTGROUPRELEASEPROTECTION_FAILURE:
		case GCPPROTGROUPRELEASEPROTECTION_TIMEOUT:
		case GCPPROTGROUPRELEASEPROTECTION_PREEMPTED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupReleaseProtection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			if (StorageTmp->gcpProtGroupTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtGroupTable_rsvs++;
		StorageTmp->gcpProtGroupReleaseProtection = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtGroupTable_tsts == 0)
				if ((ret = check_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtGroupReleaseProtection for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtGroupTable_sets == 0)
				if ((ret = update_gcpProtGroupTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtGroupTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			StorageTmp->gcpProtGroupTable_rsvs = 0;
			StorageTmp->gcpProtGroupTable_tsts = 0;
			StorageTmp->gcpProtGroupTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtGroupTable_sets == 0)
			revert_gcpProtGroupTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
			break;
		StorageTmp->gcpProtGroupReleaseProtection = StorageOld->gcpProtGroupReleaseProtection;
		if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
			gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSbolObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpSbolObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSbolTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpSbolObject entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpSbolTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpSbolStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSbolObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSbolObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSbolObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpSbolTable_old) == NULL)
			if (StorageTmp->gcpSbolTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpSbolTable_old = gcpSbolTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpSbolTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->gcpSbolObject);
		StorageTmp->gcpSbolObject = objid;
		StorageTmp->gcpSbolObjectLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpSbolTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpSbolTable_tsts == 0)
				if ((ret = check_gcpSbolTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSbolTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpSbolObject for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpSbolTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpSbolTable_sets == 0)
				if ((ret = update_gcpSbolTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpSbolTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpSbolTable_old) != NULL) {
			gcpSbolTable_destroy(&StorageTmp->gcpSbolTable_old);
			StorageTmp->gcpSbolTable_rsvs = 0;
			StorageTmp->gcpSbolTable_tsts = 0;
			StorageTmp->gcpSbolTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpSbolTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpSbolTable_sets == 0)
			revert_gcpSbolTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpSbolTable_old) == NULL)
			break;
		if (StorageOld->gcpSbolObject != NULL) {
			SNMP_FREE(StorageTmp->gcpSbolObject);
			StorageTmp->gcpSbolObject = StorageOld->gcpSbolObject;
			StorageTmp->gcpSbolObjectLen = StorageOld->gcpSbolObjectLen;
			StorageOld->gcpSbolObject = NULL;
			StorageOld->gcpSbolObjectLen = 0;
		}
		if (--StorageTmp->gcpSbolTable_rsvs == 0)
			gcpSbolTable_destroy(&StorageTmp->gcpSbolTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtUnitProtecting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtUnitProtecting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtUnitTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtUnitProtecting entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtUnitTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtUnitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitProtecting: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitProtecting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitProtecting: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitProtecting: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			if (StorageTmp->gcpProtUnitTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtUnitTable_old = gcpProtUnitTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtUnitTable_rsvs++;
		StorageTmp->gcpProtUnitProtecting = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtUnitTable_tsts == 0)
				if ((ret = check_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtUnitProtecting for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtUnitTable_sets == 0)
				if ((ret = update_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
			StorageTmp->gcpProtUnitTable_rsvs = 0;
			StorageTmp->gcpProtUnitTable_tsts = 0;
			StorageTmp->gcpProtUnitTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtUnitTable_sets == 0)
			revert_gcpProtUnitTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		StorageTmp->gcpProtUnitProtecting = StorageOld->gcpProtUnitProtecting;
		if (--StorageTmp->gcpProtUnitTable_rsvs == 0)
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtUnitReliableResourcePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtUnitReliableResourcePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtUnitTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtUnitReliableResourcePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtUnitTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtUnitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitReliableResourcePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitReliableResourcePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitReliableResourcePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			if (StorageTmp->gcpProtUnitTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtUnitTable_old = gcpProtUnitTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtUnitTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->gcpProtUnitReliableResourcePointer);
		StorageTmp->gcpProtUnitReliableResourcePointer = objid;
		StorageTmp->gcpProtUnitReliableResourcePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtUnitTable_tsts == 0)
				if ((ret = check_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtUnitReliableResourcePointer for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtUnitTable_sets == 0)
				if ((ret = update_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
			StorageTmp->gcpProtUnitTable_rsvs = 0;
			StorageTmp->gcpProtUnitTable_tsts = 0;
			StorageTmp->gcpProtUnitTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtUnitTable_sets == 0)
			revert_gcpProtUnitTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		if (StorageOld->gcpProtUnitReliableResourcePointer != NULL) {
			SNMP_FREE(StorageTmp->gcpProtUnitReliableResourcePointer);
			StorageTmp->gcpProtUnitReliableResourcePointer = StorageOld->gcpProtUnitReliableResourcePointer;
			StorageTmp->gcpProtUnitReliableResourcePointerLen = StorageOld->gcpProtUnitReliableResourcePointerLen;
			StorageOld->gcpProtUnitReliableResourcePointer = NULL;
			StorageOld->gcpProtUnitReliableResourcePointerLen = 0;
		}
		if (--StorageTmp->gcpProtUnitTable_rsvs == 0)
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtUnitUnreliableResourcePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtUnitUnreliableResourcePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtUnitTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtUnitUnreliableResourcePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtUnitTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtUnitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitUnreliableResourcePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitUnreliableResourcePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitUnreliableResourcePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			if (StorageTmp->gcpProtUnitTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtUnitTable_old = gcpProtUnitTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtUnitTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->gcpProtUnitUnreliableResourcePointer);
		StorageTmp->gcpProtUnitUnreliableResourcePointer = objid;
		StorageTmp->gcpProtUnitUnreliableResourcePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtUnitTable_tsts == 0)
				if ((ret = check_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtUnitUnreliableResourcePointer for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtUnitTable_sets == 0)
				if ((ret = update_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
			StorageTmp->gcpProtUnitTable_rsvs = 0;
			StorageTmp->gcpProtUnitTable_tsts = 0;
			StorageTmp->gcpProtUnitTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtUnitTable_sets == 0)
			revert_gcpProtUnitTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		if (StorageOld->gcpProtUnitUnreliableResourcePointer != NULL) {
			SNMP_FREE(StorageTmp->gcpProtUnitUnreliableResourcePointer);
			StorageTmp->gcpProtUnitUnreliableResourcePointer = StorageOld->gcpProtUnitUnreliableResourcePointer;
			StorageTmp->gcpProtUnitUnreliableResourcePointerLen = StorageOld->gcpProtUnitUnreliableResourcePointerLen;
			StorageOld->gcpProtUnitUnreliableResourcePointer = NULL;
			StorageOld->gcpProtUnitUnreliableResourcePointerLen = 0;
		}
		if (--StorageTmp->gcpProtUnitTable_rsvs == 0)
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtUnitProtectionStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtUnitProtectionStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtUnitTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtUnitProtectionStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtUnitTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtUnitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitProtectionStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitProtectionStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitProtectionStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitProtectionStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			if (StorageTmp->gcpProtUnitTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtUnitTable_old = gcpProtUnitTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtUnitTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpProtUnitProtectionStatus);
		StorageTmp->gcpProtUnitProtectionStatus = string;
		StorageTmp->gcpProtUnitProtectionStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtUnitTable_tsts == 0)
				if ((ret = check_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtUnitProtectionStatus for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtUnitTable_sets == 0)
				if ((ret = update_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
			StorageTmp->gcpProtUnitTable_rsvs = 0;
			StorageTmp->gcpProtUnitTable_tsts = 0;
			StorageTmp->gcpProtUnitTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtUnitTable_sets == 0)
			revert_gcpProtUnitTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		if (StorageOld->gcpProtUnitProtectionStatus != NULL) {
			SNMP_FREE(StorageTmp->gcpProtUnitProtectionStatus);
			StorageTmp->gcpProtUnitProtectionStatus = StorageOld->gcpProtUnitProtectionStatus;
			StorageTmp->gcpProtUnitProtectionStatusLen = StorageOld->gcpProtUnitProtectionStatusLen;
			StorageOld->gcpProtUnitProtectionStatus = NULL;
			StorageOld->gcpProtUnitProtectionStatusLen = 0;
		}
		if (--StorageTmp->gcpProtUnitTable_rsvs == 0)
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtUnitRequestSource(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtUnitRequestSource(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtUnitTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtUnitRequestSource entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtUnitTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtUnitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitRequestSource: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitRequestSource not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitRequestSource: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPPROTUNITREQUESTSOURCE_LOCAL:
		case GCPPROTUNITREQUESTSOURCE_REMOTE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitRequestSource: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			if (StorageTmp->gcpProtUnitTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtUnitTable_old = gcpProtUnitTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtUnitTable_rsvs++;
		StorageTmp->gcpProtUnitRequestSource = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtUnitTable_tsts == 0)
				if ((ret = check_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtUnitRequestSource for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtUnitTable_sets == 0)
				if ((ret = update_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
			StorageTmp->gcpProtUnitTable_rsvs = 0;
			StorageTmp->gcpProtUnitTable_tsts = 0;
			StorageTmp->gcpProtUnitTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtUnitTable_sets == 0)
			revert_gcpProtUnitTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		StorageTmp->gcpProtUnitRequestSource = StorageOld->gcpProtUnitRequestSource;
		if (--StorageTmp->gcpProtUnitTable_rsvs == 0)
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtUnitPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpProtUnitPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtUnitTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtUnitPriority entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpProtUnitTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpProtUnitRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitPriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitPriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			if (StorageTmp->gcpProtUnitTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpProtUnitTable_old = gcpProtUnitTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpProtUnitTable_rsvs++;
		StorageTmp->gcpProtUnitPriority = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpProtUnitTable_tsts == 0)
				if ((ret = check_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpProtUnitPriority for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpProtUnitTable_sets == 0)
				if ((ret = update_gcpProtUnitTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpProtUnitTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
			StorageTmp->gcpProtUnitTable_rsvs = 0;
			StorageTmp->gcpProtUnitTable_tsts = 0;
			StorageTmp->gcpProtUnitTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpProtUnitTable_sets == 0)
			revert_gcpProtUnitTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
			break;
		StorageTmp->gcpProtUnitPriority = StorageOld->gcpProtUnitPriority;
		if (--StorageTmp->gcpProtUnitTable_rsvs == 0)
			gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpRealmString(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpRealmString(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpRealmTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpRealmString entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpRealmTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpRealmRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmString: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmString not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmString: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
			if (StorageTmp->gcpRealmTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpRealmTable_old = gcpRealmTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpRealmTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpRealmString);
		StorageTmp->gcpRealmString = string;
		StorageTmp->gcpRealmStringLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpRealmTable_tsts == 0)
				if ((ret = check_gcpRealmTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpRealmTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpRealmString for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpRealmTable_sets == 0)
				if ((ret = update_gcpRealmTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpRealmTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
			gcpRealmTable_destroy(&StorageTmp->gcpRealmTable_old);
			StorageTmp->gcpRealmTable_rsvs = 0;
			StorageTmp->gcpRealmTable_tsts = 0;
			StorageTmp->gcpRealmTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpRealmTable_sets == 0)
			revert_gcpRealmTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
			break;
		if (StorageOld->gcpRealmString != NULL) {
			SNMP_FREE(StorageTmp->gcpRealmString);
			StorageTmp->gcpRealmString = StorageOld->gcpRealmString;
			StorageTmp->gcpRealmStringLen = StorageOld->gcpRealmStringLen;
			StorageOld->gcpRealmString = NULL;
			StorageOld->gcpRealmStringLen = 0;
		}
		if (--StorageTmp->gcpRealmTable_rsvs == 0)
			gcpRealmTable_destroy(&StorageTmp->gcpRealmTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpRealmTermsHiWat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpRealmTermsHiWat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpRealmTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpRealmTermsHiWat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpRealmTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpRealmRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmTermsHiWat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmTermsHiWat not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmTermsHiWat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
			if (StorageTmp->gcpRealmTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpRealmTable_old = gcpRealmTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpRealmTable_rsvs++;
		StorageTmp->gcpRealmTermsHiWat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpRealmTable_tsts == 0)
				if ((ret = check_gcpRealmTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpRealmTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpRealmTermsHiWat for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpRealmTable_sets == 0)
				if ((ret = update_gcpRealmTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpRealmTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
			gcpRealmTable_destroy(&StorageTmp->gcpRealmTable_old);
			StorageTmp->gcpRealmTable_rsvs = 0;
			StorageTmp->gcpRealmTable_tsts = 0;
			StorageTmp->gcpRealmTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpRealmTable_sets == 0)
			revert_gcpRealmTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
			break;
		StorageTmp->gcpRealmTermsHiWat = StorageOld->gcpRealmTermsHiWat;
		if (--StorageTmp->gcpRealmTable_rsvs == 0)
			gcpRealmTable_destroy(&StorageTmp->gcpRealmTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpRealmTermsLoWat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpRealmTermsLoWat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpRealmTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpRealmTermsLoWat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpRealmTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpRealmRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmTermsLoWat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmTermsLoWat not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmTermsLoWat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4294967295 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
			if (StorageTmp->gcpRealmTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpRealmTable_old = gcpRealmTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpRealmTable_rsvs++;
		StorageTmp->gcpRealmTermsLoWat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpRealmTable_tsts == 0)
				if ((ret = check_gcpRealmTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpRealmTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpRealmTermsLoWat for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpRealmTable_sets == 0)
				if ((ret = update_gcpRealmTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpRealmTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
			gcpRealmTable_destroy(&StorageTmp->gcpRealmTable_old);
			StorageTmp->gcpRealmTable_rsvs = 0;
			StorageTmp->gcpRealmTable_tsts = 0;
			StorageTmp->gcpRealmTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpRealmTable_sets == 0)
			revert_gcpRealmTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
			break;
		StorageTmp->gcpRealmTermsLoWat = StorageOld->gcpRealmTermsLoWat;
		if (--StorageTmp->gcpRealmTable_rsvs == 0)
			gcpRealmTable_destroy(&StorageTmp->gcpRealmTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpInterfaceIfindex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpInterfaceIfindex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpInterfaceIfindex entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceIfindex: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceIfindex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceIfindex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			if (StorageTmp->gcpInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpInterfaceTable_old = gcpInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpInterfaceTable_rsvs++;
		StorageTmp->gcpInterfaceIfindex = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpInterfaceTable_tsts == 0)
				if ((ret = check_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpInterfaceIfindex for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpInterfaceTable_sets == 0)
				if ((ret = update_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
			StorageTmp->gcpInterfaceTable_rsvs = 0;
			StorageTmp->gcpInterfaceTable_tsts = 0;
			StorageTmp->gcpInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpInterfaceTable_sets == 0)
			revert_gcpInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		StorageTmp->gcpInterfaceIfindex = StorageOld->gcpInterfaceIfindex;
		if (--StorageTmp->gcpInterfaceTable_rsvs == 0)
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpInterfaceMgId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpInterfaceMgId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpInterfaceMgId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceMgId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceMgId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceMgId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			if (StorageTmp->gcpInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpInterfaceTable_old = gcpInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpInterfaceTable_rsvs++;
		StorageTmp->gcpInterfaceMgId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpInterfaceTable_tsts == 0)
				if ((ret = check_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpInterfaceMgId for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpInterfaceTable_sets == 0)
				if ((ret = update_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
			StorageTmp->gcpInterfaceTable_rsvs = 0;
			StorageTmp->gcpInterfaceTable_tsts = 0;
			StorageTmp->gcpInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpInterfaceTable_sets == 0)
			revert_gcpInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		StorageTmp->gcpInterfaceMgId = StorageOld->gcpInterfaceMgId;
		if (--StorageTmp->gcpInterfaceTable_rsvs == 0)
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpInterfaceType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpInterfaceType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPINTERFACETYPE_B2B:
		case GCPINTERFACETYPE_IIPR:
		case GCPINTERFACETYPE_RIPR:
		case GCPINTERFACETYPE_NIPR:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			if (StorageTmp->gcpInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpInterfaceTable_old = gcpInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpInterfaceTable_rsvs++;
		StorageTmp->gcpInterfaceType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpInterfaceTable_tsts == 0)
				if ((ret = check_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpInterfaceType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpInterfaceTable_sets == 0)
				if ((ret = update_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
			StorageTmp->gcpInterfaceTable_rsvs = 0;
			StorageTmp->gcpInterfaceTable_tsts = 0;
			StorageTmp->gcpInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpInterfaceTable_sets == 0)
			revert_gcpInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		StorageTmp->gcpInterfaceType = StorageOld->gcpInterfaceType;
		if (--StorageTmp->gcpInterfaceTable_rsvs == 0)
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpInterfaceRealm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpInterfaceRealm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpInterfaceRealm entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceRealm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceRealm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceRealm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			if (StorageTmp->gcpInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpInterfaceTable_old = gcpInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpInterfaceTable_rsvs++;
		StorageTmp->gcpInterfaceRealm = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpInterfaceTable_tsts == 0)
				if ((ret = check_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpInterfaceRealm for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpInterfaceTable_sets == 0)
				if ((ret = update_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
			StorageTmp->gcpInterfaceTable_rsvs = 0;
			StorageTmp->gcpInterfaceTable_tsts = 0;
			StorageTmp->gcpInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpInterfaceTable_sets == 0)
			revert_gcpInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		StorageTmp->gcpInterfaceRealm = StorageOld->gcpInterfaceRealm;
		if (--StorageTmp->gcpInterfaceTable_rsvs == 0)
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpInterfaceTermId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpInterfaceTermId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpInterfaceTermId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceTermId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceTermId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceTermId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			if (StorageTmp->gcpInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpInterfaceTable_old = gcpInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpInterfaceTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpInterfaceTermId);
		StorageTmp->gcpInterfaceTermId = string;
		StorageTmp->gcpInterfaceTermIdLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpInterfaceTable_tsts == 0)
				if ((ret = check_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpInterfaceTermId for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpInterfaceTable_sets == 0)
				if ((ret = update_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
			StorageTmp->gcpInterfaceTable_rsvs = 0;
			StorageTmp->gcpInterfaceTable_tsts = 0;
			StorageTmp->gcpInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpInterfaceTable_sets == 0)
			revert_gcpInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		if (StorageOld->gcpInterfaceTermId != NULL) {
			SNMP_FREE(StorageTmp->gcpInterfaceTermId);
			StorageTmp->gcpInterfaceTermId = StorageOld->gcpInterfaceTermId;
			StorageTmp->gcpInterfaceTermIdLen = StorageOld->gcpInterfaceTermIdLen;
			StorageOld->gcpInterfaceTermId = NULL;
			StorageOld->gcpInterfaceTermIdLen = 0;
		}
		if (--StorageTmp->gcpInterfaceTable_rsvs == 0)
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpInterfaceTermPath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpInterfaceTermPath(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpInterfaceTermPath entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpInterfaceRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceTermPath: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceTermPath not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceTermPath: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			if (StorageTmp->gcpInterfaceTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpInterfaceTable_old = gcpInterfaceTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpInterfaceTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpInterfaceTermPath);
		StorageTmp->gcpInterfaceTermPath = string;
		StorageTmp->gcpInterfaceTermPathLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpInterfaceTable_tsts == 0)
				if ((ret = check_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpInterfaceTermPath for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpInterfaceTable_sets == 0)
				if ((ret = update_gcpInterfaceTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpInterfaceTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
			StorageTmp->gcpInterfaceTable_rsvs = 0;
			StorageTmp->gcpInterfaceTable_tsts = 0;
			StorageTmp->gcpInterfaceTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpInterfaceTable_sets == 0)
			revert_gcpInterfaceTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
			break;
		if (StorageOld->gcpInterfaceTermPath != NULL) {
			SNMP_FREE(StorageTmp->gcpInterfaceTermPath);
			StorageTmp->gcpInterfaceTermPath = StorageOld->gcpInterfaceTermPath;
			StorageTmp->gcpInterfaceTermPathLen = StorageOld->gcpInterfaceTermPathLen;
			StorageOld->gcpInterfaceTermPath = NULL;
			StorageOld->gcpInterfaceTermPathLen = 0;
		}
		if (--StorageTmp->gcpInterfaceTable_rsvs == 0)
			gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpAddressInterface(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpAddressInterface(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpAddressTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpAddressInterface entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpAddressTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressInterface: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressInterface not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressInterface: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			if (StorageTmp->gcpAddressTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpAddressTable_old = gcpAddressTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpAddressTable_rsvs++;
		StorageTmp->gcpAddressInterface = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpAddressTable_tsts == 0)
				if ((ret = check_gcpAddressTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpAddressTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpAddressInterface for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpAddressTable_sets == 0)
				if ((ret = update_gcpAddressTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpAddressTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
			StorageTmp->gcpAddressTable_rsvs = 0;
			StorageTmp->gcpAddressTable_tsts = 0;
			StorageTmp->gcpAddressTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpAddressTable_sets == 0)
			revert_gcpAddressTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			break;
		StorageTmp->gcpAddressInterface = StorageOld->gcpAddressInterface;
		if (--StorageTmp->gcpAddressTable_rsvs == 0)
			gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpAddressType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpAddressType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpAddressTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpAddressType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpAddressTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case GCPADDRESSTYPE_UNKNOWN:
		case GCPADDRESSTYPE_IPV4:
		case GCPADDRESSTYPE_IPV6:
		case GCPADDRESSTYPE_IPV4Z:
		case GCPADDRESSTYPE_IPV6Z:
		case GCPADDRESSTYPE_DNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			if (StorageTmp->gcpAddressTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpAddressTable_old = gcpAddressTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpAddressTable_rsvs++;
		StorageTmp->gcpAddressType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpAddressTable_tsts == 0)
				if ((ret = check_gcpAddressTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpAddressTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpAddressType for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpAddressTable_sets == 0)
				if ((ret = update_gcpAddressTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpAddressTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
			StorageTmp->gcpAddressTable_rsvs = 0;
			StorageTmp->gcpAddressTable_tsts = 0;
			StorageTmp->gcpAddressTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpAddressTable_sets == 0)
			revert_gcpAddressTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			break;
		StorageTmp->gcpAddressType = StorageOld->gcpAddressType;
		if (--StorageTmp->gcpAddressTable_rsvs == 0)
			gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpAddressAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpAddressAddr(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpAddressTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpAddressAddr entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpAddressTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressAddr: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressAddr not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressAddr: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			if (StorageTmp->gcpAddressTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpAddressTable_old = gcpAddressTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpAddressTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpAddressAddr);
		StorageTmp->gcpAddressAddr = string;
		StorageTmp->gcpAddressAddrLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpAddressTable_tsts == 0)
				if ((ret = check_gcpAddressTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpAddressTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpAddressAddr for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpAddressTable_sets == 0)
				if ((ret = update_gcpAddressTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpAddressTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
			StorageTmp->gcpAddressTable_rsvs = 0;
			StorageTmp->gcpAddressTable_tsts = 0;
			StorageTmp->gcpAddressTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpAddressTable_sets == 0)
			revert_gcpAddressTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			break;
		if (StorageOld->gcpAddressAddr != NULL) {
			SNMP_FREE(StorageTmp->gcpAddressAddr);
			StorageTmp->gcpAddressAddr = StorageOld->gcpAddressAddr;
			StorageTmp->gcpAddressAddrLen = StorageOld->gcpAddressAddrLen;
			StorageOld->gcpAddressAddr = NULL;
			StorageOld->gcpAddressAddrLen = 0;
		}
		if (--StorageTmp->gcpAddressTable_rsvs == 0)
			gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpAddressPortRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_gcpAddressPortRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpAddressTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 14;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpAddressPortRanges entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(gcpAddressTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->gcpAddressRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressPortRanges: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressPortRanges not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..0 4..4 8..8 12..12 16..16 20..20 24..24 30..30 32..32 */
		if (var_val_len > SPRINT_MAX_LEN
		    || (var_val_len != 0 && var_val_len != 4 && var_val_len != 8 && var_val_len != 12 && var_val_len != 16 && var_val_len != 20 && var_val_len != 24 && var_val_len != 30
			&& var_val_len != 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressPortRanges: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			if (StorageTmp->gcpAddressTable_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpAddressTable_old = gcpAddressTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpAddressTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->gcpAddressPortRanges);
		StorageTmp->gcpAddressPortRanges = string;
		StorageTmp->gcpAddressPortRangesLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->gcpAddressTable_tsts == 0)
				if ((ret = check_gcpAddressTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpAddressTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpAddressPortRanges for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpAddressTable_sets == 0)
				if ((ret = update_gcpAddressTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpAddressTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
			gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
			StorageTmp->gcpAddressTable_rsvs = 0;
			StorageTmp->gcpAddressTable_tsts = 0;
			StorageTmp->gcpAddressTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpAddressTable_sets == 0)
			revert_gcpAddressTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
			break;
		if (StorageOld->gcpAddressPortRanges != NULL) {
			SNMP_FREE(StorageTmp->gcpAddressPortRanges);
			StorageTmp->gcpAddressPortRanges = StorageOld->gcpAddressPortRanges;
			StorageTmp->gcpAddressPortRangesLen = StorageOld->gcpAddressPortRangesLen;
			StorageOld->gcpAddressPortRanges = NULL;
			StorageOld->gcpAddressPortRangesLen = 0;
		}
		if (--StorageTmp->gcpAddressTable_rsvs == 0)
			gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultMgcoIdent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultMgcoIdent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultMgcoIdent entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoIdent not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoIdent: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value ipAddress */
		switch (set_value) {
		case GCPDEFAULTMGCOIDENT_IPADDRESS:
		case GCPDEFAULTMGCOIDENT_DOMAINNAME:
		case GCPDEFAULTMGCOIDENT_DEVICENAME:
		case GCPDEFAULTMGCOIDENT_MTPADDRESS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoIdent: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultMgcoIdent = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultMgcoIdent for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultMgcoIdent = StorageOld->gcpDefaultMgcoIdent;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultMgcoExecutionTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultMgcoExecutionTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultMgcoExecutionTime entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoExecutionTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoExecutionTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoExecutionTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultMgcoExecutionTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultMgcoExecutionTime for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultMgcoExecutionTime = StorageOld->gcpDefaultMgcoExecutionTime;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultMgcoProvRespTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultMgcoProvRespTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultMgcoProvRespTimer entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoProvRespTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoProvRespTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoProvRespTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultMgcoProvRespTimer = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultMgcoProvRespTimer for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultMgcoProvRespTimer = StorageOld->gcpDefaultMgcoProvRespTimer;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultMgcpPendingLimit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultMgcpPendingLimit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultMgcpPendingLimit entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcpPendingLimit not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcpPendingLimit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultMgcpPendingLimit = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultMgcpPendingLimit for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultMgcpPendingLimit = StorageOld->gcpDefaultMgcpPendingLimit;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultMgcoLongTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultMgcoLongTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultMgcoLongTimer entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoLongTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoLongTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoLongTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultMgcoLongTimer = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultMgcoLongTimer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultMgcoLongTimer = StorageOld->gcpDefaultMgcoLongTimer;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultMgcoRtoInit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultMgcoRtoInit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultMgcoRtoInit entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoRtoInit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoRtoInit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoRtoInit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultMgcoRtoInit = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultMgcoRtoInit for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultMgcoRtoInit = StorageOld->gcpDefaultMgcoRtoInit;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultMgcoRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultMgcoRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultMgcoRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoRtoMin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultMgcoRtoMin = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultMgcoRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultMgcoRtoMin = StorageOld->gcpDefaultMgcoRtoMin;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultMgcoRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultMgcoRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultMgcoRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoRtoMax not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultMgcoRtoMax: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultMgcoRtoMax = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultMgcoRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultMgcoRtoMax = StorageOld->gcpDefaultMgcoRtoMax;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultUdpChecksum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultUdpChecksum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultUdpChecksum entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultUdpChecksum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultUdpChecksum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultUdpChecksum: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultUdpChecksum = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultUdpChecksum for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultUdpChecksum = StorageOld->gcpDefaultUdpChecksum;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultTcpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultTcpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultTcpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultTcpNoDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultTcpNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultTcpNoDelay = StorageOld->gcpDefaultTcpNoDelay;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultTcpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultTcpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultTcpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 536..65536 */
		if ((536 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultTcpMaxseg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultTcpMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultTcpMaxseg = StorageOld->gcpDefaultTcpMaxseg;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultTcpKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultTcpKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultTcpKeepAlive entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepAlive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepAlive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepAlive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultTcpKeepAlive = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultTcpKeepAlive for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultTcpKeepAlive = StorageOld->gcpDefaultTcpKeepAlive;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultTcpKeepIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultTcpKeepIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultTcpKeepIdle entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepIdle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepIdle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 72000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepIdle: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultTcpKeepIdle = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultTcpKeepIdle for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultTcpKeepIdle = StorageOld->gcpDefaultTcpKeepIdle;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultTcpKeepAliveItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultTcpKeepAliveItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultTcpKeepAliveItvl entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepAliveItvl not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepAliveItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1200 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepAliveItvl: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultTcpKeepAliveItvl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultTcpKeepAliveItvl for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultTcpKeepAliveItvl = StorageOld->gcpDefaultTcpKeepAliveItvl;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultTcpKeepCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultTcpKeepCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultTcpKeepCount entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepCount not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpKeepCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 9 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultTcpKeepCount = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultTcpKeepCount for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultTcpKeepCount = StorageOld->gcpDefaultTcpKeepCount;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultTcpSynRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultTcpSynRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultTcpSynRetrans entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpSynRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpSynRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* Note: ranges 0..255 */
		if ((0 > set_value || set_value > 255)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpSynRetrans: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultTcpSynRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultTcpSynRetrans for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultTcpSynRetrans = StorageOld->gcpDefaultTcpSynRetrans;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultTcpWindowClamp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultTcpWindowClamp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultTcpWindowClamp entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpWindowClamp not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpWindowClamp: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 536..65536 */
		if ((536 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultTcpWindowClamp: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultTcpWindowClamp = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultTcpWindowClamp for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultTcpWindowClamp = StorageOld->gcpDefaultTcpWindowClamp;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpNoDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpNoDelay = StorageOld->gcpDefaultSctpNoDelay;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 536..65536 */
		if ((536 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpMaxseg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpMaxseg = StorageOld->gcpDefaultSctpMaxseg;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpHeartbeatItvl not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpHeartbeatItvl: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpHeartbeatItvl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpHeartbeatItvl for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpHeartbeatItvl = StorageOld->gcpDefaultSctpHeartbeatItvl;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpHearbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpHearbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpHearbeat entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpHearbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpHearbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpHearbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpHearbeat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpHearbeat for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpHearbeat = StorageOld->gcpDefaultSctpHearbeat;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpRtoInitial not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 300 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpRtoInitial: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpRtoInitial = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpRtoInitial for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpRtoInitial = StorageOld->gcpDefaultSctpRtoInitial;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpRtoMin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpRtoMin = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpRtoMin = StorageOld->gcpDefaultSctpRtoMin;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpRtoMax not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpRtoMax: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpRtoMax = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpRtoMax = StorageOld->gcpDefaultSctpRtoMax;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpPathMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpPathMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpPathMaxRetrans = StorageOld->gcpDefaultSctpPathMaxRetrans;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpCookieLife not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpCookieLife: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpCookieLife = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpCookieLife for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpCookieLife = StorageOld->gcpDefaultSctpCookieLife;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpCookieInc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpCookieInc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpCookieInc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpCookieInc for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpCookieInc = StorageOld->gcpDefaultSctpCookieInc;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpMaxInitRetries = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpMaxInitRetries for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpMaxInitRetries = StorageOld->gcpDefaultSctpMaxInitRetries;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpMaxBurst = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpMaxBurst for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpMaxBurst = StorageOld->gcpDefaultSctpMaxBurst;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpAssocMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpAssocMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpAssocMaxRetrans = StorageOld->gcpDefaultSctpAssocMaxRetrans;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpSackDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..50 */
		if ((0 > set_value || set_value > 50)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpSackDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpSackDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpSackDelay = StorageOld->gcpDefaultSctpSackDelay;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_gcpDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("gcpMIB", "write_gcpDefaultSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = gcpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpDefaultSctpLifetime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			if (StorageTmp->gcpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->gcpMIB_old = gcpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->gcpMIB_rsvs++;
		StorageTmp->gcpDefaultSctpLifetime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->gcpMIB_tsts == 0)
				if ((ret = check_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->gcpDefaultSctpLifetime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->gcpMIB_sets == 0)
				if ((ret = update_gcpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->gcpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->gcpMIB_old) != NULL) {
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
			StorageTmp->gcpMIB_rsvs = 0;
			StorageTmp->gcpMIB_tsts = 0;
			StorageTmp->gcpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->gcpMIB_tsts == 0)
			revert_gcpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->gcpMIB_old) == NULL)
			break;
		StorageTmp->gcpDefaultSctpLifetime = StorageOld->gcpDefaultSctpLifetime;
		if (--StorageTmp->gcpMIB_rsvs == 0)
			gcpMIB_destroy(&StorageTmp->gcpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpMsTable_row(struct gcpMsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpMsTable_row(struct gcpMsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpMsTable_row(struct gcpMsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpMsTable_row(struct gcpMsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpMgTable_row(struct gcpMgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpMgTable_row(struct gcpMgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpMgTable_row(struct gcpMgTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpMgTable_row(struct gcpMgTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpMgcTable_row(struct gcpMgcTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpLinkageTable_row(struct gcpLinkageTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpUdpProfileTable_row(struct gcpUdpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpTcpProfileTable_row(struct gcpTcpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpSctpProfileTable_row(struct gcpSctpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpProtGroupTable_row(struct gcpProtGroupTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpSbolTable_row(struct gcpSbolTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpProtUnitTable_row(struct gcpProtUnitTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpRealmTable_row(struct gcpRealmTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpInterfaceTable_row(struct gcpInterfaceTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_gcpAddressTable_row(struct gcpAddressTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpMsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpMsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpMsRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpMsTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpMsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpMsTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpMsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpMsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpMsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
				if (StorageTmp->gcpMsTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpMsTable_old = gcpMsTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpMsTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpMsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpMsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpMsTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->gcpMsRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpMsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpMsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpMsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpMsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpMsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpMsRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpMsTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpMsRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpMsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
				}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpMsRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpMsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpMsTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpMsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpMsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpMsRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpMsTable_old) != NULL) {
				gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
				StorageTmp->gcpMsTable_rsvs = 0;
				StorageTmp->gcpMsTable_tsts = 0;
				StorageTmp->gcpMsTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpMsTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpMsTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpMsRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpMsTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpMsRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpMsTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpMsTable_del(StorageNew);
				gcpMsTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpMsTable_old) == NULL)
				break;
			if (--StorageTmp->gcpMsTable_rsvs == 0)
				gcpMsTable_destroy(&StorageTmp->gcpMsTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpMsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpMgRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpMgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpMgTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpMgId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpMgId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMgId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpMgTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpMgTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpMgId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpMgTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpMgRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpMgTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
				if (StorageTmp->gcpMgTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpMgTable_old = gcpMgTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpMgTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpMgTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpMgTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpMgTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpMgRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpMgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpMgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpMgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpMgRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpMgTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
				}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpMgRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpMgTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpMgRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpMgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpMgRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpMgTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpMgTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpMgRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpMgRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpMgRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpMgTable_old) != NULL) {
				gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
				StorageTmp->gcpMgTable_rsvs = 0;
				StorageTmp->gcpMgTable_tsts = 0;
				StorageTmp->gcpMgTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpMgTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpMgTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpMgRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpMgTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpMgRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpMgTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpMgTable_del(StorageNew);
				gcpMgTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpMgTable_old) == NULL)
				break;
			if (--StorageTmp->gcpMgTable_rsvs == 0)
				gcpMgTable_destroy(&StorageTmp->gcpMgTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpMgTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpMgcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpMgcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpMgcTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpMgcTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpMgcRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpMgcTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpMgcRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpMgcId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpMgcId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMgcId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpMgcTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpMgcTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpMgcId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpMgcTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpMgcRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpMgcTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
				if (StorageTmp->gcpMgcTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpMgcTable_old = gcpMgcTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpMgcTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpMgcTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpMgcTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpMgcTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpMgcRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpMgcTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpMgcRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpMgcTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpMgcRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpMgcTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
				}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpMgcRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpMgcTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpMgcRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpMgcTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpMgcRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpMgcTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
			break;
			/* deactivate with underlying device */
			if (deactivate_gcpMgcTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpMgcRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpMgcRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpMgcRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpMgcTable_old) != NULL) {
				gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
				StorageTmp->gcpMgcTable_rsvs = 0;
				StorageTmp->gcpMgcTable_tsts = 0;
				StorageTmp->gcpMgcTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpMgcTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpMgcTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpMgcRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpMgcTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpMgcRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpMgcTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpMgcTable_del(StorageNew);
				gcpMgcTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpMgcTable_old) == NULL)
				break;
			if (--StorageTmp->gcpMgcTable_rsvs == 0)
				gcpMgcTable_destroy(&StorageTmp->gcpMgcTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpMgcTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpLinkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpLinkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpLinkageTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpLinkageTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpLinkageRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpLinkageTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpLinkageRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpMgId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpMgcId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpMgId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMgId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpMgcId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMgcId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpLinkageTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpLinkageTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpMgId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpMgcId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpLinkageTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpLinkageRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpLinkageTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
				if (StorageTmp->gcpLinkageTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpLinkageTable_old = gcpLinkageTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpLinkageTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpLinkageTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpLinkageTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpLinkageTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpLinkageRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpLinkageTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpLinkageRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpLinkageTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpLinkageRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpLinkageTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
				}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpLinkageRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpLinkageTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpLinkageRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpLinkageTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpLinkageRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpLinkageTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpLinkageTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpLinkageRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpLinkageRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpLinkageRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpLinkageTable_old) != NULL) {
				gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
				StorageTmp->gcpLinkageTable_rsvs = 0;
				StorageTmp->gcpLinkageTable_tsts = 0;
				StorageTmp->gcpLinkageTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpLinkageTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpLinkageTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpLinkageRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpLinkageTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpLinkageRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpLinkageTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpLinkageTable_del(StorageNew);
				gcpLinkageTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpLinkageTable_old) == NULL)
				break;
			if (--StorageTmp->gcpLinkageTable_rsvs == 0)
				gcpLinkageTable_destroy(&StorageTmp->gcpLinkageTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpLinkageTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpUdpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpUdpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpUdpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpUdpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpUdpRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpUdpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpUdpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpUdpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpUdpProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpUdpProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpUdpProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpUdpProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpUdpProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->gcpUdpProfileId, vp->val.string, vp->val_len);
			StorageNew->gcpUdpProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&gcpUdpProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpUdpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpUdpProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpUdpProfileTable_old) == NULL)
				if (StorageTmp->gcpUdpProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpUdpProfileTable_old = gcpUdpProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpUdpProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpUdpProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpUdpProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpUdpProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpUdpRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpUdpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpUdpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpUdpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpUdpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpUdpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpUdpRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpUdpProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpUdpRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpUdpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
					break;
				case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpUdpRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpUdpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpUdpProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpUdpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpUdpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpUdpRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpUdpProfileTable_old) != NULL) {
				gcpUdpProfileTable_destroy(&StorageTmp->gcpUdpProfileTable_old);
				StorageTmp->gcpUdpProfileTable_rsvs = 0;
				StorageTmp->gcpUdpProfileTable_tsts = 0;
				StorageTmp->gcpUdpProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpUdpProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpUdpProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpUdpRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpUdpProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpUdpRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpUdpProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpUdpProfileTable_del(StorageNew);
				gcpUdpProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpUdpProfileTable_old) == NULL)
				break;
			if (--StorageTmp->gcpUdpProfileTable_rsvs == 0)
				gcpUdpProfileTable_destroy(&StorageTmp->gcpUdpProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpUdpProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpTcpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpTcpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpTcpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpTcpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpTcpRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpTcpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpTcpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpTcpProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpTcpProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpTcpProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpTcpProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpTcpProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->gcpTcpProfileId, vp->val.string, vp->val_len);
			StorageNew->gcpTcpProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&gcpTcpProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpTcpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpTcpProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
				if (StorageTmp->gcpTcpProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpTcpProfileTable_old = gcpTcpProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpTcpProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpTcpProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpTcpProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpTcpProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpTcpRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpTcpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpTcpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpTcpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpTcpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpTcpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
				}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpTcpRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpTcpProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpTcpRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpTcpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpTcpRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpTcpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpTcpProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpTcpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpTcpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpTcpRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) != NULL) {
				gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
				StorageTmp->gcpTcpProfileTable_rsvs = 0;
				StorageTmp->gcpTcpProfileTable_tsts = 0;
				StorageTmp->gcpTcpProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpTcpProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpTcpProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpTcpRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpTcpProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpTcpRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpTcpProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpTcpProfileTable_del(StorageNew);
				gcpTcpProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpTcpProfileTable_old) == NULL)
				break;
			if (--StorageTmp->gcpTcpProfileTable_rsvs == 0)
				gcpTcpProfileTable_destroy(&StorageTmp->gcpTcpProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpTcpProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSctpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpSctpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpSctpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpSctpRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpSctpProfileTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSctpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpSctpProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpSctpProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpSctpProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpSctpProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpSctpProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->gcpSctpProfileId, vp->val.string, vp->val_len);
			StorageNew->gcpSctpProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&gcpSctpProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpSctpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpSctpProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
				if (StorageTmp->gcpSctpProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpSctpProfileTable_old = gcpSctpProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpSctpProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpSctpProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpSctpProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpSctpProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpSctpRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpSctpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpSctpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpSctpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpSctpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpSctpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
				}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpSctpRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpSctpProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpSctpRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpSctpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpSctpRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpSctpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpSctpProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpSctpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpSctpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpSctpRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) != NULL) {
				gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
				StorageTmp->gcpSctpProfileTable_rsvs = 0;
				StorageTmp->gcpSctpProfileTable_tsts = 0;
				StorageTmp->gcpSctpProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpSctpProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpSctpProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpSctpRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpSctpProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpSctpRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpSctpProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpSctpProfileTable_del(StorageNew);
				gcpSctpProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpSctpProfileTable_old) == NULL)
				break;
			if (--StorageTmp->gcpSctpProfileTable_rsvs == 0)
				gcpSctpProfileTable_destroy(&StorageTmp->gcpSctpProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpSctpProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtGroupRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpProtGroupRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtGroupTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpProtGroupTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtGroupRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpProtGroupTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtGroupRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpProtGroupId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpProtGroupId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpProtGroupId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpProtGroupTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpProtGroupTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpProtGroupId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpProtGroupTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpProtGroupRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpProtGroupTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
				if (StorageTmp->gcpProtGroupTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpProtGroupTable_old = gcpProtGroupTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpProtGroupTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpProtGroupTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpProtGroupTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpProtGroupTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->gcpProtGroupRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpProtGroupTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpProtGroupRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpProtGroupTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpProtGroupRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpProtGroupTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpProtGroupRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpProtGroupTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpProtGroupRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpProtGroupTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
				}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpProtGroupRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpProtGroupTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpProtGroupTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpProtGroupRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpProtGroupRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpProtGroupRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpProtGroupTable_old) != NULL) {
				gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
				StorageTmp->gcpProtGroupTable_rsvs = 0;
				StorageTmp->gcpProtGroupTable_tsts = 0;
				StorageTmp->gcpProtGroupTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpProtGroupTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpProtGroupTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpProtGroupRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpProtGroupTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpProtGroupRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpProtGroupTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpProtGroupTable_del(StorageNew);
				gcpProtGroupTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpProtGroupTable_old) == NULL)
				break;
			if (--StorageTmp->gcpProtGroupTable_rsvs == 0)
				gcpProtGroupTable_destroy(&StorageTmp->gcpProtGroupTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpProtGroupTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpSbolStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpSbolStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpSbolTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpSbolTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpSbolStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpSbolTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSbolStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpSbolStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpProtGroupId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpSbolId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpProtGroupId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpProtGroupId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpSbolId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpSbolId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpSbolTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpSbolTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpProtGroupId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpSbolId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpSbolTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpSbolStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpSbolTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpSbolTable_old) == NULL)
				if (StorageTmp->gcpSbolTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpSbolTable_old = gcpSbolTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpSbolTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpSbolTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpSbolTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpSbolTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpSbolStatus != RS_ACTIVE)
				if ((ret = can_act_gcpSbolTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpSbolStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpSbolTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpSbolStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpSbolTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
				}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpSbolStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpSbolTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpSbolStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpSbolTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpSbolStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpSbolTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpSbolTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpSbolStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpSbolStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpSbolStatus = set_value;
			if ((StorageOld = StorageTmp->gcpSbolTable_old) != NULL) {
				gcpSbolTable_destroy(&StorageTmp->gcpSbolTable_old);
				StorageTmp->gcpSbolTable_rsvs = 0;
				StorageTmp->gcpSbolTable_tsts = 0;
				StorageTmp->gcpSbolTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpSbolTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpSbolTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpSbolStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpSbolTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpSbolStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpSbolTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpSbolTable_del(StorageNew);
				gcpSbolTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpSbolTable_old) == NULL)
				break;
			if (--StorageTmp->gcpSbolTable_rsvs == 0)
				gcpSbolTable_destroy(&StorageTmp->gcpSbolTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpSbolTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpProtUnitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpProtUnitRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpProtUnitTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpProtUnitTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpProtUnitRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpProtUnitTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpProtUnitRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpProtUnitId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpProtUnitId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpProtUnitId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..255 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 255)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpProtUnitId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpProtUnitTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpProtUnitTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpProtUnitId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpProtUnitTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpProtUnitRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpProtUnitTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
				if (StorageTmp->gcpProtUnitTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpProtUnitTable_old = gcpProtUnitTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpProtUnitTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpProtUnitTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpProtUnitTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpProtUnitTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpProtUnitRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpProtUnitTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpProtUnitRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpProtUnitTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpProtUnitRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpProtUnitTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
				}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpProtUnitRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpProtUnitTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpProtUnitRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpProtUnitTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpProtUnitRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpProtUnitTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpProtUnitTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpProtUnitRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpProtUnitRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpProtUnitRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpProtUnitTable_old) != NULL) {
				gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
				StorageTmp->gcpProtUnitTable_rsvs = 0;
				StorageTmp->gcpProtUnitTable_tsts = 0;
				StorageTmp->gcpProtUnitTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpProtUnitTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpProtUnitTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpProtUnitRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpProtUnitTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpProtUnitRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpProtUnitTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpProtUnitTable_del(StorageNew);
				gcpProtUnitTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpProtUnitTable_old) == NULL)
				break;
			if (--StorageTmp->gcpProtUnitTable_rsvs == 0)
				gcpProtUnitTable_destroy(&StorageTmp->gcpProtUnitTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpProtUnitTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpRealmRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpRealmRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpRealmTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpRealmTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpRealmRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpRealmTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpRealmRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpMgId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpRealmId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpMgId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMgId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpRealmId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpRealmId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpRealmTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpRealmTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpMgId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpRealmId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpRealmTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpRealmRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpRealmTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
				if (StorageTmp->gcpRealmTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpRealmTable_old = gcpRealmTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpRealmTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpRealmTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpRealmTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpRealmTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->gcpRealmRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpRealmTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpRealmRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpRealmTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpRealmRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpRealmTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpRealmRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable 
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpRealmTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpRealmRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpRealmTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
				}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpRealmRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpRealmTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpRealmTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpRealmRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpRealmRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpRealmRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpRealmTable_old) != NULL) {
				gcpRealmTable_destroy(&StorageTmp->gcpRealmTable_old);
				StorageTmp->gcpRealmTable_rsvs = 0;
				StorageTmp->gcpRealmTable_tsts = 0;
				StorageTmp->gcpRealmTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpRealmTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpRealmTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpRealmRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpRealmTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpRealmRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpRealmTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpRealmTable_del(StorageNew);
				gcpRealmTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpRealmTable_old) == NULL)
				break;
			if (--StorageTmp->gcpRealmTable_rsvs == 0)
				gcpRealmTable_destroy(&StorageTmp->gcpRealmTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpRealmTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpInterfaceRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpInterfaceRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpInterfaceTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpInterfaceTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpInterfaceRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpInterfaceTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpInterfaceRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpInterfaceId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpInterfaceId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpInterfaceId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpInterfaceTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpInterfaceTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpInterfaceId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpInterfaceTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpInterfaceRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpInterfaceTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
				if (StorageTmp->gcpInterfaceTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpInterfaceTable_old = gcpInterfaceTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpInterfaceTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpInterfaceTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpInterfaceTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpInterfaceTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpInterfaceRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpInterfaceTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpInterfaceRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpInterfaceTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpInterfaceRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpInterfaceTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
				}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpInterfaceRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpInterfaceTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpInterfaceRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpInterfaceTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpInterfaceRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpInterfaceTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
			break;
			/* deactivate with underlying device */
			if (deactivate_gcpInterfaceTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpInterfaceRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpInterfaceRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpInterfaceRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpInterfaceTable_old) != NULL) {
				gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
				StorageTmp->gcpInterfaceTable_rsvs = 0;
				StorageTmp->gcpInterfaceTable_tsts = 0;
				StorageTmp->gcpInterfaceTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpInterfaceTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpInterfaceTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpInterfaceRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpInterfaceTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpInterfaceRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpInterfaceTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpInterfaceTable_del(StorageNew);
				gcpInterfaceTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpInterfaceTable_old) == NULL)
				break;
			if (--StorageTmp->gcpInterfaceTable_rsvs == 0)
				gcpInterfaceTable_destroy(&StorageTmp->gcpInterfaceTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpInterfaceTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_gcpAddressRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_gcpAddressRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct gcpAddressTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct gcpAddressTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 14;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("gcpMIB", "write_gcpAddressRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(gcpAddressTableStorage, NULL, &name[14], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to gcpAddressRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* gcpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpMgId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpRealmId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpInterfaceId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* gcpAddressId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[14]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* gcpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpMgId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpMgId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpRealmId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpRealmId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpInterfaceId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpInterfaceId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* gcpAddressId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index gcpAddressId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = gcpAddressTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->gcpAddressTable_rsvs = 1;
			vp = vars;
			StorageNew->gcpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpMgId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpRealmId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpInterfaceId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->gcpAddressId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&gcpAddressTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->gcpAddressRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->gcpAddressTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
				if (StorageTmp->gcpAddressTable_rsvs == 0)
					if ((StorageOld = StorageTmp->gcpAddressTable_old = gcpAddressTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->gcpAddressTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->gcpAddressTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				gcpAddressTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_gcpAddressTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
				/* check that activation is possible */
			if (StorageTmp->gcpAddressRowStatus != RS_ACTIVE)
				if ((ret = can_act_gcpAddressTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->gcpAddressRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpAddressTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->gcpAddressRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_gcpAddressTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
				}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->gcpAddressRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_gcpAddressTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->gcpAddressRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_gcpAddressTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->gcpAddressRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_gcpAddressTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_gcpAddressTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->gcpAddressRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->gcpAddressRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->gcpAddressRowStatus = set_value;
			if ((StorageOld = StorageTmp->gcpAddressTable_old) != NULL) {
				gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
				StorageTmp->gcpAddressTable_rsvs = 0;
				StorageTmp->gcpAddressTable_tsts = 0;
				StorageTmp->gcpAddressTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			gcpAddressTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_gcpAddressTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->gcpAddressRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_gcpAddressTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->gcpAddressRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_gcpAddressTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				gcpAddressTable_del(StorageNew);
				gcpAddressTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->gcpAddressTable_old) == NULL)
				break;
			if (--StorageTmp->gcpAddressTable_rsvs == 0)
				gcpAddressTable_destroy(&StorageTmp->gcpAddressTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				gcpAddressTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

void
send_gcpProtectionSwitchReport_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("gcpMIB", "send_gcpProtectionSwitchReport_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = gcpProtectionSwitchReport_oid;
	trap.val_len = sizeof(gcpProtectionSwitchReport_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

void
send_gcpMgFailure_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("gcpMIB", "send_gcpMgFailure_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = gcpMgFailure_oid;
	trap.val_len = sizeof(gcpMgFailure_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

void
send_gcpMgcFailure_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("gcpMIB", "send_gcpMgcFailure_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = gcpMgcFailure_oid;
	trap.val_len = sizeof(gcpMgcFailure_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

void
send_gcpLinkageFailure_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("gcpMIB", "send_gcpLinkageFailure_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = gcpLinkageFailure_oid;
	trap.val_len = sizeof(gcpLinkageFailure_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

void
send_gcpInactivityTimeout_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("gcpMIB", "send_gcpInactivityTimeout_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = gcpInactivityTimeout_oid;
	trap.val_len = sizeof(gcpInactivityTimeout_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

void
send_gcpMgColdStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("gcpMIB", "send_gcpMgColdStart_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = gcpMgColdStart_oid;
	trap.val_len = sizeof(gcpMgColdStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

void
send_gcpOnOccEvent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("gcpMIB", "send_gcpOnOccEvent_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = gcpOnOccEvent_oid;
	trap.val_len = sizeof(gcpOnOccEvent_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/**
 * @fn void gcpMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
gcpMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("gcpMIB", "gcpMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (gcpMIBold_signal_handler != NULL)
		(*gcpMIBold_signal_handler) (sig);
	DEBUGMSGTL(("gcpMIB", "done.\n"));
}

/**
 * @fn void gcpMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
gcpMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("gcpMIB", "gcpMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("gcpMIB", "done.\n"));
	return;
}
